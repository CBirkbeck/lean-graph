[{"references": ["Quot", "Quot.mk", "Eq"],
  "name": "Quot.sound",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "constCategory": "Axiom"},
 {"references":
  ["OfNat.ofNat",
   "List.filter",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List.filter_cons_of_neg",
   "HAdd.hAdd",
   "List.countP_cons_of_neg",
   "Eq.refl",
   "List.filter_cons_of_pos",
   "dite",
   "List.length",
   "_private.Std.Data.List.Count.0.List.length._eq_2",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "List",
   "Bool.true",
   "Not",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat",
   "List.countP",
   "List.countP_cons_of_pos",
   "id",
   "instDecidableEqBool"],
  "name": "List.countP_eq_length_filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (l : List α), List.countP p l = List.length (List.filter p l)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.add_zero",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "and_congr"],
  "name": "Iff.and",
  "constType": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)",
  "constCategory": "Theorem"},
 {"references": ["PProd.rec", "PProd", "PProd.mk"],
  "name": "PProd.casesOn",
  "constType":
  "{α : Sort u} →\n  {β : Sort v} →\n    {motive : PProd α β → Sort u_1} →\n      (t : PProd α β) → ((fst : α) → (snd : β) → motive { fst := fst, snd := snd }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "propext",
   "LT.lt",
   "Nat.succ_le",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.104",
  "constType": "∀ {n m : ℕ}, (Nat.succ n ≤ m) = (n < m)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instIsTransSetSubsetInstHasSubsetSet",
   "PartialOrder.toPreorder",
   "Set.Nonempty",
   "Inter.inter",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Iff.of_eq",
   "Eq",
   "TopologicalSpace.nhds_generateFrom",
   "Eq.mpr",
   "Set.iUnion",
   "Iff",
   "Iff.mp",
   "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff.match_1",
   "Mathlib.Topology.Bases._auxLemma.2",
   "Filter",
   "And.casesOn",
   "Set.inter_subset_right",
   "Eq.trans",
   "TopologicalSpace.IsTopologicalBasis",
   "Filter.sets",
   "TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
   "HasSubset.Subset",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "TopologicalSpace.IsTopologicalBasis.exists_subset_inter",
   "iInf",
   "Filter.le_principal_iff",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "congr",
   "Set.sUnion",
   "And.intro",
   "Set.inter_subset_left",
   "congrArg",
   "exists_prop_congr'",
   "Exists",
   "Set",
   "GE.ge",
   "Filter.biInf_sets_eq",
   "Eq.refl",
   "Set.eq_univ_iff_forall",
   "Exists.intro",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "True",
   "iff_self",
   "Filter.principal",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Std.Logic._auxLemma.52",
   "Filter.instCompleteLatticeFilter",
   "id",
   "instMembershipSetFilter",
   "Membership.mem",
   "Mathlib.Topology.Bases._auxLemma.1",
   "funext",
   "nhds",
   "HasSubset.Subset.trans",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Order.Preimage",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "CompleteLattice.toInfSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {a : α} {s : Set α} {b : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis b → (s ∈ nhds a ↔ ∃ t ∈ b, a ∈ t ∧ t ⊆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "Iff.intro",
   "List.instHasSubsetList",
   "Iff",
   "Iff.mp",
   "List.Sublist.subset",
   "List",
   "Eq.rec",
   "List.subset_nil",
   "List.Sublist",
   "HasSubset.Subset",
   "List.nil",
   "Eq"],
  "name": "List.sublist_nil",
  "constType": "∀ {α : Type u_1} {l : List α}, List.Sublist l [] ↔ l = []",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Function.LeftInverse", "Function.RightInverse"],
  "name": "Equiv.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (toFun : α → β) → (invFun : β → α) → Function.LeftInverse invFun toFun → Function.RightInverse invFun toFun → α ≃ β",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "∀ {α : Type u_1} (a : Set α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instDecidableOr",
   "eq_true_of_decide",
   "Bool",
   "Eq.symm",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.dichotomy",
  "constType": "∀ (b : Bool), b = false ∨ b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpperSet.to_WithUpperSet_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithUpperSet.toUpperSet.symm = Topology.WithUpperSet.ofUpperSet",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Nat.zero",
   "List",
   "Eq.refl",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "List.take",
   "Nat.casesOn",
   "Eq"],
  "name": "List.take_nil",
  "constType": "∀ {α : Type u_1} {i : ℕ}, List.take i [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_5",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.instUnionList",
   "List.insert",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Union.union",
   "List.foldr",
   "Eq"],
  "name": "List.cons_union",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l₁ l₂ : List α), a :: l₁ ∪ l₂ = List.insert a (l₁ ∪ l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB",
   "IsGreatest.unique",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "Eq",
   "PartialOrder"],
  "name": "IsGLB.unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {s : Set α} {a b : α}, IsGLB s a → IsGLB s b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.map_le_iff_le_comap.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {g : Filter β} {m : α → β} (x : Set α) (motive : x ∈ Filter.comap m g → Prop)\n  (x_1 : x ∈ Filter.comap m g),\n  (∀ (w : Set β) (ht : w ∈ g) (hts : m ⁻¹' w ⊆ x), motive (_ : ∃ t ∈ g, m ⁻¹' t ⊆ x)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "Exists", "Iff.mp", "Iff", "Exists.imp", "Iff.mpr"],
  "name": "exists_congr",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∃ a, p a) ↔ ∃ a, q a)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "instIsCommutativeInfToInf.proof_1",
   "Inf.inf",
   "SemilatticeInf",
   "IsCommutative"],
  "name": "instIsCommutativeInfToInf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α], IsCommutative α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≤]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "add_le_add_left",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ : Multiset α), s₁ ≤ s₂ → ∀ (a : Multiset α), a + s₁ ≤ a + s₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "mem_of_mem_nhds",
   "Pure.pure",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Filter.instPureFilter",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.mem_pure",
   "Pi.hasLe",
   "instMembershipSetFilter"],
  "name": "pure_le_nhds",
  "constType": "∀ {α : Type u} [inst : TopologicalSpace α], pure ≤ nhds",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.rec",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpperSet α → Sort u} →\n        ((topology_eq_upperSetTopology : t = Topology.upperSet α) → motive (_ : Topology.IsUpperSet α)) →\n          (t : Topology.IsUpperSet α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not"],
  "name": "decide_eq_false.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → ¬p → Prop) (x : Decidable p) (x_1 : ¬p),\n  (∀ (h₁ : p) (h₂ : ¬p), motive (isTrue h₁) h₂) → (∀ (h x : ¬p), motive (isFalse h) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "iff_of_eq", "and_true", "True"],
  "name": "and_true_iff",
  "constType": "∀ (p : Prop), p ∧ True ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["List.instUnionList",
   "List.Nodup",
   "List.rec",
   "DecidableEq",
   "List.Nodup.insert",
   "List",
   "Union.union"],
  "name": "List.Nodup.union",
  "constType":
  "∀ {α : Type u} {l₂ : List α} [inst : DecidableEq α] (l₁ : List α), List.Nodup l₂ → List.Nodup (l₁ ∪ l₂)",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Quotient"],
  "name": "Trunc",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.ofLower",
  "constType": "{α : Type u_1} → Topology.WithLower α ≃ α",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "le_himp_iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "propext",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] {a b c : α}, (a ≤ b ⇨ c) = (a ⊓ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_false",
   "False",
   "Lean.Data.AC.insert",
   "List",
   "Lean.Data.AC.insert_nonEmpty",
   "List.nil",
   "Nat",
   "Eq"],
  "name": "Init.Data.AC._auxLemma.1",
  "constType":
  "∀ {x : ℕ} {xs : List ℕ}, (Lean.Data.AC.insert x xs = []) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Function.comp",
   "ContinuousAt",
   "Inducing",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "Mathlib.Topology.Maps._auxLemma.1",
   "Inducing.continuousAt_iff",
   "congrArg",
   "Eq.trans",
   "id",
   "congrFun"],
  "name": "Inducing.continuous_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Inducing g → (Continuous f ↔ Continuous (g ∘ f))",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.comap.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (m : α → β) (f : Filter β) {x : Set α} (motive : x ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s} → Prop)\n  (x_1 : x ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s}),\n  (∀ (a' : Set β) (ha' : a' ∈ f) (ma'a : m ⁻¹' a' ⊆ x), motive (_ : ∃ t ∈ f, m ⁻¹' t ⊆ x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "propext", "or_false_iff", "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.13",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termΩ",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["SupSet", "outParam", "FunLike", "sSupHomClass"],
  "name": "sSupHomClass.toFunLike",
  "constType":
  "{F : Type u_8} →\n  {α : outParam (Type u_9)} →\n    {β : outParam (Type u_10)} →\n      [inst : SupSet α] → [inst_1 : SupSet β] → [self : sSupHomClass F α β] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{α : Type u} →\n  [toCompleteLattice : CompleteLattice α] →\n    (∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)) →\n      CompletelyDistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "funext",
   "Iff.rfl",
   "TopologicalSpace.ext",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "Topology.upperSet",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLowerSet",
   "Eq",
   "Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "OrderDual",
   "Topology.IsLowerSet.topology_eq",
   "IsOpen",
   "id"],
  "name": "OrderDual.instIsUpperSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α],\n  Topology.IsUpperSet αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Syntax.casesOn",
   "Array",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.setKind.match_1",
  "constType":
  "(motive : Lean.Syntax → Sort u_1) →\n  (stx : Lean.Syntax) →\n    ((info : Lean.SourceInfo) →\n        (kind : Lean.SyntaxNodeKind) → (args : Array Lean.Syntax) → motive (Lean.Syntax.node info kind args)) →\n      ((x : Lean.Syntax) → motive x) → motive stx",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Lean.IsCommutative",
   "Option"],
  "name": "Lean.Data.AC.Context.comm",
  "constType":
  "{α : Sort u} → (self : Lean.Data.AC.Context α) → Option (Lean.IsCommutative self.op)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.topology_eq_upperSetTopology",
  "constType":
  "∀ {α : Type u_4} [t : TopologicalSpace α] [inst : Preorder α] [self : Topology.IsUpperSet α], t = Topology.upperSet α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Filter.GenerateSets", "Set", "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.basic",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {s : Set α}, s ∈ g → Filter.GenerateSets g s",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "TopologicalSpace", "Set.univ"],
  "name": "TopologicalSpace.isOpen_univ",
  "constType":
  "∀ {α : Type u} [self : TopologicalSpace α], TopologicalSpace.IsOpen Set.univ",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Exists.fst.match_1",
  "constType":
  "∀ {b : Prop} {p : b → Prop} (motive : Exists p → Prop) (x : Exists p),\n  (∀ (h : b) (h_1 : p h), motive (_ : Exists p)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Option.noConfusion",
   "Option.some",
   "Eq.casesOn",
   "Eq.symm",
   "Eq.propIntro",
   "Option",
   "Eq"],
  "name": "Option.some.injEq",
  "constType":
  "∀ {α : Type u} (val val_1 : α), (some val = some val_1) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references": ["Prod", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.modifyGet",
  "constType":
  "{σ : semiOutParam (Type u)} → {m : Type u → Type v} → [self : MonadStateOf σ m] → {α : Type u} → (σ → α × σ) → m α",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_12"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.topology_eq_upperSetTopology",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.topology_eq",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α],\n  inst_1 = Topology.upperSet α",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Min.min",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.min_succ_succ",
   "List.length",
   "Nat.zero_min",
   "List.take",
   "True",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "List.take_nil",
   "of_eq_true",
   "List",
   "PUnit",
   "congr",
   "Nat.min_zero",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "instMinNat",
   "congrArg",
   "Nat.succ",
   "List.length_take.match_1",
   "Eq.trans"],
  "name": "List.length_take",
  "constType":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), List.length (List.take i l) = min i (List.length l)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.getArgs",
   "OfNat.ofNat",
   "GE.ge",
   "Nat.sub",
   "Lean.Name.mkStr1",
   "EStateM.Result",
   "Lean.Syntax.node4",
   "EStateM.Result.error",
   "Lean.TSyntax",
   "Array",
   "Decidable.casesOn",
   "PUnit.unit",
   "instLENat",
   "Lean.replaceRef",
   "Array.append",
   "Decidable",
   "instOfNatNat",
   "List.nil",
   "Lean.SourceInfo.fromRef",
   "Nat",
   "Lean.Name.anonymous",
   "Nat.decLe",
   "Array.extract",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.Syntax.getNumArgs",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "LE.le",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Lean.SourceInfo.none",
   "Bool.casesOn",
   "List",
   "Bool.false",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "Not",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Iff",
   "Iff.rfl",
   "Set",
   "SetLike.instMembership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.mem_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (r : α → β → Sort u) → Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Prod.mk.inj_iff",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "propext",
   "Prod.mk",
   "Eq.refl",
   "Prod",
   "Prod.fst",
   "id",
   "Eq"],
  "name": "Prod.ext_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadWithReader"],
  "name": "MonadWithReader.mk",
  "constType":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → ({α : Type u} → (ρ → ρ) → m α → m α) → MonadWithReader ρ m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "SupSet.sSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (s : Set αᵒᵈᵒᵈ) (a : αᵒᵈᵒᵈ), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Prod.fst",
   "Exists.intro",
   "And.left",
   "Set.instMembershipSet",
   "Set.Nonempty.fst.match_1"],
  "name": "Set.Nonempty.fst",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, Set.Nonempty (s ×ˢ t) → Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisCoinsertion.liftCompleteLattice.proof_2",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisCoinsertion.liftCompleteLattice.proof_7",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "SupSet.mk",
   "CompleteLattice.toBot",
   "CompleteLattice.toLattice",
   "GaloisCoinsertion",
   "GaloisCoinsertion.liftCompleteLattice.proof_6",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice",
   "CompleteLattice.toSupSet",
   "GaloisCoinsertion.liftCompleteLattice.proof_1",
   "GaloisCoinsertion.choice",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "GaloisCoinsertion.liftCompleteLattice.proof_4",
   "Function.comp",
   "FunLike.coe",
   "SupSet.sSup",
   "GaloisCoinsertion.liftCompleteLattice.proof_3",
   "GaloisCoinsertion.dual",
   "Equiv.instFunLikeEquiv",
   "PartialOrder",
   "InfSet.mk",
   "OrderDual.ofDual",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "CompleteLattice.toTop",
   "OrderDual",
   "GaloisCoinsertion.liftCompleteLattice.proof_5",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisCoinsertion.liftCompleteLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder α] → [inst_1 : CompleteLattice β] → GaloisCoinsertion l u → CompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references": [],
  "name": "Max",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Set",
   "HasCompl.compl",
   "ClosedIciTopology.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Set.Ici",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "rfl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "isOpen_compl_iff",
   "Preorder.toLE",
   "Iff.mpr",
   "Topology.IsLower.isOpen_iff_generate_Ici_compl",
   "Eq",
   "Iff.mp",
   "Topology.IsLower",
   "TopologicalSpace",
   "IsClosed",
   "ClosedIciTopology",
   "IsOpen"],
  "name": "Topology.IsLower.instClosedIciTopology.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], ClosedIciTopology α",
  "constCategory": "Theorem"},
 {"references":
  ["iSup_congr_Prop",
   "Iff",
   "iInf",
   "OrderDual",
   "InfSet",
   "OrderDual.supSet",
   "Iff.mpr",
   "Eq"],
  "name": "iInf_congr_Prop",
  "constType":
  "∀ {α : Type u_1} [inst : InfSet α] {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q),\n  (∀ (x : q), f₁ (_ : p) = f₂ x) → iInf f₁ = iInf f₂",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Or",
   "Nat.below",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "LE.le",
   "instLTNat",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.eq_or_lt_of_le.match_2",
   "instLENat",
   "Nat.zero",
   "Or.inl",
   "Nat.le_of_succ_le_succ",
   "Nat.eq_or_lt_of_le.match_1",
   "Eq.rec",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.zero_le",
   "absurd",
   "Nat.succ"],
  "name": "Nat.eq_or_lt_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n = m ∨ n < m",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.ofLowerSet",
  "constType": "{α : Type u_1} → Topology.WithLowerSet α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "inferInstanceAs",
   "OrderDual",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_1",
  "constType": "∀ (α : Type u_1) [inst : PartialOrder α] (a : αᵒᵈ), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.EvalInformation"],
  "name": "Lean.Data.AC.EvalInformation.arbitrary",
  "constType":
  "{α : Sort u} → {β : Sort v} → [self : Lean.Data.AC.EvalInformation α β] → α → β",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "absurd"],
  "name": "instDecidableForAll.proof_1",
  "constType": "∀ {p q : Prop}, p → ¬q → (p → q) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "DecidableEq",
   "Set.toFinset",
   "Finset.image",
   "Set",
   "Set.fintypeImage.proof_1",
   "Set.image",
   "Fintype.ofFinset"],
  "name": "Set.fintypeImage",
  "constType":
  "{α : Type u} →\n  {β : Type v} → [inst : DecidableEq β] → (s : Set α) → (f : α → β) → [inst : Fintype ↑s] → Fintype ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "MonadExcept",
   "tryCatchThe",
   "MonadExcept.mk",
   "throwThe",
   "MonadExceptOf"],
  "name": "instMonadExcept",
  "constType":
  "(ε : outParam (Type u)) → (m : Type v → Type w) → [inst : MonadExceptOf ε m] → MonadExcept ε m",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint.symm",
   "Disjoint",
   "HeytingAlgebra.toBoundedOrder",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "disjoint_compl_left",
   "HeytingAlgebra.toHasCompl",
   "Preorder.toLE",
   "BoundedOrder.toOrderBot"],
  "name": "disjoint_compl_right",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, Disjoint a aᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "False",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "Nat.not_le_of_gt",
   "Eq.rec",
   "LT.lt",
   "HMod.hMod",
   "Not",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "if_neg",
   "Nat.decLe"],
  "name": "Nat.mod_eq_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a % b = a",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "SetLike", "Function.Injective", "Set", "SetLike.coe"],
  "name": "SetLike.coe_injective'",
  "constType":
  "∀ {A : Type u_1} {B : outParam (Type u_2)} [self : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Definition"},
 {"references": ["SizeOf", "Nat", "SizeOf.mk"],
  "name": "instSizeOfNat",
  "constType": "SizeOf ℕ",
  "constCategory": "Definition"},
 {"references": ["Ne", "Not", "rfl", "Eq"],
  "name": "ne_eq",
  "constType": "∀ {α : Sort u_1} (a b : α), (a ≠ b) = ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["congr_fun",
   "Filter.map",
   "Function.comp",
   "Filter",
   "Filter.map_compose",
   "Eq"],
  "name": "Filter.map_map",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {f : Filter α} {m : α → β} {m' : β → γ},\n  Filter.map m' (Filter.map m f) = Filter.map (m' ∘ m) f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Preorder.toLE",
   "disjoint_compl_right",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "Disjoint.eq_bot",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "inf_compl_self",
  "constType": "∀ {α : Type u_2} [inst : HeytingAlgebra α] (a : α), a ⊓ aᶜ = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.instMembershipList",
   "List",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "List.mem_map_of_injective.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α} {l : List α} (motive : (∃ a_1 ∈ l, f a_1 = f a) → Prop)\n  (x : ∃ a_1 ∈ l, f a_1 = f a), (∀ (w : α) (m' : w ∈ l) (e : f w = f a), motive (_ : ∃ a_1 ∈ l, f a_1 = f a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin.mk", "Fin", "Fin.casesOn"],
  "name": "Fin.succ.match_1",
  "constType":
  "{n : ℕ} →\n  (motive : Fin n → Sort u_1) → (x : Fin n) → ((i : ℕ) → (h : i < n) → motive { val := i, isLt := h }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.Pairwise.chain.match_1",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α} (motive : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l → Prop)\n  (x : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l),\n  (∀ (r : ∀ a' ∈ l, R a a') (p' : List.Pairwise R l), motive (_ : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "List.Mem.tail",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Mem",
   "List.Sublist.slnil",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.below.cons₂",
   "List.Sublist.cons₂",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.subset.match_1._@.Std.Data.List.Lemmas._hyg.8578",
  "constType":
  "∀ {α : Type u_1}\n  (motive : (l₂ l₁ : List α) → (x : List.Sublist l₁ l₂) → (x_1 : α) → x_1 ∈ l₁ → List.Sublist.below x → Prop)\n  (l₂ l₁ : List α) (x : List.Sublist l₁ l₂) (x_1 : α) (x_2 : x_1 ∈ l₁) (h_below : List.Sublist.below x),\n  (∀ (x : α) (h : x ∈ []),\n      motive [] [] (_ : List.Sublist [] []) x h (_ : List.Sublist.below (_ : List.Sublist [] []))) →\n    (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (x : α) (h : x ∈ l₁) (h_2 : List.Sublist.below s)\n        (a_1 : ∀ x ∈ l₁, x ∈ l₂),\n        motive (a :: l₂) l₁ (_ : List.Sublist l₁ (a :: l₂)) x h\n          (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ (l₁ l₂ : List α) (a : α) (a_1 : List.Sublist l₁ l₂) (h : List.Sublist.below a_1) (a_2 : ∀ x ∈ l₁, x ∈ l₂),\n          motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂)) a (_ : List.Mem a (a :: l₁))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (a_1 : α) (h : List.Mem a_1 l₁)\n            (h_4 : List.Sublist.below s) (a_2 : ∀ x ∈ l₁, x ∈ l₂),\n            motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂)) a_1 (_ : List.Mem a_1 (a :: l₁))\n              (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n          motive l₂ l₁ x x_1 x_2 h_below",
  "constCategory": "Definition"},
 {"references": ["InvImage.accessible.proof_1", "InvImage", "Acc"],
  "name": "InvImage.accessible",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} {a : α} (f : α → β), Acc r (f a) → Acc (InvImage r f) a",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "Preorder",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisInsertion.mk",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            (choice : (x : α) → u (l x) ≤ x → β) →\n              GaloisConnection l u →\n                (∀ (x : β), x ≤ l (u x)) → (∀ (a : α) (h : u (l a) ≤ a), choice a h = l a) → GaloisInsertion l u",
  "constCategory": "Other"},
 {"references": ["InfSet", "CompleteSemilatticeInf"],
  "name": "CompleteSemilatticeInf.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteSemilatticeInf α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.IsOpen_of._closed_14",
   "Topology.IsOpen_of._closed_3"],
  "name": "Topology.IsOpen_of._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "List",
   "And.intro",
   "Exists.intro",
   "List.map",
   "rfl",
   "Iff.mpr",
   "Eq"],
  "name": "List.mem_map_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a : α} {l : List α} (f : α → β), a ∈ l → f a ∈ List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "GeneralizedCoheytingAlgebra.mk",
   "GeneralizedBooleanAlgebra.toSDiff",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "OrderBot",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_2",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_1",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "SDiff.mk",
   "GeneralizedCoheytingAlgebra",
   "GeneralizedBooleanAlgebra",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{α : Type u} → [inst : GeneralizedBooleanAlgebra α] → GeneralizedCoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "List.Nodup",
   "propext",
   "List",
   "List.Perm.nodup_iff",
   "List.isSetoid",
   "Eq"],
  "name": "Multiset.Nodup.proof_1",
  "constType":
  "∀ {α : Type u_1} (x x_1 : List α), Setoid.r x x_1 → List.Nodup x = List.Nodup x_1",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.apply",
   "WellFounded.intro",
   "WellFounded",
   "InvImage",
   "InvImage.accessible"],
  "name": "InvImage.wf.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : β → β → Prop} (f : α → β), WellFounded r → WellFounded (InvImage r f)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M →+ N),\n  (fun f ↦ f.toFun) f = (fun f ↦ f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.42",
   "Mathlib.Data.Set.Image._auxLemma.4",
   "congr",
   "Singleton.singleton",
   "Set.image",
   "congrArg",
   "Eq.trans"],
  "name": "Set.image_singleton",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α}, f '' {a} = {f a}",
  "constCategory": "Theorem"},
 {"references": ["maxOfLe", "instLENat", "Max", "Nat", "Nat.decLe"],
  "name": "Nat.instMaxNat",
  "constType": "Max ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.replicate.match_1",
  "constType":
  "{α : Type u_2} →\n  (motive : ℕ → α → Sort u_1) →\n    (x : ℕ) → (x_1 : α) → ((x : α) → motive 0 x) → ((n : ℕ) → (a : α) → motive (Nat.succ n) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.instHasSubsetSet",
   "Set",
   "le_sInf",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.subset_sInter",
  "constType":
  "∀ {α : Type u_1} {S : Set (Set α)} {t : Set α}, (∀ t' ∈ S, t ⊆ t') → t ⊆ ⋂₀ S",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddRightCancelMonoid"],
  "name": "AddRightCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Preorder",
   "GaloisInsertion",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : Preorder α],\n  GaloisInsertion l u → GaloisConnection l u",
  "constCategory": "Theorem"},
 {"references": ["Or", "False", "Or.elim.match_1", "Not"],
  "name": "instDecidableOr.proof_1",
  "constType": "∀ {p q : Prop}, ¬p → ¬q → p ∨ q → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Order.Frame",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Pi.generalizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Pi.heytingAlgebra.proof_1",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → HeytingAlgebra (α i)] (a : (i : ι) → α i), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.ParserDescr",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["List.cons", "List", "List.replicate", "Eq.refl", "Nat", "Nat.succ", "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.replicate._eq_2",
  "constType":
  "∀ {α : Type u} (x : α) (n : ℕ), List.replicate (Nat.succ n) x = x :: List.replicate n x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Quot",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort u",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "And",
   "Or",
   "Iff",
   "False",
   "Or.inl",
   "Or.inr",
   "Decidable.not_and_iff_or_not.match_1",
   "Decidable",
   "And.comm.match_1",
   "Not",
   "And.intro",
   "Decidable.not_and_iff_or_not.match_2",
   "absurd"],
  "name": "Decidable.not_and_iff_or_not",
  "constType":
  "∀ (p q : Prop) [d₁ : Decidable p] [d₂ : Decidable q], ¬(p ∧ q) ↔ ¬p ∨ ¬q",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.ofUpper._cstage1",
  "constType": "{α : Type u_1} → Topology.WithUpper α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen",
   "interior",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.interior._eq_1",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), interior s = ⋃₀ {t | IsOpen t ∧ t ⊆ s}",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.get",
  "constType":
  "{σ : semiOutParam (Type u)} → {m : Type u → Type v} → [self : MonadStateOf σ m] → m σ",
  "constCategory": "Definition"},
 {"references":
  ["Set.sUnion_eq_compl_sInter_compl",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.compl_compl_image",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "id",
   "Eq"],
  "name": "Set.compl_sInter",
  "constType": "∀ {α : Type u_1} (S : Set (Set α)), (⋂₀ S)ᶜ = ⋃₀ (compl '' S)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "HEq",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.length",
   "List.Sublist.slnil",
   "LE.le",
   "Eq",
   "Eq.ndrec",
   "instLENat",
   "HEq.refl",
   "List",
   "List.Sublist.below.cons₂",
   "Unit.unit",
   "List.Sublist.cons₂",
   "List.nil",
   "Nat",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.reverse.match_1._@.Std.Data.List.Lemmas._hyg.8887",
  "constType":
  "∀ {α : Type u_1} (motive : (l₂ l₁ : List α) → (x : List.Sublist l₁ l₂) → List.Sublist.below x → Prop) (l₂ l₁ : List α)\n  (x : List.Sublist l₁ l₂) (h_below : List.Sublist.below x),\n  (Unit → motive [] [] (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] []))) →\n    (∀ (l₁ l₂ : List α) (a : α) (h : List.Sublist l₁ l₂) (h_2 : List.Sublist.below h)\n        (a_1 : List.length l₁ ≤ List.length l₂),\n        motive (a :: l₂) l₁ (_ : List.Sublist l₁ (a :: l₂)) (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ (l₁ l₂ : List α) (a : α) (h : List.Sublist l₁ l₂) (h_3 : List.Sublist.below h)\n          (a_1 : List.length l₁ ≤ List.length l₂),\n          motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        motive l₂ l₁ x h_below",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.ne_of_lt",
   "Nat.zero_lt_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.linearOrderedCommSemiring.proof_5",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.IsNeutral",
  "constType": "{α : Sort u} → (α → α → α) → α → Type",
  "constCategory": "Other"},
 {"references": ["Iff", "iff_true_intro", "True", "id"],
  "name": "imp_self",
  "constType": "∀ {a : Prop}, a → a ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeSup",
   "CompleteLattice.sSup_le",
   "CompleteLattice",
   "CompleteSemilatticeSup.mk",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeSup",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String", "String.casesOn"],
  "name": "String.decEq.match_1",
  "constType":
  "(motive : String → String → Sort u_1) →\n  (s₁ s₂ : String) → ((s₁ s₂ : List Char) → motive { data := s₁ } { data := s₂ }) → motive s₁ s₂",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instSubNat",
   "Eq.refl",
   "instLTNat",
   "True",
   "Eq",
   "PProd",
   "Nat.succ_sub_succ",
   "Eq.mpr",
   "Nat.lt_of_succ_lt_succ",
   "eq_false'",
   "PUnit",
   "Nat.sub_ne_zero_of_lt.match_1",
   "instOfNatNat",
   "Nat",
   "not_false_eq_true",
   "Nat.succ",
   "absurd",
   "Eq.trans",
   "Nat.not_lt_zero",
   "id",
   "instHSub",
   "Ne",
   "Nat.below",
   "Nat.brecOn",
   "False",
   "HSub.hSub",
   "PProd.fst",
   "Nat.rec",
   "Eq.ndrec",
   "of_eq_true",
   "Nat.noConfusion",
   "LT.lt",
   "Nat.lt_irrefl",
   "Not",
   "congrArg"],
  "name": "Nat.sub_ne_zero_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → b - a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Prod.fst",
   "Set.univ",
   "True",
   "Set.inter_univ",
   "Eq",
   "of_eq_true",
   "SProd.sprod",
   "Prod",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "congrFun"],
  "name": "Set.prod_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α}, s ×ˢ Set.univ = Prod.fst ⁻¹' s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ReaderT",
  "constType": "Type u → (Type u → Type v) → Type u → Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "forall_congr'",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∀ (a : α), q a)",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.nodup_dedup",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.dedup"],
  "name": "Multiset.nodup_dedup",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α), Multiset.Nodup (Multiset.dedup s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq",
   "Equiv",
   "induced_id",
   "Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Inducing.mk",
   "Topology.IsUpper",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Topology.WithUpper.ofUpper",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.upper",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "id"],
  "name": "Topology.IsUpper.WithUpperHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α],\n  Inducing ↑Topology.WithUpper.ofUpper",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 ↦ x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "IsLowerSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Topology.WithLowerSet",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsLowerSet.WithLowerSetHomeomorph._spec_1",
  "constType":
  "(α : Type u_1) →\n  (inst : Preorder α) →\n    (inst_1 : TopologicalSpace α) →\n      let _x_1 :=\n        { IsOpen := IsLowerSet, isOpen_univ := (_ : ∀ ⦃a b : α⦄, b ≤ a → a ∈ Set.univ → b ∈ Set.univ),\n          isOpen_inter := (_ : ∀ (x x_1 : Set α), IsLowerSet x → IsLowerSet x_1 → IsLowerSet (Inter.inter✝ x x_1)),\n          isOpen_sUnion := (_ : ∀ (x : Set (Set α)), (∀ s ∈ x, IsLowerSet s) → IsLowerSet (⋃₀ x)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithLowerSet α ≃ α) → Inducing ↑f → Topology.WithLowerSet α ≃ₜ α",
  "constCategory": "Axiom"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div_rec_lemma.match_1",
  "constType":
  "∀ {x y : ℕ} (motive : 0 < y ∧ y ≤ x → Prop) (x_1 : 0 < y ∧ y ≤ x),\n  (∀ (ypos : 0 < y) (ylex : y ≤ x), motive (_ : 0 < y ∧ y ≤ x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["Set.iUnion", "iSup_congr", "Set", "Set.instSupSetSet", "Eq"],
  "name": "Set.iUnion_congr",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {s t : ι → Set α}, (∀ (i : ι), s i = t i) → ⋃ i, s i = ⋃ i, t i",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "_auto._@.Mathlib.Data.List.Range._hyg.49",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "optParam",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "List.pairwise_lt_range'.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → (x : optParam ℕ 1) → autoParam (0 < x) _auto✝ → Prop) (x x_1 : ℕ) (x_2 : optParam ℕ 1)\n  (x_3 : autoParam (0 < x_2) _auto✝),\n  (∀ (x : ℕ) (x_4 : optParam ℕ 1) (x_5 : autoParam (0 < x_4) _auto✝), motive x 0 x_4) →\n    (∀ (s n : ℕ) (x : optParam ℕ 1) (h : autoParam (0 < x) _auto✝), motive s (Nat.succ n) x) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.snd",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length.match_1",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.sInf_le",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe",
   "ContinuousMapClass.toFunLike"],
  "name": "ContinuousMapClass.map_continuous",
  "constType":
  "∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : TopologicalSpace α]\n  [inst_1 : TopologicalSpace β] [self : ContinuousMapClass F α β] (f : F), Continuous ↑f",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.casesOn"],
  "name": "Nat.not_succ_le_zero.match_3",
  "constType":
  "∀ (motive : (x : ℕ) → Nat.succ x ≤ 0 → Prop) (x : ℕ) (x_1 : Nat.succ x ≤ 0),\n  (∀ (h : Nat.succ 0 ≤ 0), motive 0 h) →\n    (∀ (n : ℕ) (h : Nat.succ (Nat.succ n) ≤ 0), motive (Nat.succ n) h) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.prod",
   "Prod.snd",
   "Set",
   "Prod",
   "And.intro",
   "Prod.fst",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "Filter.mem_prod_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s₁ : Set α) (s₂ : Set β) (p : α × β) (motive : p ∈ Set.prod s₁ s₂ → Prop)\n  (x : p ∈ Set.prod s₁ s₂), (∀ (h : p.1 ∈ s₁) (h' : p.2 ∈ s₂), motive (_ : p.1 ∈ s₁ ∧ p.2 ∈ s₂)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.iUnion",
   "CompleteAtomicBooleanAlgebra.toCompleteBooleanAlgebra",
   "Set",
   "Set.iInter",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "compl_iSup",
   "Eq"],
  "name": "Set.compl_iUnion",
  "constType":
  "∀ {β : Type u_2} {ι : Sort u_4} (s : ι → Set β), (⋃ i, s i)ᶜ = ⋂ i, (s i)ᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "congr",
   "Singleton.singleton",
   "Mathlib.Data.Finset.Basic._auxLemma.26",
   "congrArg",
   "Eq.trans",
   "Finset.instSingletonFinset"],
  "name": "Set.fintypeSingleton.proof_1",
  "constType": "∀ {α : Type u_1} (a a_1 : α), a_1 ∈ {a} ↔ a_1 ∈ {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "IsUpperSet",
   "Preorder",
   "Set.Ici",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "forall_swap",
   "Iff.mp",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "congrArg",
   "Eq.trans"],
  "name": "IsUpperSet.Ici_subset",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, IsUpperSet s → ∀ ⦃a : α⦄, a ∈ s → Set.Ici a ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.cons",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.subperm_cons.match_1",
  "constType":
  "∀ {α : Type u_1} (a : α) {l₁ l₂ : List α} (motive : a :: l₁ <+~ a :: l₂ → Prop) (x : a :: l₁ <+~ a :: l₂),\n  (∀ (l : List α) (p : l ~ a :: l₁) (s : List.Sublist l (a :: l₂)),\n      motive (_ : ∃ l, ∃ (_ : l ~ a :: l₁), List.Sublist l (a :: l₂))) →\n    motive x",
  "constCategory": "Definition"},
 {"references": ["invImage", "WellFoundedRelation", "Nat.lt_wfRel", "Nat"],
  "name": "measure",
  "constType": "{α : Sort u} → (α → ℕ) → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLowerSet.of_WithLowerSet_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithLowerSet.ofLowerSet.symm = Topology.WithLowerSet.toLowerSet",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Prod.snd",
   "setOf",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.prod",
  "constType": "{α : Type u_1} → {β : Type u_2} → Set α → Set β → Set (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.le_total.match_1",
  "constType":
  "∀ (m n : ℕ) (motive : m < n ∨ m ≥ n → Prop) (x : m < n ∨ m ≥ n),\n  (∀ (h : m < n), motive (_ : m < n ∨ m ≥ n)) → (∀ (h : m ≥ n), motive (_ : m < n ∨ m ≥ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "BEq.beq",
   "List.cons",
   "BEq",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "Bool",
   "List.erase.match_1",
   "List.nil",
   "List.erase.match_2"],
  "name": "List.erase",
  "constType": "{α : Type u_1} → [inst : BEq α] → List α → α → List α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "iSup_exists.match_1",
  "constType":
  "∀ {ι : Sort u_1} {p : ι → Prop} (motive : Exists p → Prop) (x : Exists p),\n  (∀ (i : ι) (h : p i), motive (_ : Exists p)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Unit",
   "Bool.true",
   "Eq.refl",
   "List.erase.match_1",
   "Bool",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "id",
   "Eq"],
  "name": "List.filter_cons_of_pos",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {a : α} (l : List α), p a = true → List.filter p (a :: l) = a :: List.filter p l",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "OrderTop.le_top",
   "BoundedOrder.toOrderTop",
   "Prop.le",
   "LE.le",
   "Prop.boundedOrder"],
  "name": "Prop.heytingAlgebra.proof_1",
  "constType": "∀ (a : Prop), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds_empty",
   "OrderDual.instPreorder",
   "EmptyCollection.emptyCollection",
   "Set",
   "lowerBounds",
   "OrderDual",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Set.univ",
   "Eq"],
  "name": "lowerBounds_empty",
  "constType": "∀ {α : Type u} [inst : Preorder α], lowerBounds ∅ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "And",
   "Iff",
   "Preorder.toLT",
   "Pi.partialOrder",
   "LT.lt",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "Not",
   "IsOpen",
   "Preorder.lt_iff_le_not_le"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_3",
  "constType":
  "∀ {α : Type u_1} (a b : TopologicalSpace α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.«term𝓝[≥]_»._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_9"],
  "name": "Topology.«term𝓝[≥]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Not", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_not_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x ≤ x_1 → ¬x_1 ≤ x → Prop) (x x_1 : α) (x_2 : x ≤ x_1)\n  (x_3 : ¬x_1 ≤ x), (∀ (_a _b : α) (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive _a _b hab hba) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals.loop.match_2",
   "List.cons",
   "Lean.Data.AC.removeNeutrals.loop",
   "List",
   "Unit",
   "List.nil",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.removeNeutrals.match_1",
   "Nat"],
  "name": "Lean.Data.AC.removeNeutrals",
  "constType":
  "{α : Sort u_1} → [info : Lean.Data.AC.ContextInformation α] → α → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.bot_le",
  "constType": "∀ {α : Type u} [self : BooleanAlgebra α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.le_sSup",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Classical.choose", "Quot", "Quot.exists_rep", "Quot.mk", "Eq"],
  "name": "Quot.out",
  "constType": "{α : Sort u_1} → {r : α → α → Prop} → Quot r → α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.le.step",
   "Nat.le",
   "Nat.below",
   "Nat.brecOn",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.le_trans.match_1"],
  "name": "Nat.le_trans",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "constCategory": "Theorem"},
 {"references":
  ["le_iSup_of_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iSup",
   "iSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "iSup_mono",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f g : ι → α}, (∀ (i : ι), f i ≤ g i) → iSup f ≤ iSup g",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.replicate.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.replicate",
  "constType": "{α : Type u} → ℕ → α → List α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_4",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.toLower._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.toDualHomeomorph._lambda_1._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "PUnit.unit",
   "Lean.Syntax.missing",
   "List",
   "String",
   "PUnit",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax.rec",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.casesOn",
  "constType":
  "{motive_1 : Lean.Syntax → Sort u} →\n  (t : Lean.Syntax) →\n    motive_1 Lean.Syntax.missing →\n      ((info : Lean.SourceInfo) →\n          (kind : Lean.SyntaxNodeKind) → (args : Array Lean.Syntax) → motive_1 (Lean.Syntax.node info kind args)) →\n        ((info : Lean.SourceInfo) → (val : String) → motive_1 (Lean.Syntax.atom info val)) →\n          ((info : Lean.SourceInfo) →\n              (rawVal : Substring) →\n                (val : Lean.Name) →\n                  (preresolved : List Lean.Syntax.Preresolved) →\n                    motive_1 (Lean.Syntax.ident info rawVal val preresolved)) →\n            motive_1 t",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.symm.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∧ b → Prop) (x : a ∧ b), (∀ (ha : a) (hb : b), motive (_ : a ∧ b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.symm", "and_imp", "And", "Iff"],
  "name": "Prop.heytingAlgebra.proof_2",
  "constType": "∀ (x x_1 x_2 : Prop), x → x_1 → x_2 ↔ x ∧ x_1 → x_2",
  "constCategory": "Theorem"},
 {"references": ["Char", "UInt32.toNat", "Nat", "Char.utf8Size"],
  "name": "String.csize",
  "constType": "Char → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "List.instLawfulBEqListInstBEqList.match_1",
   "BEq",
   "LawfulBEq",
   "Eq.refl",
   "List.casesOn",
   "beq_self_eq_true",
   "implies_congr",
   "rfl",
   "Eq",
   "BEq.beq",
   "Eq.mpr",
   "List.rec",
   "Bool.true",
   "Init.Core._auxLemma.1",
   "List.nil",
   "Eq.symm",
   "Eq.trans",
   "id",
   "List.cons",
   "Bool.true_and",
   "List.beq",
   "And",
   "Eq.ndrec",
   "List.instBEqList",
   "List",
   "and",
   "LawfulBEq.mk",
   "Bool.and_eq_true",
   "Bool",
   "And.intro",
   "congrArg",
   "List.cons.injEq",
   "congrFun"],
  "name": "List.instLawfulBEqListInstBEqList.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α], LawfulBEq (List α)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "Union.union",
   "Set",
   "Singleton.singleton",
   "Insert.insert",
   "rfl",
   "Set.instUnionSet",
   "Eq",
   "Set.instInsertSet"],
  "name": "Set.insert_eq",
  "constType": "∀ {α : Type u} (x : α) (s : Set α), insert x s = {x} ∪ s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "le_iSup₂",
   "iSup",
   "Exists.intro",
   "le_iSup",
   "iSup_le",
   "iSup_exists.match_1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSup₂_le",
   "CompleteLattice.toSupSet"],
  "name": "iSup_exists",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {p : ι → Prop} {f : Exists p → α},\n  ⨆ (x : Exists p), f x = ⨆ i, ⨆ (h : p i), f (_ : Exists p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "mem_of_mem_nhds.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] {a : α} {s : Set α} (motive : (∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t) → Prop)\n  (x : ∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t),\n  (∀ (_t : Set α) (ht : _t ⊆ s) (left : IsOpen _t) (hs : a ∈ _t), motive (_ : ∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["SProd.sprod",
   "Inf.inf",
   "Filter.prod_inf_prod",
   "Filter.instInfFilter",
   "Prod",
   "Filter",
   "Filter.instSProd",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Topology.Constructions._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f₁ f₂ : Filter α} {g₁ g₂ : Filter β}, (f₁ ⊓ f₂) ×ˢ (g₁ ⊓ g₂) = f₁ ×ˢ g₁ ⊓ f₂ ×ˢ g₂",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "PartialOrder.toPreorder",
   "t0Space_iff_inseparable",
   "Set",
   "Set.Ici",
   "Iff.mpr",
   "PartialOrder",
   "Eq",
   "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.2",
   "Set.instSingletonSet",
   "Topology.IsLower",
   "Set.Ici_injective",
   "Eq.mp",
   "congr",
   "TopologicalSpace",
   "Singleton.singleton",
   "T0Space",
   "Inseparable",
   "congrArg",
   "Topology.IsLower.closure_singleton",
   "Eq.trans"],
  "name": "Topology.IsLower.t0Space.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsLower α], T0Space α",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.ext",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.Subset.antisymm",
  "constType": "∀ {α : Type u} {a b : Set α}, a ⊆ b → b ⊆ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.mk",
  "constType": "{α : Sort u} → (α → α → Sort v) → HasEquiv α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set.preimage",
   "Set",
   "coinduced_le_iff_le_induced.match_1",
   "Exists.intro",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.coinduced",
   "Eq",
   "Iff.intro",
   "And",
   "Iff",
   "Eq.rec",
   "TopologicalSpace",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen"],
  "name": "coinduced_le_iff_le_induced",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {tα : TopologicalSpace α} {tβ : TopologicalSpace β},\n  TopologicalSpace.coinduced f tα ≤ tβ ↔ tα ≤ TopologicalSpace.induced f tβ",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Preorder",
   "LE.le",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_upperClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} {x : α}, x ∈ upperClosure s ↔ ∃ a ∈ s, a ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Function.LeftInverse", "Equiv.invFun"],
  "name": "Equiv.left_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.LeftInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List.Perm", "propext", "List", "List.perm_cons", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.18",
  "constType":
  "∀ {α : Type uu} (a : α) {l₁ l₂ : List α}, (a :: l₁ ~ a :: l₂) = (l₁ ~ l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "List.cons",
   "Nat.le",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "instBEq",
   "List.indexOf",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "HEq.refl",
   "DecidableEq",
   "List",
   "Nat.noConfusion",
   "LT.lt",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.indexOf_get.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} (motive : (x : List α) → List.indexOf a x < List.length x → Prop)\n  (x : List α) (x_1 : List.indexOf a x < List.length x),\n  (∀ (b : α) (l : List α) (h : List.indexOf a (b :: l) < List.length (b :: l)), motive (b :: l) h) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "CovariantClass.mk",
   "LE.le",
   "Multiset.instAddMultiset",
   "Iff.mpr",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
  "constType":
  "∀ {α : Type u_1}, CovariantClass (Multiset α) (Multiset α) (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["T0Space.rec",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "T0Space.casesOn",
  "constType":
  "{α : Type u} →\n  [inst : TopologicalSpace α] →\n    {motive : T0Space α → Sort u_1} →\n      (t : T0Space α) → ((t0 : ∀ ⦃x y : α⦄, Inseparable x y → x = y) → motive (_ : T0Space α)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Or",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Std.Logic._auxLemma.25",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "or_and_right",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_insert_iff",
   "Membership.mem",
   "Or",
   "propext",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.32",
  "constType":
  "∀ {α : Type u} {x a : α} {s : Set α}, (x ∈ insert a s) = (x = a ∨ x ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "SemilatticeSup.le_sup_right",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b : α × β), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [inst : OrderedCancelAddCommMonoid α] → AddCancelCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["LowerSet", "Set", "LE"],
  "name": "LowerSet.carrier",
  "constType": "{α : Type u_6} → [inst : LE α] → LowerSet α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableEqList",
   "Eq.refl",
   "eq_true_of_decide",
   "Classical.em",
   "Lean.Data.AC.mergeIdem.loop",
   "implies_congr",
   "instDecidableEqNat",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "instDecidableNot",
   "Lean.Data.AC.List.two_step_induction",
   "eq_false'",
   "Bool.true",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "if_neg",
   "id",
   "true_implies",
   "Ne",
   "List.cons",
   "Or",
   "False",
   "eq_false_of_decide",
   "Or.casesOn",
   "instDecidableFalse",
   "eq_false",
   "if_pos",
   "False.elim",
   "of_eq_true",
   "Bool.false",
   "List",
   "Eq.mp",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_nonEmpty",
  "constType": "∀ (e : List ℕ), e ≠ [] → Lean.Data.AC.mergeIdem e ≠ []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.Mem.tail"],
  "name": "List.mem_cons_of_mem",
  "constType":
  "∀ {α : Type u_1} (y : α) {a : α} {l : List α}, a ∈ l → a ∈ y :: l",
  "constCategory": "Theorem"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set.Elem",
   "Set",
   "Finset",
   "Set.instEmptyCollectionSet",
   "Fintype.ofFinset",
   "Set.fintypeEmpty.proof_1"],
  "name": "Set.fintypeEmpty",
  "constType": "{α : Type u} → Fintype ↑∅",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Contravariant",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.rel", "WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.wf",
  "constType":
  "∀ {α : Sort u} [self : WellFoundedRelation α], WellFounded WellFoundedRelation.rel",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«termI^_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Monotone.mem_lowerBounds_image",
   "And.left",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image",
   "GaloisInsertion.isGLB_of_u_image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), u (l (sInf (u '' s))) ≤ sInf (u '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Variable",
   "Lean.Data.AC.Context",
   "List",
   "Lean.IsCommutative",
   "Lean.IsAssociative",
   "Lean.IsIdempotent",
   "Option"],
  "name": "Lean.Data.AC.Context.mk",
  "constType":
  "{α : Sort u} →\n  (op : α → α → α) →\n    Lean.IsAssociative op →\n      Option (Lean.IsCommutative op) →\n        Option (Lean.IsIdempotent op) → List (Lean.Data.AC.Variable op) → α → Lean.Data.AC.Context α",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr", "Not", "Or.casesOn"],
  "name": "Decidable.not_and_iff_or_not.match_2",
  "constType":
  "∀ (p q : Prop) (motive : ¬p ∨ ¬q → Prop) (h : ¬p ∨ ¬q),\n  (∀ (h : ¬p), motive (_ : ¬p ∨ ¬q)) → (∀ (h : ¬q), motive (_ : ¬p ∨ ¬q)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u} → α → Bot α",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Or", "Iff", "Or.symm"],
  "name": "Or.comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike", "Set", "SetLike.coe_injective", "SetLike.coe", "Eq"],
  "name": "SetLike.ext'",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, ↑p = ↑q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_right",
   "Sup.sup",
   "le_trans",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_of_le_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c ≤ b → c ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.instPreorderWithLower._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Classical.choice",
   "Classical.indefiniteDescription.proof_1",
   "Subtype"],
  "name": "Classical.indefiniteDescription",
  "constType": "{α : Sort u} → (p : α → Prop) → (∃ x, p x) → { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{α : Type u_1} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["SupSet", "CompleteSemilatticeSup"],
  "name": "CompleteSemilatticeSup.toSupSet",
  "constType": "{α : Type u_9} → [self : CompleteSemilatticeSup α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.right",
   "Nat.gt_of_not_le",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "LT.lt",
   "Not",
   "Nat.le_of_lt",
   "And.intro",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_iff_le_not_le",
  "constType": "∀ {m n : ℕ}, m < n ↔ m ≤ n ∧ ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "IsOpen.inter",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "OrderBot",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.of_eq",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis.prod",
   "Topology.IsLower.isTopologicalBasis",
   "Eq.mpr",
   "Set.iUnion",
   "Topology.IsLower",
   "And.casesOn",
   "IsOpen",
   "Eq.trans",
   "Set.compl_iUnion",
   "Set.instSProd",
   "isClosed_Ici",
   "TopologicalSpace.generateFrom",
   "Set.image2",
   "Prod.snd",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "instTopologicalSpaceProd",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Prod.fst",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "propext",
   "Set.Finite.isOpen_biInter",
   "OrderBot.toBot",
   "congr",
   "Set.iInter",
   "Set.preimage_iInter",
   "le_antisymm",
   "congrArg",
   "congrFun",
   "SetLike.coe",
   "Set.Ici_bot",
   "Exists",
   "Set.prod_univ",
   "coe_upperClosure",
   "Topology.IsLower.instClosedIciTopology",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Exists.intro",
   "Set.Ici",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "UpperSet",
   "True",
   "Set.univ_prod",
   "IsClosed.isOpen_compl",
   "Topology.lower",
   "Prod.instPreorderProd",
   "SProd.sprod",
   "upperClosure",
   "TopologicalSpace",
   "le_generateFrom",
   "Topology.IsLower.lowerBasis",
   "id",
   "eq_self",
   "Membership.mem",
   "Bot.bot",
   "TopologicalSpace.GenerateOpen.basic",
   "funext",
   "Set.preimage",
   "Set.iInter_congr_Prop",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.univ",
   "LE.le",
   "IsClosed.prod",
   "Set.Finite",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "Set.image2_subset_iff",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Prod.mk",
   "Prod",
   "Topology.IsLower.mk",
   "Set.instInterSet"],
  "name": "Topology.instIsLowerProd.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α]\n  [inst_3 : OrderBot α] [inst_4 : Preorder β] [inst_5 : TopologicalSpace β] [inst_6 : Topology.IsLower β]\n  [inst_7 : OrderBot β], Topology.IsLower (α × β)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "Or.inr",
   "instOfNatNat",
   "Or.casesOn",
   "Nat",
   "instLTNat",
   "GT.gt",
   "Eq"],
  "name": "Nat.mod_eq_sub_mod.match_1",
  "constType":
  "∀ {b : ℕ} (motive : b = 0 ∨ b > 0 → Prop) (x : b = 0 ∨ b > 0),\n  (∀ (h₁ : b = 0), motive (_ : b = 0 ∨ b > 0)) → (∀ (h₁ : b > 0), motive (_ : b = 0 ∨ b > 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Eq.refl",
   "Filter",
   "Filter.Eventually",
   "instMembershipSetFilter",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.Filter.Eventually._eq_1",
  "constType":
  "∀ {α : Type u} (p : α → Prop) (f : Filter α), Filter.Eventually p f = ({x | p x} ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra",
   "Prop.distribLattice",
   "Prop.heytingAlgebra.proof_3",
   "Prop.heytingAlgebra.proof_1",
   "Prop.heytingAlgebra.proof_2",
   "BoundedOrder.toOrderTop",
   "DistribLattice.toLattice",
   "OrderTop.toTop",
   "DistribLattice",
   "HImp.mk",
   "OrderBot.toBot",
   "HeytingAlgebra.mk",
   "Prop.heytingAlgebra.proof_4",
   "Prop.le",
   "Prop.boundedOrder",
   "BoundedOrder.toOrderBot",
   "Prop.hasCompl",
   "BoundedOrder",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Prop.heytingAlgebra",
  "constType": "HeytingAlgebra Prop",
  "constCategory": "Definition"},
 {"references": ["Top", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toTop : Top α] → (∀ (a : α), a ≤ ⊤) → OrderTop α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "GaloisInsertion.gc",
   "Set",
   "LE.le.trans",
   "Monotone.mem_lowerBounds_image",
   "Preorder",
   "GaloisConnection.monotone_u",
   "And.left",
   "GaloisInsertion",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "And.right",
   "upperBounds",
   "GaloisInsertion.le_l_u",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "And.intro",
   "Set.image",
   "Set.mem_image_of_mem"],
  "name": "GaloisInsertion.isGLB_of_u_image",
  "constType":
  "∀ {α : Type u} {β : Type v} {l : α → β} {u : β → α} [inst : Preorder α] [inst_1 : Preorder β],\n  GaloisInsertion l u → ∀ {s : Set β} {a : α}, IsGLB (u '' s) a → IsGLB s (l a)",
  "constCategory": "Theorem"},
 {"references": ["MonadWithReaderOf", "semiOutParam"],
  "name": "MonadWithReaderOf.withReader",
  "constType":
  "{ρ : semiOutParam (Type u)} →\n  {m : Type u → Type v} → [self : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "isGLB_iInf",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α}, IsGLB (Set.range f) (⨅ j, f j)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Topology.WithUpper",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4034",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "List.instMembershipList",
   "HAdd.hAdd",
   "List.Sublist",
   "Eq.refl",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "Exists.intro",
   "Std.Data.Fin.Lemmas._auxLemma.15",
   "Std.Data.List.Lemmas._auxLemma.12",
   "Exists.casesOn",
   "implies_congr",
   "instLTNat",
   "True",
   "Std.Data.List.Basic._auxLemma.2",
   "Eq",
   "Std.Data.List.Basic._auxLemma.3",
   "Eq.mpr",
   "forall_congr",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Std.Data.List.Pairwise._auxLemma.18",
   "Eq.trans",
   "Nat.succ",
   "Fin.mk",
   "id",
   "Std.Logic._auxLemma.29",
   "Membership.mem",
   "eq_self",
   "List.map_map",
   "funext",
   "List.cons",
   "instAddNat",
   "Std.Data.Fin.Lemmas._auxLemma.17",
   "instHAdd",
   "Function.comp",
   "Std.Data.List.Pairwise._auxLemma.19",
   "implies_true",
   "List.length",
   "Std.Logic._auxLemma.23",
   "instLTFin",
   "List.Sublist.rec",
   "Std.Logic._auxLemma.57",
   "List.Pairwise",
   "And",
   "eq_true",
   "List.sublist_eq_map_get.match_1",
   "of_eq_true",
   "List",
   "LT.lt",
   "congr",
   "List.map",
   "List.get",
   "congrArg",
   "Fin.succ",
   "Fin",
   "and_self",
   "congrFun"],
  "name": "List.sublist_eq_map_get",
  "constType":
  "∀ {α : Type u_1} {l' l : List α},\n  List.Sublist l' l → ∃ is, l' = List.map (List.get l) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Monotone.comp",
   "Function.comp",
   "OrderHom.mono",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.comp.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ]\n  (g : β →o γ) (f : α →o β), Monotone (↑g ∘ ↑f)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsLower",
  "constType":
  "(α : Type u_1) → [t : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_7",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_8"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.eq_or_lt_of_le.match_2",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ≤ x_1 → Prop) (x x_1 : ℕ) (x_2 : x ≤ x_1),\n  (∀ (x : Nat.zero ≤ Nat.zero), motive Nat.zero Nat.zero x) →\n    (∀ (n : ℕ) (x : Nat.zero ≤ Nat.succ n), motive Nat.zero (Nat.succ n) x) →\n      (∀ (n : ℕ) (h : Nat.succ n ≤ Nat.zero), motive (Nat.succ n) Nat.zero h) →\n        (∀ (n m : ℕ) (h : Nat.succ n ≤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UInt8",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet.toLowerSet_le_iff",
   "Topology.WithLowerSet",
   "propext",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  (↑Topology.WithLowerSet.toLowerSet a ≤ ↑Topology.WithLowerSet.toLowerSet b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeSup",
   "le_sSup",
   "iSup",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "rfl",
   "CompleteLattice.toSupSet",
   "Preorder.toLE",
   "Eq"],
  "name": "le_iSup",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] (f : ι → α) (i : ι), f i ≤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.termπ_._closed_4",
   "Topology.termπ_._closed_2"],
  "name": "Topology.termπ_._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet", "Nonempty"],
  "name": "Topology.WithUpperSet.instNonemptyWithUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α], Nonempty (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references": ["Min", "LE", "Min.mk", "LE.le", "ite", "DecidableRel"],
  "name": "minOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 ↦ x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 ↦ x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.gt_of_not_le.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat",
   "LE.le",
   "GT.gt"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references": ["Unit", "SeqLeft"],
  "name": "SeqLeft.mk",
  "constType":
  "{f : Type u → Type v} → ({α β : Type u} → f α → (Unit → f β) → f α) → SeqLeft f",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_1",
  "constType": "127 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "Preorder",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Eq",
   "Iff.symm",
   "isLowerSet_compl",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.isClosed_iff_isLower",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α] {s : Set α},\n  IsClosed s ↔ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "iInf_le_of_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_mono",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f g : ι → α}, (∀ (i : ι), f i ≤ g i) → iInf f ≤ iInf g",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "SetLike",
   "SetLike.mk",
   "LowerSet.instSetLikeLowerSet.proof_1",
   "LE",
   "LowerSet.carrier"],
  "name": "LowerSet.instSetLikeLowerSet",
  "constType": "{α : Type u_1} → [inst : LE α] → SetLike (LowerSet α) α",
  "constCategory": "Definition"},
 {"references":
  ["And", "Exists", "exists_and_right", "propext", "Eq.symm", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.106",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, ((∃ x, p x) ∧ b) = ∃ x, p x ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Subtype.val",
   "nhds",
   "Set",
   "Subtype.ext",
   "Eq.refl",
   "wrapped._@.Mathlib.Topology.Basic._hyg.10536",
   "rfl",
   "ConditionallyCompleteLattice.toInfSet",
   "Eq",
   "Set.instMembershipSet",
   "Subtype.property",
   "And",
   "Filter.principal",
   "definition._@.Mathlib.Topology.Basic._hyg.10536",
   "Eq.mpr",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Eq.symm",
   "IsOpen",
   "Subtype",
   "Subtype.mk",
   "id",
   "Filter.instCompleteLatticeFilter"],
  "name": "nhds_def",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] (a : α), nhds a = ⨅ s ∈ {s | a ∈ s ∧ IsOpen s}, Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Function.comp._rarg",
   "Topology.WithUpperSet.map._elambda_1",
   "_neutral"],
  "name": "Topology.WithUpperSet.map._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Nat.noConfusion",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.propIntro",
   "Eq"],
  "name": "Nat.succ.injEq",
  "constType": "∀ (n n_1 : ℕ), (Nat.succ n = Nat.succ n_1) = (n = n_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.eq",
   "List.Nodup.map",
   "List.instMembershipList",
   "Subtype.val",
   "List.Nodup.of_map",
   "List.attach",
   "Iff.mpr",
   "Eq",
   "Iff.intro",
   "List.Nodup",
   "List",
   "Eq.rec",
   "List.attach_map_val",
   "List.map",
   "Eq.symm",
   "Subtype"],
  "name": "List.Nodup.attach",
  "constType":
  "∀ {α : Type u} {l : List α}, List.Nodup l → List.Nodup (List.attach l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.isOpen_sUnion",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "isOpen_sUnion",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set (Set α)}, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "Multiset.zero", "Multiset", "Zero.mk"],
  "name": "Multiset.instZeroMultiset",
  "constType": "{α : Type u_1} → Zero (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "top_sdiff'",
   "Eq.symm",
   "CoheytingAlgebra.toHNot",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.27",
  "constType":
  "∀ {α : Type u_2} [inst : CoheytingAlgebra α] (a : α), ￢a = ⊤ \\ a",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["Exists", "Classical.skolem", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.5",
  "constType":
  "∀ {α : Sort u} {b : α → Sort v} {p : (x : α) → b x → Prop}, (∀ (x : α), ∃ y, p x y) = ∃ f, ∀ (x : α), p x (f x)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.toLowerSet._cstage1",
  "constType": "{α : Type u_1} → α ≃ Topology.WithLowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "Decidable.byCases"],
  "name": "Decidable.em",
  "constType": "∀ (p : Prop) [inst : Decidable p], p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Or", "Iff.mp", "Iff", "Iff.mpr", "Or.imp"],
  "name": "or_congr",
  "constType": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∨ b ↔ c ∨ d)",
  "constCategory": "Theorem"},
 {"references":
  ["List.nil_sublist",
   "eq_true",
   "List",
   "List.Sublist",
   "List.nil",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.29",
  "constType": "∀ {α : Type u_1} (l : List α), List.Sublist [] l = True",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Eq.rec", "HasSubset.Subset", "HasSubset", "subset_rfl", "Eq"],
  "name": "subset_of_eq",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1], a = b → a ⊆ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Basic._auxLemma.130",
   "Pure.pure",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Set.instMembershipSet",
   "Filter.principal",
   "Mathlib.Order.Filter.Basic._auxLemma.132",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "Filter.instPureFilter",
   "Iff",
   "of_eq_true",
   "congr",
   "Singleton.singleton",
   "Filter",
   "Filter.ext",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter"],
  "name": "Filter.principal_singleton",
  "constType": "∀ {α : Type u} (a : α), Filter.principal {a} = pure a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_get",
   "List.indexOf_lt_length",
   "List.instMembershipList",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "DecidableEq",
   "of_eq_true",
   "List",
   "LT.lt",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin.mk",
   "congrFun"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α) (h : ∀ (x : α), x ∈ l) (a : α),\n  List.get l { val := List.indexOf a l, isLt := (_ : List.indexOf a l < List.length l) } = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Eq.refl",
   "eq_true_of_decide",
   "True",
   "Eq",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "Bool.true",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "congrFun"],
  "name": "Nat.beq_refl",
  "constType": "∀ (a : ℕ), Nat.beq a a = true",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.union_right",
   "List.instUnionList",
   "List.Perm",
   "DecidableEq",
   "List",
   "Union.union",
   "List.Perm.union_left",
   "List.Perm.trans"],
  "name": "List.Perm.union",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {l₁ l₂ t₁ t₂ : List α}, l₁ ~ l₂ → t₁ ~ t₂ → l₁ ∪ t₁ ~ l₂ ∪ t₂",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.mk",
  "constType": "{α : Type u} → (α → α → Prop) → HasSubset α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "And",
   "And.right",
   "Iff.mp",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "Continuous",
   "continuous_prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst"],
  "name": "continuous_snd",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], Continuous Prod.snd",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.comm",
   "Lean.Data.AC.sort.loop",
   "Lean.Data.AC.insert_nonEmpty",
   "Eq.refl",
   "List.casesOn",
   "Lean.Data.AC.sort",
   "Lean.Data.AC.ContextInformation.isComm",
   "True",
   "Eq",
   "Lean.Data.AC.Context.evalList_sort_cons",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Option.none",
   "Lean.Data.AC.List.two_step_induction",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Option.toBool.match_1",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "instDecidableEqBool",
   "Option",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Unit",
   "Option.casesOn",
   "eq_false_of_decide",
   "Lean.Data.AC.Context.op",
   "False.elim",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.Data.AC.Context.sort_loop_nonEmpty",
   "of_eq_true",
   "Bool.false",
   "List",
   "Lean.IsCommutative",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α),\n  Lean.Data.AC.ContextInformation.isComm ctx = true →\n    ∀ (e : List ℕ), Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort e) = Lean.Data.AC.evalList α ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "And.intro",
   "Nat",
   "And.casesOn",
   "instLTNat",
   "LE.le"],
  "name": "List.mem_range'_1.match_2",
  "constType":
  "∀ {m s n : ℕ} (motive : s ≤ m ∧ m < s + n → Prop) (x : s ≤ m ∧ m < s + n),\n  (∀ (h₁ : s ≤ m) (h₂ : m < s + n), motive (_ : s ≤ m ∧ m < s + n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonadWithReaderOf", "Monad", "ReaderT", "MonadWithReaderOf.mk"],
  "name": "instMonadWithReaderOfReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadWithReaderOf ρ (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Iff",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Iff.not_right",
   "Set.not_nonempty_iff_eq_empty",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Set.nonempty_iff_ne_empty",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Nonempty s ↔ s ≠ ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Not",
   "List.not_mem_nil",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.not_mem_zero",
  "constType": "∀ {α : Type u_1} (a : α), ¬a ∈ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "UInt32",
   "Char",
   "DecidableEq",
   "Decidable.isFalse",
   "Decidable",
   "Char.eq_of_val_eq",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqChar.match_1",
   "decEq",
   "Char.ne_of_val_ne",
   "instDecidableEqUInt32",
   "Eq"],
  "name": "instDecidableEqChar",
  "constType": "DecidableEq Char",
  "constCategory": "Definition"},
 {"references":
  ["instIsIdempotentInfToInf.proof_1",
   "SemilatticeInf.toInf",
   "IsIdempotent",
   "Inf.inf",
   "SemilatticeInf"],
  "name": "instIsIdempotentInfToInf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α], IsIdempotent α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Definition"},
 {"references":
  ["definition._@.Mathlib.Topology.Basic._hyg.10536",
   "TopologicalSpace",
   "Filter",
   "Subtype",
   "Eq"],
  "name": "wrapped._@.Mathlib.Topology.Basic._hyg.10536",
  "constType": "Subtype (Eq @definition✝)",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "Iff", "Subtype.forall.match_1", "Subtype.mk", "Subtype"],
  "name": "Subtype.forall",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop},\n  (∀ (x : { a // p a }), q x) ↔ ∀ (a : α) (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "IsClosed.mk",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen sᶜ → IsClosed s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "propext",
   "List.mem_singleton",
   "List.nil",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.3",
  "constType": "∀ {α : Type u_1} {a b : α}, (a ∈ [b]) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "Set.preimage",
   "TopologicalSpace.ext",
   "Function.comp",
   "Set",
   "Exists.intro",
   "rfl",
   "induced_compose.match_2",
   "Eq",
   "Iff.intro",
   "And",
   "propext",
   "Eq.rec",
   "TopologicalSpace",
   "induced_compose.match_1",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen"],
  "name": "induced_compose",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [tγ : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  TopologicalSpace.induced f (TopologicalSpace.induced g tγ) = TopologicalSpace.induced (g ∘ f) tγ",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsOpen_of._closed_6", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SizeOf",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Functor"],
  "name": "Functor.map",
  "constType":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β",
  "constCategory": "Definition"},
 {"references":
  ["List",
   "List.Sublist",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.slnil",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop}, List.Sublist.below (_ : List.Sublist [] [])",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "LE.le.trans",
   "iInf₂_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf₂_le_of_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {a : α} {f : (i : ι) → κ i → α} (i : ι)\n  (j : κ i), f i j ≤ a → ⨅ i, ⨅ j, f i j ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_trans.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x < x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x < x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a < _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "le_iInf",
   "CompleteLattice.toInfSet",
   "le_trans",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iSup_le",
   "iInf_le",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toSupSet"],
  "name": "le_iInf_iSup",
  "constType":
  "∀ {α : Type u} {ι : Sort w} {κ : ι → Sort w'} [inst : CompleteLattice α] {f : (a : ι) → κ a → α},\n  ⨆ g, ⨅ a, f a (g a) ≤ ⨅ a, ⨆ b, f a b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "And.intro", "And.left"],
  "name": "And.imp",
  "constType": "∀ {a c b d : Prop}, (a → c) → (b → d) → a ∧ b → c ∧ d",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "compl_compl",
   "Function.comp",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra",
   "Eq",
   "id"],
  "name": "compl_comp_compl",
  "constType": "∀ {α : Type u} [inst : BooleanAlgebra α], compl ∘ compl = id",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Multiset.cons",
   "Finset.cons",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Not",
   "rfl",
   "Eq"],
  "name": "Finset.cons_val",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a : α} (h : ¬a ∈ s), (Finset.cons a s h).val = a ::ₘ s.val",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Subtype.val",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "And.casesOn",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Subtype.coe_image.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {s : Set (Subtype p)} (a : α) (motive : a ∈ Subtype.val '' s → Prop)\n  (x : a ∈ Subtype.val '' s),\n  (∀ (val : α) (ha' : p val) (in_s : { val := val, property := ha' } ∈ s) (h_eq : ↑{ val := val, property := ha' } = a),\n      motive (_ : ∃ a_1 ∈ s, ↑a_1 = a)) →\n    motive x",
  "constCategory": "Definition"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "Set.mem_compl_iff",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.78",
  "constType": "∀ {α : Type u} (s : Set α) (x : α), (x ∈ sᶜ) = ¬x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Pi.generalizedHeytingAlgebra.proof_3",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "SemilatticeInf.toPartialOrder",
   "Pi.instHImpForAll",
   "Lattice.mk",
   "Pi.generalizedHeytingAlgebra.proof_5",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Pi.generalizedHeytingAlgebra.proof_1",
   "Pi.generalizedHeytingAlgebra.proof_2",
   "Pi.generalizedHeytingAlgebra.proof_4",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderTop",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "Lattice",
   "GeneralizedHeytingAlgebra",
   "Pi.hasLe",
   "Lattice.toSemilatticeSup",
   "Pi.orderTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.generalizedHeytingAlgebra",
  "constType":
  "{ι : Type u_1} →\n  {α : ι → Type u_4} → [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] → GeneralizedHeytingAlgebra ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Append",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["propext", "imp_self", "True", "Eq"],
  "name": "Std.Logic._auxLemma.5",
  "constType": "∀ {a : Prop}, (a → a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "LE.le",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "instLENat",
   "List.rec",
   "Nat.le_of_succ_le_succ",
   "List",
   "Option.none",
   "PUnit",
   "List.get?_len_le.match_1",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.get?",
   "Option"],
  "name": "List.get?_len_le",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ}, List.length l ≤ n → List.get? l n = none",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Std.Data.List.Lemmas.0.List.erase.match_1.splitter",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → motive true → motive false → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "Setoid",
   "Equivalence.refl",
   "HasEquiv.Equiv",
   "Setoid.iseqv"],
  "name": "Setoid.refl",
  "constType": "∀ {α : Sort u} [inst : Setoid α] (a : α), a ≈ a",
  "constCategory": "Theorem"},
 {"references": ["Union", "Union.mk", "DecidableEq", "List", "List.union"],
  "name": "List.instUnionList",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Union (List α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "inf_le_inf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → b ⊓ a ≤ c ⊓ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsCommutative",
  "constType": "(α : Type u) → (α → α → α) → Prop",
  "constCategory": "Other"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.mem_cons_self",
   "List.nil"],
  "name": "List.mem_singleton_self",
  "constType": "∀ {α : Type u_1} (a : α), a ∈ [a]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RelIso",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["Array.foldl",
   "Array",
   "OfNat.ofNat",
   "Array.push",
   "instOfNatNat",
   "Nat",
   "Array.size"],
  "name": "Array.append",
  "constType": "{α : Type u} → Array α → Array α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Subtype", "Set.instMembershipSet"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.61",
  "constType":
  "∀ {α : Type u} {s : Set α} {f : Filter α}, (s ∈ f) = (f ≤ Filter.principal s)",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "and_assoc.match_2",
  "constType":
  "∀ {a b c : Prop} (motive : a ∧ b ∧ c → Prop) (x : a ∧ b ∧ c),\n  (∀ (ha : a) (hb : b) (hc : c), motive (_ : a ∧ b ∧ c)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["List.Pairwise", "eq_true", "List.Pairwise.nil", "List.nil", "True", "Eq"],
  "name": "Std.Data.List.Basic._auxLemma.2",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop}, List.Pairwise R [] = True",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Finite.intro", "Finite", "Nat", "Fin"],
  "name": "Finite.rec",
  "constType":
  "∀ {α : Sort u_1} {motive : Finite α → Prop},\n  (∀ {n : ℕ} (a : α ≃ Fin n), motive (_ : Finite α)) → ∀ (t : Finite α), motive t",
  "constCategory": "Other"},
 {"references": ["UpperSet.carrier", "LE", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.upper'",
  "constType":
  "∀ {α : Type u_6} [inst : LE α] (self : UpperSet α), IsUpperSet self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "InfSet",
   "iSup",
   "SupSet.sSup",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "iInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.mk",
  "constType":
  "{α : Type u_1} →\n  [toBooleanAlgebra : BooleanAlgebra α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) →\n                  (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "DistribLattice.ofInfSupLe.proof_1",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.mk",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "DistribLattice.ofInfSupLe",
  "constType":
  "{α : Type u} → [inst : Lattice α] → (∀ (a b c : α), a ⊓ (b ⊔ c) ≤ a ⊓ b ⊔ a ⊓ c) → DistribLattice α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_9} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "sInf_empty",
   "Set.univ",
   "Set.sInter",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_empty",
  "constType": "∀ {α : Type u_1}, ⋂₀ ∅ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderBot.toBot",
   "OrderBot.bot_le",
   "Prop.le",
   "LE.le",
   "Prop.boundedOrder",
   "BoundedOrder.toOrderBot"],
  "name": "Prop.heytingAlgebra.proof_3",
  "constType": "∀ (a : Prop), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsIdempotent", "Eq"],
  "name": "Lean.IsIdempotent.mk",
  "constType":
  "{α : Sort u} → {op : α → α → α} → (∀ (x : α), op x x = x) → Lean.IsIdempotent op",
  "constCategory": "Other"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "IsTrans",
   "Set.instIsTransSetSubsetInstHasSubsetSet.proof_1"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet",
  "constType": "∀ {α : Type u}, IsTrans (Set α) fun x x_1 ↦ x ⊆ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLower.toLower",
   "Iff.rfl",
   "Topology.WithLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.toLower_inj",
  "constType":
  "∀ {α : Type u_1} {a b : α}, ↑Topology.WithLower.toLower a = ↑Topology.WithLower.toLower b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Or.elim",
   "le_total",
   "Eq"],
  "name": "lt_trichotomy",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a = b ∨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instLENat",
   "Iff.rfl",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m ↔ n < m",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.toLowerSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Not", "Bool", "Eq"],
  "name": "Bool.of_not_eq_true.match_1",
  "constType":
  "∀ (motive : (x : Bool) → ¬x = true → Prop) (x : Bool) (x_1 : ¬x = true),\n  (∀ (h : ¬true = true), motive true h) → (∀ (x : ¬false = true), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "trueSetoid",
   "Setoid.r",
   "Trunc.induction_on₂",
   "Trunc",
   "Quot.sound",
   "Eq"],
  "name": "Trunc.eq",
  "constType": "∀ {α : Sort u_1} (a b : Trunc α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "UpperSet.Ici",
   "Topology.IsLowerSet.closure_eq_upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "upperClosure_singleton",
   "Preorder",
   "Topology.IsLowerSet",
   "Set.Ici",
   "UpperSet",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "upperClosure",
   "TopologicalSpace",
   "Singleton.singleton",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsLowerSet.closure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α] {a : α},\n  closure {a} = Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Mathlib.Topology.Basic._auxLemma.13",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Topology.Basic._auxLemma.12",
   "TopologicalSpace",
   "congr",
   "Set.sUnion",
   "Mathlib.Topology.Basic._auxLemma.11",
   "congrArg",
   "interior",
   "IsOpen",
   "Eq.trans"],
  "name": "mem_interior",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {x : α}, x ∈ interior s ↔ ∃ t, t ⊆ s ∧ IsOpen t ∧ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Topology.upperSet.proof_1",
   "Topology.upperSet.proof_3",
   "TopologicalSpace",
   "Topology.upperSet.proof_2",
   "IsUpperSet",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.upperSet",
  "constType": "(α : Type u_4) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.ext.match_1", "Subtype.val", "rfl", "Subtype.mk", "Subtype", "Eq"],
  "name": "Subtype.ext",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "Preorder.le_trans",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : TopologicalSpace α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "Or",
   "List.mem_cons.match_1",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "or_true",
   "True",
   "Eq",
   "Iff.intro",
   "eq_true",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "of_eq_true",
   "List",
   "true_or",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.mem_cons",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α}, a ∈ b :: l ↔ a = b ∨ a ∈ l",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "inferInstance",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsRefl",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "instIsReflLeToLE",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsReflSetSubsetInstHasSubsetSet.proof_1",
  "constType": "∀ {α : Type u_1}, IsRefl (Set α) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.Range._hyg.49",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "sInf_image",
   "Set",
   "Set.iInter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.image",
   "Set.sInter",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → Set β) (s : Set α), ⋂₀ (f '' s) = ⋂ x ∈ s, f x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Topology.IsLower",
   "TopologicalSpace",
   "T0Space",
   "Topology.IsLower.t0Space.proof_1",
   "PartialOrder"],
  "name": "Topology.IsLower.t0Space",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsLower α], T0Space α",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.id",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.map",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "ContinuousMap.id",
   "Eq",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map_id",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.WithUpperSet.map OrderHom.id = ContinuousMap.id (Topology.WithUpperSet α)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.closure_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithUpperSet.map._elambda_1._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.map._elambda_1._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "instMonadReaderOfReaderT",
   "Unit",
   "Lean.MonadQuotation.mk",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "instMonadWithReaderOfReaderT",
   "instMonadWithReader",
   "instMonadReader",
   "Lean.MonadRef.mk",
   "Lean.PrettyPrinter.UnexpandM",
   "instOfNatNat",
   "Lean.Name",
   "Lean.MonadQuotation",
   "MonadWithReader.withReader",
   "Applicative.toPure",
   "id"],
  "name": "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
  "constType": "Lean.MonadQuotation Lean.PrettyPrinter.UnexpandM",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "EStateM.dummyRestore",
  "constType": "{σ : Type u} → σ → PUnit.{u_1} → σ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ContravariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_sUnion",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.sUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} {x : α} {S : Set (Set α)}, (x ∈ ⋃₀ S) = ∃ t ∈ S, x ∈ t",
  "constCategory": "Theorem"},
 {"references": ["Seq", "Unit"],
  "name": "Seq.mk",
  "constType":
  "{f : Type u → Type v} → ({α β : Type u} → f (α → β) → (Unit → f α) → f β) → Seq f",
  "constCategory": "Other"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_1",
  "constType": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.induction_on",
   "List.mem_dedup",
   "Multiset.instMembershipMultiset",
   "Multiset.dedup"],
  "name": "Multiset.mem_dedup",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, a ∈ Multiset.dedup s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Prod.snd",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Set.univ",
   "True",
   "Eq",
   "of_eq_true",
   "SProd.sprod",
   "Prod",
   "Set.univ_inter",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "congrFun"],
  "name": "Set.univ_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {t : Set β}, Set.univ ×ˢ t = Prod.snd ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "lt_trans", "IsTrans", "IsTrans.mk", "Preorder"],
  "name": "instIsTransLtToLT.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], IsTrans α fun x x_1 ↦ x < x_1",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.instUnionList",
   "List.insert",
   "List.perm_insert_swap",
   "List.Perm.insert",
   "Union.union",
   "List.Perm.rec",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "Eq",
   "List.nil_union",
   "List.cons_union",
   "Eq.mpr",
   "List.Perm",
   "DecidableEq",
   "of_eq_true",
   "List",
   "congr",
   "List.Perm.trans",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "List.Perm.union_right",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {l₁ l₂ : List α} (t₁ : List α), l₁ ~ l₂ → l₁ ∪ t₁ ~ l₂ ∪ t₁",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Quot.lift", "Quot", "Eq"],
  "name": "Quot.liftOn",
  "constType":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "constCategory": "Definition"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{α : Type u} → [self : Lattice α] → Inf α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_left",
   "True",
   "Eq",
   "Set.instInterSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.26",
  "constType": "∀ {α : Type u} (s t : Set α), (s ∩ t ⊆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "inf_of_le_right",
   "OrderBot.toBot",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "bot_le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_bot_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a : α}, a ⊓ ⊥ = ⊥",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List.Perm", "List"],
  "name": "List.Perm.swap",
  "constType":
  "∀ {α : Type uu} (x y : α) (l : List α), y :: x :: l ~ x :: y :: l",
  "constCategory": "Other"},
 {"references":
  ["continuous_iff_isClosed",
   "Iff.mp",
   "Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsClosed"],
  "name": "IsClosed.preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ {s : Set β}, IsClosed s → IsClosed (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.map._elambda_1",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    ((a : β) → (fun x ↦ Topology.WithUpperSet β) a) →\n      (Topology.WithUpperSet α → β) → Topology.WithUpperSet α → Topology.WithUpperSet β",
  "constCategory": "Axiom"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Array.appendCore.loop.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (i : ℕ) → (Unit → motive 0) → ((i' : ℕ) → motive (Nat.succ i')) → motive i",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "propext",
   "Multiset.mem_dedup",
   "Multiset",
   "Multiset.instMembershipMultiset",
   "Eq",
   "Multiset.dedup"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.23",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ Multiset.dedup s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "BiheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_GenLoop_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "decidable_of_decidable_of_iff.proof_1"],
  "name": "decidable_of_decidable_of_iff",
  "constType": "{p q : Prop} → [inst : Decidable p] → (p ↔ q) → Decidable q",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.rec",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.casesOn",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLower α → Sort u} →\n        (t_1 : Topology.IsLower α) →\n          ((topology_eq_lowerTopology : t = Topology.lower α) → motive (_ : Topology.IsLower α)) → motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "Function.comp",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_const_mono",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {ι' : Sort u_6} [inst : CompleteLattice α] {a : α}, (ι' → ι) → ⨅ x, a ≤ ⨅ x, a",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.instSupSetSet", "SupSet.sSup"],
  "name": "Set.sUnion",
  "constType": "{α : Type u_1} → Set (Set α) → Set α",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_2",
  "constType": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "Set.preimage_mono",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (m : α → β) (f : Filter α) {x y : Set β},\n  x ∈ Set.preimage m ⁻¹' f.sets → x ⊆ y → m ⁻¹' y ∈ f",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x < x_1 → Prop) (x x_1 : α) (x_2 : x < x_1),\n  (∀ (_a _b : α) (hab : _a < _b), motive _a _b hab) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsAssociative.mk",
   "instIsAssociative.proof_1",
   "IsAssociative",
   "Lean.IsAssociative"],
  "name": "instIsAssociative",
  "constType":
  "{α : Type u_1} → {op : α → α → α} → [inst : IsAssociative α op] → Lean.IsAssociative op",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Mathlib.Data.List.Pairwise._auxLemma.8",
   "Eq.refl",
   "Std.Logic._auxLemma.45",
   "List.pmap._sunfold.proof_1",
   "rfl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "forall_congr",
   "List.nil",
   "Mathlib.Data.List.Pairwise._auxLemma.2",
   "And.casesOn",
   "Eq.trans",
   "id",
   "Membership.mem",
   "List.cons",
   "Or",
   "List.pmap",
   "Mathlib.Data.List.Pairwise._auxLemma.10",
   "List.pmap._sunfold.proof_2",
   "Iff.intro",
   "List.Pairwise",
   "And",
   "Eq.ndrec",
   "Mathlib.Data.List.Pairwise._auxLemma.9",
   "of_eq_true",
   "propext",
   "List",
   "Eq.mp",
   "congr",
   "congrArg"],
  "name": "List.pairwise_pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → α → Prop} {p : β → Prop} {f : (b : β) → p b → α} {l : List β}\n  (h : ∀ x ∈ l, p x),\n  List.Pairwise R (List.pmap f l h) ↔ List.Pairwise (fun b₁ b₂ ↦ ∀ (h₁ : p b₁) (h₂ : p b₂), R (f b₁ h₁) (f b₂ h₂)) l",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_false",
   "False",
   "of_decide_eq_false",
   "Bool.false",
   "Decidable",
   "Bool",
   "Eq"],
  "name": "eq_false_of_decide",
  "constType": "∀ {p : Prop} {x : Decidable p}, decide p = false → p = False",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff", "iff_true_intro", "True"],
  "name": "imp_true_iff",
  "constType": "∀ (α : Sort u), α → True ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "cond",
   "List.findIdx.go.match_1",
   "List.below",
   "List.brecOn",
   "Nat.succ_eq_add_one",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "List.findIdx.go",
   "Eq",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go._unfold",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.symm",
   "id",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "PProd.fst",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.findIdx_cons.findIdx_go_succ",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (l : List α) (n : ℕ), List.findIdx.go p l (n + 1) = List.findIdx.go p l n + 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "InfSet", "sInfHomClass"],
  "name": "sInfHomClass.toFunLike",
  "constType":
  "{F : Type u_8} →\n  {α : outParam (Type u_9)} →\n    {β : outParam (Type u_10)} →\n      [inst : InfSet α] → [inst_1 : InfSet β] → [self : sInfHomClass F α β] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "rfl",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "Nat.eq_of_beq_eq_true.match_1",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ"],
  "name": "Nat.eq_of_beq_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = true → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["cond",
   "Bool.casesOn",
   "Set.Elem",
   "Bool.false",
   "Bool.true",
   "Set",
   "PUnit",
   "Bool"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
  "constType":
  "{α : Type u_1} →\n  (s : Set α) →\n    (motive : (x : Bool) → (bif x then PUnit.{u_1 + 1} else ↑s) → Sort u_2) →\n      (x : Bool) →\n        (y : bif x then PUnit.{u_1 + 1} else ↑s) →\n          ((y : bif true then PUnit.{u_1 + 1} else ↑s) → motive true y) →\n            ((y : bif false then PUnit.{u_1 + 1} else ↑s) → motive false y) → motive x y",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Set.Ici",
   "Preorder",
   "Set.Ici_subset_Ici",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.10",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, (Set.Ici a ⊆ Set.Ici b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "propext",
   "SProd.sprod",
   "Prod",
   "Filter",
   "Filter.instSProd",
   "Filter.prod_neBot",
   "Filter.NeBot",
   "Eq"],
  "name": "Mathlib.Topology.Constructions._auxLemma.28",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : Filter α} {g : Filter β}, Filter.NeBot (f ×ˢ g) = (Filter.NeBot f ∧ Filter.NeBot g)",
  "constCategory": "Theorem"},
 {"references":
  ["BEq.beq",
   "BEq",
   "List",
   "Eq.refl",
   "List.countP",
   "Nat",
   "List.count",
   "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.count._eq_1",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] (a : α), List.count a = List.countP fun x ↦ x == a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.instBEqName",
   "BEq.beq",
   "Lean.Syntax.getKind",
   "Lean.SyntaxNodeKind",
   "Bool",
   "Lean.Syntax"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Lean.Syntax → Lean.SyntaxNodeKind → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "List.Nodup.pmap.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a} (a : α)\n  (ha : a ∈ l)\n  (motive :\n    (x : { x // x ∈ l }) →\n      f ↑{ val := a, property := ha } (_ : p ↑{ val := a, property := ha }) = f ↑x (_ : p ↑x) → Prop)\n  (x : { x // x ∈ l }) (h : f ↑{ val := a, property := ha } (_ : p ↑{ val := a, property := ha }) = f ↑x (_ : p ↑x)),\n  (∀ (b : α) (hb : b ∈ l)\n      (h :\n        f ↑{ val := a, property := ha } (_ : p ↑{ val := a, property := ha }) =\n          f ↑{ val := b, property := hb } (_ : p ↑{ val := b, property := hb })),\n      motive { val := b, property := hb } h) →\n    motive x h",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Classical.propDecidable",
   "Finite",
   "Eq.refl",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Set.fintypeImage",
   "Set.image",
   "Eq.symm",
   "Finite.of_fintype",
   "nonempty_fintype"],
  "name": "Finite.Set.finite_image.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Set α) (f : α → β) [inst : Finite ↑s], Finite ↑(f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.getArgs",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1",
   "Lean.Name.mkStr4",
   "Lean.Syntax.getNumArgs",
   "Lean.Syntax.atom",
   "Nat.sub",
   "Array.extract._rarg",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_2",
   "Lean.Name.mkStr2",
   "UInt8",
   "PUnit.unit",
   "Lean.SourceInfo.none",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef",
   "Nat.decLe"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le.proof_1",
   "Quotient.liftOn₂",
   "List",
   "List.Subperm",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Le",
  "constType": "{α : Type u_1} → Multiset α → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "instLENat",
   "Nat.lt_of_lt_of_le",
   "LT.lt",
   "Nat",
   "Array.size",
   "instLTNat",
   "LE.le"],
  "name": "Array.foldlM.loop.proof_1",
  "constType":
  "∀ {α : Type u_1} (as : Array α), ∀ stop ≤ Array.size as, ∀ j < stop, j < Array.size as",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "interior_subset",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "interior",
   "True",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.16",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (interior s ⊆ s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.sUnion",
   "IsOpen"],
  "name": "interior",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Std.Data.List.Lemmas.0.List.find?_cons.match_1.splitter",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → motive true → motive false → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.gciGenerateFrom.proof_1",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "TopologicalSpace.gciGenerateFrom.proof_2",
   "Function.comp",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "LE.le",
   "TopologicalSpace.gc_generateFrom",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.gciGenerateFrom.proof_3",
   "OrderDual.ofDual",
   "GaloisCoinsertion",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisCoinsertion.mk",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom",
  "constType":
  "(α : Type u_1) →\n  GaloisCoinsertion (fun t ↦ ↑OrderDual.toDual {s | IsOpen s}) (TopologicalSpace.generateFrom ∘ ↑OrderDual.ofDual)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_5",
   "List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_7",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "Set.biUnion_range",
   "Eq.refl",
   "Set.iUnion_exists",
   "Eq",
   "Set.instMembershipSet",
   "Iff.of_eq",
   "Set.range",
   "Set.iUnion",
   "Eq.mp",
   "Set.iUnion_congr_Prop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_iUnion_eq'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {f : ι → α} {g : α → Set β},\n  ⋃ x, ⋃ y, ⋃ (_ : f y = x), g x = ⋃ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "EquivLike.toEmbeddingLike.proof_1",
   "EmbeddingLike.mk",
   "FunLike.mk",
   "EmbeddingLike",
   "EquivLike.toEmbeddingLike.proof_2"],
  "name": "EquivLike.toEmbeddingLike",
  "constType":
  "{E : Sort u_1} → {α : Sort u_3} → {β : Sort u_4} → [iE : EquivLike E α β] → EmbeddingLike E α β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.IsClosed_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SemilatticeSup.toSup",
   "hnot_inf_distrib",
   "Inf.inf",
   "HasCompl.compl",
   "Sup.sup",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toHasCompl",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "compl_inf",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], (x ⊓ y)ᶜ = xᶜ ⊔ yᶜ",
  "constCategory": "Theorem"},
 {"references": ["WellFoundedRelation"],
  "name": "WellFoundedRelation.rel",
  "constType": "{α : Sort u} → [self : WellFoundedRelation α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.9",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∃ x, p x ∨ q x) = ((∃ x, p x) ∨ ∃ x, q x)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.RightInverse", "Function.Surjective", "Exists.intro", "Eq"],
  "name": "Function.RightInverse.surjective",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α}, Function.RightInverse g f → Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["HImp"],
  "name": "HImp.himp",
  "constType": "{α : Type u_4} → [self : HImp α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Trunc.mk", "Trunc", "Trunc.ind"],
  "name": "Trunc.induction_on",
  "constType":
  "∀ {α : Sort u_1} {β : Trunc α → Prop} (q : Trunc α), (∀ (a : α), β (Trunc.mk a)) → β q",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "sup_comm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Iff",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "sdiff_le_iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "sdiff_le_iff'",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b c : α}, a \\ b ≤ c ↔ a ≤ c ⊔ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mod",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OrderTop", "LE", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{α : Type u} → [inst : LE α] → [self : BoundedOrder α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Eq.to_iff.match_1",
  "constType":
  "∀ {a : Prop} (motive : (b : Prop) → a = b → Prop) (b : Prop) (x : a = b), (Unit → motive a (_ : a = a)) → motive b x",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Inhabited", "PUnit", "Inhabited.mk"],
  "name": "instInhabitedPUnit",
  "constType": "Inhabited PUnit.{u_1}",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper",
   "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper.proof_1",
   "Topology.WithUpper.instPreorderWithUpper",
   "Preorder"],
  "name":
  "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpper (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["OrderHomClass.mono",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "InfSet.sInf",
   "OrderHom",
   "CompleteLattice.toBot",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "sInfHomClass.toInfTopHomClass",
   "Eq.mpr",
   "Topology.IsLower",
   "Continuous",
   "le_trans",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Set.image",
   "sInfHom.instSInfHomClassSInfHom",
   "Eq.trans",
   "sInfHomClass.map_sInf",
   "isClosed_Ici",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "eq_of_heq",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "bot_nonempty",
   "Std.Logic._auxLemma.5",
   "sInfHomClass.toFunLike",
   "Std.Logic._auxLemma.23",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "Std.Logic._auxLemma.57",
   "And",
   "HEq.refl",
   "of_eq_true",
   "IsClosed",
   "congrArg",
   "congrFun",
   "sInfHom",
   "Exists",
   "HEq",
   "Topology.IsLower.instClosedIciTopology",
   "Eq.ge",
   "Set",
   "Eq.refl",
   "InfHomClass.toOrderHomClass",
   "Set.Ici",
   "True",
   "Std.Logic._auxLemma.33",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "InfTopHomClass.toInfHomClass",
   "TopologicalSpace",
   "OrderHomClass.toOrderHom",
   "Eq.symm",
   "Set.Subset.antisymm",
   "id",
   "Membership.mem",
   "Std.Logic._auxLemma.29",
   "funext",
   "Set.image_congr",
   "Set.preimage",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "LE.le.trans",
   "ConditionallyCompleteLattice.toLattice",
   "FunLike.coe",
   "Topology.IsLower.continuous_of_Ici",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "sInf_le",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toTop",
   "Eq.casesOn",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Mathlib.Order.CompleteLattice._auxLemma.3"],
  "name": "sInfHom.continuous",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : CompleteLattice α] [inst_1 : CompleteLattice β] [inst_2 : TopologicalSpace α]\n  [inst_3 : Topology.IsLower α] [inst_4 : TopologicalSpace β] [inst_5 : Topology.IsLower β] (f : sInfHom α β),\n  Continuous ↑f",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Topology.Basic._auxLemma.49",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Topology.Basic._auxLemma.18",
   "Set.ext",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "congr",
   "TopologicalSpace",
   "Filter",
   "congrArg",
   "IsOpen",
   "interior",
   "Eq.trans",
   "instMembershipSetFilter"],
  "name": "interior_eq_nhds'",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, interior s = {a | s ∈ nhds a}",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "∀ (n : ℕ), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "sSup_eq_iSup",
   "Set",
   "InfSet.sInf",
   "OrderDual",
   "Set.instMembershipSet",
   "Eq"],
  "name": "sInf_eq_iInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α}, sInf s = ⨅ a ∈ s, a",
  "constCategory": "Theorem"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{α : Type u_1} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower", "Preorder"],
  "name": "Topology.WithLower.instPreorderWithLower._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "ContinuousMap"],
  "name": "ContinuousMap.toFun",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → C(α, β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references": ["SupSet", "InfSet.sInf", "OrderDual", "SupSet.mk", "InfSet"],
  "name": "OrderDual.supSet",
  "constType": "(α : Type u_9) → [inst : InfSet α] → SupSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Iff", "not_congr", "Not"],
  "name": "Iff.not",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Bot.bot",
   "propext",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.neBot_iff",
   "Filter.NeBot",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.30",
  "constType": "∀ {α : Type u} {f : Filter α}, Filter.NeBot f = (f ≠ ⊥)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : Lean.SyntaxNodeKinds} → Lean.TSyntax ks → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT", "MonadLiftT.monadLift"],
  "name": "liftM",
  "constType":
  "{m : Type u_1 → Type u_2} → {n : Type u_1 → Type u_3} → [self : MonadLiftT m n] → {α : Type u_1} → m α → n α",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.ofLowerSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "HEq.refl",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.mem_split",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, a ∈ l → ∃ s, ∃ t, l = s ++ a :: t",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.ofUpperSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.finite_empty",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set.Finite.isOpen_sInter",
   "Set.sInter_empty",
   "Set",
   "Eq.refl",
   "Set.union_subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Iff.mpr",
   "Set.Subset.rfl",
   "Eq",
   "Set.instSingletonSet",
   "Set.sInter_union",
   "Eq.mpr",
   "TopologicalSpace.IsTopologicalBasis.mk",
   "Set.iUnion",
   "Eq.substr",
   "Set.sUnion_image",
   "le_generateFrom",
   "TopologicalSpace",
   "Set.Finite.union",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "IsOpen",
   "id",
   "TopologicalSpace.IsTopologicalBasis",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "Set.singleton_subset_iff",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "Union.union",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.iUnion₂_eq_univ_iff",
   "Set.univ",
   "Set.Finite",
   "Set.instMembershipSet",
   "TopologicalSpace.generateFrom_anti",
   "And",
   "Set.instHasSubsetSet",
   "Set.finite_singleton",
   "Eq.ndrec",
   "propext",
   "Set.empty_subset",
   "Singleton.singleton",
   "Set.sUnion",
   "And.intro",
   "le_antisymm",
   "Set.sInter",
   "Set.sInter_singleton",
   "Set.mem_univ",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isTopologicalBasis_of_subbasis",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f ↦ ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "False",
   "Iff",
   "EmptyCollection.emptyCollection",
   "Iff.rfl",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_empty_iff_false",
  "constType": "∀ {α : Type u} (x : α), x ∈ ∅ ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β],\n  GaloisCoinsertion l u →\n    ∀ (s : Set α),\n      (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)\n          ((↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (sInf (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual '' s))) ≤\n        sInf (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual '' s)",
  "constCategory": "Theorem"},
 {"references": ["Quot", "Eq"],
  "name": "Quot.lift",
  "constType":
  "{α : Sort u} → {r : α → α → Prop} → {β : Sort v} → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → Quot r → β",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step", "instLENat", "Nat.le.refl", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ",
  "constType": "∀ (n : ℕ), n ≤ Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Nonempty", "Subtype"],
  "name": "NonemptyType",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SupSet",
   "CompleteSemilatticeSup",
   "PartialOrder.toPreorder",
   "Set",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeSup.mk",
  "constType":
  "{α : Type u_9} →\n  [toPartialOrder : PartialOrder α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) → CompleteSemilatticeSup α",
  "constCategory": "Other"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_9",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false",
   "Lean.replaceRef.match_1",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.replaceRef",
  "constType": "Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.substr",
  "constType": "∀ {α : Sort u} {p : α → Prop} {a b : α}, b = a → p a → p b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_le_succ",
   "dite",
   "List.indexOf",
   "ite",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "List.rec",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.indexOf_cons",
   "Nat.succ",
   "if_neg",
   "Nat.strictOrderedSemiring",
   "id",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "instBEq",
   "List.length",
   "LE.le",
   "if_pos",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "List",
   "le_refl",
   "Not",
   "Nat.zero_le",
   "congrArg",
   "congrFun"],
  "name": "List.indexOf_le_length",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, List.indexOf a l ≤ List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.beq.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → List α → Sort u_2) →\n    (x x_1 : List α) →\n      (Unit → motive [] []) →\n        ((a : α) → (as : List α) → (b : α) → (bs : List α) → motive (a :: as) (b :: bs)) →\n          ((x x_2 : List α) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "Filter.NeBot.mk",
   "Set",
   "Set.Nonempty",
   "Set.not_nonempty_empty",
   "Set.instEmptyCollectionSet",
   "Filter.nonempty_of_mem",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.rec",
   "Filter",
   "Filter.mem_bot",
   "Eq.symm",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.forall_mem_nonempty_iff_neBot",
  "constType":
  "∀ {α : Type u} {f : Filter α}, (∀ s ∈ f, Set.Nonempty s) ↔ Filter.NeBot f",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp", "Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Set.Finite"],
  "name": "Set.toFinite",
  "constType": "∀ {α : Type u} (s : Set α) [inst : Finite ↑s], Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sInter",
   "IsOpen",
   "AlexandrovDiscrete",
   "Set.instMembershipSet"],
  "name": "AlexandrovDiscrete.mk",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α],\n  (∀ (S : Set (Set α)), (∀ s ∈ S, IsOpen s) → IsOpen (⋂₀ S)) → AlexandrovDiscrete α",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "Set",
   "Set.Iic",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "Mathlib.Order.UpperLower.Basic._auxLemma.95",
   "lowerClosure",
   "Eq.trans",
   "LowerSet.ext",
   "Membership.mem",
   "funext",
   "LowerSet.Iic",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.38",
   "LowerSet",
   "And",
   "of_eq_true",
   "LowerSet.instSetLikeLowerSet",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "SetLike.coe",
   "congrFun"],
  "name": "lowerClosure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (a : α), lowerClosure {a} = LowerSet.Iic a",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "propext", "and_not_self_iff", "Not", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.85",
  "constType": "∀ (a : Prop), (a ∧ ¬a) = False",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.65",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "∀ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references":
  ["IsCommutative.mk",
   "Set",
   "Set.inter_comm",
   "Inter.inter",
   "IsCommutative",
   "Set.instInterSet"],
  "name": "Set.inter_isComm.proof_1",
  "constType": "∀ {α : Type u_1}, IsCommutative (Set α) fun x x_1 ↦ x ∩ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.instMembershipSet"],
  "name": "Filter.sets_of_superset",
  "constType":
  "∀ {α : Type u_1} (self : Filter α) {x y : Set α}, x ∈ self.sets → x ⊆ y → y ∈ self.sets",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "or_and_left", "Iff.mpr"],
  "name": "Prop.distribLattice.proof_3",
  "constType": "∀ (x x_1 x_2 : Prop), (x ∨ x_1) ∧ (x ∨ x_2) → x ∨ x_1 ∧ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Order.Coframe", "CompleteLattice"],
  "name": "Order.Coframe.toCompleteLattice",
  "constType": "{α : Type u_1} → [self : Order.Coframe α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "CompleteLattice.le_sSup",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "SupSet.sSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (s : Set αᵒᵈᵒᵈ), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Eq.ndrec",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Eq.subset",
  "constType": "∀ {α : Type u_1} {s t : Set α}, s = t → s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.7",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, (a ⊔ b ≤ c) = (a ≤ c ∧ b ≤ c)",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Classical.em.match_2",
  "constType":
  "∀ (p u v : Prop) (motive : u ≠ v ∨ p → Prop) (not_uv_or_p : u ≠ v ∨ p),\n  (∀ (hne : u ≠ v), motive (_ : u ≠ v ∨ p)) → (∀ (h : p), motive (_ : u ≠ v ∨ p)) → motive not_uv_or_p",
  "constCategory": "Definition"},
 {"references": ["PLift"],
  "name": "PLift.down",
  "constType": "{α : Sort u} → PLift α → α",
  "constCategory": "Definition"},
 {"references": ["Or", "propext", "Not", "imp_iff_not_or", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.64",
  "constType": "∀ {a b : Prop}, (a → b) = (¬a ∨ b)",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Nonempty.some",
  "constType": "{α : Sort u_2} → Nonempty α → α",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Multiset.map.proof_1",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.map",
   "Multiset.ofList"],
  "name": "Multiset.map",
  "constType":
  "{α : Type u_1} → {β : Type v} → (α → β) → Multiset α → Multiset β",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpper",
   "Exists",
   "Equiv.toHomeomorphOfInducing",
   "setOf",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Topology.IsUpper",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "Equiv.refl",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsUpper α] → Topology.WithUpper α ≃ₜ α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name": "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["PProd", "Lean.Data.AC.Expr", "PUnit", "Lean.Data.AC.Expr.rec", "Nat"],
  "name": "Lean.Data.AC.Expr.below",
  "constType":
  "{motive : Lean.Data.AC.Expr → Sort u} → Lean.Data.AC.Expr → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Functor"],
  "name": "Functor.mapConst",
  "constType":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → α → f β → f α",
  "constCategory": "Definition"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "And.comm.match_1",
   "And.intro",
   "And.comm.match_2"],
  "name": "And.comm",
  "constType": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Topology.IsUpperSet.rec",
   "Eq"],
  "name": "Topology.IsUpperSet.recOn",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpperSet α → Sort u} →\n        (t_1 : Topology.IsUpperSet α) →\n          ((topology_eq_upperSetTopology : t = Topology.upperSet α) → motive (_ : Topology.IsUpperSet α)) → motive t_1",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam"],
  "name": "ZeroHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Zero M] → [inst : Zero N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["Inf", "SemilatticeInf"],
  "name": "SemilatticeInf.toInf",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → Inf α",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Inf.inf",
   "InfSet.sInf",
   "Eq.refl",
   "Insert.insert",
   "True",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Set.image",
   "Eq.symm",
   "Eq.trans",
   "id",
   "eq_self",
   "sInfHomClass.map_sInf",
   "Set.image_pair",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sInfHomClass",
   "sInf_insert",
   "sInf_singleton",
   "CompleteLattice",
   "Eq.ndrec",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "Singleton.singleton",
   "sInf_pair",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Set.instInsertSet",
   "congrFun"],
  "name": "sInfHomClass.toInfTopHomClass.proof_1",
  "constType":
  "∀ {F : Type u_3} {α : Type u_2} {β : Type u_1} [inst : CompleteLattice α] [inst_1 : CompleteLattice β]\n  [inst_2 : sInfHomClass F α β] (f : F) (a b : α), ↑f (a ⊓ b) = ↑f a ⊓ ↑f b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "le_sup_inf"],
  "name": "Pi.distribLattice.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → DistribLattice (α' i)] (x x_1 x_2 : (i : ι) → α' i) (x_3 : ι),\n  (x x_3 ⊔ x_1 x_3) ⊓ (x x_3 ⊔ x_2 x_3) ≤ x x_3 ⊔ x_1 x_3 ⊓ x_2 x_3",
  "constCategory": "Theorem"},
 {"references": ["LE", "OrderBot", "BoundedOrder"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{α : Type u} → [inst : LE α] → [self : BoundedOrder α] → OrderBot α",
  "constCategory": "Definition"},
 {"references": ["Nat.isValidChar", "UInt32", "UInt32.toNat"],
  "name": "UInt32.isValidChar",
  "constType": "UInt32 → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "GaloisConnection.u_inf",
   "Filter.gc_map_comap",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Filter.map",
   "Filter.instInfFilter",
   "Filter.comap",
   "Filter",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.comap_inf",
  "constType":
  "∀ {α : Type u} {β : Type v} {g₁ g₂ : Filter β} {m : α → β},\n  Filter.comap m (g₁ ⊓ g₂) = Filter.comap m g₁ ⊓ Filter.comap m g₂",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.isEmpty.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((head : α) → (tail : List α) → motive (head :: tail)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "And",
   "Exists",
   "setOf",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "lowerClosure",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsUpper.upperBasis",
  "constType": "(α : Type u_1) → [inst : Preorder α] → Set (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "HImp.himp",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "HeytingAlgebra.toHasCompl",
   "HeytingAlgebra.himp_bot",
   "Eq"],
  "name": "himp_bot",
  "constType": "∀ {α : Type u_2} [inst : HeytingAlgebra α] (a : α), a ⇨ ⊥ = aᶜ",
  "constCategory": "Theorem"},
 {"references": ["UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.val",
  "constType": "UInt32 → Fin UInt32.size",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "outParam",
   "Function.Injective",
   "EmbeddingLike",
   "FunLike.coe"],
  "name": "EmbeddingLike.injective'",
  "constType":
  "∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EmbeddingLike F α β] (f : F),\n  Function.Injective ↑f",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.9",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_coe",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.4",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets", "Filter.filter_eq_iff", "propext", "Set", "Filter", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.3",
  "constType": "∀ {α : Type u} {f g : Filter α}, (f = g) = (f.sets = g.sets)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EStateM.Result",
  "constType": "Type u → Type u → Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Nat.pred",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.sub_succ",
  "constType": "∀ (n m : ℕ), n - Nat.succ m = Nat.pred (n - m)",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "OrderHom",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : Preorder α] → [inst : Preorder β] → Type (max u_6 u_7)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff.rfl",
   "antitone_comp_ofDual_iff",
   "Function.comp",
   "Eq.refl",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "monotone_toDual_comp_iff",
   "Monotone",
   "OrderDual",
   "Antitone",
   "id"],
  "name": "monotone_dual_iff",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone (↑OrderDual.toDual ∘ f ∘ ↑OrderDual.ofDual) ↔ Monotone f",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist"],
  "name": "List.Sublist.cons",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist l₁ (a :: l₂)",
  "constCategory": "Other"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.ilast'.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : α → List α → Sort u_2) →\n    (x : α) → (x_1 : List α) → ((a : α) → motive a []) → ((x b : α) → (l : List α) → motive x (b :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Option.none",
   "Bool.false",
   "Option.some",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.getPos?.match_1",
   "optParam",
   "Substring",
   "String.Pos",
   "Option"],
  "name": "Lean.SourceInfo.getPos?",
  "constType": "Lean.SourceInfo → optParam Bool false → Option String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.IsClosed_of._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Or",
   "Iff",
   "Iff.rfl",
   "Union.union",
   "Set",
   "Set.instUnionSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_union",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), x ∈ a ∪ b ↔ x ∈ a ∨ x ∈ b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "le_top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a → a = ⊤",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((x : ℕ) → motive x 0) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r", "Setoid", "Quotient", "Quot.inductionOn", "Quotient.mk"],
  "name": "Quotient.inductionOn",
  "constType":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s),\n  (∀ (a : α), motive (Quotient.mk s a)) → motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length",
   "instLTNat",
   "List.get.proof_1",
   "PProd",
   "PProd.fst",
   "List.get.match_1",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Fin.mk",
   "Fin"],
  "name": "List.get",
  "constType": "{α : Type u} → (as : List α) → Fin (List.length as) → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.Subset.trans",
  "constType": "∀ {α : Type u} {a b c : Set α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.Perm.refl.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (x : List α),\n  (Unit → motive []) → (∀ (x : α) (xs : List α), motive (x :: xs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set", "Inter.inter", "TopologicalSpace.GenerateOpen", "Set.instInterSet"],
  "name": "TopologicalSpace.GenerateOpen.inter",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} (s t : Set α),\n  TopologicalSpace.GenerateOpen g s → TopologicalSpace.GenerateOpen g t → TopologicalSpace.GenerateOpen g (s ∩ t)",
  "constCategory": "Other"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "List.pairwise_cons.match_1",
   "List.cons",
   "Iff",
   "List.pairwise_cons.match_2",
   "List.instMembershipList",
   "List",
   "And.intro",
   "List.Pairwise.cons"],
  "name": "List.pairwise_cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) ↔ (∀ a' ∈ l, R a a') ∧ List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«term𝓝[_]_»._closed_10",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[_]_»._closed_2"],
  "name": "Topology.«term𝓝[_]_»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finite.Set.finite_image.proof_1", "Set.Elem", "Set", "Finite", "Set.image"],
  "name": "Finite.Set.finite_image",
  "constType":
  "∀ {α : Type u} {β : Type v} (s : Set α) (f : α → β) [inst : Finite ↑s], Finite ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "Set.Ici",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.IsLower.topology_eq",
   "Set.instMembershipSet",
   "Eq",
   "continuous_generateFrom",
   "Eq.ndrec",
   "IsClosed.isOpen_compl",
   "Topology.IsLower",
   "Topology.lower",
   "Continuous",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen"],
  "name": "Topology.IsLower.continuous_of_Ici",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α]\n  [inst_3 : TopologicalSpace β] {f : β → α}, (∀ (a : α), IsClosed (f ⁻¹' Set.Ici a)) → Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.toHomeomorphOfInducing._at.Topology.IsUpperSet.WithUpperSetHomeomorph._spec_1",
   "Equiv.refl",
   "_obj",
   "_neutral"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._rarg._cstage2",
  "constType": "_obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "ContinuousMap",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references":
  ["instHasEquiv", "Setoid", "Quotient", "HasEquiv.Equiv", "Quot.lift", "Eq"],
  "name": "Quotient.lift",
  "constType":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedCancelAddCommMonoid α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_3",
  "constType":
  "∀ {ι : Type u_2} {α : ι → Type u_1} [inst : (i : ι) → BooleanAlgebra (α i)] (x : (i : ι) → α i) (x_1 : ι),\n  ⊤ ≤ x x_1 ⊔ (x x_1)ᶜ",
  "constCategory": "Theorem"},
 {"references": ["Monotone", "Preorder", "LE.le", "Preorder.toLE", "id"],
  "name": "monotone_id",
  "constType": "∀ {α : Type u} [inst : Preorder α], Monotone id",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.getPos?",
   "Bool.false",
   "Bool",
   "optParam",
   "Lean.Syntax",
   "Lean.Syntax.getHeadInfo",
   "String.Pos",
   "Option"],
  "name": "Lean.Syntax.getPos?",
  "constType": "Lean.Syntax → optParam Bool false → Option String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet.topology_eq_lowerSetTopology",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.topology_eq",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α],\n  inst_1 = Topology.lowerSet α",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "le_compl_comm",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "le_compl_compl",
   "LE.le.trans",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "Antitone",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE"],
  "name": "compl_anti",
  "constType": "∀ {α : Type u_2} [inst : HeytingAlgebra α], Antitone compl",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll.match_3",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.decidableBAll.proof_4",
   "Decidable.isTrue",
   "dite",
   "List.decidableBAll.proof_2",
   "List.decidableBAll.proof_1",
   "DecidablePred",
   "PProd",
   "List.decidableBEx.match_5",
   "PProd.fst",
   "List.rec",
   "Decidable.isFalse",
   "List",
   "PUnit",
   "Decidable",
   "Not",
   "List.nil",
   "List.decidableBAll.proof_3"],
  "name": "List.decidableBAll",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → (l : List α) → Decidable (∀ x ∈ l, p x)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.rec",
  "constType":
  "{motive : Lean.Name → Sort u} →\n  motive Lean.Name.anonymous →\n    ((pre : Lean.Name) → (str : String) → motive pre → motive (Lean.Name.str pre str)) →\n      ((pre : Lean.Name) → (i : ℕ) → motive pre → motive (Lean.Name.num pre i)) → (t : Lean.Name) → motive t",
  "constCategory": "Other"},
 {"references": ["forall_eq'", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.35",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a' = a → p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝ˢ»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Set",
   "OrderDual",
   "TopologicalSpace",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_2",
  "constType":
  "∀ (α : Type u_1) (x : TopologicalSpace α) (s : Set α),\n  IsOpen s → TopologicalSpace.GenerateOpen (↑OrderDual.ofDual (↑OrderDual.toDual {s | IsOpen s})) s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "BEq",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Function.Bijective",
   "Function.Surjective",
   "Fintype.ofBijective.match_1",
   "Finset.instMembershipFinset",
   "And.left",
   "Eq",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "And.right",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "Finset",
   "Finset.mem_univ",
   "Finset.mem_map_of_mem"],
  "name": "Fintype.ofBijective.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Fintype α] (f : α → β) (H : Function.Bijective f) (b : β),\n  b ∈ Finset.map { toFun := f, inj' := (_ : Function.Injective f) } Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike",
   "Function.Injective",
   "Set",
   "SetLike.coe_injective'",
   "SetLike.coe",
   "Eq"],
  "name": "SetLike.coe_injective",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[<]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.upper._cstage1",
  "constType": "(α : Type u_1) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Finite.casesOn",
   "Eq.ndrec",
   "Finite.intro",
   "Finite",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "Equiv.trans",
   "Fin",
   "Equiv.symm",
   "Eq"],
  "name": "Finite.of_equiv",
  "constType":
  "∀ {β : Sort u_2} (α : Sort u_3) [h : Finite α], α ≃ β → Finite β",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "propext",
   "LE.le",
   "le_antisymm_iff",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.36",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, (a = b) = (a ≤ b ∧ b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.get",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "instLTNat",
   "Fin.mk",
   "Eq"],
  "name": "List.get?_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}\n  (motive : (∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a) → Prop)\n  (x : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a),\n  (∀ (w : n < List.length l) (e : List.get l { val := n, isLt := w } = a),\n      motive (_ : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Exists.intro",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn"],
  "name": "Subtype.exists.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop} (motive : (∃ x, q x) → Prop) (x : ∃ x, q x),\n  (∀ (a : α) (b : p a) (h : q { val := a, property := b }), motive (_ : ∃ x, q x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.List.Perm._auxLemma.2",
   "List.cons",
   "Or",
   "List.instMembershipList",
   "Iff.rfl",
   "List.Perm.rec",
   "True",
   "iff_self",
   "Eq",
   "List.Perm",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.List.Perm._auxLemma.3",
   "propext",
   "List",
   "congr",
   "Iff.trans",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.Perm.mem_iff",
  "constType":
  "∀ {α : Type uu} {a : α} {l₁ l₂ : List α}, l₁ ~ l₂ → (a ∈ l₁ ↔ a ∈ l₂)",
  "constCategory": "Theorem"},
 {"references": ["Monotone", "OrderHom", "OrderHom.toFun", "Preorder"],
  "name": "OrderHom.monotone'",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β), Monotone self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b _c : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → _b ≤ _c ∧ ¬_c ≤ _b → Prop)\n  (x : _a ≤ _b ∧ ¬_b ≤ _a) (x_1 : _b ≤ _c ∧ ¬_c ≤ _b),\n  (∀ (hab : _a ≤ _b) (_hba : ¬_b ≤ _a) (hbc : _b ≤ _c) (hcb : ¬_c ≤ _b),\n      motive (_ : _a ≤ _b ∧ ¬_b ≤ _a) (_ : _b ≤ _c ∧ ¬_c ≤ _b)) →\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Fin.veq_of_eq.match_1",
   "Fin.val",
   "LT.lt",
   "Nat",
   "rfl",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Fin.veq_of_eq",
  "constType": "∀ {n : ℕ} {i j : Fin n}, i = j → ↑i = ↑j",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.IsOpen_of._closed_4"],
  "name": "Topology.IsOpen_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.seq",
  "constType": "{α : Type u_1} → {β : Type u_2} → Set (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["List.filter",
   "funext",
   "Eq.refl",
   "instBEq",
   "List.filter_eq'",
   "Subsingleton.elim",
   "Eq",
   "Decidable.decide",
   "Eq.mpr",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "Eq.rec",
   "Decidable",
   "List.replicate",
   "Eq.mp",
   "Std.Data.List.Count._auxLemma.10",
   "Bool",
   "List.count",
   "congrArg",
   "Eq.trans",
   "instSubsingletonDecidable",
   "id",
   "congrFun"],
  "name": "List.filter_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α) (a : α),\n  List.filter (fun x ↦ decide (a = x)) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["And", "Or", "Iff", "Iff.trans", "forall_and", "or_imp", "forall_congr'"],
  "name": "ball_or_left",
  "constType":
  "∀ {α : Sort u_1} {r p q : α → Prop}, (∀ (x : α), p x ∨ q x → r x) ↔ (∀ (x : α), p x → r x) ∧ ∀ (x : α), q x → r x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "iSup_exists",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.iUnion_exists",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {p : ι → Prop} {f : Exists p → Set α},\n  ⋃ (x : Exists p), f x = ⋃ i, ⋃ (h : p i), f (_ : Exists p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.insert",
   "List.instMembershipList",
   "dite",
   "List.Perm.cons",
   "mt",
   "Iff.mpr",
   "True",
   "Eq",
   "List.Perm.subset",
   "eq_false",
   "Eq.mpr",
   "eq_true",
   "List.Perm",
   "List.insert_of_not_mem",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.Perm.mem_iff",
   "List.instDecidableMemListInstMembershipList",
   "Eq.mp",
   "Mathlib.Data.List.Perm._auxLemma.18",
   "congr",
   "Not",
   "not_false_eq_true",
   "congrArg",
   "List.insert_of_mem",
   "Eq.trans",
   "id"],
  "name": "List.Perm.insert",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] (a : α) {l₁ l₂ : List α}, l₁ ~ l₂ → List.insert a l₁ ~ List.insert a l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.iUnion",
   "Set",
   "TopologicalSpace",
   "IsOpen",
   "isOpen_iUnion",
   "Set.instMembershipSet"],
  "name": "isOpen_biUnion",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] {s : Set β} {f : β → Set α},\n  (∀ i ∈ s, IsOpen (f i)) → IsOpen (⋃ i ∈ s, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet.isLowerSet_toLowerSet_preimage",
   "Equiv",
   "Iff.symm",
   "Iff",
   "Topology.WithLowerSet",
   "IsLowerSet",
   "Set.preimage",
   "Set",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.isOpen_ofLowerSet_preimage",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, IsOpen (↑Topology.WithLowerSet.ofLowerSet ⁻¹' s) ↔ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["PUnit", "Prod", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.mk",
  "constType":
  "{σ : semiOutParam (Type u)} →\n  {m : Type u → Type v} → m σ → (σ → m PUnit.{u + 1}) → ({α : Type u} → (σ → α × σ) → m α) → MonadStateOf σ m",
  "constCategory": "Other"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.mk",
  "constType":
  "{ε : semiOutParam (Type u)} →\n  {m : Type v → Type w} → ({α : Type v} → ε → m α) → ({α : Type v} → m α → (ε → m α) → m α) → MonadExceptOf ε m",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "bot_unique",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toDistribLattice",
   "BoundedOrder.toOrderBot"],
  "name": "inf_compl_eq_bot'",
  "constType": "∀ {α : Type u} {x : α} [inst : BooleanAlgebra α], x ⊓ xᶜ = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Set.preimage",
   "IsLowerSet.preimage",
   "OrderHom.monotone",
   "Function.comp",
   "Set",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithLowerSet.toLowerSet",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithLowerSet",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "IsOpen",
   "continuous_def"],
  "name": "Topology.WithLowerSet.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β),\n  Continuous (↑Topology.WithLowerSet.toLowerSet ∘ ↑f ∘ ↑Topology.WithLowerSet.ofLowerSet)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.RightInverse", "Function.comp", "Function.LeftInverse.comp"],
  "name": "Function.RightInverse.comp",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.RightInverse f g → Function.RightInverse h i → Function.RightInverse (h ∘ f) (g ∘ i)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Or", "Iff", "Classical.propDecidable", "Not", "Decidable.imp_iff_not_or"],
  "name": "imp_iff_not_or",
  "constType": "∀ {a b : Prop}, a → b ↔ ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Std.Data.List.Count._auxLemma.10",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.mem_Ici",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a x : α}, x ∈ Set.Ici a ↔ a ≤ x",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.cat",
  "constType": "Lean.Name → ℕ → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "readThe", "MonadReader", "MonadReader.mk"],
  "name": "instMonadReader",
  "constType":
  "(ρ : Type u) → (m : Type u → Type v) → [inst : MonadReaderOf ρ m] → MonadReader ρ m",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_6",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "List.casesOn",
   "Classical.em",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableEqNat",
   "ite",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.List.two_step_induction",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Nat",
   "Lean.IsIdempotent.idempotent",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "Or",
   "Lean.Data.AC.Context.idem",
   "eq_false_of_decide",
   "Or.casesOn",
   "instDecidableTrue",
   "Lean.Data.AC.Context.op",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
   "Lean.Data.AC.Context.mergeIdem_head2",
   "False.elim",
   "of_eq_true",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Eq.mp",
   "congr",
   "Not",
   "congrArg",
   "congrFun",
   "Eq.refl",
   "Lean.Data.AC.Context.mergeIdem_nonEmpty",
   "Lean.Data.AC.ContextInformation.isIdem",
   "True",
   "Lean.Data.AC.Context.assoc",
   "Lean.Data.AC.Context",
   "eq_false'",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "absurd",
   "Option.toBool.match_1",
   "if_neg",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "Option",
   "eq_self",
   "List.cons",
   "False",
   "Or.inr",
   "Unit",
   "Option.casesOn",
   "Lean.IsIdempotent",
   "ite_congr",
   "if_pos",
   "eq_false",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "Or.inl",
   "Bool.false",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Lean.Data.AC.Context.mergeIdem_head",
   "Bool",
   "List.noConfusion"],
  "name": "Lean.Data.AC.Context.evalList_mergeIdem",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α),\n  Lean.Data.AC.ContextInformation.isIdem ctx = true →\n    ∀ (e : List ℕ), Lean.Data.AC.evalList α ctx (Lean.Data.AC.mergeIdem e) = Lean.Data.AC.evalList α ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "IsOpen.mem_nhds",
   "Exists.intro",
   "TopologicalSpace.IsTopologicalBasis.isOpen",
   "Exists.casesOn",
   "Eq",
   "Iff.mp",
   "Filter.HasBasis.prod_nhds",
   "TopologicalSpace.IsTopologicalBasis.nhds_hasBasis",
   "SProd.sprod",
   "TopologicalSpace",
   "Filter",
   "And.casesOn",
   "IsOpen",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter",
   "Membership.mem",
   "Set.instSProd",
   "Set.image2",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "TopologicalSpace.isTopologicalBasis_of_open_of_nhds",
   "IsOpen.prod",
   "nhds",
   "HasSubset.Subset",
   "Prod.fst",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.mem_image2_of_mem",
   "Prod.casesOn",
   "Prod.mk",
   "Prod",
   "And.intro"],
  "name": "TopologicalSpace.IsTopologicalBasis.prod",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β] {B₁ : Set (Set α)}\n  {B₂ : Set (Set β)},\n  TopologicalSpace.IsTopologicalBasis B₁ →\n    TopologicalSpace.IsTopologicalBasis B₂ →\n      TopologicalSpace.IsTopologicalBasis (Set.image2 (fun x x_1 ↦ x ×ˢ x_1) B₁ B₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLower.to_WithLower_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithLower.toLower.symm = Topology.WithLower.ofLower",
  "constCategory": "Theorem"},
 {"references": ["IsAntisymm", "Eq"],
  "name": "IsAntisymm.antisymm",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsAntisymm α r] (a b : α), r a b → r b a → a = b",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.finRange.proof_1",
   "List.Nodup",
   "LT.lt",
   "List.finRange",
   "List.Pairwise.pmap",
   "Fin.ne_of_vne",
   "List.nodup_range",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.nodup_finRange",
  "constType": "∀ (n : ℕ), List.Nodup (List.finRange n)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.37",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_1"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["instLENat", "LT.lt", "Nat", "instLTNat", "Nat.succ", "LE.le"],
  "name": "Nat.lt_of_succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "ZeroHom.mk",
   "Multiset.card.proof_2",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Multiset.card.proof_1",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "AddMonoidHom",
   "AddMonoidHom.mk"],
  "name": "Multiset.card",
  "constType": "{α : Type u_1} → Multiset α →+ ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsAssociative",
   "Sup.sup",
   "instIsAssociativeSupToSup.proof_1"],
  "name": "instIsAssociativeSupToSup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α], IsAssociative α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Definition"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.10",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "sInfHom.toFun",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "Set.image",
   "Eq"],
  "name": "sInfHom.map_sInf'",
  "constType":
  "∀ {α : Type u_8} {β : Type u_9} [inst : InfSet α] [inst_1 : InfSet β] (self : sInfHom α β) (s : Set α),\n  sInfHom.toFun self (sInf s) = sInf (self.toFun '' s)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "instIsAntisymmLeToLEToPreorder",
   "inferInstance",
   "IsAntisymm",
   "Set.instBooleanAlgebraSet",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsAntisymmSetSubsetInstHasSubsetSet.proof_1",
  "constType": "∀ {α : Type u_1}, IsAntisymm (Set α) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references": ["Bool.false", "Bool.true", "Bool.rec", "Bool"],
  "name": "Bool.casesOn",
  "constType":
  "{motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "imp_intro",
  "constType": "∀ {α β : Prop}, α → β → α",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "∀ (x x_1 : ℕ), (fun m n ↦ m * n) (x + 1) x_1 = x_1 + (fun m n ↦ m * n) x x_1",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet.rec._rarg", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.rec._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "List.range_loop_range'",
   "Nat.zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.range.loop",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "List.range",
   "id"],
  "name": "List.range_eq_range'",
  "constType": "∀ (n : ℕ), List.range n = List.range' 0 n",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "continuous_fst",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "continuous_snd",
   "IsOpen.inter",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "IsOpen.prod",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β},\n  IsOpen s → IsOpen t → IsOpen (s ×ˢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_4",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (s : Set αᵒᵈᵒᵈ), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Function.RightInverse",
   "Equiv.invFun",
   "Function.comp",
   "Equiv.right_inv",
   "FunLike.coe",
   "Function.RightInverse.comp",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.RightInverse (↑e₁.symm ∘ e₂.invFun) (e₂.toFun ∘ ↑e₁)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "List.length",
   "Nat",
   "And.casesOn",
   "Eq"],
  "name": "List.eq_replicate.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} {l : List α} (motive : (List.length l = n ∧ ∀ b ∈ l, b = a) → Prop)\n  (x : List.length l = n ∧ ∀ b ∈ l, b = a),\n  (∀ (e : List.length l = n) (al : ∀ b ∈ l, b = a), motive (_ : List.length l = n ∧ ∀ b ∈ l, b = a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.symm",
  "constType": "∀ {a b : Prop}, a ∨ b → b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.bot_le",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_5",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → BooleanAlgebra (α i)] (a : (i : ι) → α i), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.save",
  "constType":
  "{δ : outParam (Type u)} → {σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_idem",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_idem",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a : α}, a ⊓ a = a",
  "constCategory": "Theorem"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Finite.intro", "Finite", "Nat", "Finite.rec", "Fin"],
  "name": "Finite.casesOn",
  "constType":
  "∀ {α : Sort u_1} {motive : Finite α → Prop} (t : Finite α),\n  (∀ {n : ℕ} (a : α ≃ Fin n), motive (_ : Finite α)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.State", "Lean.MacroScope"],
  "name": "Lean.Macro.State.macroScope",
  "constType": "Lean.Macro.State → Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "OrderDual.toDual_ofDual",
  "constType":
  "∀ {α : Type u_1} (a : αᵒᵈ), ↑OrderDual.toDual (↑OrderDual.ofDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.left",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_left",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["UInt64.size", "LT.lt", "UInt64", "UInt64.mk", "Nat", "instLTNat", "Fin.mk"],
  "name": "UInt64.ofNatCore",
  "constType": "(n : ℕ) → n < UInt64.size → UInt64",
  "constCategory": "Definition"},
 {"references":
  ["isLUB_pair",
   "SemilatticeSup",
   "Set.instSingletonSet",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set",
   "Sup.sup",
   "Singleton.singleton",
   "Insert.insert",
   "True",
   "SemilatticeSup.toPartialOrder",
   "IsLUB",
   "Eq",
   "Set.instInsertSet"],
  "name": "Mathlib.Order.GaloisConnection._auxLemma.1",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {a b : γ}, IsLUB {a, b} (a ⊔ b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "HEq",
   "List.instMembershipList",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "List.indexOf",
   "rfl",
   "Eq",
   "ite",
   "Nat.add",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.symm",
   "List.indexOf_cons",
   "Eq.trans",
   "Nat.succ",
   "if_neg",
   "Mathlib.Data.List.Basic._auxLemma.33",
   "id",
   "Membership.mem",
   "Nat.succ_inj'",
   "List.cons",
   "Or",
   "False",
   "instAddNat",
   "instHAdd",
   "iff_of_true",
   "instBEq",
   "List.not_mem_nil",
   "List.length",
   "Mathlib.Data.List.Basic._auxLemma.12",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "Or.inl",
   "HEq.refl",
   "DecidableEq",
   "propext",
   "Nat.noConfusion",
   "List",
   "congr",
   "Not",
   "Eq.casesOn",
   "iff_of_false",
   "congrArg",
   "congrFun"],
  "name": "List.indexOf_eq_length",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, List.indexOf a l = List.length l ↔ ¬a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Subtype.val",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "Directed",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Filter.HasBasis",
   "Filter.principal",
   "Eq.mpr",
   "Filter",
   "Eq.symm",
   "Directed.mono_comp",
   "Subtype",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Membership.mem",
   "Function.comp",
   "Filter.principal_mono",
   "HasSubset.Subset",
   "DirectedOn",
   "directedOn_iff_directed",
   "directed_comp",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Order.Preimage",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toInfSet",
   "propext",
   "Eq.mp",
   "Filter.instPartialOrderFilter",
   "Filter.mem_biInf_of_directed",
   "Filter.HasBasis.mk"],
  "name": "Filter.hasBasis_biInf_principal",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : β → Set α} {S : Set β},\n  DirectedOn (s ⁻¹'o fun x x_1 ↦ x ≥ x_1) S →\n    Set.Nonempty S → Filter.HasBasis (⨅ i ∈ S, Filter.principal (s i)) (fun i ↦ i ∈ S) s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Filter.principal",
   "Iff",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Set.Subset.rfl",
   "Preorder.toLE",
   "instMembershipSetFilter"],
  "name": "Filter.le_principal_iff",
  "constType":
  "∀ {α : Type u} {s : Set α} {f : Filter α}, f ≤ Filter.principal s ↔ s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "False",
   "GE.ge",
   "instLTNat",
   "LE.le",
   "GT.gt",
   "Eq",
   "Nat.le_total.match_1",
   "instLENat",
   "Eq.subst",
   "LT.lt",
   "Nat.lt_trans",
   "Nat.lt_irrefl",
   "Not",
   "Nat.lt_or_ge",
   "Nat",
   "Nat.le_antisymm",
   "absurd"],
  "name": "Nat.not_le_of_gt",
  "constType": "∀ {n m : ℕ}, n > m → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "iff_self",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_eq_univ_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → Set α}, ⋃ i, f i = Set.univ ↔ ∀ (x : α), ∃ i, x ∈ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "mem_interior",
   "IsOpen",
   "interior",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.18",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {x : α}, (x ∈ interior s) = ∃ t, t ⊆ s ∧ IsOpen t ∧ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMap.rec",
   "Continuous",
   "TopologicalSpace",
   "ContinuousMap",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.casesOn",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : TopologicalSpace β] →\n        {motive : C(α, β) → Sort u} →\n          (t : C(α, β)) →\n            ((toFun : α → β) → (continuous_toFun : Continuous toFun) → motive (ContinuousMap.mk toFun)) → motive t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.instPreorderWithUpper._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "IsAntisymm",
   "propext",
   "IsRefl",
   "HasSubset.Subset",
   "subset_antisymm_iff",
   "HasSubset",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.19",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1]\n  [inst_2 : IsAntisymm α fun x x_1 ↦ x ⊆ x_1], (a ⊆ b ∧ b ⊆ a) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMod α β γ",
  "constCategory": "Other"},
 {"references": ["and_or_left", "And", "Or", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.8",
  "constType": "∀ {a b c : Prop}, (a ∧ (b ∨ c)) = (a ∧ b ∨ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot.proof_1",
   "GeneralizedBooleanAlgebra",
   "Bot.mk",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "OrderBot",
   "OrderBot.mk",
   "Preorder.toLE",
   "GeneralizedBooleanAlgebra.toBot"],
  "name": "GeneralizedBooleanAlgebra.toOrderBot",
  "constType":
  "{α : Type u} → [inst : GeneralizedBooleanAlgebra α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Std.Data.List.Lemmas._auxLemma.108",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.112",
   "HAdd.hAdd",
   "List.range_eq_range'",
   "instLTNat",
   "LE.le",
   "True",
   "iff_self",
   "Nat.zero_add",
   "And",
   "Iff",
   "instLENat",
   "of_eq_true",
   "List",
   "LT.lt",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "List.range",
   "congrFun"],
  "name": "List.mem_range",
  "constType": "∀ {m n : ℕ}, m ∈ List.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "Iff", "And.intro", "And.left"],
  "name": "and_iff_left_of_imp",
  "constType": "∀ {a b : Prop}, (a → b) → (a ∧ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "List",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "List.hasDecEq.match_1",
  "constType":
  "{α : Type u_1} →\n  (as bs : List α) →\n    (motive : Decidable (as = bs) → Sort u_2) →\n      (x : Decidable (as = bs)) →\n        ((habs : as = bs) → motive (isTrue habs)) → ((nabs : ¬as = bs) → motive (isFalse nabs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_singleton",
   "Iff",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Finset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithLowerSet",
   "IsLowerSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "List.cons",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GeneralizedHeytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{α : Type u_1} → α → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Eq.ndrec",
   "Function.comp",
   "Eq.refl",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.comp",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.LeftInverse f g → Function.LeftInverse h i → Function.LeftInverse (h ∘ f) (g ∘ i)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "le_top",
   "CompleteLattice.toBoundedOrder",
   "Eq.refl",
   "biInf_mono",
   "Inter.inter",
   "And.left",
   "BoundedOrder.toOrderTop",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.subset_sUnion_of_mem",
   "Eq",
   "OrderTop.toTop",
   "Filter.principal",
   "And.right",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Filter.instTopFilter",
   "le_inf",
   "Filter",
   "Filter.inf_principal",
   "iInf₂_le",
   "Eq.symm",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.rec",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Top.top",
   "nhds",
   "LE.le.trans",
   "Filter.principal_mono",
   "HasSubset.Subset",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace.GenerateOpen",
   "TopologicalSpace.nhds_generateFrom.match_3",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Set.instMembershipSet",
   "nhds_def",
   "le_iInf₂",
   "Filter.principal_univ",
   "And",
   "TopologicalSpace.nhds_generateFrom.match_1",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "iInf",
   "Filter.instPartialOrderFilter",
   "Set.sUnion",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "LE.le.trans_eq",
   "TopologicalSpace.nhds_generateFrom.match_2",
   "Set.instInterSet"],
  "name": "TopologicalSpace.nhds_generateFrom",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {a : α}, nhds a = ⨅ s ∈ {s | a ∈ s ∧ s ∈ g}, Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references": ["CompleteBooleanAlgebra", "InfSet"],
  "name": "CompleteBooleanAlgebra.toInfSet",
  "constType": "{α : Type u_1} → [self : CompleteBooleanAlgebra α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : ℕ) → Decidable (n = m)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "HImp.himp",
   "Eq.ndrec",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "propext",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Setoid", "Quot"],
  "name": "Quotient",
  "constType": "{α : Sort u} → Setoid α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Or.imp_left",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "Or.imp_right",
   "Or.rec"],
  "name": "or_assoc",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "inseparable_iff_specializes_and",
   "Specializes",
   "propext",
   "TopologicalSpace",
   "Inseparable",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.9",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y = (x ⤳ y ∧ y ⤳ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "rfl", "Eq"],
  "name": "forall_apply_eq_imp_iff₂",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) ↔ ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references": ["Id"],
  "name": "Id.run",
  "constType": "{α : Type u_1} → Id α → α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "cond.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (c : Bool) → (Unit → motive true) → (Unit → motive false) → motive c",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "Quotient.liftOn₂",
   "HAppend.hAppend",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ofList",
   "Multiset.add.proof_1"],
  "name": "Multiset.add",
  "constType": "{α : Type u_1} → Multiset α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet"],
  "name": "Topology.WithLowerSet.map._elambda_1._cstage1",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    ((a : β) → (fun x ↦ Topology.WithLowerSet β) a) →\n      (Topology.WithLowerSet α → β) → Topology.WithLowerSet α → Topology.WithLowerSet β",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Std.Logic._auxLemma.34",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.8",
   "Eq.refl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Std.Data.List.Lemmas._auxLemma.11",
   "Std.Data.List.Basic._auxLemma.3",
   "Iff",
   "List.rec",
   "forall_congr",
   "List.nil",
   "Eq.trans",
   "Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.18",
   "implies_true",
   "Std.Data.List.Lemmas._auxLemma.70",
   "and_true",
   "Std.Data.List.Lemmas._auxLemma.19",
   "List.Pairwise",
   "And",
   "instHAppend",
   "List.instAppendList",
   "of_eq_true",
   "propext",
   "HAppend.hAppend",
   "List",
   "congr",
   "congrArg",
   "congrFun"],
  "name": "List.pairwise_append",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {l₁ l₂ : List α},\n  List.Pairwise R (l₁ ++ l₂) ↔ List.Pairwise R l₁ ∧ List.Pairwise R l₂ ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelMonoid", "Nat"],
  "name": "AddRightCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike.coe",
   "EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.RightInverse.surjective",
   "Function.Surjective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe",
   "EquivLike.right_inv",
   "EquivLike.inv"],
  "name": "EquivLike.surjective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Surjective ↑e",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "UInt32.val",
   "UInt32",
   "LE",
   "instLEFin",
   "UInt32.size",
   "LE.le",
   "Fin"],
  "name": "instLEUInt32",
  "constType": "LE UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Prod.fst",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "InfSet.mk",
   "And",
   "sInf_le",
   "Prod.infSet",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Prod",
   "And.intro",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Set.mem_image_of_mem"],
  "name": "Prod.completeLattice.proof_6",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (x : Set (α × β)),\n  ∀ x_1 ∈ x, (sInf x).1 ≤ x_1.1 ∧ (sInf x).2 ≤ x_1.2",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Set.instMembershipSet"],
  "name": "Set.Subset",
  "constType": "{α : Type u_1} → Set α → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["IsCommutative.comm", "Eq", "IsCommutative"],
  "name": "instIsCommutative.proof_1",
  "constType":
  "∀ {α : Type u_1} {op : α → α → α} [inst : IsCommutative α op] (a b : α), op a b = op b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.instMembershipList",
   "List.get?_eq_some",
   "List.length",
   "instLTNat",
   "Eq",
   "Iff.mp",
   "List",
   "Eq.rec",
   "LT.lt",
   "List.get_mem",
   "Option.some",
   "Nat",
   "List.get?",
   "List.get",
   "List.get?_mem.match_1",
   "Fin.mk",
   "Option"],
  "name": "List.get?_mem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}, List.get? l n = some a → a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Subtype.exists.match_2",
   "Exists.intro",
   "Subtype.exists.match_1",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) ↔ ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_sup_left",
   "True",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inf_comm",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans"],
  "name": "inf_sup_right",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, (y ⊔ z) ⊓ x = y ⊓ x ⊔ z ⊓ x",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "Equiv.pprodEquivProd",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Prod.fst",
   "PProd.snd",
   "Filter.HasBasis",
   "PProd",
   "And",
   "PProd.fst",
   "Filter.HasBasis.comp_equiv",
   "Filter.instInfFilter",
   "Filter.HasBasis.inf'",
   "Filter",
   "Prod",
   "Set.instInterSet",
   "Equiv.symm"],
  "name": "Filter.HasBasis.inf",
  "constType":
  "∀ {α : Type u_1} {l l' : Filter α} {ι : Type u_6} {ι' : Type u_7} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n  {s' : ι' → Set α},\n  Filter.HasBasis l p s →\n    Filter.HasBasis l' p' s' → Filter.HasBasis (l ⊓ l') (fun i ↦ p i.1 ∧ p' i.2) fun i ↦ s i.1 ∩ s' i.2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Or",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.mem_cons",
   "Multiset.cons",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.mem_cons",
  "constType":
  "∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ b ::ₘ s ↔ a = b ∨ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_5",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (s : Set β) (a : β), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "propext",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.8",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedHeytingAlgebra α] (a b c : α), (a ≤ b ⇨ c) = (a ⊓ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_4",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne", "DecidableEq", "List", "instDecidableNot", "List.pwFilter", "Eq"],
  "name": "List.dedup",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["not_le_of_gt",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "Preorder",
   "Preorder.toLE"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Iff", "Nat.succ.inj", "Nat", "congrArg", "Nat.succ", "Eq"],
  "name": "Nat.succ_inj'",
  "constType": "∀ {n m : ℕ}, Nat.succ n = Nat.succ m ↔ n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "HEq",
   "eq_of_heq",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "Inter.inter",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "HEq.refl",
   "Filter.casesOn",
   "Filter.mk",
   "Filter",
   "Eq.casesOn",
   "Eq.symm",
   "Set.instInterSet"],
  "name": "Filter.filter_eq.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x x_1 : Filter α) → x.sets = x_1.sets → Prop) (x x_1 : Filter α) (x_2 : x.sets = x_1.sets),\n  (∀ (sets : Set (Set α)) (univ_sets : Set.univ ∈ sets)\n      (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets)\n      (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) (univ_sets_1 : Set.univ ∈ sets)\n      (sets_of_superset_1 : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets)\n      (inter_sets_1 : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets),\n      motive { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset, inter_sets := inter_sets }\n        { sets := sets, univ_sets := univ_sets_1, sets_of_superset := sets_of_superset_1, inter_sets := inter_sets_1 }\n        (_ :\n          { sets := sets, univ_sets := (_ : Set.univ ∈ sets),\n                sets_of_superset := (_ : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets),\n                inter_sets := (_ : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) }.sets =\n            { sets := sets, univ_sets := (_ : Set.univ ∈ sets),\n                sets_of_superset := (_ : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets),\n                inter_sets := (_ : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) }.sets)) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (a b : α × β), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«term𝓝[<]_»._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[<]_»._closed_5"],
  "name": "Topology.«term𝓝[<]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_right",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_5",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b : (i : ι) → α' i), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.inter_sets",
   "Membership.mem",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Filter.inter_mem",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → t ∈ f → s ∩ t ∈ f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Macro.State",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "And",
   "Bot.bot",
   "Prod.snd",
   "OrderBot.toBot",
   "inferInstanceAs",
   "Bot.mk",
   "LE",
   "Prod",
   "Prod.fst",
   "And.intro",
   "OrderBot",
   "bot_le",
   "LE.le",
   "Prod.bot"],
  "name": "Prod.orderBot.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : LE α] [inst_1 : LE β] [inst_2 : OrderBot α] [inst_3 : OrderBot β] (x : α × β),\n  ⊥.1 ≤ x.1 ∧ ⊥.2 ≤ x.2",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "Union.union",
   "Set",
   "sInf_union",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.sInter",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_union",
  "constType": "∀ {α : Type u_1} (S T : Set (Set α)), ⋂₀ (S ∪ T) = ⋂₀ S ∩ ⋂₀ T",
  "constCategory": "Theorem"},
 {"references": ["Char", "UInt32", "UInt32.isValidChar"],
  "name": "Char.mk",
  "constType": "(val : UInt32) → UInt32.isValidChar val → Char",
  "constCategory": "Other"},
 {"references": ["Set", "Filter"],
  "name": "Filter.HasBasis",
  "constType":
  "{α : Type u_1} → {ι : Sort u_4} → Filter α → (ι → Prop) → (ι → Set α) → Prop",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Function.LeftInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "_private.Std.Data.List.Count.0.List.countP.go._unfold",
   "True",
   "Eq",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "List.rec",
   "Bool.true",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Eq.trans",
   "id",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List.countP.go",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.countP_go_eq_add",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {n : ℕ} (l : List α), List.countP.go p l n = n + List.countP.go p l 0",
  "constCategory": "Theorem"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Codisjoint_comm",
   "OrderTop",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Codisjoint.symm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] ⦃a b : α⦄, Codisjoint a b → Codisjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq", "LawfulBEq", "instBEq", "instLawfulBEqInstBEq.proof_1"],
  "name": "instLawfulBEqInstBEq",
  "constType": "∀ {α : Type u_1} [inst : DecidableEq α], LawfulBEq α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Exists",
   "OfNat.ofNat",
   "Iff",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.length",
   "Nat",
   "instLTNat",
   "List.exists_mem_of_length_pos",
   "List.length_pos_of_mem",
   "List.length_pos_iff_exists_mem.match_1"],
  "name": "List.length_pos_iff_exists_mem",
  "constType": "∀ {α : Type u_1} {l : List α}, 0 < List.length l ↔ ∃ a, a ∈ l",
  "constCategory": "Theorem"},
 {"references": ["UInt64.size", "UInt64", "Fin"],
  "name": "UInt64.mk",
  "constType": "Fin UInt64.size → UInt64",
  "constCategory": "Other"},
 {"references": ["Nat.le", "Nat"],
  "name": "Nat.le.refl",
  "constType": "∀ {n : ℕ}, Nat.le n n",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_sUnion",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.sUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {x : α} {S : Set (Set α)}, (x ∈ ⋃₀ S) = ∃ t ∈ S, x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra.proof_2",
  "constType": "∀ {α : Type u_1} [inst : BiheytingAlgebra α] (a : α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "Filter.le_generate_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm"],
  "name": "Filter.giGenerate.proof_1",
  "constType":
  "∀ (α : Type u_1) (s : Set (Set α)), (Filter.generate s).sets ≤ s → (Filter.generate s).sets = s",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Topology.IsUpperSet.closure_eq_lowerClosure",
   "OrderDual.instPreorder",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "Topology.IsLowerSet",
   "Preorder",
   "UpperSet",
   "Preorder.toLE",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsLowerSet.closure_eq_upperClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α] {s : Set α},\n  closure s = ↑(upperClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "eq_self",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "True",
   "Eq",
   "Nat.zero_add",
   "instHAppend",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans"],
  "name": "List.length_append",
  "constType":
  "∀ {α : Type u} (as bs : List α), List.length (as ++ bs) = List.length as + List.length bs",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "Multiset.attach",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.nodup_attach",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "Iff.mpr"],
  "name": "Finset.attach.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Finset α), Multiset.Nodup (Multiset.attach s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_4",
  "constType":
  "∀ {α : Type u_1} (a b : TopologicalSpace α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Set.mem_Iic",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {b x : α}, (x ∈ Set.Iic b) = (x ≤ b)",
  "constCategory": "Theorem"},
 {"references": ["Char", "String.rec", "List", "String.mk", "String"],
  "name": "String.casesOn",
  "constType":
  "{motive : String → Sort u} → (t : String) → ((data : List Char) → motive { data := data }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.sup_le",
  "constType":
  "∀ {α : Type u} [self : SemilatticeSup α] (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "Prod.snd",
   "Set",
   "Prod.fst",
   "SupSet.sSup",
   "iSup",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "sSup_image",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Prod.supSet",
   "Prod",
   "Sup.sup",
   "iSup_sup_eq",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "supsSupHom.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] (s : Set (α × α)),\n  (fun x ↦ x.1 ⊔ x.2) (sSup s) = sSup ((fun x ↦ x.1 ⊔ x.2) '' s)",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "Eq.ndrec",
   "Set.preimage",
   "Set",
   "IsOpen.inter",
   "TopologicalSpace",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Set.preimage_inter",
   "Set.instInterSet",
   "Eq"],
  "name": "TopologicalSpace.induced.proof_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (t : TopologicalSpace β) (s₁ s₂ : Set α),\n  (∃ s', IsOpen s' ∧ f ⁻¹' s' = s₁) →\n    (fun s ↦ ∃ s', IsOpen s' ∧ f ⁻¹' s' = s) s₂ → (fun s ↦ ∃ s', IsOpen s' ∧ f ⁻¹' s' = s) (s₁ ∩ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_6",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsUpper",
  "constType":
  "(α : Type u_1) → [t : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.exists_perm_sublist.match_1",
  "constType":
  "∀ {α : Type u_1} {l₂ l₁ : List α} (motive : (∃ l₁', ∃ (_ : l₁' ~ l₁), List.Sublist l₁' l₂) → Prop)\n  (x : ∃ l₁', ∃ (_ : l₁' ~ l₁), List.Sublist l₁' l₂),\n  (∀ (l₁' : List α) (p' : l₁' ~ l₁) (s' : List.Sublist l₁' l₂),\n      motive (_ : ∃ l₁', ∃ (_ : l₁' ~ l₁), List.Sublist l₁' l₂)) →\n    motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Topology.WithUpperSet",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Definition"},
 {"references": ["Nat", "Fin"],
  "name": "Fin.val",
  "constType": "{n : ℕ} → Fin n → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Nodup.pmap.match_1",
   "List.pmap",
   "List.Nodup.map",
   "List.Nodup.pmap.match_2",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "List.Nodup.attach",
   "List.pmap_eq_map_attach",
   "List.attach",
   "Eq",
   "Subtype.property",
   "Eq.mpr",
   "List.Nodup",
   "Eq.ndrec",
   "List",
   "Eq.rec",
   "List.map",
   "Subtype.mk",
   "Subtype",
   "id"],
  "name": "List.Nodup.pmap",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a},\n  (∀ (a : α) (ha : p a) (b : α) (hb : p b), f a ha = f b hb → a = b) → List.Nodup l → List.Nodup (List.pmap f l H)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filterMap",
   "Eq.refl",
   "dite",
   "List.filter_cons_of_pos",
   "True",
   "Eq",
   "ite",
   "Bool.of_not_eq_true",
   "List.rec",
   "List.filterMap_cons.match_1",
   "Option.none",
   "Bool.true",
   "Option.some",
   "List.nil",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "Option",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "List.filter",
   "funext",
   "False",
   "List.filter_cons_of_neg",
   "Unit",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "of_eq_true",
   "Bool.false",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "Option.guard",
   "congrFun"],
  "name": "List.filterMap_eq_filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool), List.filterMap (Option.guard fun x ↦ p x = true) = List.filter p",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "LowerSet.mk",
   "Set.Iic",
   "Preorder",
   "isLowerSet_Iic",
   "Preorder.toLE"],
  "name": "LowerSet.Iic",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → LowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "LE.mk",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_3",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_1",
   "Set",
   "TopologicalSpace.ext",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_2",
   "FunLike.coe",
   "Prop.partialOrder",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "Preorder.mk",
   "Preorder.toLT",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.instPartialOrderTopologicalSpace.proof_4",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace",
  "constType": "{α : Type u} → PartialOrder (TopologicalSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "inferInstanceAs",
   "OrderDual",
   "OrderDual.instPartialOrder.proof_3",
   "OrderDual.instPartialOrder.proof_1",
   "Preorder",
   "le_antisymm",
   "LE.le",
   "OrderDual.instPartialOrder.proof_2",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(α : Type u_3) → [inst : PartialOrder α] → PartialOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "isUpperSet_sInter",
   "Eq.refl",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "IsUpperSet",
   "Preorder",
   "implies_congr",
   "AlexandrovDiscrete",
   "AlexandrovDiscrete.mk",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "forall_congr",
   "TopologicalSpace",
   "Set.sInter",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.toAlexandrovDiscrete.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsUpperSet α], AlexandrovDiscrete α",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "or_false.match_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ False → Prop) (x : p ∨ False), (∀ (h : p), motive (_ : p ∨ False)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "PartialOrder.toPreorder",
   "Prop.heytingAlgebra",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Prop.booleanAlgebra.proof_2",
  "constType": "∀ (a : Prop), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Ne",
   "OfNat.ofNat",
   "And.right",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.replicate",
   "List.mem_replicate",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "List.eq_of_mem_replicate",
  "constType":
  "∀ {α : Type u_1} {a b : α} {n : ℕ}, b ∈ List.replicate n a → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Function.Surjective.exists",
   "Iff",
   "PLift.up",
   "PLift",
   "PLift.up_surjective"],
  "name": "PLift.exists",
  "constType":
  "∀ {α : Sort u} {p : PLift α → Prop}, (∃ x, p x) ↔ ∃ x, p { down := x }",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHAppend",
   "Or",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_append",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} {a : α} {s t : List α}, (a ∈ s ++ t) = (a ∈ s ∨ a ∈ t)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "semiOutParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLowerSet.to_WithLowerSet_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithLowerSet.toLowerSet.symm = Topology.WithLowerSet.ofLowerSet",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.namespace",
  "constType": "Lean.Name → Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_range",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {x : α}, x ∈ Set.range f ↔ ∃ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instHAdd",
   "HAdd.hAdd",
   "PUnit",
   "Nat",
   "Add",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "nsmulRec",
  "constType": "{M : Type u} → [inst : Zero M] → [inst : Add M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Inf.inf",
   "Function.comp",
   "ConditionallyCompleteLattice.toLattice",
   "Prod.fst",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "And",
   "Iff",
   "continuous_induced_rng",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "Continuous",
   "TopologicalSpace",
   "Iff.trans",
   "Prod",
   "TopologicalSpace.induced",
   "continuous_inf_rng",
   "Iff.and"],
  "name": "continuous_prod_mk",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : α → γ}, (Continuous fun x ↦ (f x, g x)) ↔ Continuous f ∧ Continuous g",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Iff.mp",
   "IsClosed.isOpen_compl",
   "isUpperSet_compl",
   "Set",
   "Topology.IsUpper",
   "HasCompl.compl",
   "TopologicalSpace",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "IsClosed",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE"],
  "name": "Topology.IsUpper.isLowerSet_of_isClosed",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] {s : Set α},\n  IsClosed s → IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "Set.eq_univ_of_forall",
   "Or",
   "Bool.false",
   "Bool.dichotomy",
   "Bool.true",
   "Set",
   "Singleton.singleton",
   "Bool",
   "Insert.insert",
   "Set.univ",
   "Eq.symm",
   "Set.instInsertSet",
   "Eq"],
  "name": "Bool.univ_eq",
  "constType": "Set.univ = {false, true}",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat.le_trans",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_le_of_lt",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.sublist_append_left.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → List α → Prop) (x x_1 : List α),\n  (∀ (x : List α), motive [] x) → (∀ (head : α) (l₁ l₂ : List α), motive (head :: l₁) l₂) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Pi.distribLattice",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_1",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → BooleanAlgebra (α i)] (x y z : (i : ι) → α i),\n  (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteBooleanAlgebra",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_8",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Option.getD.match_1", "Option"],
  "name": "Option.getD",
  "constType": "{α : Type u_1} → Option α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "sup_inf_le",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "le_antisymm",
   "Eq",
   "le_sup_inf"],
  "name": "sup_inf_left",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, x ⊔ y ⊓ z = (x ⊔ y) ⊓ (x ⊔ z)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.map._elambda_1._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.rec",
  "constType":
  "{n : ℕ} →\n  {motive : Fin n → Sort u} →\n    ((val : ℕ) → (isLt : val < n) → motive { val := val, isLt := isLt }) → (t : Fin n) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.Finite.intro",
   "Exists",
   "Fintype",
   "Set.coe_toFinset",
   "Eq.ndrec",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Finset",
   "Eq.refl",
   "Exists.intro",
   "Eq.symm",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.exists_finset_coe",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Finite s → ∃ s', ↑s' = s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.take_append_drop.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : ℕ → List α → Prop) (x : ℕ) (x_1 : List α),\n  (∀ (x : List α), motive 0 x) →\n    (∀ (n : ℕ), motive (Nat.succ n) []) →\n      (∀ (n : ℕ) (x : α) (xs : List α), motive (Nat.succ n) (x :: xs)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], α → b ↔ b",
  "constCategory": "Theorem"},
 {"references":
  ["IsUpperSet", "ge_trans", "Set.Ici", "Preorder", "Preorder.toLE"],
  "name": "isUpperSet_Ici",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (a : α), IsUpperSet (Set.Ici a)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.inter_mem_inf",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s t : Set α}, s ∈ f → t ∈ g → s ∩ t ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Perm",
  "constType": "{α : Type uu} → List α → List α → Prop",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.Pairwise",
  "constType": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "npowRec.match_1",
  "constType":
  "{M : Type u_2} →\n  (motive : ℕ → M → Sort u_1) →\n    (x : ℕ) → (x_1 : M) → ((x : M) → motive 0 x) → ((n : ℕ) → (a : M) → motive (Nat.succ n) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.pwFilter",
   "Not",
   "List.nil",
   "if_neg",
   "Eq",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter_cons_of_neg",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R] {a : α} {l : List α},\n  (¬∀ b ∈ List.pwFilter R l, R a b) → List.pwFilter R (a :: l) = List.pwFilter R l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≠]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Acc.rec", "Eq.ndrec", "Acc.intro", "InvImage", "Acc", "rfl", "Eq"],
  "name": "_private.Init.WF.0.InvImage.accAux.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : β → β → Prop} (f : α → β) {b : β},\n  Acc r b → ∀ (x : α), f x = b → Acc (InvImage r f) x",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "Iff", "And.symm.match_1", "And.intro"],
  "name": "and_imp",
  "constType": "∀ {a b c : Prop}, a ∧ b → c ↔ a → b → c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.count_pos_iff_mem",
   "OfNat.ofNat",
   "Nat.pos_of_ne_zero",
   "List.instMembershipList",
   "instBEq",
   "instLTNat",
   "instDecidableEqNat",
   "Eq",
   "Iff.mp",
   "DecidableEq",
   "List",
   "LT.lt",
   "Not",
   "instOfNatNat",
   "Nat",
   "Decidable.byContradiction",
   "List.count"],
  "name": "List.count_eq_zero_of_not_mem",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, ¬a ∈ l → List.count a l = 0",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.append",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.drop",
   "List.take",
   "rfl",
   "Eq",
   "PProd",
   "instHAppend",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "List.take_append_drop.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "List.take_append_drop",
  "constType":
  "∀ {α : Type u_1} (n : ℕ) (l : List α), List.take n l ++ List.drop n l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "∀ {α : Type u_1} (x : Set α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "Nat.linearOrderedCommSemiring.proof_3",
  "constType": "∀ (a b : ℕ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.foldl.match_1",
  "constType":
  "{α : Type u_3} →\n  {β : Type u_1} →\n    (motive : α → List β → Sort u_2) →\n      (x : α) →\n        (x_1 : List β) → ((a : α) → motive a []) → ((a : α) → (b : β) → (l : List β) → motive a (b :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "Set.instHasSubsetSet",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "LE.le",
   "IsOpen",
   "Preorder.toLE",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "le_generateFrom",
  "constType":
  "∀ {α : Type u} {t : TopologicalSpace α} {g : Set (Set α)}, (∀ s ∈ g, IsOpen s) → t ≤ TopologicalSpace.generateFrom g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "eq_false",
   "False",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.not_lt_zero",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.103",
  "constType": "∀ (n : ℕ), (n < 0) = False",
  "constCategory": "Theorem"},
 {"references": ["monotone_id", "OrderHom.mk", "OrderHom", "Preorder", "id"],
  "name": "OrderHom.id",
  "constType": "{α : Type u_2} → [inst : Preorder α] → α →o α",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "rfl",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "List",
   "PUnit",
   "List.range.loop",
   "instOfNatNat",
   "Nat",
   "List.range_loop_range'.match_1",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "List.range_loop_range'",
  "constType":
  "∀ (s n : ℕ), List.range.loop s (List.range' s n) = List.range' 0 (n + s)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "RelHomClass", "LE", "LE.le"],
  "name": "OrderHomClass",
  "constType":
  "Type u_6 →\n  (α : outParam (Type u_7)) → (β : outParam (Type u_8)) → [inst : LE α] → [inst : LE β] → Type (max (max u_6 u_7) u_8)",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.map._elambda_1._cstage1",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    ((a : β) → (fun x ↦ Topology.WithUpperSet β) a) →\n      (Topology.WithUpperSet α → β) → Topology.WithUpperSet α → Topology.WithUpperSet β",
  "constCategory": "Definition"},
 {"references":
  ["Inf.mk", "Prod.snd", "Prod.mk", "Inf", "Inf.inf", "Prod", "Prod.fst"],
  "name": "Prod.instInfProd",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Inf α] → [inst : Inf β] → Inf (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "Or",
   "not_and_or",
   "List.instMembershipList",
   "List.dedup",
   "And.left",
   "mt",
   "Eq",
   "And",
   "Mathlib.Data.List.Dedup._auxLemma.1",
   "And.right",
   "Iff.mp",
   "Iff",
   "DecidableEq",
   "List.forall_mem_pwFilter",
   "not_congr",
   "List",
   "instDecidableNot",
   "Eq.mp",
   "congr",
   "Not",
   "List.pwFilter",
   "congrArg",
   "Mathlib.Data.List.Dedup._auxLemma.2",
   "Eq.trans",
   "id"],
  "name": "List.mem_dedup",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, a ∈ List.dedup l ↔ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_9} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≥]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "List.cons",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "List.length",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "List.get_cons_drop.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → Fin (List.length x) → Prop) (x : List α) (x_1 : Fin (List.length x)),\n  (∀ (head : α) (tail : List α) (isLt : 0 < List.length (head :: tail)),\n      motive (head :: tail) { val := 0, isLt := isLt }) →\n    (∀ (head : α) (tail : List α) (i : ℕ) (isLt : i + 1 < List.length (head :: tail)),\n        motive (head :: tail) { val := Nat.succ i, isLt := isLt }) →\n      motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.«termΩ^»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_irrefl.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x : α) → x < x → Prop) (x : α) (x_1 : x < x),\n  (∀ (_a : α) (haa : _a < _a), motive _a haa) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_on",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r), (∀ (a : α), β (Quot.mk r a)) → β q",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.beq",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.mk", "Monotone", "OrderHom", "Preorder", "OrderHom.rec"],
  "name": "OrderHom.casesOn",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {motive : (α →o β) → Sort u} →\n          (t : α →o β) →\n            ((toFun : α → β) → (monotone' : Monotone toFun) → motive { toFun := toFun, monotone' := monotone' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "Lean.Data.AC.Expr",
   "Eq.refl",
   "eq_true_of_decide",
   "Lean.Data.AC.sort",
   "Lean.Data.AC.ContextInformation.isComm",
   "Lean.Data.AC.ContextInformation.isIdem",
   "True",
   "ite",
   "Eq",
   "Lean.Data.AC.Context.evalList_mergeIdem",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.Context.evalList_sort",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Lean.Data.AC.norm",
   "Nat",
   "Eq.symm",
   "Lean.Data.AC.Expr.toList",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "eq_self",
   "False",
   "Lean.Data.AC.eval",
   "Lean.Data.AC.Context.evalList_removeNeutrals",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "Bool.casesOn",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "Lean.Data.AC.Context.eval_toList",
   "List",
   "Bool.false",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.eval_norm",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α) (e : Lean.Data.AC.Expr),\n  Lean.Data.AC.evalList α ctx (Lean.Data.AC.norm ctx e) = Lean.Data.AC.eval α ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_inter",
  "constType": "∀ {α : Type u} {s t r : Set α}, r ⊆ s → r ⊆ t → r ⊆ s ∩ t",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.term𝓝._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "GaloisConnection.liftOrderBot.proof_1",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "Bot.mk",
   "OrderBot.mk",
   "OrderBot",
   "Preorder",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisConnection.liftOrderBot",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : OrderBot α] → [inst_2 : PartialOrder β] → {l : α → β} → {u : β → α} → GaloisConnection l u → OrderBot β",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedCoheytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff"],
  "name": "sdiff_le_iff",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b c : α}, a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.mpr",
   "Eq.ndrec",
   "IsLowerSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.topology_eq",
   "IsOpen",
   "Preorder.toLE",
   "Eq",
   "id"],
  "name": "Topology.IsLowerSet.isOpen_iff_isLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α] {s : Set α},\n  IsOpen s ↔ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Context"],
  "name": "Lean.Data.AC.Context.arbitrary",
  "constType": "{α : Sort u} → Lean.Data.AC.Context α → α",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "List.cons",
   "HEq",
   "eq_of_heq",
   "List.Sublist",
   "List.Sublist.cons",
   "Eq.refl",
   "List.Sublist.rec",
   "Eq",
   "List.Sublist.trans.match_1",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Eq.rec",
   "List.Sublist.cons₂",
   "List.nil",
   "Eq.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.Sublist.trans",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ l₃ : List α}, List.Sublist l₁ l₂ → List.Sublist l₂ l₃ → List.Sublist l₁ l₃",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_eq_left", "Eq"],
  "name": "Std.Logic._auxLemma.38",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm",
   "PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "IsAntisymm.mk",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "instIsAntisymmLeToLEToPreorder.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α], IsAntisymm α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "PSigma.casesOn",
   "invImage",
   "SizeOf.sizeOf",
   "WellFounded",
   "instSizeOfNat",
   "Nat",
   "instWellFoundedRelation"],
  "name": "Nat.modCore._unary.proof_1",
  "constType":
  "WellFounded (invImage (fun a ↦ PSigma.casesOn a fun x snd ↦ sizeOf x) instWellFoundedRelation).1",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Prod.mk",
   "eq_of_heq",
   "Eq.refl",
   "Prod",
   "Eq.casesOn",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Eq.propIntro",
   "Prod.noConfusion",
   "Eq"],
  "name": "Prod.mk.injEq",
  "constType":
  "∀ {α : Type u} {β : Type v} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),\n  ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet", "sSupHom.mk", "sSupHom", "Set", "SupSet.sSup", "Set.image", "Eq"],
  "name": "sSupHom.rec",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : SupSet α] →\n      [inst_1 : SupSet β] →\n        {motive : sSupHom α β → Sort u} →\n          ((toFun : α → β) →\n              (map_sSup' : ∀ (s : Set α), toFun (sSup s) = sSup (toFun '' s)) →\n                motive { toFun := toFun, map_sSup' := map_sSup' }) →\n            (t : sSupHom α β) → motive t",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_sets",
   "Filter.sets",
   "Membership.mem",
   "propext",
   "Set",
   "Filter",
   "Eq.symm",
   "Eq",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.13",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (s ∈ f) = (s ∈ f.sets)",
  "constCategory": "Theorem"},
 {"references":
  ["IsLUB.sSup_eq",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "isLUB_singleton",
   "Singleton.singleton",
   "SupSet.sSup",
   "CompleteSemilatticeSup.toSupSet",
   "Eq"],
  "name": "sSup_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {a : α}, sSup {a} = a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "lowerClosure.proof_1",
   "Set",
   "LowerSet.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerClosure",
  "constType": "{α : Type u_1} → [inst : Preorder α] → Set α → LowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Function.RightInverse.comp_eq_id",
   "Eq.ndrec",
   "Trans.trans",
   "Function.RightInverse",
   "Function.comp.right_id",
   "Function.comp",
   "Function.comp.left_id",
   "Function.comp.assoc",
   "Eq.refl",
   "instTransEq",
   "Function.LeftInverse.comp_eq_id",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.eq_rightInverse",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g₁ g₂ : β → α},\n  Function.LeftInverse g₁ f → Function.RightInverse g₂ f → g₁ = g₂",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) (src : LE (α × β)) (c : α) (d : β) (motive : (x : α × β) → (c, d) ≤ x → Prop)\n  (x : α × β) (x_1 : (c, d) ≤ x), (∀ (e : α) (f : β) (x : (c, d) ≤ (e, f)), motive (e, f) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "funext",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.le_top",
   "SemilatticeInf.toPartialOrder",
   "Pi.generalizedHeytingAlgebra",
   "Preorder.toLE",
   "Eq",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HImp.himp",
   "himp_bot",
   "Pi.hasCompl",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "Pi.orderBot",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.hasLe",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.heytingAlgebra.proof_4",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → HeytingAlgebra (α i)] (f : (i : ι) → α i), f ⇨ ⊥ = fᶜ",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "LT", "OrderDual", "LT.mk"],
  "name": "OrderDual.instLTOrderDual",
  "constType": "(α : Type u_3) → [inst : LT α] → LT αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.toFun", "ZeroHom", "Eq"],
  "name": "ZeroHom.map_zero'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ZeroHom.toFun self 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet.mk",
   "Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Topology.IsUpperSet.rec",
   "Eq"],
  "name": "Topology.IsUpperSet.casesOn",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpperSet α → Sort u} →\n        (t_1 : Topology.IsUpperSet α) →\n          ((topology_eq_upperSetTopology : t = Topology.upperSet α) → motive (_ : Topology.IsUpperSet α)) → motive t_1",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat"],
  "name": "UInt32.size",
  "constType": "ℕ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.lowerSet._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "And.left",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "SemilatticeSup",
   "And",
   "And.right",
   "SemilatticeSup.toSup",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "sup_le",
   "Prod",
   "Sup.sup",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] (x x_1 x_2 : α × β),\n  x ≤ x_2 → x_1 ≤ x_2 → (x ⊔ x_1).1 ≤ x_2.1 ∧ (x ⊔ x_1).2 ≤ x_2.2",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.«term𝓝[≤]_»._closed_4",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_9"],
  "name": "Topology.«term𝓝[≤]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap'.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : Filter β} {s : Set α} (motive : s ∈ Filter.comap f l → Prop)\n  (x : s ∈ Filter.comap f l),\n  (∀ (t : Set β) (ht : t ∈ l) (hts : f ⁻¹' t ⊆ s), motive (_ : ∃ t ∈ l, f ⁻¹' t ⊆ s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_comap_le", "Filter.comap", "Filter.Tendsto", "Filter"],
  "name": "Filter.tendsto_comap",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {x : Filter β}, Filter.Tendsto f (Filter.comap f x) x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Bot",
   "Bot.bot",
   "le_top",
   "Bot.mk",
   "inferInstanceAs",
   "OrderDual",
   "OrderTop",
   "LE",
   "OrderBot",
   "OrderBot.mk",
   "OrderDual.bot",
   "OrderDual.instLEOrderDual"],
  "name": "OrderDual.orderBot",
  "constType":
  "(α : Type u) → [inst : LE α] → [inst_1 : OrderTop α] → OrderBot αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Lean.Name.mkStr",
   "Lean.Name.num",
   "List.brecOn",
   "List.below",
   "String",
   "Lean.instInhabitedName",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "Lean.Name.mkNum",
   "panic",
   "List.nil",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.assembleParts.match_1",
   "Nat",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.assembleParts",
  "constType": "List Lean.Name → Lean.Name → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_9",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["InvImage.wf.proof_1", "WellFounded", "InvImage"],
  "name": "InvImage.wf",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} (f : α → β), WellFounded r → WellFounded (InvImage r f)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«term𝓝[≠]_»._closed_1",
   "Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[≠]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_6",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "OrderDual.instIsUpperSet.proof_1"],
  "name": "OrderDual.instIsUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α],\n  Topology.IsUpperSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (x : α), (∀ (y : α), r y x → Acc r y) → Acc r x",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.mk",
   "Prod.boundedOrder.proof_1",
   "Prod.boundedOrder.proof_2",
   "Prod.orderBot",
   "Prod.instLEProd",
   "OrderBot",
   "Prod.orderTop",
   "BoundedOrder.toOrderTop",
   "OrderTop.toTop",
   "BoundedOrder.mk",
   "OrderBot.toBot",
   "LE",
   "OrderTop",
   "inferInstanceAs",
   "Prod",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "Prod.boundedOrder",
  "constType":
  "(α : Type u) →\n  (β : Type v) →\n    [inst : LE α] → [inst_1 : LE β] → [inst_2 : BoundedOrder α] → [inst_3 : BoundedOrder β] → BoundedOrder (α × β)",
  "constCategory": "Definition"},
 {"references": ["Acc.inv.proof_1", "Acc"],
  "name": "Acc.inv",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {x y : α}, Acc r x → r y x → Acc r y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "List.Sublist",
   "HasSubset.Subset",
   "List.Mem",
   "List.Mem.head",
   "List.nil",
   "List.Sublist.subset.match_1._@.Std.Data.List.Lemmas._hyg.8578",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.subset",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → l₁ ⊆ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Iff.symm",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsOpen"],
  "name": "TopologicalSpace.gc_generateFrom",
  "constType":
  "∀ (α : Type u_1),\n  GaloisConnection (fun t ↦ ↑OrderDual.toDual {s | IsOpen s}) (TopologicalSpace.generateFrom ∘ ↑OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["InfHomClass.toOrderHomClass.proof_1",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "InfHomClass.toFunLike",
   "SemilatticeInf.toPartialOrder",
   "RelHomClass.mk",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE",
   "SemilatticeInf",
   "InfHomClass"],
  "name": "InfHomClass.toOrderHomClass",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_3} →\n    {β : Type u_4} →\n      [inst : SemilatticeInf α] → [inst_1 : SemilatticeInf β] → [inst_2 : InfHomClass F α β] → OrderHomClass F α β",
  "constCategory": "Definition"},
 {"references": ["List", "Lean.Data.AC.sort.loop", "List.nil", "Nat"],
  "name": "Lean.Data.AC.sort",
  "constType": "List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.hnot",
  "constType": "{α : Type u_4} → [self : HNot α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HNot",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": [],
  "name": "Monad",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["IsAssociative", "Eq"],
  "name": "IsAssociative.mk",
  "constType":
  "∀ {α : Type u} {op : α → α → α}, (∀ (a b c : α), op (op a b) c = op a (op b c)) → IsAssociative α op",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Preorder.lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Append"],
  "name": "Append.append",
  "constType": "{α : Type u} → [self : Append α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["IsLowerSet", "le_trans", "Set.Iic", "Preorder", "Preorder.toLE"],
  "name": "isLowerSet_Iic",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (a : α), IsLowerSet (Set.Iic a)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.46",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "BooleanAlgebra.toHasCompl",
   "Set.compl_subset_compl",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.23",
  "constType": "∀ {α : Type u} {s t : Set α}, (sᶜ ⊆ tᶜ) = (t ⊆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And.right",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "IsLeast",
   "And.left",
   "le_antisymm",
   "Eq",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "IsLeast.unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {s : Set α} {a b : α}, IsLeast s a → IsLeast s b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
  "constType":
  "∀ {α : Type u_1} (n : ℕ) (x : Multiset α), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq",
   "Exists",
   "setOf",
   "Iff.rfl",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.upper",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpper.isOpen_iff_generate_Iic_compl",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] {s : Set α},\n  IsOpen s ↔ TopologicalSpace.GenerateOpen {t | ∃ a, (Set.Iic a)ᶜ = t} s",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "sSupHom",
   "FunLike.ext",
   "FunLike.coe",
   "Eq"],
  "name": "sSupHom.ext",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : SupSet α] [inst_1 : SupSet β] {f g : sSupHom α β},\n  (∀ (a : α), ↑f a = ↑g a) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.mem_iUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Array.mkArray6",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node6",
  "constType":
  "Lean.SourceInfo →\n  Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpperSet.map._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.map._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "Nat.decLt",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "Eq.refl",
   "Mathlib.Data.List.Range._auxLemma.2",
   "eq_true_of_decide",
   "List.range_eq_range'",
   "autoParam",
   "optParam",
   "instDecidableTrue",
   "Lean.Syntax",
   "instLTNat",
   "True",
   "List.Nodup",
   "of_eq_true",
   "List",
   "Bool.true",
   "LT.lt",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "List.range"],
  "name": "List.nodup_range",
  "constType": "∀ (n : ℕ), List.Nodup (List.range n)",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false", "Bool", "optParam", "Lean.Syntax", "String.Pos", "Option"],
  "name": "Lean.Syntax.getTailPos?",
  "constType": "Lean.Syntax → optParam Bool false → Option String.Pos",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "List.range'",
   "instHAdd",
   "HAdd.hAdd",
   "List.map_add_range'.match_1",
   "optParam",
   "rfl",
   "Eq",
   "List.Chain.cons",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "PUnit",
   "List.Chain.nil",
   "instOfNatNat",
   "Nat",
   "List.Chain",
   "Nat.succ"],
  "name": "List.chain_succ_range'",
  "constType":
  "∀ (s n step : ℕ), List.Chain (fun a b ↦ b = a + step) s (List.range' (s + step) n step)",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Nonempty.some", "Finite", "nonempty_fintype"],
  "name": "Fintype.ofFinite",
  "constType": "(α : Type u_4) → [inst : Finite α] → Fintype α",
  "constCategory": "Definition"},
 {"references":
  ["inf_inf_sdiff",
   "OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "inf_sup_left",
   "Preorder.toLE",
   "Eq",
   "inf_comm",
   "Eq.mpr",
   "Lean.Data.AC.Variable",
   "SemilatticeSup.toSup",
   "Option.none",
   "Lean.Data.AC.Context.eq_of_norm",
   "Bool.true",
   "instIsIdempotent",
   "Nat",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "instIsIdempotentSupToSup",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Lean.Data.AC.eval",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "SDiff.sdiff",
   "DistribLattice.toLattice",
   "instIsAssociative",
   "bot_sup_eq",
   "OrderBot.toBot",
   "congr",
   "instTransEq",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Lean.Data.AC.Context.mk",
   "congrArg",
   "Lean.Data.AC.Expr.var",
   "congrFun",
   "Lean.Data.AC.Expr.op",
   "inf_of_le_right",
   "inf_idem",
   "Eq.refl",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
   "Lean.IsNeutral",
   "instIsIdempotentInfToInf",
   "Lattice.toInf",
   "instIsAssociativeInfToInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Context",
   "Option.some",
   "instOfNatNat",
   "List.nil",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id",
   "Bot.bot",
   "List.cons",
   "instIsCommutative",
   "instIsCommutativeInfToInf",
   "Lean.IsIdempotent",
   "sup_inf_sdiff",
   "inf_sup_right",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.IsCommutative",
   "GeneralizedBooleanAlgebra",
   "Sup.sup",
   "Bool",
   "instIsAssociativeSupToSup"],
  "name": "sdiff_inf_sdiff",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : GeneralizedBooleanAlgebra α], x \\ y ⊓ y \\ x = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Equiv",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
   "Set",
   "Topology.WithLowerSet.toLowerSet",
   "Set.Ici",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.11",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "Eq.trans",
   "id",
   "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.10",
   "HasSubset.Subset",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Topology.IsLowerSet.closure_singleton",
   "Equiv.instFunLikeEquiv",
   "Set.instHasSubsetSet",
   "Topology.WithLowerSet",
   "of_eq_true",
   "Specializes",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "congr",
   "Singleton.singleton",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "congrArg",
   "congrFun"],
  "name": "Topology.WithLowerSet.toLowerSet_specializes_toLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  ↑Topology.WithLowerSet.toLowerSet a ⤳ ↑Topology.WithLowerSet.toLowerSet b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadExcept",
  "constType":
  "outParam (Type u) → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Filter",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.univ_mem'",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (∀ (a : α), a ∈ s) → s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "BiheytingAlgebra.sdiff_le_iff",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "BiheytingAlgebra.toCoheytingAlgebra.proof_1",
   "BiheytingAlgebra.toCoheytingAlgebra.proof_2",
   "HeytingAlgebra.toBot",
   "GeneralizedCoheytingAlgebra.mk",
   "BiheytingAlgebra.top_sdiff",
   "GeneralizedHeytingAlgebra.toLattice",
   "CoheytingAlgebra.mk",
   "BiheytingAlgebra.toSDiff",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra",
  "constType":
  "{α : Type u_2} → [inst : BiheytingAlgebra α] → CoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : Topology.WithLowerSet α},\n  ↑Topology.WithLowerSet.ofLowerSet a ≤ ↑Topology.WithLowerSet.ofLowerSet b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Iff.rfl",
   "Set",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Set.instMembershipSet"],
  "name": "Set.mem_compl_iff",
  "constType": "∀ {α : Type u} (s : Set α) (x : α), x ∈ sᶜ ↔ ¬x ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_comm.match_2",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {p : α → β → Prop} (motive : (∃ b, ∃ a, p a b) → Prop) (x : ∃ b, ∃ a, p a b),\n  (∀ (b : β) (a : α) (h : p a b), motive (_ : ∃ b, ∃ a, p a b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Pi.partialOrder.proof_2",
   "Pi.partialOrder.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Pi.partialOrder.proof_3",
   "Preorder.toLT",
   "Pi.preorder",
   "Pi.partialOrder.proof_1",
   "Preorder",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder",
  "constType":
  "{ι : Type u_1} → {π : ι → Type u_2} → [inst : (i : ι) → PartialOrder (π i)] → PartialOrder ((i : ι) → π i)",
  "constCategory": "Definition"},
 {"references": ["And", "And.imp", "id"],
  "name": "And.imp_right",
  "constType": "∀ {a b c : Prop}, (a → b) → c ∧ a → c ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "Nat.succ_le_succ_iff",
   "propext",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Std.Data.Nat.Lemmas._auxLemma.5",
  "constType": "∀ {a b : ℕ}, (Nat.succ a ≤ Nat.succ b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "TopologicalSpace.GenerateOpen.basic",
   "setOf",
   "ClosedIicTopology.mk",
   "Set",
   "Topology.IsUpper",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "rfl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "isOpen_compl_iff",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Topology.IsUpper.isOpen_iff_generate_Iic_compl",
   "Iff.mp",
   "ClosedIicTopology",
   "TopologicalSpace",
   "IsClosed",
   "IsOpen"],
  "name": "Topology.IsUpper.instClosedIicTopology.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], ClosedIicTopology α",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff", "Iff.rfl", "Eq.rec", "Not", "Eq"],
  "name": "instDecidableEqProp.proof_1",
  "constType": "∀ {p q : Prop}, ¬(p ↔ q) → p = q → False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List",
   "List.decidableBAll.match_1",
   "List.nil"],
  "name": "List.decidableBAll.proof_1",
  "constType": "∀ {α : Type u_1} (p : α → Prop), ∀ a ∈ [], p a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "SemilatticeSup.le_sup_right",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_2",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b : (i : ι) → α' i), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Classical.skolem.match_1",
  "constType":
  "∀ {α : Sort u_1} {b : α → Sort u_2} {p : (x : α) → b x → Prop} (motive : (∃ f, ∀ (x : α), p x (f x)) → Prop)\n  (x : ∃ f, ∀ (x : α), p x (f x)),\n  (∀ (f : (x : α) → b x) (hw : ∀ (x : α), p x (f x)), motive (_ : ∃ f, ∀ (x : α), p x (f x))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "False",
   "instLENat",
   "Bool.true",
   "Not",
   "Bool",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "absurd",
   "LE.le",
   "Eq"],
  "name": "Nat.not_le_of_not_ble_eq_true",
  "constType": "∀ {n m : ℕ}, ¬Nat.ble n m = true → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Classical.choose_spec",
   "Classical.choose",
   "Eq.refl",
   "Exists.intro",
   "eq_true_of_decide",
   "rfl",
   "True",
   "Eq",
   "Eq.mpr",
   "instDecidableNot",
   "Bool.true",
   "Classical.em.match_1",
   "Eq.trans",
   "instDecidableEqProp",
   "id",
   "Ne",
   "funext",
   "Or",
   "False",
   "Or.inr",
   "mt",
   "instDecidableIff",
   "instDecidableTrue",
   "Iff.intro",
   "instDecidableFalse",
   "Eq.ndrec",
   "Or.inl",
   "of_eq_true",
   "propext",
   "Classical.em.match_2",
   "congr",
   "Not",
   "Bool",
   "congrArg"],
  "name": "Classical.em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap.proof_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → p a",
  "constCategory": "Theorem"},
 {"references":
  ["List.instBEqList",
   "BEq",
   "List",
   "LawfulBEq",
   "List.instLawfulBEqListInstBEqList.proof_1"],
  "name": "List.instLawfulBEqListInstBEqList",
  "constType":
  "∀ {α : Type u} [inst : BEq α] [inst_1 : LawfulBEq α], LawfulBEq (List α)",
  "constCategory": "Definition"},
 {"references": ["Append"],
  "name": "Append.mk",
  "constType": "{α : Type u} → (α → α → α) → Append α",
  "constCategory": "Other"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Iff.mp",
   "Filter.instTopFilter",
   "Top.top",
   "Eq.rec",
   "Set",
   "Filter",
   "Eq.symm",
   "Set.univ",
   "Top.mk",
   "Filter.univ_mem",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.proof_11",
  "constType": "∀ {α : Type u_1} (x : Filter α), ∀ _s ∈ ⊤, _s ∈ x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_10",
  "constType":
  "∀ {α : Type u_1} (s : Set (Filter α)ᵒᵈᵒᵈ) (a : (Filter α)ᵒᵈᵒᵈ), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsAntisymm",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≤]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.refl",
   "dite",
   "beq_self_eq_true",
   "List.erase",
   "True",
   "Iff.mpr",
   "ite",
   "Eq",
   "instLawfulBEqInstBEq",
   "BEq.beq",
   "Bool.true",
   "beq_eq_false_iff_ne",
   "List.erase.match_1",
   "Eq.trans",
   "eq_self",
   "Ne",
   "List.cons",
   "funext",
   "False",
   "Unit",
   "instBEq",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.erase_cons",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : α) (l : List α),\n  List.erase (b :: l) a = if b = a then l else b :: List.erase l a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HeytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.decidableBAll.match_2",
  "constType":
  "∀ {α : Type u_1} (x : α) (xs : List α) (motive : (x_1 : α) → x_1 ∈ x :: xs → Prop) (x_1 : α) (x_2 : x_1 ∈ x :: xs),\n  (∀ (y : α) (h : List.Mem y xs), motive y (_ : List.Mem y (x :: xs))) →\n    (Unit → motive x (_ : List.Mem x (x :: xs))) → motive x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec", "Prod.casesOn", "Eq.refl", "Prod.noConfusionType", "Prod", "Eq"],
  "name": "Prod.noConfusion",
  "constType":
  "{α : Type u} → {β : Type v} → {P : Sort u_1} → {v1 v2 : α × β} → v1 = v2 → Prod.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Preorder", "le_of_le_of_eq", "LE.le", "Preorder.toLE", "Eq"],
  "name": "LE.le.trans_eq",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "AlexandrovDiscrete",
   "Topology.IsLowerSet.toAlexandrovDiscrete.proof_1"],
  "name": "Topology.IsLowerSet.toAlexandrovDiscrete",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsLowerSet α], AlexandrovDiscrete α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sInf",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Function.comp",
   "InfSet.sInf",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_5",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (s : Set αᵒᵈᵒᵈ) (a : αᵒᵈᵒᵈ), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Membership.mem",
   "Iff",
   "Set",
   "TopologicalSpace",
   "nhdsWithin",
   "Filter.NeBot",
   "mem_closure_iff_clusterPt",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff_nhdsWithin_neBot",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {x : α}, x ∈ closure s ↔ Filter.NeBot (nhdsWithin x s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.basic",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "setOf",
   "TopologicalSpace.GenerateOpen.recOn",
   "isOpen_sUnion",
   "Set",
   "IsOpen.inter",
   "HasSubset.Subset",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "isOpen_univ",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "IsOpen"],
  "name": "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {t : TopologicalSpace α}, t ≤ TopologicalSpace.generateFrom g ↔ g ⊆ {s | IsOpen s}",
  "constCategory": "Theorem"},
 {"references": ["Or", "False", "false_or_iff", "propext", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.12",
  "constType": "∀ (p : Prop), (False ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.succ_le_succ.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (x : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "Bool.false",
   "and",
   "Bool.true",
   "Eq.refl",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "Bool.true_and",
  "constType": "∀ (b : Bool), (true && b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "isGLB_empty",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "sInf_empty",
  "constType": "∀ {α : Type u_1} [inst : CompleteLattice α], sInf ∅ = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«term𝓝[<]_»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[<]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsAssociative",
  "constType": "{α : Sort u} → (α → α → α) → Type",
  "constCategory": "Other"},
 {"references":
  ["UInt32.mk",
   "UInt32",
   "False",
   "UInt32.noConfusion",
   "Not",
   "UInt32.size",
   "absurd",
   "Fin",
   "Eq"],
  "name": "UInt32.decEq.proof_2",
  "constType":
  "∀ (n m : Fin UInt32.size), ¬n = m → { val := n } = { val := m } → False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "Prod.mk",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Set.Nonempty.prod.match_1",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, Set.Nonempty s → Set.Nonempty t → Set.Nonempty (s ×ˢ t)",
  "constCategory": "Theorem"},
 {"references": ["SupSet"],
  "name": "sSupHom",
  "constType":
  "(α : Type u_8) → (β : Type u_9) → [inst : SupSet α] → [inst : SupSet β] → Type (max u_8 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Fin.succ_lt_succ_iff",
   "propext",
   "LT.lt",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "Nat.succ",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.17",
  "constType": "∀ {n : ℕ} {a b : Fin n}, (Fin.succ a < Fin.succ b) = (a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.imp",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_inter",
  "constType":
  "∀ {α : Type u} {s₁ s₂ t₁ t₂ : Set α}, s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ ∩ s₂ ⊆ t₁ ∩ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "List.mem_map.match_1",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.Sublist.refl",
  "constType": "∀ {α : Type u_1} (l : List α), List.Sublist l l",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet"],
  "name": "Topology.WithLowerSet.map._elambda_1",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    ((a : β) → (fun x ↦ Topology.WithLowerSet β) a) →\n      (Topology.WithLowerSet α → β) → Topology.WithLowerSet α → Topology.WithLowerSet β",
  "constCategory": "Axiom"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "instHAppend",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "false_or",
   "Std.Data.List.Lemmas._auxLemma.10",
   "congrFun"],
  "name": "List.mem_append",
  "constType":
  "∀ {α : Type u_1} {a : α} {s t : List α}, a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "constCategory": "Theorem"},
 {"references": ["List.insert", "DecidableEq", "List", "List.foldr"],
  "name": "List.union",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → List α → List α → List α",
  "constCategory": "Definition"},
 {"references": ["False", "Iff", "Not", "absurd", "Iff.mpr"],
  "name": "decidable_of_decidable_of_iff.proof_1",
  "constType": "∀ {p q : Prop}, (p ↔ q) → ¬p → q → False",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.termπ_._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.termπ_._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "DecidableEq",
   "Finset.mem_union",
   "propext",
   "Union.union",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.instUnionFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.73",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, (a ∈ s ∪ t) = (a ∈ s ∨ a ∈ t)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "List.cons",
   "Lean.mkNode",
   "Array.empty",
   "Lean.SyntaxNodeKind",
   "Lean.TSyntax.raw",
   "List.nil",
   "Lean.nullKind",
   "optParam",
   "Lean.Syntax"],
  "name": "Lean.mkNullNode",
  "constType": "optParam (Array Lean.Syntax) #[] → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "forall_imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∀ (a : α), p a) → ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) = ((∀ a' ∈ l, R a a') ∧ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["And", "and_iff_left_of_imp", "Iff"],
  "name": "and_iff_left",
  "constType": "∀ {b a : Prop}, b → (a ∧ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.iInf_sets_eq.match_1",
   "GE.ge",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Mathlib.Order.Filter.Basic._auxLemma.47",
   "Directed",
   "implies_congr",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Filter.univ_mem",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Filter.inter_mem",
   "Filter.mk",
   "forall_congr",
   "Filter",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "id",
   "eq_self",
   "Filter.sets",
   "Membership.mem",
   "congr_arg",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Basic._auxLemma.48",
   "Set.univ",
   "Set.mem_iUnion",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "Filter.eq_iInf_of_mem_iff_exists_mem",
   "Set.instInterSet"],
  "name": "Filter.iInf_sets_eq",
  "constType":
  "∀ {α : Type u} {ι : Sort x} {f : ι → Filter α},\n  Directed (fun x x_1 ↦ x ≥ x_1) f → ∀ [ne : Nonempty ι], (iInf f).sets = ⋃ i, (f i).sets",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toSDiff",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq"],
  "name": "CompleteAtomicBooleanAlgebra.sdiff_eq",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x y : α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.map._elambda_1._rarg._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "TopologicalSpace.IsOpen",
  "constType": "{α : Type u} → [self : TopologicalSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_left_cancel",
   "Exists",
   "Nat.le_of_add_le_add_left.match_1",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.mp",
   "Eq.refl",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left",
  "constType": "∀ {a b c : ℕ}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "congr_arg",
   "HAppend.hAppend",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Multiset.instAddMultiset",
   "Quot.mk",
   "Add.mk",
   "Eq"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ s₃ : Multiset α), s₁ + s₂ + s₃ = s₁ + (s₂ + s₃)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instIsTransLtToLT.proof_1",
   "Preorder.toLT",
   "LT.lt",
   "IsTrans",
   "Preorder"],
  "name": "instIsTransLtToLT",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsTrans α fun x x_1 ↦ x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.«term𝓝ˢ»._closed_4", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝ˢ»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["le_iSup_of_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toSupSet"],
  "name": "le_iSup₂",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {f : (i : ι) → κ i → α} (i : ι) (j : κ i),\n  f i j ≤ ⨆ i, ⨆ j, f i j",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq",
   "PartialOrder"],
  "name": "OrderDual.semilatticeSup.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : SemilatticeInf α] (a b : αᵒᵈ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "IsUpperSet",
   "Preorder",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "forall_congr",
   "Continuous",
   "IsUpperSet.preimage",
   "TopologicalSpace",
   "Monotone",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "IsOpen",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
   "id"],
  "name": "Topology.IsUpperSet.monotone_to_upperTopology_continuous",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : TopologicalSpace α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Topology.IsUpperSet α] [inst_5 : Topology.IsUpper β] {f : α → β},\n  Monotone f → Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.Nonempty",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.prod.match_1",
  "constType":
  "∀ {β : Type u_1} {t : Set β} (motive : Set.Nonempty t → Prop) (x : Set.Nonempty t),\n  (∀ (y : β) (hy : y ∈ t), motive (_ : ∃ x, x ∈ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Equiv.mk",
   "Topology.WithUpperSet.toDualHomeomorph._closed_1",
   "_neutral"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And", "Iff", "propext", "Eq.symm", "and_congr_right_iff", "Eq"],
  "name": "Std.Logic._auxLemma.13",
  "constType": "∀ {a b c : Prop}, (a → (b ↔ c)) = (a ∧ b ↔ a ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Iff", "Iff.rfl", "Function.comp", "Directed", "Order.Preimage"],
  "name": "directed_comp",
  "constType":
  "∀ {α : Type u} {β : Type v} {r : α → α → Prop} {ι : Sort u_1} {f : ι → β} {g : β → α},\n  Directed r (g ∘ f) ↔ Directed (g ⁻¹'o r) f",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "outParam"],
  "name": "sSupHomClass",
  "constType":
  "Type u_8 →\n  (α : outParam (Type u_9)) →\n    (β : outParam (Type u_10)) → [inst : SupSet α] → [inst : SupSet β] → Type (max (max u_10 u_8) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "False",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.not_nonempty_empty.match_1",
   "Set.instMembershipSet"],
  "name": "Set.not_nonempty_empty",
  "constType": "∀ {α : Type u}, ¬Set.Nonempty ∅",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Lean.Data.AC.Expr.op",
   "PProd.fst",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.EvalInformation",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Lean.Data.AC.Expr.brecOn",
   "PProd.snd",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "Lean.Data.AC.EvalInformation.evalOp",
   "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40"],
  "name": "Lean.Data.AC.eval",
  "constType":
  "{α : Sort u_1} → (β : Sort u) → [inst : Lean.Data.AC.EvalInformation α β] → α → Lean.Data.AC.Expr → β",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.withRef",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadRef m] → {α : Type} → Lean.Syntax → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "False", "Or.inr", "false_or.match_1", "propext", "Eq"],
  "name": "false_or",
  "constType": "∀ (p : Prop), (False ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "IsGLB",
   "isGLB_sInf",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "IsGLB.unique",
   "CompleteSemilatticeInf",
   "Eq"],
  "name": "IsGLB.sInf_eq",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, IsGLB s a → sInf s = a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_union",
   "Membership.mem",
   "Or",
   "propext",
   "Union.union",
   "Set",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.17",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∪ b) = (x ∈ a ∨ x ∈ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Equiv",
   "AddZeroClass.toAdd",
   "Multiset.card",
   "List.instMembershipList",
   "Finset.mem_univ_val",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Multiset.instMembershipMultiset",
   "Quot.recOnSubsingleton'",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Fintype",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "Trunc.mk",
   "Fintype.truncEquivFin.proof_2",
   "Multiset",
   "Finset.val",
   "Trunc",
   "Nat",
   "Equiv.symm",
   "id",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "Multiset.Nodup",
   "Fintype.card",
   "FunLike.coe",
   "List.length",
   "Setoid.r",
   "Finset.univ",
   "List.Nodup",
   "DecidableEq",
   "List",
   "Fintype.truncEquivFin.proof_1",
   "AddMonoidHomClass.toAddHomClass",
   "List.Nodup.getEquivOfForallMemList",
   "AddMonoidHom.addMonoidHomClass",
   "Fin",
   "AddMonoidHom",
   "Quot.mk"],
  "name": "Fintype.truncEquivFin",
  "constType":
  "(α : Type u_4) → [inst : DecidableEq α] → [inst : Fintype α] → Trunc (α ≃ Fin (Fintype.card α))",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_comm",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ⊓ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Substring"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Monad", "Bind"],
  "name": "Monad.toBind",
  "constType": "{m : Type u → Type v} → [self : Monad m] → Bind m",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.Expr.rec",
   "Nat",
   "Lean.Data.AC.Expr.var"],
  "name": "Lean.Data.AC.Expr.casesOn",
  "constType":
  "{motive : Lean.Data.AC.Expr → Sort u} →\n  (t : Lean.Data.AC.Expr) →\n    ((x : ℕ) → motive (Lean.Data.AC.Expr.var x)) →\n      ((lhs rhs : Lean.Data.AC.Expr) → motive (Lean.Data.AC.Expr.op lhs rhs)) → motive t",
  "constCategory": "Definition"},
 {"references": ["HImp.himp", "HImp.mk", "HImp"],
  "name": "Pi.instHImpForAll",
  "constType":
  "{ι : Type u_1} → {π : ι → Type u_4} → [inst : (i : ι) → HImp (π i)] → HImp ((i : ι) → π i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_iff'",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ (t : Set α), t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT"],
  "name": "MonadLiftT.mk",
  "constType":
  "{m : Type u → Type v} → {n : Type u → Type w} → ({α : Type u} → m α → n α) → MonadLiftT m n",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "Multiset", "Multiset.instMembershipMultiset", "id"],
  "name": "Multiset.attach.proof_1",
  "constType": "∀ {α : Type u_1} (s : Multiset α), ∀ _a ∈ s, _a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "congr_arg",
   "Trans.trans",
   "Function.Injective",
   "instTransEq",
   "Eq.symm",
   "Eq"],
  "name": "Function.LeftInverse.injective",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {g : β → α} {f : α → β}, Function.LeftInverse g f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Preorder.le_refl",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_1",
  "constType": "∀ {α : Type u_1} (a : (Filter α)ᵒᵈᵒᵈ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Equiv",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
   "Set",
   "Set.Iic",
   "Topology.WithUpperSet.toUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.5",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.4",
   "Eq.trans",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "id",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "HasSubset.Subset",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Equiv.instFunLikeEquiv",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "Specializes",
   "congr",
   "Singleton.singleton",
   "Topology.IsUpperSet.closure_singleton",
   "congrArg",
   "congrFun"],
  "name": "Topology.WithUpperSet.toUpperSet_specializes_toUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  ↑Topology.WithUpperSet.toUpperSet a ⤳ ↑Topology.WithUpperSet.toUpperSet b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Not.elim", "Iff", "Not"],
  "name": "iff_of_false",
  "constType": "∀ {a b : Prop}, ¬a → ¬b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": ["PSigma"],
  "name": "PSigma.mk",
  "constType": "{α : Sort u} → {β : α → Sort v} → (fst : α) → β fst → PSigma β",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "le_top",
   "OrderTop",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "GaloisInsertion.liftOrderTop.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : Preorder α] [inst_1 : OrderTop α], u (l ⊤) ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.removeNeutrals.loop.match_2",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "Lean.Data.AC.removeNeutrals.loop.match_1",
   "List.nil",
   "Bool",
   "Lean.Data.AC.ContextInformation",
   "Nat",
   "Lean.Data.AC.ContextInformation.isNeutral"],
  "name": "Lean.Data.AC.removeNeutrals.loop",
  "constType":
  "{α : Sort u_1} → [info : Lean.Data.AC.ContextInformation α] → α → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.antisymm",
   "funext",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Pi.preorder",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "LE.le",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_4",
  "constType":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → PartialOrder (π i)] (x x_1 : (i : ι) → π i),\n  x ≤ x_1 → x_1 ≤ x → x = x_1",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.nil", "Nat", "Array.mk"],
  "name": "Array.mkEmpty",
  "constType": "{α : Type u} → ℕ → Array α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "CompleteLattice.toBoundedOrder",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "Filter.principal",
   "of_eq_true",
   "Filter.instTopFilter",
   "Filter.instPartialOrderFilter",
   "Filter",
   "Mathlib.Order.Filter.Basic._auxLemma.18",
   "Eq.trans",
   "instMembershipSetFilter",
   "top_unique",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.principal_univ",
  "constType": "∀ {α : Type u}, Filter.principal Set.univ = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Add M] →\n        [inst_1 : Add N] →\n          [toFunLike : FunLike F M fun x ↦ N] → (∀ (f : F) (x y : M), ↑f (x + y) = ↑f x + ↑f y) → AddHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instBEq",
   "instDecidableTrue",
   "ite_congr",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "List.count",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_cons_self",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.count a (a :: l) = List.count a l + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "PProd",
   "PUnit.unit",
   "Lean.Data.AC.Expr",
   "PUnit",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "PProd.mk"],
  "name": "Lean.Data.AC.Expr.brecOn",
  "constType":
  "{motive : Lean.Data.AC.Expr → Sort u} →\n  (t : Lean.Data.AC.Expr) → ((t : Lean.Data.AC.Expr) → Lean.Data.AC.Expr.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Set",
   "Set.iInter",
   "Set.instInfSetSet",
   "Iff.mpr",
   "iInf_congr_Prop",
   "Eq"],
  "name": "Set.iInter_congr_Prop",
  "constType":
  "∀ {α : Type u_1} {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q),\n  (∀ (x : q), f₁ (_ : p) = f₂ x) → Set.iInter f₁ = Set.iInter f₂",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "propext", "or_imp", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.18",
  "constType": "∀ {a b c : Prop}, (a ∨ b → c) = ((a → c) ∧ (b → c))",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "dite"],
  "name": "Decidable.not_or_of_imp",
  "constType": "∀ {a b : Prop} [inst : Decidable a], (a → b) → ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "sInf_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "rfl",
   "Preorder.toLE",
   "Eq"],
  "name": "iInf_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] (f : ι → α) (i : ι), iInf f ≤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.brecOn",
   "List.below",
   "List.perm_middle.match_1",
   "List.Perm.cons",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "List.Perm.symm",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "List.Perm",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "List.perm_middle",
   "PUnit",
   "List.Perm.trans",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "List.append_nil"],
  "name": "List.perm_append_comm",
  "constType": "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ++ l₂ ~ l₂ ++ l₁",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.mk",
   "Membership.mem",
   "IsLowerSet",
   "Set",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "ContinuousMap",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Equiv.instFunLikeEquiv",
   "ContinuousMap.mk",
   "Set.instMembershipSet",
   "Topology.WithLowerSet",
   "lcProof",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Set.sUnion",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.map._elambda_1",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithLowerSet.map._cstage1",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → C(Topology.WithLowerSet α, Topology.WithLowerSet β)",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "IsLowerSet",
   "LowerSet.instSetLikeLowerSet",
   "LE",
   "LowerSet.lower'",
   "SetLike.coe"],
  "name": "LowerSet.lower",
  "constType": "∀ {α : Type u_1} [inst : LE α] (s : LowerSet α), IsLowerSet ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "Eq.symm",
   "Eq"],
  "name": "List.Sublist.trans.match_1",
  "constType":
  "∀ {α : Type u_1} {l₂ : List α} (a : α)\n  (motive : (l₂' l₁ : List α) → List.Sublist l₁ l₂' → List.Sublist l₁ (a :: l₂) → a :: l₂ = l₂' → Prop)\n  (l₂' l₁ : List α) (x : List.Sublist l₁ l₂') (h₁ : List.Sublist l₁ (a :: l₂)) (e : a :: l₂ = l₂'),\n  (∀ (h₁ : List.Sublist [] (a :: l₂)) (e : a :: l₂ = []), motive [] [] (_ : List.Sublist [] []) h₁ e) →\n    (∀ (l₁ l₂_1 : List α) (a' : α) (h₁' : List.Sublist l₁ l₂_1) (h₁ : List.Sublist l₁ (a :: l₂))\n        (e : a :: l₂ = a' :: l₂_1), motive (a' :: l₂_1) l₁ (_ : List.Sublist l₁ (a' :: l₂_1)) h₁ e) →\n      (∀ (l₁ l₂_1 : List α) (a' : α) (h₁' : List.Sublist l₁ l₂_1) (h₁ : List.Sublist (a' :: l₁) (a :: l₂))\n          (e : a :: l₂ = a' :: l₂_1), motive (a' :: l₂_1) (a' :: l₁) (_ : List.Sublist (a' :: l₁) (a' :: l₂_1)) h₁ e) →\n        motive l₂' l₁ x h₁ e",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.symm",
   "List.Perm.subperm_left.match_1",
   "Iff.intro",
   "Exists",
   "Iff",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "List.Perm.trans",
   "Exists.intro"],
  "name": "List.Perm.subperm_right",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ l : List α}, l₁ ~ l₂ → (l₁ <+~ l ↔ l₂ <+~ l)",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddRightCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = c + b → a = c) → AddRightCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "UInt8",
   "Lean.Name.mkStr2",
   "Lean.Syntax.isOfKind",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.SourceInfo.fromRef",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node3",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.Result.error"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.drop.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.take",
  "constType": "{α : Type u} → ℕ → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Ne", "List.Pairwise.sublist", "List.Nodup", "List", "List.Sublist"],
  "name": "List.Nodup.sublist",
  "constType":
  "∀ {α : Type u} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.Nodup l₂ → List.Nodup l₁",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "Nat"],
  "name": "SizeOf.mk",
  "constType": "{α : Sort u} → (α → ℕ) → SizeOf α",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ", "Nat.le.rec"],
  "name": "Nat.le.casesOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {a : ℕ} (t : Nat.le n a),\n  motive n (_ : Nat.le n n) → (∀ {m : ℕ} (a : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive a t",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "List.find?_cons.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "OrderDual.distribLattice.proof_3",
   "OrderDual.distribLattice.proof_1",
   "DistribLattice",
   "OrderDual.distribLattice.proof_2",
   "OrderDual.distribLattice.proof_4",
   "DistribLattice.mk",
   "inferInstanceAs",
   "OrderDual",
   "Lattice.mk",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice"],
  "name": "OrderDual.distribLattice",
  "constType":
  "(α : Type u_1) → [inst : DistribLattice α] → DistribLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termπ_._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.mkArray0",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusionType",
  "constType": "Sort u → ℕ → ℕ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Nat.addMonoid",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "AddHomClass.toFunLike",
   "Multiset",
   "Finset",
   "Finset.val",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "Nat",
   "AddMonoidHom",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["exists_prop_congr", "Exists", "Iff", "propext", "Iff.mpr", "Eq"],
  "name": "exists_prop_congr'",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "Filter.sets",
   "Filter.filter_eq",
   "Iff.rfl",
   "Set",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Set.Subset.rfl",
   "Eq",
   "Preorder.mk",
   "And",
   "LT.lt",
   "Filter",
   "Not",
   "Set.Subset.trans",
   "Set.Subset.antisymm",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_4",
  "constType": "∀ {α : Type u_1} (a b : Filter α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Filter.instTopFilter",
   "Top.top",
   "Iff.rfl",
   "Set",
   "Filter",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_top_iff_forall",
  "constType": "∀ {α : Type u} {s : Set α}, s ∈ ⊤ ↔ ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype.subtype.proof_1",
   "Membership.mem",
   "Fintype",
   "Fintype.subtype.proof_3",
   "Fintype.mk",
   "Iff",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Fintype.subtype.proof_2",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype",
  "constType":
  "{α : Type u_1} → {p : α → Prop} → (s : Finset α) → (∀ (x : α), x ∈ s ↔ p x) → Fintype { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["namedPattern",
   "Lean.Name.num",
   "List",
   "String",
   "Eq.refl",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str",
   "Eq"],
  "name": "_private.Init.Prelude.0.Lean.extractImported.match_1",
  "constType":
  "(motive : Lean.Name → List Lean.Name → Sort u_1) →\n  (x : Lean.Name) →\n    (x_1 : List Lean.Name) →\n      ((n p : Lean.Name) →\n          (str : String) →\n            (h : n = Lean.Name.str p str) →\n              (parts : List Lean.Name) → motive (namedPattern n (Lean.Name.str p str) h) parts) →\n        ((n p : Lean.Name) →\n            (i : ℕ) →\n              (h : n = Lean.Name.num p i) →\n                (parts : List Lean.Name) → motive (namedPattern n (Lean.Name.num p i) h) parts) →\n          ((x : Lean.Name) → (x_2 : List Lean.Name) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "IsClosed",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.dedup",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_dedup",
   "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.3",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, (a ∈ List.dedup l) = (a ∈ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[≤]_»._closed_2",
   "Topology.«term𝓝[≤]_»._closed_5"],
  "name": "Topology.«term𝓝[≤]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Specializes",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Singleton.singleton",
   "specializes_iff_closure_subset",
   "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.18",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ⤳ y = (closure {y} ⊆ closure {x})",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "propext", "or_imp", "Eq"],
  "name": "Std.Logic._auxLemma.43",
  "constType": "∀ {a b c : Prop}, (a ∨ b → c) = ((a → c) ∧ (b → c))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "HEq",
   "List.Pairwise.below",
   "List.instMembershipList",
   "eq_of_heq",
   "Unit",
   "Eq.refl",
   "List.Pairwise.below.nil",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Pairwise.below.casesOn",
   "List.nil",
   "Eq.symm"],
  "name": "List.Pairwise.imp.match_1._@.Std.Data.List.Lemmas._hyg.29208",
  "constType":
  "∀ {α : Type u_1} {R S : α → α → Prop}\n  (motive : (x : List α) → (x_1 : List.Pairwise R x) → List.Pairwise.below x_1 → Prop) (x : List α)\n  (x_1 : List.Pairwise R x) (h_below : List.Pairwise.below x_1),\n  (Unit → motive [] (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R []))) →\n    (∀ (a : α) (l : List α) (h₁ : ∀ a' ∈ l, R a a') (h₂ : List.Pairwise R l) (h : List.Pairwise.below h₂)\n        (a_1 : List.Pairwise S l),\n        motive (a :: l) (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) →\n      motive x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["Filter.univ_sets",
   "Filter.sets",
   "Membership.mem",
   "eq_true",
   "Set",
   "Filter",
   "Set.univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.12",
  "constType":
  "∀ {α : Type u_1} (self : Filter α), (Set.univ ∈ self.sets) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "DistribLattice",
   "CompleteLattice",
   "Filter.instDistribLatticeFilter.proof_1",
   "DistribLattice.mk",
   "Filter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.instDistribLatticeFilter",
  "constType": "{α : Type u} → DistribLattice (Filter α)",
  "constCategory": "Definition"},
 {"references": ["Equivalence"],
  "name": "Equivalence.mk",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop},\n  (∀ (x : α), r x x) → (∀ {x y : α}, r x y → r y x) → (∀ {x y z : α}, r x y → r y z → r x z) → Equivalence r",
  "constCategory": "Other"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "Monad.toApplicative",
   "Bool.false",
   "Lean.MonadRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bind.bind",
   "Pure.pure",
   "Lean.MonadRef.getRef",
   "Lean.Syntax",
   "Monad.toBind",
   "Applicative.toPure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadRef m] → m Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithLower.instInhabitedWithLower._rarg", "_neutral"],
  "name": "Topology.WithLower.instInhabitedWithLower._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nonempty_subtype",
   "Exists",
   "Set.Elem",
   "Set",
   "Set.Nonempty",
   "Subtype",
   "Nonempty",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.to_subtype",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Nonempty s → Nonempty ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeInf.le_sInf",
  "constType":
  "∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.nil",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.rec",
  "constType":
  "∀ {α : Type uu} {motive : (a a_1 : List α) → a ~ a_1 → Prop},\n  motive [] [] (_ : [] ~ []) →\n    (∀ (x : α) {l₁ l₂ : List α} (a : l₁ ~ l₂), motive l₁ l₂ a → motive (x :: l₁) (x :: l₂) (_ : x :: l₁ ~ x :: l₂)) →\n      (∀ (x y : α) (l : List α), motive (y :: x :: l) (x :: y :: l) (_ : y :: x :: l ~ x :: y :: l)) →\n        (∀ {l₁ l₂ l₃ : List α} (a : l₁ ~ l₂) (a_1 : l₂ ~ l₃),\n            motive l₁ l₂ a → motive l₂ l₃ a_1 → motive l₁ l₃ (_ : l₁ ~ l₃)) →\n          ∀ {a a_1 : List α} (t : a ~ a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references": ["Exists", "False", "Not", "exists_false.match_1"],
  "name": "exists_false",
  "constType": "∀ {α : Sort u_1}, ¬∃ _a, False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finite",
  "constType": "Sort u_1 → Prop",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "rfl",
   "TopologicalSpace.ext.match_1",
   "IsOpen",
   "Set.instMembershipSet",
   "Set.instInterSet",
   "Eq"],
  "name": "TopologicalSpace.ext",
  "constType":
  "∀ {α : Type u} {f g : TopologicalSpace α}, IsOpen = IsOpen → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "ClosedIicTopology",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "ClosedIicTopology.mk",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α],\n  (∀ (a : α), IsClosed {b | b ≤ a}) → ClosedIicTopology α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced"],
  "name": "instTopologicalSpaceProd",
  "constType":
  "{α : Type u} → {β : Type v} → [t₁ : TopologicalSpace α] → [t₂ : TopologicalSpace β] → TopologicalSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "instTopologicalSpaceProd",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced",
   "Eq"],
  "name":
  "_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
  "constType":
  "∀ {α : Type u} {β : Type v} [t₁ : TopologicalSpace α] [t₂ : TopologicalSpace β],\n  instTopologicalSpaceProd = TopologicalSpace.induced Prod.fst t₁ ⊓ TopologicalSpace.induced Prod.snd t₂",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → α ≃o Topology.WithLowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.«term𝓝[<]_»._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_9"],
  "name": "Topology.«term𝓝[<]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "propext", "or_self.match_1", "Eq"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32", "Decidable", "instLEUInt32", "UInt32.decLe", "LE.le"],
  "name": "instDecidableLeUInt32InstLEUInt32",
  "constType": "(a b : UInt32) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references": ["And", "And.right", "False", "Not"],
  "name": "instDecidableAnd.proof_1",
  "constType": "∀ {p q : Prop}, ¬q → p ∧ q → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_refl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_1",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["InfTopHomClass",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "sInfHomClass.toInfTopHomClass.proof_1",
   "InfHomClass.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "sInfHomClass.toInfTopHomClass.proof_2",
   "CompleteLattice.toTop",
   "sInfHomClass.toFunLike",
   "InfTopHomClass.mk",
   "sInfHomClass"],
  "name": "sInfHomClass.toInfTopHomClass",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : CompleteLattice α] → [inst_1 : CompleteLattice β] → [inst_2 : sInfHomClass F α β] → InfTopHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "List.length",
   "Nat",
   "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.length._eq_2",
  "constType":
  "∀ {α : Type u_1} (head : α) (as : List α), List.length (head :: as) = List.length as + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvImage",
  "constType":
  "{α : Sort u} → {β : Sort v} → (β → β → Prop) → (α → β) → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.succ_eq_add_one",
  "constType": "∀ (n : ℕ), Nat.succ n = n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Bot.bot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "GeneralizedBooleanAlgebra.inf_inf_sdiff",
   "Eq"],
  "name": "inf_inf_sdiff",
  "constType":
  "∀ {α : Type u} [inst : GeneralizedBooleanAlgebra α] (x y : α), x ⊓ y ⊓ x \\ y = ⊥",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "Not", "And.left"],
  "name": "instDecidableAnd.proof_2",
  "constType": "∀ {p q : Prop}, ¬p → p ∧ q → False",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["GaloisConnection",
   "GaloisCoinsertion",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisCoinsertion.mk",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            (choice : (x : β) → x ≤ l (u x) → α) →\n              GaloisConnection l u →\n                (∀ (x : α), u (l x) ≤ x) → (∀ (a : β) (h : a ≤ l (u a)), choice a h = u a) → GaloisCoinsertion l u",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "iSup",
   "le_iSup",
   "iSup_le",
   "le_sup_left",
   "Eq",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "iSup_mono",
   "Sup.sup",
   "sup_le",
   "le_sup_right",
   "sup_le_sup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "le_antisymm",
   "CompleteLattice.toSupSet"],
  "name": "iSup_sup_eq",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f g : ι → α}, ⨆ x, f x ⊔ g x = (⨆ x, f x) ⊔ ⨆ x, g x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.preimage_mono",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s t : Set β}, s ⊆ t → f ⁻¹' s ⊆ f ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.drop.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : ℕ → List α → Sort u_2) →\n    (x : ℕ) →\n      (x_1 : List α) →\n        ((a : List α) → motive 0 a) →\n          ((n : ℕ) → motive (Nat.succ n) []) →\n            ((n : ℕ) → (head : α) → (as : List α) → motive (Nat.succ n) (head :: as)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GeneralizedBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.le_top",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_14",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableEqProp.match_1",
  "constType":
  "{p q : Prop} →\n  (motive : Decidable (p ↔ q) → Sort u_1) →\n    (d : Decidable (p ↔ q)) → ((h : p ↔ q) → motive (isTrue h)) → ((h : ¬(p ↔ q)) → motive (isFalse h)) → motive d",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≥]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Image._auxLemma.23",
   "Exists",
   "funext",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "True",
   "iff_self",
   "Eq",
   "Multiset.map",
   "And",
   "Mathlib.Data.Finset.Image._auxLemma.8",
   "Mathlib.Data.Finset.Image._auxLemma.22",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.image",
   "Finset",
   "Multiset",
   "Finset.val",
   "congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Finset.mem_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},\n  b ∈ Finset.image f s ↔ ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.mk",
   "OrderHom.comp.proof_1",
   "Function.comp",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.comp",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    {γ : Type u_4} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : Preorder γ] → (β →o γ) → (α →o β) → α →o γ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DecidableEq", "Classical.propDecidable", "Eq"],
  "name": "Classical.decEq",
  "constType": "(α : Sort u) → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "Singleton.singleton",
   "IsGLB.sInf_eq",
   "CompleteSemilatticeInf",
   "Eq",
   "isGLB_singleton"],
  "name": "sInf_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {a : α}, sInf {a} = a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.mk",
  "constType":
  "{δ : outParam (Type u)} → {σ : Type u} → (σ → δ) → (σ → δ → σ) → EStateM.Backtrackable δ σ",
  "constCategory": "Other"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite.rec",
   "Set.Finite"],
  "name": "Set.Finite.casesOn",
  "constType":
  "∀ {α : Type u} {s : Set α} {motive : Set.Finite s → Prop} (t : Set.Finite s),\n  (∀ (a : Fintype ↑s), motive (_ : Set.Finite s)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.ofUpper",
  "constType": "{α : Type u_1} → Topology.WithUpper α ≃ α",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable", "Not", "Decidable.byContradiction"],
  "name": "Decidable.by_contradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "List.pairwise_lt_range'",
   "List.Pairwise.imp",
   "List.range'",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "ne_of_lt",
   "optParam",
   "autoParam",
   "instLTNat",
   "List.Nodup",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.strictOrderedSemiring"],
  "name": "List.nodup_range'",
  "constType":
  "∀ (s n : ℕ) (step : optParam ℕ 1), autoParam (0 < step) _auto✝ → List.Nodup (List.range' s n step)",
  "constCategory": "Theorem"},
 {"references":
  ["List.instMembershipList",
   "Std.Data.List.Count._auxLemma.7",
   "Eq.refl",
   "implies_congr",
   "True",
   "Eq",
   "instLawfulBEqInstBEq",
   "trivial",
   "And.right",
   "BEq.beq",
   "Eq.mpr",
   "forall_congr",
   "Bool.true",
   "Nat",
   "List.countP",
   "Eq.trans",
   "id",
   "Membership.mem",
   "eq_self",
   "List.filter",
   "Std.Data.List.Count._auxLemma.9",
   "instBEq",
   "Std.Data.List.Count._auxLemma.2",
   "List.length",
   "And",
   "DecidableEq",
   "List",
   "List.replicate",
   "congr",
   "Bool",
   "And.intro",
   "List.count",
   "congrArg",
   "congrFun",
   "List.countP_eq_length_filter"],
  "name": "List.filter_beq'",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α) (a : α),\n  List.filter (fun x ↦ x == a) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["nhds",
   "Inf.inf",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.NeBot"],
  "name": "ClusterPt",
  "constType":
  "{α : Type u} → [inst : TopologicalSpace α] → α → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.toDualHomeomorph.proof_2",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toDualHomeomorph.proof_3",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Topology.WithUpperSet.toDualHomeomorph.proof_1",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.toDualHomeomorph",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithUpperSet α ≃ₜ Topology.WithLowerSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.rec", "Option.some", "Option"],
  "name": "Option.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} → (t : Option α) → motive none → ((val : α) → motive (some val)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Name.mkStr1"],
  "name": "Lean.nullKind",
  "constType": "Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike.mem_coe",
   "SetLike",
   "propext",
   "Set",
   "SetLike.instMembership",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.SetLike.Basic._auxLemma.3",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Add M] → [inst_1 : Add N] → [self : AddHomClass F M N] → FunLike F M fun x ↦ N",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower", "Topology.IsLower", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsLower.topology_eq_lowerTopology",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α] [inst : Preorder α] [self : Topology.IsLower α], t = Topology.lower α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Iff",
   "Fin.val",
   "LT.lt",
   "Nat.succ_lt_succ_iff",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "Nat.succ",
   "Fin"],
  "name": "Fin.succ_lt_succ_iff",
  "constType": "∀ {n : ℕ} {a b : Fin n}, Fin.succ a < Fin.succ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["IsLUB.unique",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "isLUB_sSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "CompleteSemilatticeSup.toSupSet",
   "IsLUB",
   "Eq"],
  "name": "IsLUB.sSup_eq",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, IsLUB s a → sSup s = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "supsSupHom.proof_1",
   "sSupHom.mk",
   "Prod.snd",
   "SemilatticeSup.toSup",
   "CompleteLattice",
   "sSupHom",
   "Prod.supSet",
   "Sup.sup",
   "Prod",
   "Prod.fst",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet"],
  "name": "supsSupHom",
  "constType":
  "{α : Type u_2} → [inst : CompleteLattice α] → sSupHom (α × α) α",
  "constCategory": "Definition"},
 {"references":
  ["Union",
   "Union.mk",
   "Multiset.ndunion",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Finset.mk",
   "Finset.instUnionFinset.proof_1"],
  "name": "Finset.instUnionFinset",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Union (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "Equiv.mk",
   "Equiv.trans.proof_2",
   "FunLike.coe",
   "Equiv.trans.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans",
  "constType":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → α ≃ β → β ≃ γ → α ≃ γ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "Lean.Data.AC.Expr",
   "List",
   "Bool.true",
   "Lean.Data.AC.mergeIdem",
   "Lean.Data.AC.sort",
   "Bool",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.ContextInformation.isComm",
   "Nat",
   "Lean.Data.AC.Expr.toList",
   "Lean.Data.AC.ContextInformation.isIdem",
   "instDecidableEqBool",
   "Eq",
   "ite"],
  "name": "Lean.Data.AC.norm",
  "constType":
  "{α : Sort u_1} → [info : Lean.Data.AC.ContextInformation α] → α → Lean.Data.AC.Expr → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.trans",
   "List",
   "List.Sublist",
   "List.sublist_cons"],
  "name": "List.sublist_of_cons_sublist",
  "constType":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, List.Sublist (a :: l₁) l₂ → List.Sublist l₁ l₂",
  "constCategory": "Theorem"},
 {"references": ["Function.comp", "rfl", "Eq"],
  "name": "Function.comp.assoc",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {δ : Sort u₄} (f : φ → δ) (g : β → φ) (h : α → β), (f ∘ g) ∘ h = f ∘ g ∘ h",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : SProd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Filter.sets_of_superset",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "rfl",
   "implies_congr",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "forall_congr",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "Set.inter_subset_right",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Filter.Basic._auxLemma.25",
   "Mathlib.Order.Filter.Basic._auxLemma.49",
   "Mathlib.Order.Filter.Basic._auxLemma.48",
   "Mathlib.Order.Filter.Basic._auxLemma.50",
   "And",
   "Eq.ndrec",
   "Filter.instInfFilter",
   "congr",
   "Sup.sup",
   "And.intro",
   "Set.inter_subset_left",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.42",
   "Set.instInterSet",
   "congrFun"],
  "name": "Filter.instDistribLatticeFilter.proof_1",
  "constType":
  "∀ {α : Type u_1} (x y z : Filter α) ⦃s : Set α⦄, s ∈ x ⊔ y ⊓ z → s ∈ (x ⊔ y) ⊓ (x ⊔ z)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Order.Frame.toCompleteLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteLattice.toInfSet",
   "Sup.sup",
   "CompleteDistribLattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteDistribLattice.mk",
  "constType":
  "{α : Type u_1} →\n  [toFrame : Order.Frame α] → (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteDistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Function.LeftInverse",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.preimage_subset_image_of_inverse",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {g : β → α}, Function.LeftInverse g f → ∀ (s : Set β), f ⁻¹' s ⊆ g '' s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsUpperSet",
  "constType":
  "(α : Type u_4) → [t : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Exists",
   "OfNat.ofNat",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.sub_self_add",
   "id"],
  "name": "Nat.sub_eq_zero_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n - m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_left_comm",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_left_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ (b ⊓ c) = b ⊓ (a ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["BEq.beq", "BEq", "LawfulBEq.rfl", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "beq_self_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a : α), (a == a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Eq.refl",
   "Option.casesOn",
   "Option.noConfusionType",
   "Eq",
   "Option"],
  "name": "Option.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {v1 v2 : Option α} → v1 = v2 → Option.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.nil",
   "rfl",
   "Eq"],
  "name": "List.nil_append",
  "constType": "∀ {α : Type u} (as : List α), [] ++ as = as",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.8",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Expr"],
  "name": "Lean.Data.AC.Expr.op",
  "constType": "Lean.Data.AC.Expr → Lean.Data.AC.Expr → Lean.Data.AC.Expr",
  "constCategory": "Other"},
 {"references": ["UInt32", "Char"],
  "name": "Char.val",
  "constType": "Char → UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.le_sup_right",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_6",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Filter",
   "Eq.trans",
   "Subtype",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "DirectedOn.directed_val",
   "DirectedOn",
   "Set.Nonempty.to_subtype",
   "Filter.mem_iInf_of_directed",
   "Set.instMembershipSet",
   "Order.Preimage",
   "And",
   "of_eq_true",
   "iInf",
   "iInf_subtype'",
   "CompleteLattice.toInfSet",
   "propext",
   "Filter.instPartialOrderFilter",
   "Mathlib.Order.Filter.Basic._auxLemma.46",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.17",
   "Subtype.mk",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Filter.mem_biInf_of_directed",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : β → Filter α} {s : Set β},\n  DirectedOn (f ⁻¹'o fun x x_1 ↦ x ≥ x_1) s → Set.Nonempty s → ∀ {t : Set α}, t ∈ ⨅ i ∈ s, f i ↔ ∃ i ∈ s, t ∈ f i",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.rec",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {motive : (M →+ N) → Sort u} →\n          ((toZeroHom : ZeroHom M N) →\n              (map_add' :\n                  ∀ (x y : M),\n                    ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n                motive { toZeroHom := toZeroHom, map_add' := map_add' }) →\n            (t : M →+ N) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Eq"],
  "name": "List.eq_replicate_of_mem.match_2",
  "constType":
  "∀ {α : Type u_1} (b : α) (l : List α) (motive : (a : α) → (b = a ∧ ∀ x ∈ l, x = a) → (∀ b_1 ∈ b :: l, b_1 = a) → Prop)\n  (a : α) (x : b = a ∧ ∀ x ∈ l, x = a) (H : ∀ b_1 ∈ b :: l, b_1 = a),\n  (∀ (H₂ : ∀ x ∈ l, x = b) (H : ∀ b_1 ∈ b :: l, b_1 = b), motive b (_ : b = b ∧ ∀ x ∈ l, x = b) H) → motive a x H",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.map_id",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "List.map",
   "List.attach_map_coe'",
   "List.attach",
   "Eq.trans",
   "Subtype",
   "Eq",
   "id"],
  "name": "List.attach_map_val",
  "constType":
  "∀ {α : Type u} (l : List α), List.map Subtype.val (List.attach l) = l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton_iff",
  "constType": "∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "IsCompl",
   "le_rfl",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Lattice.toSemilatticeSup",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder",
   "id",
   "sup_bot_eq",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "inf_le_inf",
   "instTransLeToLE",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "inf_sup_right",
   "Eq.ndrec",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.inf_eq_bot"],
  "name": "IsCompl.inf_left_le_of_le_sup_right",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {a b x y : α}, IsCompl x y → a ≤ b ⊔ y → a ⊓ x ≤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≤]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "OrderDual.orderTop",
   "OrderBot",
   "OrderDual.boundedOrder.proof_1",
   "BoundedOrder.toOrderTop",
   "OrderDual.instLEOrderDual",
   "OrderTop.toTop",
   "OrderDual.orderBot",
   "BoundedOrder.mk",
   "OrderDual.boundedOrder.proof_2",
   "OrderBot.toBot",
   "LE",
   "OrderTop",
   "OrderDual",
   "inferInstanceAs",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder",
  "constType":
  "(α : Type u) → [inst : LE α] → [inst_1 : BoundedOrder α] → BoundedOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["le_trans", "IsTrans", "IsTrans.mk", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "instIsTransLeToLE.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], IsTrans α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Subsingleton",
   "Quot",
   "Eq",
   "Quot.sound",
   "Subsingleton.elim",
   "Quot.mk"],
  "name": "Quot.recOnSubsingleton'.proof_1",
  "constType":
  "∀ {α : Sort u_2} {r : α → α → Prop} {motive : Quot r → Sort u_1} [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))]\n  (f : (a : α) → motive (Quot.mk r a)) (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b",
  "constCategory": "Theorem"},
 {"references": ["SDiff"],
  "name": "SDiff.sdiff",
  "constType": "{α : Type u} → [self : SDiff α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.lower._cstage1",
  "constType": "(α : Type u_1) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "iSup_range",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.biUnion_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {f : ι → α} {g : α → Set β}, ⋃ x ∈ Set.range f, g x = ⋃ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis.ge_iff",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "Eq.refl",
   "Filter.Eventually",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.Tendsto",
   "Filter",
   "Mathlib.Order.Filter.Bases._auxLemma.61",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_right_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι' : Sort u_5} {la : Filter α} {lb : Filter β} {pb : ι' → Prop} {sb : ι' → Set β}\n  {f : α → β}, Filter.HasBasis lb pb sb → (Filter.Tendsto f la lb ↔ ∀ (i : ι'), pb i → ∀ᶠ (x : α) in la, f x ∈ sb i)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "True",
   "Eq",
   "Nat.succ_pos"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.14",
  "constType": "∀ (n : ℕ), (0 < Nat.succ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Function.comp", "Monotone", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone.comp",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ] {g : β → γ}\n  {f : α → β}, Monotone g → Monotone f → Monotone (g ∘ f)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Equiv.toHomeomorphOfInducing",
   "IsLowerSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Set.sUnion",
   "Topology.WithLowerSet.ofLowerSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsLowerSet α] → Topology.WithLowerSet α ≃ₜ α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsClosed_of._closed_5",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.IsClosed_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_6"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SupSet", "sSupHom"],
  "name": "sSupHom.toFun",
  "constType":
  "{α : Type u_8} → {β : Type u_9} → [inst : SupSet α] → [inst_1 : SupSet β] → sSupHom α β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{α : Type u_1} → SupSet (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.add_right_cancel",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsRightCancelAdd G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Topology.IsUpperSet.casesOn",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.noConfusionType",
  "constType":
  "{α : Type u_4} →\n  {t : TopologicalSpace α} → {inst : Preorder α} → Sort u → Topology.IsUpperSet α → Topology.IsUpperSet α → Sort u",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "And.left",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), l (sSup (u '' s)) ∈ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.instHasSubsetSet",
   "Filter.comap.match_1",
   "setOf",
   "Set.preimage",
   "HasSubset.Subset.trans",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.comap.proof_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (m : α → β) (f : Filter β) {x y : Set α},\n  x ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s} → x ⊆ y → y ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "Lean.Data.AC.sort.loop",
   "Eq.refl",
   "Lean.Data.AC.Context.evalList_sort_congr",
   "List.casesOn",
   "Lean.Data.AC.sort",
   "True",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "Init.Data.AC._auxLemma.1",
   "eq_false'",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.evalList_sort_loop_swap",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "List.noConfusion",
   "Lean.IsCommutative.comm",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_cons",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α),\n  Lean.IsCommutative ctx.op →\n    ∀ (x : ℕ) (xs : List ℕ),\n      Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort (x :: xs)) =\n        Lean.Data.AC.evalList α ctx (x :: Lean.Data.AC.sort xs)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "∀ (n : ℕ), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "IsOpen.inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "TopologicalSpace.coinduced.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (t : TopologicalSpace α) (s₁ s₂ : Set β),\n  IsOpen (f ⁻¹' s₁) → IsOpen (f ⁻¹' s₂) → IsOpen (f ⁻¹' s₁ ∩ fun x ↦ s₂ (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Topology.WithLower.toLower",
   "Set.preimage",
   "Topology.lower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Iff.rfl",
   "Topology.WithLower",
   "Set",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.isOpen_def",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (T : Set (Topology.WithLower α)),\n  IsOpen T ↔ TopologicalSpace.IsOpen (↑Topology.WithLower.toLower ⁻¹' T)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "List.filterMap",
   "List.filterMap_eq_filter",
   "List.Sublist",
   "Eq.refl",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Bool.true",
   "Bool",
   "Eq.symm",
   "Option.guard",
   "instDecidableEqBool",
   "id",
   "Option",
   "List.Sublist.filterMap"],
  "name": "List.Sublist.filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {l₁ l₂ : List α},\n  List.Sublist l₁ l₂ → List.Sublist (List.filter p l₁) (List.filter p l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "Set.Nonempty",
   "HasSubset.Subset",
   "Exists.imp",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.mono",
  "constType":
  "∀ {α : Type u} {s t : Set α}, s ⊆ t → Set.Nonempty s → Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "HEq",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Sublist.slnil",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "HEq.refl",
   "List",
   "HAppend.hAppend",
   "List.Sublist.below.cons₂",
   "List.Sublist.cons₂",
   "List.nil",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Sublist.append_right.match_1._@.Std.Data.List.Lemmas._hyg.7596",
  "constType":
  "∀ {α : Type u_1} (motive : (l₂ l₁ : List α) → (x : List.Sublist l₁ l₂) → List α → List.Sublist.below x → Prop)\n  (l₂ l₁ : List α) (x : List.Sublist l₁ l₂) (x_1 : List α) (h_below : List.Sublist.below x),\n  (∀ (x : List α), motive [] [] (_ : List.Sublist [] []) x (_ : List.Sublist.below (_ : List.Sublist [] []))) →\n    (∀ (l₁ l₂ : List α) (a : α) (h : List.Sublist l₁ l₂) (x : List α) (h_2 : List.Sublist.below h)\n        (a_1 : ∀ (x : List α), List.Sublist (l₁ ++ x) (l₂ ++ x)),\n        motive (a :: l₂) l₁ (_ : List.Sublist l₁ (a :: l₂)) x\n          (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ (l₁ l₂ : List α) (a : α) (h : List.Sublist l₁ l₂) (x : List α) (h_3 : List.Sublist.below h)\n          (a_1 : ∀ (x : List α), List.Sublist (l₁ ++ x) (l₂ ++ x)),\n          motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂)) x\n            (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        motive l₂ l₁ x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Equiv",
   "IsLowerSet",
   "Set",
   "Preorder.toLE",
   "Eq",
   "lcProof",
   "Continuous",
   "Homeomorph",
   "TopologicalSpace",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Membership.mem",
   "OrderDual.toDual",
   "Equiv.toFun",
   "OrderDual.instPreorder",
   "Topology.WithUpperSet",
   "IsUpperSet",
   "FunLike.coe",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "Set.sUnion",
   "OrderDual.ofDual_toDual",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithUpperSet α ≃ₜ Topology.WithLowerSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView",
   "Inhabited",
   "List",
   "Lean.instInhabitedName",
   "Lean.MacroScopesView.mk",
   "instInhabitedList",
   "Lean.Name",
   "Inhabited.mk",
   "Lean.MacroScope",
   "Inhabited.default"],
  "name": "Lean.instInhabitedMacroScopesView",
  "constType": "Inhabited Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.iUnion",
   "isOpen_sUnion",
   "Set",
   "TopologicalSpace",
   "Set.forall_range_iff",
   "IsOpen",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "isOpen_iUnion",
  "constType":
  "∀ {α : Type u} {ι : Sort w} [inst : TopologicalSpace α] {f : ι → Set α}, (∀ (i : ι), IsOpen (f i)) → IsOpen (⋃ i, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "Sup.sup",
   "sup_sup_sup_comm",
   "sup_idem",
   "id",
   "Eq"],
  "name": "sup_sup_distrib_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] (a b c : α), a ⊔ (b ⊔ c) = a ⊔ b ⊔ (a ⊔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice",
   "le_iSup₂",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "le_sSup",
   "iSup",
   "SupSet.sSup",
   "sSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSup₂_le",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "sSup_eq_iSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α}, sSup s = ⨆ a ∈ s, a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "iInf",
   "Bool.false",
   "CompleteLattice.toInfSet",
   "Bool.true",
   "Inf.inf",
   "OrderDual.completeLattice",
   "OrderDual",
   "Bool",
   "Eq",
   "iSup_bool_eq"],
  "name": "iInf_bool_eq",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {f : Bool → α}, ⨅ b, f b = f true ⊓ f false",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "Bool.decEq.match_1",
  "constType":
  "(motive : Bool → Bool → Sort u_1) →\n  (a b : Bool) →\n    (Unit → motive false false) →\n      (Unit → motive false true) → (Unit → motive true false) → (Unit → motive true true) → motive a b",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Mathlib.Order.Filter.Bases._auxLemma.37",
   "Inter.inter",
   "implies_congr",
   "True",
   "iff_self",
   "Filter.principal",
   "Filter.HasBasis",
   "Iff",
   "forall_congr",
   "Filter",
   "Eq.trans",
   "instMembershipSetFilter",
   "Mathlib.Order.Filter.Bases._auxLemma.35",
   "Membership.mem",
   "funext",
   "setOf",
   "HasSubset.Subset",
   "Mathlib.Order.Filter.Bases._auxLemma.36",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "propext",
   "Filter.instInfFilter",
   "congr",
   "congrArg",
   "Filter.HasBasis.mk",
   "Set.instInterSet"],
  "name": "Filter.HasBasis.inf_principal",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ (s' : Set α), Filter.HasBasis (l ⊓ Filter.principal s') p fun i ↦ s i ∩ s'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "instAddNat",
   "Nat.sub_le",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.lt_succ_of_le",
   "instLTNat",
   "Eq",
   "Nat.sub_lt.match_1",
   "LT.lt",
   "Eq.rec",
   "Nat.lt_irrefl",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ_sub_succ_eq_sub",
   "absurd",
   "Nat.succ"],
  "name": "Nat.sub_lt",
  "constType": "∀ {n m : ℕ}, 0 < n → 0 < m → n - m < n",
  "constCategory": "Theorem"},
 {"references": ["Top", "Top.top", "Prod.mk", "Prod", "Top.mk"],
  "name": "Prod.top",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Top α] → [inst : Top β] → Top (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Iff.rfl",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.ofLower_inj",
  "constType":
  "∀ {α : Type u_1} {a b : Topology.WithLower α}, ↑Topology.WithLower.ofLower a = ↑Topology.WithLower.ofLower b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["List.attach.proof_1",
   "Membership.mem",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype"],
  "name": "List.attach",
  "constType": "{α : Type u_1} → (l : List α) → List { x // x ∈ l }",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "LE.le",
   "sdiff_le_iff'",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Iff",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "sdiff_le_iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "sdiff_le_comm",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b c : α}, a \\ b ≤ c ↔ a \\ c ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_7",
  "constType": "4 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.termΩ._closed_4", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termΩ._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_8"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "imp_congr_right",
  "constType": "∀ {a : Sort u_1} {b c : Prop}, (a → (b ↔ c)) → (a → b ↔ a → c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Inf.mk",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.match_1",
  "constType":
  "∀ {α : Type u_1} (x x_1 : Filter α) (_s : Set α) (motive : _s ∈ x ⊓ x_1 → Prop) (x_2 : _s ∈ x ⊓ x_1),\n  (∀ (_a : Set α) (ha : _a ∈ x) (_b : Set α) (hb : _b ∈ x_1) (hs : _s = _a ∩ _b),\n      motive (_ : ∃ a ∈ x, ∃ b ∈ x_1, _s = a ∩ b)) →\n    motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Set.preimage",
   "Continuous.mk",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "continuous_def",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : TopologicalSpace α} {x_1 : TopologicalSpace β} {f : α → β},\n  Continuous f ↔ ∀ (s : Set β), IsOpen s → IsOpen (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.rec",
   "Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.casesOn",
  "constType":
  "{motive : Lean.Name → Sort u} →\n  (t : Lean.Name) →\n    motive Lean.Name.anonymous →\n      ((pre : Lean.Name) → (str : String) → motive (Lean.Name.str pre str)) →\n        ((pre : Lean.Name) → (i : ℕ) → motive (Lean.Name.num pre i)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation"],
  "name": "Lean.Data.AC.EvalInformation.evalOp",
  "constType":
  "{α : Sort u} → {β : Sort v} → [self : Lean.Data.AC.EvalInformation α β] → α → β → β → β",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_4",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.pmap._eq_2",
   "List.instMembershipList",
   "List.mem_cons_of_mem",
   "Eq.refl",
   "List.forall_mem_cons",
   "And.left",
   "Eq",
   "And",
   "Eq.mpr",
   "And.right",
   "Iff.mp",
   "Eq.ndrec",
   "List.rec",
   "List",
   "List.mem_cons_self",
   "List.nil",
   "id"],
  "name": "List.pmap_congr",
  "constType":
  "∀ {α : Type u} {β : Type v} {p q : α → Prop} {f : (a : α) → p a → β} {g : (a : α) → q a → β} (l : List α)\n  {H₁ : ∀ a ∈ l, p a} {H₂ : ∀ a ∈ l, q a},\n  (∀ a ∈ l, ∀ (h₁ : p a) (h₂ : q a), f a h₁ = g a h₂) → List.pmap f l H₁ = List.pmap g l H₂",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "DecidableEq", "Finset", "Finset.val", "Multiset.toFinset"],
  "name": "Finset.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq β] → (α → β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references": ["eq_false", "False", "Eq"],
  "name": "eq_false'",
  "constType": "∀ {p : Prop}, (p → False) → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
   "PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toCompletelyDistribLattice : CompletelyDistribLattice α] →\n    (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) →\n      [toHasCompl : HasCompl α] →\n        [toSDiff : SDiff α] →\n          [toHImp : HImp α] →\n            (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n              (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                  autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ →\n                    (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) →\n                      (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteAtomicBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_2",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_3",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_4",
   "_obj",
   "Lean.Name.mkStr4",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_1"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.Perm.rec",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.symm",
  "constType": "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ~ l₂ → l₂ ~ l₁",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.countP.go",
   "Eq",
   "Eq.ndrec",
   "List",
   "instOfNatNat",
   "_private.Std.Data.List.Count.0.List.countP.go._eq_1",
   "Bool",
   "List.nil",
   "Nat",
   "Eq.symm",
   "_private.Std.Data.List.Count.0.List.findIdx.go.match_1.splitter",
   "id"],
  "name": "_private.Std.Data.List.Count.0.List.countP.go._unfold",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (x : List α) (x_1 : ℕ),\n  List.countP.go p x x_1 =\n    match x, x_1 with\n    | [], acc => acc\n    | x :: xs, acc => bif p x then List.countP.go p xs (acc + 1) else List.countP.go p xs acc",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.monotone'",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.monotone",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β), Monotone ↑f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Macro.Context",
   "Nat",
   "Lean.Name",
   "Lean.Syntax",
   "Lean.MacroScope",
   "_private.Init.Prelude.0.Lean.Macro.MethodsRef"],
  "name": "Lean.Macro.Context.mk",
  "constType":
  "Lean.Macro.MethodsRef → Lean.Name → Lean.MacroScope → ℕ → ℕ → Lean.Syntax → Lean.Macro.Context",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid.zero_add",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Classical.choose",
   "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "iSup_subtype",
   "OrderDual",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "iInf_subtype",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {p : ι → Prop} {f : Subtype p → α},\n  iInf f = ⨅ i, ⨅ (h : p i), f { val := i, property := h }",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Not", "Bool", "Eq"],
  "name": "eq_false_of_ne_true.match_1",
  "constType":
  "∀ (motive : (x : Bool) → ¬x = true → Prop) (x : Bool) (x_1 : ¬x = true),\n  (∀ (h : ¬true = true), motive true h) → (∀ (x : ¬false = true), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Subsingleton.intro", "Subsingleton", "Subsingleton.elim"],
  "name": "instSubsingletonForAll.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : α → Sort u_2} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "IsIdempotent.mk",
   "SemilatticeSup.toSup",
   "IsIdempotent",
   "Sup.sup",
   "sup_idem"],
  "name": "instIsIdempotentSupToSup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α], IsIdempotent α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB.insert",
   "isGLB_sInf",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instInsertSet"],
  "name": "sInf_insert",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a : α} {s : Set α}, sInf (insert a s) = a ⊓ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm",
   "PartialOrder.toPreorder",
   "instIsAntisymmLeToLEToPreorder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "instIsAntisymmLeToLEToPreorder",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α], IsAntisymm α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Nonempty.elim.match_1",
  "constType":
  "∀ {α : Sort u_1} (motive : Nonempty α → Prop) (h₁ : Nonempty α), (∀ (a : α), motive (_ : Nonempty α)) → motive h₁",
  "constCategory": "Definition"},
 {"references":
  ["Function.Embedding.toFun", "Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.inj'",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ↪ β), Function.Injective self.toFun",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Chain"],
  "name": "List.Chain.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references":
  ["OrderIso",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.ofUpperSet_le_iff",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithUpperSet α ≃o α",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "OrderBot.toBot",
   "GeneralizedBooleanAlgebra",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.bot_le",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (a : α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat"],
  "name": "List.countP.go",
  "constType": "{α : Type u_1} → (α → Bool) → List α → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Array", "Lean.SyntaxNodeKinds", "Lean.TSyntaxArray", "Lean.Syntax"],
  "name": "Lean.TSyntaxArray.mk",
  "constType":
  "{ks : Lean.SyntaxNodeKinds} → Array Lean.Syntax → Lean.TSyntaxArray ks",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Subtype.val",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "Subtype.eq.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (motive : (x x_1 : { x // p x }) → ↑x = ↑x_1 → Prop) (x x_1 : { x // p x })\n  (x_2 : ↑x = ↑x_1),\n  (∀ (val : α) (property property_1 : p val),\n      motive { val := val, property := property } { val := val, property := property_1 }\n        (_ : ↑{ val := val, property := (_ : p val) } = ↑{ val := val, property := (_ : p val) })) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.Subperm.trans.match_1",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ l₃ : List α} (motive : l₁ <+~ l₂ → l₂ <+~ l₃ → Prop) (x : l₁ <+~ l₂) (x_1 : l₂ <+~ l₃),\n  (∀ (s : l₁ <+~ l₂) (_l₂' : List α) (p₂ : _l₂' ~ l₂) (s₂ : List.Sublist _l₂' l₃),\n      motive s (_ : ∃ l, ∃ (_ : l ~ l₂), List.Sublist l l₃)) →\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Filter.NeBot.ne'",
   "Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "mt",
   "Eq",
   "Iff.mp",
   "Eq.rec",
   "Filter",
   "Not",
   "Set.eq_empty_or_nonempty",
   "Eq.symm",
   "absurd",
   "Or.elim",
   "id",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.nonempty_of_mem",
  "constType":
  "∀ {α : Type u} {f : Filter α} [hf : Filter.NeBot f] {s : Set α}, s ∈ f → Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "and_congr"],
  "name": "and_congr_left'",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (a ∧ c ↔ b ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "exists_and_left.match_1",
   "Exists.intro",
   "And.intro",
   "exists_and_left.match_2"],
  "name": "exists_and_left",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) ↔ b ∧ ∃ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termπ_",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Bool.false", "Bool.true", "Unit", "Bool"],
  "name": "not",
  "constType": "Bool → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Heyting.Basic._auxLemma.6",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Heyting.Basic._auxLemma.8",
   "LE.le",
   "Preorder.toLE",
   "Mathlib.Order.Heyting.Basic._auxLemma.9",
   "Eq",
   "inf_comm",
   "Lattice.toInf",
   "And",
   "HImp.himp",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "le_refl",
   "GeneralizedHeytingAlgebra.toLattice",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Heyting.Basic._auxLemma.7",
   "GeneralizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "GeneralizedHeytingAlgebra.toDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : GeneralizedHeytingAlgebra α] (a b c : α), a ⊓ (b ⊔ c) ≤ a ⊓ b ⊔ a ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "true_implies",
  "constType": "∀ (p : Prop), (True → p) = p",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "Topology.WithLowerSet",
   "OrderDual",
   "OrderDual.ofDual_toDual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithLowerSet αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "PartialOrder"],
  "name": "Prod.semilatticeSup.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] (a b : α × β),\n  a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "String.decEq", "String"],
  "name": "instDecidableEqString",
  "constType": "DecidableEq String",
  "constCategory": "Definition"},
 {"references": ["WellFounded.rec", "WellFounded", "Acc"],
  "name": "WellFounded.apply.proof_1",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop}, WellFounded r → ∀ (a : α), Acc r a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "False", "propext", "or_false.match_1", "Eq"],
  "name": "or_false",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_eq_left'", "Eq"],
  "name": "Std.Logic._auxLemma.42",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a' = a ∧ p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Equiv.mk",
   "_neutral"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "Pi.instSupForAll",
   "Pi.semilatticeSup.proof_2",
   "Pi.partialOrder",
   "Pi.semilatticeSup.proof_1",
   "SemilatticeSup.mk",
   "Pi.semilatticeSup.proof_3",
   "SemilatticeSup.toPartialOrder"],
  "name": "Pi.semilatticeSup",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → SemilatticeSup (α' i)] → SemilatticeSup ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["And", "Or", "or_and_right", "propext", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.14",
  "constType": "∀ {a b c : Prop}, ((a ∨ b) ∧ c) = (a ∧ c ∨ b ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_false",
   "False",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Std.Data.Nat.Lemmas._auxLemma.3",
  "constType": "∀ (n : ℕ), (Nat.succ n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "Sup.sup",
   "instIsCommutativeSupToSup.proof_1",
   "IsCommutative"],
  "name": "instIsCommutativeSupToSup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α], IsCommutative α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.201",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4034",
   "HMul.hMul",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3995",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.25",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∃ x, p x ∨ q x) = ((∃ x, p x) ∨ ∃ x, q x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → ({a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) → Trans r s t",
  "constCategory": "Other"},
 {"references": ["eq_self", "And", "of_eq_true", "Not", "Eq"],
  "name": "Prop.booleanAlgebra.proof_3",
  "constType": "∀ (x_1 y_1 : Prop), (x_1 ∧ ¬y_1) = (x_1 ∧ ¬y_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (a b c : αᵒᵈ), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Or.elim.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∨ b → Prop) (h : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[≥]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "propext", "exists_const", "Nonempty", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.26",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∃ x, b) = b",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.50",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.iUnion",
   "isUpperSet_sUnion",
   "Set",
   "LE",
   "Set.forall_range_iff",
   "IsUpperSet",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "isUpperSet_iUnion",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} [inst : LE α] {f : ι → Set α}, (∀ (i : ι), IsUpperSet (f i)) → IsUpperSet (⋃ i, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "LE",
   "IsUpperSet",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "id"],
  "name": "isUpperSet_univ",
  "constType": "∀ {α : Type u_1} [inst : LE α], IsUpperSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "Set.preimage",
   "Set",
   "Monotone",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "IsLowerSet.preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {s : Set α},\n  IsLowerSet s → ∀ {f : β → α}, Monotone f → IsLowerSet (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadState", "PUnit", "Prod"],
  "name": "MonadState.mk",
  "constType":
  "{σ : outParam (Type u)} →\n  {m : Type u → Type v} → m σ → (σ → m PUnit.{u + 1}) → ({α : Type u} → (σ → α × σ) → m α) → MonadState σ m",
  "constCategory": "Other"},
 {"references": ["False", "Decidable", "if_neg", "ite", "Eq", "id"],
  "name": "if_false",
  "constType":
  "∀ {α : Sort u_1} {h : Decidable False} (t e : α), (if False then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "or_assoc",
   "Eq.symm",
   "or_comm",
   "Eq",
   "id"],
  "name": "or_left_comm",
  "constType": "∀ {a b c : Prop}, a ∨ b ∨ c ↔ b ∨ a ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termΩ._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.liftOn₂",
   "DecidableEq",
   "List",
   "Multiset.ndunion.proof_1",
   "List.isSetoid",
   "Multiset",
   "Multiset.ofList",
   "List.union"],
  "name": "Multiset.ndunion",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "congrFun",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeInf α]\n  (gi : GaloisInsertion l u) (a b : β), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsLeftCancelAdd.add_left_cancel",
   "Add",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_left_cancel",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references": ["Monad", "Applicative", "Bind"],
  "name": "Monad.mk",
  "constType":
  "{m : Type u → Type v} → [toApplicative : Applicative m] → [toBind : Bind m] → Monad m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.instPureFilter",
   "propext",
   "Set",
   "Filter.mem_pure",
   "Filter",
   "Pure.pure",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.130",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, (s ∈ pure a) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "List.Perm.length_eq",
   "OfNat.ofNat",
   "Quotient.inductionOn₂",
   "List.length_append",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "rfl",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Zero.toOfNat0",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat"],
  "name": "Multiset.card.proof_2",
  "constType":
  "∀ {α : Type u_1} (s t : Multiset α),\n  ZeroHom.toFun\n      {\n        toFun := fun s ↦\n          Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n        map_zero' :=\n          (_ :\n            (fun s ↦\n                  Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                0 =\n              (fun s ↦\n                  Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                0) }\n      (s + t) =\n    ZeroHom.toFun\n        {\n          toFun := fun s ↦\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s ↦\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s ↦\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        s +\n      ZeroHom.toFun\n        {\n          toFun := fun s ↦\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s ↦\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s ↦\n                    Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        t",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set.Elem",
   "Bool.true",
   "Set",
   "Exists.intro",
   "Bool",
   "Exists.casesOn",
   "Eq"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.match_2",
  "constType":
  "∀ {α : Type u_1} (s : Set α) (f : ↑s → Bool) (motive : (∃ i, f i = true) → Prop) (x : ∃ i, f i = true),\n  (∀ (i : ↑s) (h : f i = true), motive (_ : ∃ i, f i = true)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → SemilatticeInf (α' i)] (x x_1 : (i : ι) → α' i) (x_2 : ι),\n  x x_2 ⊓ x_1 x_2 ≤ x x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Or",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Mathlib.Data.Set.Image._auxLemma.8",
   "Mathlib.Data.Set.Image._auxLemma.11",
   "Insert.insert",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.32",
   "Mathlib.Data.Set.Image._auxLemma.9",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.42",
   "Mathlib.Data.Set.Image._auxLemma.4",
   "congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Set.instInsertSet"],
  "name": "Set.image_insert_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α} {s : Set α}, f '' insert a s = insert (f a) (f '' s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTrans",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.iInf_sup_le_sup_sInf",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["le_bot_iff",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "DistribLattice",
   "Iff",
   "bot_sup_eq",
   "propext",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot",
   "id",
   "BoundedOrder"],
  "name": "IsCompl.inf_left_eq_bot_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y z : α}, IsCompl y z → (x ⊓ y = ⊥ ↔ x ≤ z)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Lattice.toSemilatticeSup",
   "sup_eq_right",
   "Set.instUnionSet",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.union_eq_right",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∪ t = t ↔ s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithUpperSet.instPreorderWithUpperSet._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Filter.filter_eq",
   "funext",
   "Set",
   "Filter.map",
   "Function.comp",
   "Filter",
   "rfl",
   "Eq"],
  "name": "Filter.map_compose",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {m : α → β} {m' : β → γ}, Filter.map m' ∘ Filter.map m = Filter.map (m' ∘ m)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.rec",
  "constType":
  "{α : Type u_1} →\n  {β : Topology.WithLowerSet α → Sort u_4} →\n    ((a : α) → β (↑Topology.WithLowerSet.toLowerSet a)) → (a : Topology.WithLowerSet α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "Function.Involutive.leftInverse",
   "Function.LeftInverse.injective",
   "Function.Involutive"],
  "name": "Function.Involutive.injective",
  "constType":
  "∀ {α : Sort u} {f : α → α}, Function.Involutive f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.univ",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.sUnion_eq",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)}, TopologicalSpace.IsTopologicalBasis s → ⋃₀ s = Set.univ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "isOpen_univ",
   "Iff.mpr",
   "Set.sUnion_eq_univ_iff",
   "Preorder.toLE",
   "Eq",
   "trivial",
   "Filter.principal",
   "TopologicalSpace.nhds_generateFrom",
   "Eq.mpr",
   "TopologicalSpace.IsTopologicalBasis.mk",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "le_generateFrom",
   "Filter",
   "And.casesOn",
   "IsOpen",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "HasSubset.Subset",
   "Set.univ",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Set.instMembershipSet",
   "LE.le.antisymm",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Filter.le_principal_iff",
   "iInf",
   "isOpen_iff_nhds",
   "Filter.instPartialOrderFilter",
   "Set.sUnion",
   "And.intro",
   "iInf₂_le_of_le",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isTopologicalBasis_of_open_of_nhds",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ u ∈ s, IsOpen u) →\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v ∈ s, a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Setoid.r",
   "List",
   "List.Nodup.map_on",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.Nodup.map_on",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Multiset α} {f : α → β},\n  (∀ x ∈ s, ∀ y ∈ s, f x = f y → x = y) → Multiset.Nodup s → Multiset.Nodup (Multiset.map f s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.forall_mem_cons",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.101",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ x ∈ a :: l, p x) = (p a ∧ ∀ x ∈ l, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "inferInstance",
   "Set.Elem",
   "Fintype.ofFinite",
   "Classical.propDecidable",
   "PLift",
   "Finite",
   "Set.fintypeRange",
   "instFinitePLift",
   "Finite.of_fintype",
   "Eq"],
  "name": "Finite.Set.finite_range.proof_1",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_2} (f : ι → α) [inst : Finite ι], Finite ↑(Set.range f)",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Eq.refl", "Bool", "Eq"],
  "name": "Nat.decEq.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (x = true → motive true) → (x = false → motive false) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.mk",
   "Membership.mem",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Set",
   "Function.comp",
   "Topology.WithUpperSet.map._elambda_1",
   "OrderHom",
   "FunLike.coe",
   "IsUpperSet",
   "ContinuousMap",
   "Preorder",
   "Set.univ",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Equiv.instFunLikeEquiv",
   "ContinuousMap.mk",
   "Set.instMembershipSet",
   "lcProof",
   "Continuous",
   "TopologicalSpace",
   "Set.sUnion",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithUpperSet.map._cstage1",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → C(Topology.WithUpperSet α, Topology.WithUpperSet β)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Function.Injective",
   "Function.Embedding.casesOn",
   "Function.Embedding.toFun",
   "Function.Embedding.mk",
   "Eq.rec",
   "Eq.refl",
   "Function.Embedding",
   "Eq.symm",
   "Eq"],
  "name": "Function.instEmbeddingLikeEmbedding.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f g : α ↪ β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._lambda_1._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Lean.Data.AC.EvalInformation",
   "Unit",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "List.nil",
   "Lean.Data.AC.EvalInformation.arbitrary",
   "Nat",
   "Lean.Data.AC.evalList.match_1",
   "Lean.Data.AC.EvalInformation.evalOp"],
  "name": "Lean.Data.AC.evalList",
  "constType":
  "{α : Sort u_1} → (β : Sort u) → [inst : Lean.Data.AC.EvalInformation α β] → α → List ℕ → β",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "IsLowerSet",
   "Set",
   "Eq.refl",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "Preorder",
   "Topology.IsLowerSet",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.IsLower",
   "propext",
   "Topology.IsLowerSet.isOpen_iff_isLowerSet",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsLowerSet.lowerSet_le_lower",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {t₁ t₂ : TopologicalSpace α} [inst_1 : Topology.IsLowerSet α]\n  [inst : Topology.IsLower α], t₁ ≤ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.ofUpper_toUpper",
  "constType":
  "∀ {α : Type u_1} (a : α), ↑Topology.WithUpper.ofUpper (↑Topology.WithUpper.toUpper a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Iff",
   "Continuous",
   "TopologicalSpace",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.coinduced",
   "continuous_def"],
  "name": "continuous_iff_coinduced_le",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t₁ : TopologicalSpace α} {t₂ : TopologicalSpace β},\n  Continuous f ↔ TopologicalSpace.coinduced f t₁ ≤ t₂",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Not", "Or.casesOn"],
  "name": "Classical.propDecidable.match_1",
  "constType":
  "∀ (a : Prop) (motive : a ∨ ¬a → Prop) (x : a ∨ ¬a),\n  (∀ (h : a), motive (_ : a ∨ ¬a)) → (∀ (h : ¬a), motive (_ : a ∨ ¬a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["OrderTop.toTop", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderTop α] (a : α), a ≤ ⊤",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.mk",
  "constType": "{α : Type u} → α → EmptyCollection α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Lean.Name.rec",
   "Lean.Name.below",
   "Lean.Name.num",
   "String",
   "PUnit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "PProd.mk",
   "Lean.Name.str"],
  "name": "Lean.Name.brecOn",
  "constType":
  "{motive : Lean.Name → Sort u} → (t : Lean.Name) → ((t : Lean.Name) → Lean.Name.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "List.cons",
   "List.chain_cons",
   "propext",
   "List",
   "List.Chain",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, List.Chain R a (b :: l) = (R a b ∧ List.Chain R b l)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.nil",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Add.mk",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3",
  "constType": "∀ {α : Type u_1} (s : Multiset α), s + 0 = s",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.orderTop.proof_1",
   "OrderTop.mk",
   "OrderTop.toTop",
   "Top",
   "Top.top",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Pi.instTopForAll",
   "Pi.hasLe",
   "Top.mk"],
  "name": "Pi.orderTop",
  "constType":
  "{ι : Type u_3} →\n  {α' : ι → Type u_4} → [inst : (i : ι) → LE (α' i)] → [inst_1 : (i : ι) → OrderTop (α' i)] → OrderTop ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "Multiset.induction",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "Multiset.instZeroMultiset",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "Multiset.Nodup",
   "Multiset.instMembershipMultiset",
   "Finset.eq_of_veq",
   "Eq",
   "Zero.toOfNat0",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "Finset.cons_induction.match_1",
   "Finset.cons_val",
   "Finset",
   "Multiset",
   "Finset.val",
   "Finset.cons",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Not",
   "And.intro",
   "Finset.mk",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Finset.cons_induction",
  "constType":
  "∀ {α : Type u_4} {p : Finset α → Prop},\n  p ∅ → (∀ ⦃a : α⦄ {s : Finset α} (h : ¬a ∈ s), p s → p (Finset.cons a s h)) → ∀ (s : Finset α), p s",
  "constCategory": "Theorem"},
 {"references": ["Decidable.byCases.match_1", "Decidable", "Not"],
  "name": "Decidable.byCases",
  "constType":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "GaloisConnection.u_inf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "gc_nhds",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Lattice.toSemilatticeInf",
   "nhds",
   "Inf.inf",
   "Filter.instInfFilter",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "nhdsAdjoint",
   "Filter",
   "Eq",
   "Filter.instCompleteLatticeFilter"],
  "name": "nhds_inf",
  "constType":
  "∀ {α : Type u} {t₁ t₂ : TopologicalSpace α} {a : α}, nhds a = nhds a ⊓ nhds a",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "List.nil", "Bool", "Nat", "List.countP.go", "Eq"],
  "name": "_private.Std.Data.List.Count.0.List.countP.go._eq_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (x : ℕ), List.countP.go p [] x = x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "OrderTop",
   "GeneralizedHeytingAlgebra.le_top",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "GeneralizedHeytingAlgebra.toOrderTop",
  "constType":
  "{α : Type u_2} → [inst : GeneralizedHeytingAlgebra α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "And",
   "Iff",
   "SemilatticeSup.toSup",
   "Iff.rfl",
   "Set",
   "Sup.sup",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_sup",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ f ⊔ g ↔ s ∈ f ∧ s ∈ g",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSet_ofUpperSet",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithUpperSet α),\n  ↑Topology.WithUpperSet.toUpperSet (↑Topology.WithUpperSet.ofUpperSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "FunLike",
   "EquivLike.toEmbeddingLike",
   "Equiv.instEquivLikeEquiv"],
  "name": "Equiv.instFunLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α fun x ↦ β",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.le_total",
  "constType": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Iff",
   "Iff.rfl",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_upperBounds",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, a ∈ upperBounds s ↔ ∀ x ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[≤]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MonadLiftT",
  "constType":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "constCategory": "Other"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc.mk", "Quot.ind", "Trunc"],
  "name": "Trunc.ind",
  "constType":
  "∀ {α : Sort u_1} {β : Trunc α → Prop}, (∀ (a : α), β (Trunc.mk a)) → ∀ (q : Trunc α), β q",
  "constCategory": "Theorem"},
 {"references": ["SProd", "SProd.mk", "Filter.prod", "Prod", "Filter"],
  "name": "Filter.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Filter α) (Filter β) (Filter (α × β))",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper.instPreorderWithUpper._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instPreorderWithUpper._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["AddCancelCommMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelCommMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [inst : Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references": ["Decidable.decide", "BEq", "DecidableEq", "BEq.mk", "Eq"],
  "name": "instBEq",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → BEq α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.sort.loop",
   "Lean.Data.AC.Context.evalList_sort_congr",
   "List.casesOn",
   "Eq.refl",
   "True",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "Init.Data.AC._auxLemma.1",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "List.cons",
   "False",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_loop_swap",
  "constType":
  "∀ {α : Sort u_1} {y : ℕ} (ctx : Lean.Data.AC.Context α),\n  Lean.IsCommutative ctx.op →\n    ∀ (xs ys : List ℕ),\n      Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort.loop xs (y :: ys)) =\n        Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort.loop (y :: xs) ys)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And", "iff_false_intro", "False", "Iff", "Not", "and_not_self"],
  "name": "and_not_self_iff",
  "constType": "∀ (a : Prop), a ∧ ¬a ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "em",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Set.eq_univ_iff_forall",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "Set.instUnionSet",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.union_compl_self",
  "constType": "∀ {α : Type u} (s : Set α), s ∪ sᶜ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "IsCompl.disjoint_left_iff",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.disjoint_right_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y z : α}, IsCompl y z → (Disjoint x z ↔ x ≤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.casesOn",
   "Eq.ndrec",
   "Topology.upper",
   "Topology.IsUpper.noConfusionType",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.noConfusion",
  "constType":
  "{α : Type u_1} →\n  {t : TopologicalSpace α} →\n    {inst : Preorder α} →\n      {P : Sort u} → {v1 v2 : Topology.IsUpper α} → v1 = v2 → Topology.IsUpper.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "Nat.zero",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.modCore_eq_mod.match_1",
  "constType":
  "∀ (y : ℕ) (motive : 0 < y ∧ y ≤ Nat.zero → Prop) (x : 0 < y ∧ y ≤ Nat.zero),\n  (∀ (hlt : 0 < y) (hle : y ≤ Nat.zero), motive (_ : 0 < y ∧ y ≤ Nat.zero)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Lean.Name._impl", "String", "UInt64", "Lean.Name"],
  "name": "Lean.Name.str._impl",
  "constType": "UInt64 → Lean.Name → String → Lean.Name._impl",
  "constCategory": "Other"},
 {"references": ["Or", "propext", "or_left_comm", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.3",
  "constType": "∀ {a b c : Prop}, (a ∨ b ∨ c) = (b ∨ a ∨ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeSup.le_sup_right",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_2",
  "constType": "∀ (α : Type u_1) [inst : Lattice α] (a b : αᵒᵈ), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.forall_mem_cons",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.14",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ x ∈ a :: l, p x) = (p a ∧ ∀ x ∈ l, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8577",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "Top.top",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "autoParam",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Top",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Sup.sup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "HImp",
   "SemilatticeSup.toPartialOrder"],
  "name": "BooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toDistribLattice : DistribLattice α] →\n    [toHasCompl : HasCompl α] →\n      [toSDiff : SDiff α] →\n        [toHImp : HImp α] →\n          [toTop : Top α] →\n            [toBot : Bot α] →\n              (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n                (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                  (∀ (a : α), a ≤ ⊤) →\n                    (∀ (a : α), ⊥ ≤ a) →\n                      autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                        autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ → BooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.isOpen_univ", "TopologicalSpace", "Set.univ", "IsOpen"],
  "name": "isOpen_univ",
  "constType": "∀ {α : Type u} [inst : TopologicalSpace α], IsOpen Set.univ",
  "constCategory": "Theorem"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.casesOn", "UInt32.size", "Fin"],
  "name": "UInt32.decEq.match_1",
  "constType":
  "(motive : UInt32 → UInt32 → Sort u_1) →\n  (a b : UInt32) → ((n m : Fin UInt32.size) → motive { val := n } { val := m }) → motive a b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Eq.mpr", "propext", "Eq.mp", "Eq"],
  "name": "implies_dep_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ : Prop}, p₁ = p₂ → ∀ {q₂ : p₂ → Prop}, (∀ (h : p₂), q₁ = q₂ h) → (p₁ → q₁) = ∀ (h : p₂), q₂ h",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisConnection.dual",
   "GaloisCoinsertion",
   "Function.comp",
   "OrderDual",
   "GaloisCoinsertion.gc",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisCoinsertion.dual.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisCoinsertion l u →\n    GaloisConnection (↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Function.comp",
   "CompleteLattice.toBot",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_7",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (x : αᵒᵈᵒᵈ), ⊥ ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "Set.iUnion",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "InfSet",
   "UpperSet.instInfSetUpperSet.proof_1",
   "LE",
   "UpperSet.mk",
   "UpperSet",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "UpperSet.instInfSetUpperSet",
  "constType": "{α : Type u_1} → [inst : LE α] → InfSet (UpperSet α)",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String"],
  "name": "String.rec",
  "constType":
  "{motive : String → Sort u} → ((data : List Char) → motive { data := data }) → (t : String) → motive t",
  "constCategory": "Other"},
 {"references": ["Setoid.r", "Setoid", "HasEquiv", "HasEquiv.mk"],
  "name": "instHasEquiv",
  "constType": "{α : Sort u} → [inst : Setoid α] → HasEquiv α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Option.some.injEq",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.Mem.tail",
   "dite",
   "Eq",
   "PProd",
   "List.find?",
   "Bool.of_not_eq_true",
   "PProd.fst",
   "List.rec",
   "Bool.false",
   "List",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "Eq.mp",
   "List.find?_some.match_1",
   "List.Mem.head",
   "Not",
   "Option.some",
   "List.erase.match_1",
   "Bool",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option",
   "instDecidableEqBool"],
  "name": "List.mem_of_find?_eq_some",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {a : α} {l : List α}, List.find? p l = some a → a ∈ l",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.toUpper._cstage1",
  "constType": "{α : Type u_1} → α ≃ Topology.WithUpper α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "List.Nodup.getEquivOfForallMemList.proof_2",
   "Membership.mem",
   "List.Nodup",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Equiv.mk",
   "instBEq",
   "List.indexOf",
   "List.get",
   "List.length",
   "List.Nodup.getEquivOfForallMemList.proof_3",
   "List.Nodup.getEquivOfForallMemList.proof_1",
   "Fin.mk",
   "Fin"],
  "name": "List.Nodup.getEquivOfForallMemList",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → List.Nodup l → (∀ (x : α), x ∈ l) → Fin (List.length l) ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.pairwise_pmap",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "List.Pairwise.imp_of_mem",
   "Iff.mpr"],
  "name": "List.Pairwise.pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → α → Prop} {l : List α},\n  List.Pairwise R l →\n    ∀ {p : α → Prop} {f : (a : α) → p a → β} (h : ∀ x ∈ l, p x) {S : β → β → Prop},\n      (∀ ⦃x : α⦄ (hx : p x) ⦃y : α⦄ (hy : p y), R x y → S (f x hx) (f y hy)) → List.Pairwise S (List.pmap f l h)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.cons",
   "Exists.intro",
   "List.length",
   "Exists.casesOn",
   "instLTFin",
   "Eq",
   "List.Pairwise",
   "And",
   "List",
   "LT.lt",
   "List.nil",
   "List.map",
   "And.intro",
   "List.get",
   "And.casesOn",
   "Fin"],
  "name": "List.pairwise_iff_get.match_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} {a b : α}\n  (motive : (∃ is, [a, b] = List.map (List.get l) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is) → Prop)\n  (x : ∃ is, [a, b] = List.map (List.get l) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is),\n  (∀ (is : List (Fin (List.length l))) (h' : [a, b] = List.map (List.get l) is)\n      (hij : List.Pairwise (fun x x_1 ↦ x < x_1) is),\n      motive (_ : ∃ is, [a, b] = List.map (List.get l) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is)) →\n    motive x",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse", "Function.Involutive"],
  "name": "Function.Involutive.leftInverse",
  "constType":
  "∀ {α : Sort u} {f : α → α}, Function.Involutive f → Function.LeftInverse f f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Variable",
   "Lean.Data.AC.Variable.value",
   "Lean.IsNeutral",
   "Option"],
  "name": "Lean.Data.AC.Variable.neutral",
  "constType":
  "{α : Sort u} → {op : α → α → α} → (self : Lean.Data.AC.Variable op) → Option (Lean.IsNeutral op self.value)",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "Equiv",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Function.comp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "GaloisConnection.dual",
   "GaloisConnection.l_sup",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "SemilatticeInf"],
  "name": "GaloisConnection.u_inf",
  "constType":
  "∀ {α : Type u} {β : Type v} {b₁ b₂ : β} [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] {l : α → β} {u : β → α},\n  GaloisConnection l u → u (b₁ ⊓ b₂) = u b₁ ⊓ u b₂",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Set.Iic",
   "Preorder",
   "IsGLB.lowerBounds_eq",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "lowerBounds",
   "id"],
  "name": "le_isGLB_iff",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a b : α}, IsGLB s a → (b ≤ a ↔ b ∈ lowerBounds s)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_6",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b c : α × β), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.Subset.antisymm",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_1",
  "constType":
  "∀ (α : Type u_1), ∀ g ≤ ↑OrderDual.toDual {s | IsOpen s}, {u | TopologicalSpace.GenerateOpen g u} = g",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Iff", "False", "Not", "exists_imp"],
  "name": "not_exists",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) ↔ ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "Iff",
   "isGLB_sInf",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "le_isGLB_iff",
   "Set.instMembershipSet"],
  "name": "le_sInf_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ≤ sInf s ↔ ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Iff.rfl",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSet_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  ↑Topology.WithUpperSet.toUpperSet a ≤ ↑Topology.WithUpperSet.toUpperSet b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "Set", "TopologicalSpace"],
  "name": "IsOpen",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "LT.lt", "Not", "LT.mk", "Preorder"],
  "name": "Pi.preorder.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → Preorder (α i)] (a b : (i : ι) → α i), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "HMod.hMod",
   "instOfNatNat",
   "Nat.mod_lt",
   "Nat.zero_lt_succ",
   "Nat",
   "instLTNat"],
  "name": "Fin.ofNat.proof_1",
  "constType": "∀ {n : ℕ} (a : ℕ), a % (n + 1) < n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«term𝓝[_]_»._closed_1",
   "Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[_]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "isUpperSet_sUnion",
   "Set",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Topology.upperSet.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] (x : Set (Set α)), (∀ s ∈ x, IsUpperSet s) → IsUpperSet (⋃₀ x)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn", "Eq"],
  "name": "Function.Surjective.forall.match_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} (y : β) (motive : (∃ a, f a = y) → Prop) (x : ∃ a, f a = y),\n  (∀ (x : α) (hx : f x = y), motive (_ : ∃ a, f a = y)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Definition"},
 {"references": ["propext", "Subtype.forall", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop},\n  (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_4",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "OrderDual.orderTop",
   "Top.top",
   "OrderTop.le_top",
   "OrderTop",
   "inferInstanceAs",
   "OrderDual",
   "LE",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : LE α] [inst_1 : BoundedOrder α] (a : αᵒᵈ), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat", "List", "List.findIdx.go", "instOfNatNat", "Bool", "Nat"],
  "name": "List.findIdx",
  "constType": "{α : Type u_1} → (α → Bool) → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List.eq_replicate_of_mem",
   "List.length_replicate",
   "List.length",
   "Eq",
   "Iff.intro",
   "And",
   "Iff",
   "List",
   "Eq.rec",
   "List.replicate",
   "List.eq_of_mem_replicate",
   "List.eq_replicate.match_1",
   "And.intro",
   "Nat",
   "Eq.symm"],
  "name": "List.eq_replicate",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} {l : List α}, l = List.replicate n a ↔ List.length l = n ∧ ∀ b ∈ l, b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "MonadState",
  "constType": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Array.mkArray0",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node6",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "ReaderT",
   "Lean.Macro.State",
   "Lean.Macro.Exception"],
  "name": "Lean.MacroM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.Expr",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.GenerateOpen.rec",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.recOn",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {motive : (a : Set α) → TopologicalSpace.GenerateOpen g a → Prop} {a : Set α}\n  (t : TopologicalSpace.GenerateOpen g a),\n  (∀ (s : Set α) (a : s ∈ g), motive s (_ : TopologicalSpace.GenerateOpen g s)) →\n    motive Set.univ (_ : TopologicalSpace.GenerateOpen g Set.univ) →\n      (∀ (s t : Set α) (a : TopologicalSpace.GenerateOpen g s) (a_1 : TopologicalSpace.GenerateOpen g t),\n          motive s a → motive t a_1 → motive (s ∩ t) (_ : TopologicalSpace.GenerateOpen g (s ∩ t))) →\n        (∀ (S : Set (Set α)) (a : ∀ s ∈ S, TopologicalSpace.GenerateOpen g s),\n            (∀ (s : Set α) (a_1 : s ∈ S), motive s (_ : TopologicalSpace.GenerateOpen g s)) →\n              motive (⋃₀ S) (_ : TopologicalSpace.GenerateOpen g (⋃₀ S))) →\n          motive a t",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.State", "List", "String", "Prod", "Lean.Name"],
  "name": "Lean.Macro.State.traceMsgs",
  "constType": "Lean.Macro.State → List (Lean.Name × String)",
  "constCategory": "Definition"},
 {"references": ["Iff", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Set.Finite.intro",
   "Set.finite_def.match_2",
   "Nonempty.intro",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Set.finite_def.match_1",
   "Nonempty",
   "Set.Finite"],
  "name": "Set.finite_def",
  "constType":
  "∀ {α : Type u} {s : Set α}, Set.Finite s ↔ Nonempty (Fintype ↑s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Disjoint.le_compl_right",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE",
   "disjoint_compl_right"],
  "name": "le_compl_compl",
  "constType": "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, a ≤ aᶜᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.mem_empty_iff_false",
   "False",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Set.instEmptyCollectionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.8",
  "constType": "∀ {α : Type u} (x : α), (x ∈ ∅) = False",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_1",
  "constType":
  "∀ (α : Type u_1) (motive : (∃ n, Nonempty (α ≃ Fin n)) → Prop) (x : ∃ n, Nonempty (α ≃ Fin n)),\n  (∀ (_k : ℕ) (e : α ≃ Fin _k), motive (_ : ∃ n, Nonempty (α ≃ Fin n))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.le.dest.match_2",
   "Exists",
   "Nat.add_comm",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Exists.intro",
   "LE.le",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.zero",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "Nat.succ"],
  "name": "Nat.le.dest",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Iff", "Classical.propDecidable", "Not", "Decidable.not_forall"],
  "name": "Classical.not_forall",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Exception"],
  "name": "Lean.Macro.Exception.unsupportedSyntax",
  "constType": "Lean.Macro.Exception",
  "constCategory": "Other"},
 {"references": ["Topology.WithUpper", "Inhabited"],
  "name": "Topology.WithUpper.instInhabitedWithUpper",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Disjoint",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : OrderBot α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "And.comm", "Eq"],
  "name": "Mathlib.Order.Directed._auxLemma.1",
  "constType": "∀ {a b : Prop}, (a ∧ b) = (b ∧ a)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "List.drop",
   "List.length",
   "LE.le",
   "True",
   "Nat.sub_eq_zero_of_le",
   "Eq",
   "instHAppend",
   "instLENat",
   "List.instAppendList",
   "of_eq_true",
   "List.drop_append_eq_append_drop",
   "List",
   "HAppend.hAppend",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.drop_append_of_le_length",
  "constType":
  "∀ {α : Type u_1} {n : ℕ} {l₁ l₂ : List α}, n ≤ List.length l₁ → List.drop n (l₁ ++ l₂) = List.drop n l₁ ++ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "And.casesOn",
   "Preorder.lt_iff_le_not_le"],
  "name": "Prod.instPartialOrder.match_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (x x_1 : α × β),\n  let src := inferInstanceAs (Preorder (α × β));\n  ∀ (motive : x ≤ x_1 → Prop) (x_2 : x ≤ x_1),\n    (∀ (hac : x.1 ≤ x_1.1) (hbd : x.2 ≤ x_1.2), motive (_ : x.1 ≤ x_1.1 ∧ x.2 ≤ x_1.2)) → motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_6",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_7"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["False", "Function.comp", "Decidable", "Not", "Decidable.byContradiction"],
  "name": "Decidable.not_imp_symm",
  "constType": "∀ {a b : Prop} [inst : Decidable a], (¬a → b) → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "TopologicalSpace.generateFrom",
   "setOf",
   "Set",
   "TopologicalSpace",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Iic",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq"],
  "name": "Topology.upper",
  "constType": "(α : Type u_1) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": ["InfTopHomClass", "Top", "outParam", "Inf", "InfHomClass"],
  "name": "InfTopHomClass.toInfHomClass",
  "constType":
  "{F : Type u_7} →\n  {α : outParam (Type u_8)} →\n    {β : outParam (Type u_9)} →\n      [inst : Inf α] →\n        [inst_1 : Inf β] → [inst_2 : Top α] → [inst_3 : Top β] → [self : InfTopHomClass F α β] → InfHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_6",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "lcProof",
  "constType": "∀ {α : Prop}, α",
  "constCategory": "Axiom"},
 {"references": [],
  "name": "AddRightCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.65",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u_1} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.symm",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.subset_empty_iff",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasSubset.Subset",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_empty_iff_forall_not_mem",
  "constType": "∀ {α : Type u} {s : Set α}, s = ∅ ↔ ∀ (x : α), ¬x ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "GaloisInsertion.le_l_u",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "GaloisConnection.monotone_l",
   "LE.le.trans",
   "Sup.sup",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeSup α],\n  GaloisInsertion l u → ∀ (a x : β), a ≤ l (u a ⊔ u x)",
  "constCategory": "Theorem"},
 {"references":
  ["MonadLiftT.mk",
   "MonadLift",
   "MonadLiftT",
   "MonadLiftT.monadLift",
   "MonadLift.monadLift"],
  "name": "instMonadLiftT",
  "constType":
  "(m : Type u_1 → Type u_2) →\n  (n : Type u_1 → Type u_3) →\n    (o : Type u_1 → Type u_4) → [inst : MonadLift n o] → [inst : MonadLiftT m n] → MonadLiftT m o",
  "constCategory": "Definition"},
 {"references": ["Exists", "Not", "Exists.intro", "Exists.casesOn"],
  "name": "not_forall_of_exists_not.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ x, ¬p x) → (∀ (x : α), p x) → Prop) (x : ∃ x, ¬p x) (x_1 : ∀ (x : α), p x),\n  (∀ (x : α) (hn : ¬p x) (h : ∀ (x : α), p x), motive (_ : ∃ x, ¬p x) h) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.sort.loop",
   "instDecidableEqList",
   "Lean.Data.AC.insert_nonEmpty",
   "List.casesOn",
   "Eq.refl",
   "eq_true_of_decide",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "List.rec",
   "Lean.Data.AC.Context",
   "instDecidableNot",
   "Bool.true",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "absurd",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "eq_self",
   "Ne",
   "List.cons",
   "Lean.Data.AC.insert",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.evalList_insert",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Lean.IsCommutative",
   "Lean.Data.AC.EvalInformation.evalVar",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_sort_congr",
  "constType":
  "∀ {α : Sort u_1} {a b c : List ℕ} (ctx : Lean.Data.AC.Context α),\n  Lean.IsCommutative ctx.op →\n    Lean.Data.AC.evalList α ctx a = Lean.Data.AC.evalList α ctx b →\n      a ≠ [] →\n        b ≠ [] →\n          Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort.loop a c) =\n            Lean.Data.AC.evalList α ctx (Lean.Data.AC.sort.loop b c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Homeomorph._hyg.46",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "Iff",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "OrderDual.instIsLowerSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.isUpperSet_orderDual",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α], Topology.IsUpperSet αᵒᵈ ↔ Topology.IsLowerSet α",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Function.LeftInverse", "Function.RightInverse", "Equiv.mk"],
  "name": "Equiv.rec",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : α ≃ β → Sort u} →\n      ((toFun : α → β) →\n          (invFun : β → α) →\n            (left_inv : Function.LeftInverse invFun toFun) →\n              (right_inv : Function.RightInverse invFun toFun) →\n                motive { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) →\n        (t : α ≃ β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Nat.sub_add_cancel",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.add_sub_cancel'",
  "constType": "∀ {n m : ℕ}, m ≤ n → m + (n - m) = n",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_filter.match_1",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "or_congr_left",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.14",
   "dite",
   "List.filter_cons_of_pos",
   "List.mem_filter.match_2",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "or_iff_right",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "Bool.true",
   "List.nil",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Membership.mem",
   "eq_self",
   "and_iff_left_of_imp",
   "List.filter",
   "List.cons",
   "Or",
   "False",
   "List.filter_cons_of_neg",
   "eq_false_of_decide",
   "Iff.symm",
   "And",
   "of_eq_true",
   "Bool.false",
   "List",
   "propext",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.mem_filter",
  "constType":
  "∀ {α : Type u_1} {x : α} {p : α → Bool} {as : List α}, x ∈ List.filter p as ↔ x ∈ as ∧ p x = true",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.ok",
  "constType": "{ε σ α : Type u} → α → σ → EStateM.Result ε σ α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.18",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Set.fintypeEmpty.proof_1",
  "constType": "∀ {α : Type u_1} (a : α), a ∈ ∅ ↔ a ∈ ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.closure_of._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.closure_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_4",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_6",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_3",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["forall_apply_eq_imp_iff", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.55",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : β → Prop}, (∀ (b : β) (a : α), f a = b → p b) = ∀ (a : α), p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Fintype.Basic._auxLemma.23",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Set.toFinset",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "Fintype",
   "Iff",
   "DecidableEq",
   "Set.Elem",
   "of_eq_true",
   "forall_congr",
   "Finset.image",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.fintypeImage.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : DecidableEq β] (s : Set α) (f : α → β) [inst_1 : Fintype ↑s] (a : β),\n  a ∈ Finset.image f (Set.toFinset s) ↔ a ∈ f '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "implies_congr",
   "Eq",
   "PProd",
   "Filter.HasBasis",
   "Eq.mpr",
   "Filter",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "Set.inter_subset_inter",
   "funext",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "PProd.snd",
   "Filter.HasBasis.mem_iff",
   "Iff.intro",
   "And",
   "PProd.fst",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Mathlib.Order.Filter.Bases._auxLemma.20",
   "Filter.mem_inf_of_inter",
   "propext",
   "Filter.instInfFilter",
   "congr",
   "And.intro",
   "PProd.casesOn",
   "congrArg",
   "PProd.mk",
   "Filter.HasBasis.mk",
   "Set.instInterSet",
   "congrFun"],
  "name": "Filter.HasBasis.inf'",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {l l' : Filter α} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n  {s' : ι' → Set α},\n  Filter.HasBasis l p s →\n    Filter.HasBasis l' p' s' → Filter.HasBasis (l ⊓ l') (fun i ↦ p i.fst ∧ p' i.snd) fun i ↦ s i.fst ∩ s' i.snd",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Eq.refl", "Not", "Filter", "Filter.Eventually", "Filter.Frequently", "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.Filter.Frequently._eq_1",
  "constType":
  "∀ {α : Type u} (p : α → Prop) (f : Filter α), Filter.Frequently p f = ¬∀ᶠ (x : α) in f, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.subtype.proof_1",
   "Subtype.val",
   "Function.Embedding.mk",
   "Function.Embedding",
   "Subtype"],
  "name": "Function.Embedding.subtype",
  "constType": "{α : Sort u_1} → (p : α → Prop) → Subtype p ↪ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Set.sUnion",
   "Filter",
   "TopologicalSpace.nhds_generateFrom.match_3",
   "Set.subset_sUnion_of_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.proof_2",
  "constType":
  "∀ {α : Type u_1} (a : α) (f : Filter α) (_k : Set (Set α)),\n  (∀ t ∈ _k, (fun s ↦ a ∈ s → s ∈ f) t) → a ∈ ⋃₀ _k → ⋃₀ _k ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "Or",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Iff.intro",
   "Iff",
   "of_eq_true",
   "List",
   "congr",
   "or_false",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "List.eq_of_mem_singleton",
   "congrFun"],
  "name": "List.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, a ∈ [b] ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod"],
  "name": "Prod.rec",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → ((fst : α) → (snd : β) → motive (fst, snd)) → (t : α × β) → motive t",
  "constCategory": "Other"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{α : Type u_3} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references": ["Bot", "bot_nonempty.proof_1", "Nonempty"],
  "name": "bot_nonempty",
  "constType": "∀ (α : Type u) [inst : Bot α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "List.hasDecEq.match_2",
  "constType":
  "{α : Type u_1} →\n  (a b : α) →\n    (motive : Decidable (a = b) → Sort u_2) →\n      (x : Decidable (a = b)) →\n        ((hab : a = b) → motive (isTrue hab)) → ((nab : ¬a = b) → motive (isFalse nab)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithLowerSet.toLowerSet",
   "ContinuousMap",
   "LE.le",
   "Preorder.toLE",
   "ContinuousMap.mk",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.map.proof_1"],
  "name": "Topology.WithLowerSet.map",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → C(Topology.WithLowerSet α, Topology.WithLowerSet β)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.Continuous_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.26",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "nhds",
   "Function.comp",
   "ContinuousAt",
   "TopologicalSpace",
   "Inducing",
   "Inducing.tendsto_nhds_iff"],
  "name": "Inducing.continuousAt_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Inducing g → ∀ {x : α}, ContinuousAt f x ↔ ContinuousAt (g ∘ f) x",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.nil",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter",
  "constType":
  "{α : Type u_1} → (R : α → α → Prop) → [inst : DecidableRel R] → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (a b : αᵒᵈ), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsNeutral", "Eq"],
  "name": "Lean.IsNeutral.left_neutral",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} {neutral : α} [self : Lean.IsNeutral op neutral] (a : α), op neutral a = a",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Not"],
  "name": "Decidable.isFalse",
  "constType": "{p : Prop} → ¬p → Decidable p",
  "constCategory": "Other"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["List.filter",
   "Eq.mpr",
   "List.Perm.filterMap",
   "Eq.ndrec",
   "List.Perm",
   "List.filterMap_eq_filter",
   "List.filterMap",
   "List",
   "Bool.true",
   "Eq.refl",
   "Bool",
   "Eq.symm",
   "id",
   "instDecidableEqBool",
   "Eq",
   "Option.guard"],
  "name": "List.Perm.filter",
  "constType":
  "∀ {α : Type uu} (p : α → Bool) {l₁ l₂ : List α}, l₁ ~ l₂ → List.filter p l₁ ~ List.filter p l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a b : α), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Filter.GenerateSets",
  "constType": "{α : Type u} → Set (Set α) → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.sUnion_subset",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "interior",
   "IsOpen"],
  "name": "interior_subset",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, interior s ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.casesOn",
   "Equiv.toFun",
   "Eq.ndrec",
   "Function.RightInverse",
   "Equiv.invFun",
   "Eq.rec",
   "Eq.refl",
   "Equiv.mk",
   "Eq.symm",
   "Eq"],
  "name": "Equiv.instEquivLikeEquiv.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (e₁ e₂ : α ≃ β), e₁.toFun = e₂.toFun → e₁.invFun = e₂.invFun → e₁ = e₂",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range", "Set.Elem", "Finite", "Finite.Set.finite_range.proof_1"],
  "name": "Finite.Set.finite_range",
  "constType":
  "∀ {α : Type u} {ι : Sort w} (f : ι → α) [inst : Finite ι], Finite ↑(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "List.subset_nil.match_2",
  "constType":
  "∀ {α : Type u_1} {l : List α} (motive : (x : List α) → l = x → Prop) (x : List α) (x_1 : l = x),\n  (Unit → motive l (_ : l = l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "True.intro",
   "False.elim",
   "False",
   "BoundedOrder.mk",
   "Bot.mk",
   "OrderBot.mk",
   "Prop.le",
   "Top.mk",
   "True",
   "BoundedOrder"],
  "name": "Prop.boundedOrder",
  "constType": "BoundedOrder Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.Subset.rfl",
   "Filter.exists_mem_subset_iff.match_1",
   "instMembershipSetFilter"],
  "name": "Filter.exists_mem_subset_iff",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (∃ t ∈ f, t ⊆ s) ↔ s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "Top",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedCoheytingAlgebra",
   "HNot",
   "HNot.hnot",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "CoheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toGeneralizedCoheytingAlgebra : GeneralizedCoheytingAlgebra α] →\n    [toTop : Top α] → [toHNot : HNot α] → (∀ (a : α), a ≤ ⊤) → (∀ (a : α), ⊤ \\ a = ￢a) → CoheytingAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasSubset.Subset",
   "Set.empty_subset.match_1",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.empty_subset",
  "constType": "∀ {α : Type u} (s : Set α), ∅ ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≥]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "instBEq",
   "rfl",
   "List.erase",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "List.count_erase",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "instOfNatNat",
   "Nat",
   "List.count",
   "id"],
  "name": "List.count_erase_self",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.count a (List.erase l a) = List.count a l - 1",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe", "EquivLike", "outParam", "EquivLike.inv", "Eq"],
  "name": "EquivLike.coe_injective'",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "And.intro",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "le_antisymm_iff.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α} (motive : a ≤ b ∧ b ≤ a → Prop) (x : a ≤ b ∧ b ≤ a),\n  (∀ (h1 : a ≤ b) (h2 : b ≤ a), motive (_ : a ≤ b ∧ b ≤ a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "Iff",
   "And.comm",
   "exists_congr",
   "Iff.trans",
   "exists_eq_left",
   "Eq"],
  "name": "exists_eq_right",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') ↔ p a'",
  "constCategory": "Theorem"},
 {"references": ["Inf.mk", "Sup", "Inf", "OrderDual", "Sup.sup"],
  "name": "instInfOrderDual",
  "constType": "(α : Type u_1) → [inst : Sup α] → Inf αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet", "IsLowerSet", "LowerSet.rec", "Set", "LowerSet.mk", "LE"],
  "name": "LowerSet.casesOn",
  "constType":
  "{α : Type u_6} →\n  [inst : LE α] →\n    {motive : LowerSet α → Sort u} →\n      (t : LowerSet α) →\n        ((carrier : Set α) → (lower' : IsLowerSet carrier) → motive { carrier := carrier, lower' := lower' }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "EmptyCollection.emptyCollection",
   "Monad.toApplicative",
   "Set.monad",
   "Union.union",
   "Unit",
   "Set",
   "Unit.unit",
   "Set.instEmptyCollectionSet",
   "Alternative.mk",
   "Alternative",
   "Set.instUnionSet"],
  "name": "Set.instAlternativeSet",
  "constType": "Alternative Set",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.instInhabitedWithLower._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "Order.Frame.mk",
   "CompleteDistribLattice.mk",
   "CompletelyDistribLattice",
   "CompleteDistribLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.proof_2",
   "CompletelyDistribLattice.toCompleteDistribLattice.proof_1"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice",
  "constType":
  "{α : Type u} → [inst : CompletelyDistribLattice α] → CompleteDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "nhds",
   "Set",
   "ContinuousAt",
   "IsOpen.mem_nhds",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Iff.intro",
   "Iff",
   "Continuous",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Continuous.tendsto",
   "continuous_def",
   "instMembershipSetFilter",
   "isOpen_iff_mem_nhds"],
  "name": "continuous_iff_continuousAt",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f ↔ ∀ (x : α), ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Function.comp",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "ContinuousMap",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "ContinuousMap.mk",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Topology.WithUpperSet.map.proof_1",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → C(Topology.WithUpperSet α, Topology.WithUpperSet β)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.instSingletonSet",
   "Iff",
   "upperClosure",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "UpperSet.Ici",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.38",
   "And",
   "of_eq_true",
   "UpperSet.ext",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "SetLike.coe",
   "congrFun"],
  "name": "upperClosure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (a : α), upperClosure {a} = UpperSet.Ici a",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "T0Space", "Inseparable", "Eq"],
  "name": "T0Space.mk",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α], (∀ ⦃x y : α⦄, Inseparable x y → x = y) → T0Space α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Set.Basic._auxLemma.11",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "congr",
   "Not",
   "congrArg",
   "Mathlib.Data.Set.Basic._auxLemma.10",
   "Eq.trans"],
  "name": "Set.not_nonempty_iff_eq_empty",
  "constType": "∀ {α : Type u} {s : Set α}, ¬Set.Nonempty s ↔ s = ∅",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Mem",
  "constType": "{α : Type u} → α → List α → Prop",
  "constCategory": "Other"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Classical.indefiniteDescription.match_1",
  "constType":
  "∀ {α : Sort u_1} (p : α → Prop) (motive : (∃ x, p x) → Prop) (h : ∃ x, p x),\n  (∀ (x : α) (px : p x), motive (_ : ∃ x, p x)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "EStateM.modifyGet.match_1",
  "constType":
  "{σ α : Type u_1} → (motive : α × σ → Sort u_2) → (x : α × σ) → ((a : α) → (s : σ) → motive (a, s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper", "Topology.upper", "TopologicalSpace", "Preorder"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "∀ {α ι : Type u_1} {κ : ι → Type u_1} (f : (a : ι) → κ a → Set α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "le_inf",
   "Pi.partialOrder",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → SemilatticeInf (α' i)] (x x_1 x_2 : (i : ι) → α' i),\n  x ≤ x_1 → x ≤ x_2 → ∀ (i : ι), x i ≤ x_1 i ⊓ x_2 i",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "DecidableEq",
   "Set.toFinset",
   "Union.union",
   "Set",
   "Finset",
   "Set.fintypeUnion.proof_1",
   "Fintype.ofFinset",
   "Finset.instUnionFinset",
   "Set.instUnionSet"],
  "name": "Set.fintypeUnion",
  "constType":
  "{α : Type u} → [inst : DecidableEq α] → (s t : Set α) → [inst : Fintype ↑s] → [inst : Fintype ↑t] → Fintype ↑(s ∪ t)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "le_antisymm_iff.match_1",
   "And.intro",
   "le_antisymm",
   "Eq.symm",
   "le_of_eq",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Fin.val", "LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.isLt",
  "constType": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.inter_subset_inter",
   "setOf",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Set.instMembershipSet",
   "And",
   "Set.instHasSubsetSet",
   "Filter.comap.match_1",
   "Filter.inter_mem",
   "Filter",
   "And.intro",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.comap.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (m : α → β) (f : Filter β) {x y : Set α},\n  x ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s} → y ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s} → x ∩ y ∈ {s | ∃ t ∈ f, m ⁻¹' t ⊆ s}",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff", "Not", "Iff.mpr"],
  "name": "instDecidableIff.proof_3",
  "constType": "∀ {p q : Prop}, ¬p → q → (p ↔ q) → False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.cons",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instBEq",
   "ite_congr",
   "True",
   "Eq",
   "ite",
   "instDecidableFalse",
   "eq_false",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "List.count",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_cons_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α}, a ≠ b → ∀ (l : List α), List.count a (b :: l) = List.count a l",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.image_congr",
   "of_eq_true",
   "Set.image_id'",
   "Set",
   "Eq.refl",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "True",
   "Set.instMembershipSet",
   "congrFun",
   "id",
   "Eq"],
  "name": "Set.image_id",
  "constType": "∀ {α : Type u_1} (s : Set α), id '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "Eq.refl",
   "List.pmap._sunfold.proof_2",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.pmap_eq_map",
  "constType":
  "∀ {α : Type u} {β : Type v} (p : α → Prop) (f : α → β) (l : List α) (H : ∀ a ∈ l, p a),\n  List.pmap (fun a x ↦ f a) l H = List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.image_id'",
   "Set",
   "Set.sUnion_image",
   "Eq.refl",
   "Set.sUnion",
   "Set.image",
   "Eq.symm",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.sUnion_eq_biUnion",
  "constType": "∀ {α : Type u_1} {s : Set (Set α)}, ⋃₀ s = ⋃ i ∈ s, i",
  "constCategory": "Theorem"},
 {"references": ["Lean.MonadQuotation", "Lean.MacroScope"],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → m Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.sub_add_cancel",
  "constType": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«term𝓝[>]_»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[>]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax",
  "constType": "Lean.SyntaxNodeKinds → Type",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_3",
  "constType": "2047 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop", "Top.top", "OrderTop.le_top", "OrderTop", "LE", "LE.le"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "inf_assoc",
   "LE.le",
   "GeneralizedBooleanAlgebra.inf_inf_sdiff",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra",
   "Bot.mk",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "GeneralizedBooleanAlgebra.toOrderBot.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (a : α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.List.Basic._auxLemma.62",
   "List.pmap",
   "List.instMembershipList",
   "Subtype.val",
   "Mathlib.Data.List.Basic._auxLemma.9",
   "Mathlib.Data.List.Basic._auxLemma.65",
   "Eq.refl",
   "List.pmap_eq_map_attach",
   "List.attach",
   "Iff.mpr",
   "True",
   "iff_self",
   "Mathlib.Data.List.Basic._auxLemma.64",
   "Eq",
   "Iff.of_eq",
   "Subtype.property",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.List.Basic._auxLemma.63",
   "List",
   "congr",
   "List.map",
   "congrArg",
   "Eq.trans",
   "Subtype",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "List.mem_pmap",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a} {b : β},\n  b ∈ List.pmap f l H ↔ ∃ a, ∃ (h : a ∈ l), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "List", "List.hasDecEq"],
  "name": "instDecidableEqList",
  "constType": "{α : Type u} → [inst : DecidableEq α] → DecidableEq (List α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "_private.Std.Data.List.Count.0.List.count._eq_1",
   "List.instMembershipList",
   "List.countP_eq_length",
   "Eq.refl",
   "instBEq",
   "beq_self_eq_true",
   "List.length",
   "instLawfulBEqInstBEq",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "BEq.beq",
   "Iff",
   "Eq.ndrec",
   "DecidableEq",
   "propext",
   "List",
   "Bool.true",
   "Eq.mp",
   "Init.Core._auxLemma.1",
   "Bool",
   "Nat",
   "List.countP",
   "Eq.symm",
   "List.count",
   "id"],
  "name": "List.count_eq_length",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, List.count a l = List.length l ↔ ∀ b ∈ l, a = b",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.loop.match_1.splitter",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → motive true → motive false → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references":
  ["PSigma",
   "OfNat.ofNat",
   "instSubNat",
   "WellFounded.fix_eq",
   "Nat.decLt",
   "Eq.refl",
   "instSizeOfNat",
   "dite",
   "instLTNat",
   "ite",
   "Eq",
   "instWellFoundedRelation",
   "instLENat",
   "Nat.div_rec_lemma",
   "SizeOf.sizeOf",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.decLe",
   "id",
   "instHSub",
   "PSigma.casesOn",
   "HSub.hSub",
   "Nat.modCore",
   "instDecidableAnd",
   "Nat.modCore._unary.proof_1",
   "WellFounded.fix",
   "LE.le",
   "And",
   "Nat.modCore._unary",
   "invImage",
   "LT.lt",
   "PSigma.mk",
   "Not"],
  "name": "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
  "constType":
  "∀ (x y : ℕ), Nat.modCore x y = if 0 < y ∧ y ≤ x then Nat.modCore (x - y) y else x",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.closure_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Order.Frame.toCompleteLattice",
   "Order.Coframe",
   "Order.Coframe.mk",
   "CompleteDistribLattice",
   "CompleteDistribLattice.toFrame"],
  "name": "CompleteDistribLattice.toCoframe",
  "constType":
  "{α : Type u} → [inst : CompleteDistribLattice α] → Order.Coframe α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Top", "Top.top", "Nonempty"],
  "name": "top_nonempty.proof_1",
  "constType": "∀ (α : Type u_1) [inst : Top α], Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Filter.instPartialOrderFilter.proof_3",
   "Membership.mem",
   "LE.mk",
   "And",
   "Filter.instPartialOrderFilter.proof_1",
   "PartialOrder.mk",
   "Set",
   "Not",
   "Filter",
   "LT.mk",
   "Filter.instPartialOrderFilter.proof_2",
   "Filter.instPartialOrderFilter.proof_4",
   "PartialOrder",
   "instMembershipSetFilter",
   "Preorder.mk"],
  "name": "Filter.instPartialOrderFilter",
  "constType": "{α : Type u} → PartialOrder (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.pairwise_cons.match_2",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α} (motive : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l → Prop)\n  (x : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l),\n  (∀ (h₁ : ∀ a' ∈ l, R a a') (h₂ : List.Pairwise R l), motive (_ : (∀ a' ∈ l, R a a') ∧ List.Pairwise R l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "of_eq_true",
   "Inf.inf",
   "congr",
   "Sup.sup",
   "sup_comm",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "True",
   "sup_inf_left",
   "Eq"],
  "name": "sup_inf_right",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, y ⊓ z ⊔ x = (y ⊔ x) ⊓ (z ⊔ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set.preimage",
   "Continuous",
   "Set",
   "le_generateFrom",
   "TopologicalSpace",
   "LE.le",
   "IsOpen",
   "Preorder.toLE",
   "Iff.mpr",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced",
   "Set.instMembershipSet"],
  "name": "continuous_generateFrom",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t : TopologicalSpace α} {b : Set (Set β)},\n  (∀ s ∈ b, IsOpen (f ⁻¹' s)) → Continuous f",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Context"],
  "name": "Lean.Data.AC.Context.op",
  "constType": "{α : Sort u} → Lean.Data.AC.Context α → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Exists",
   "List.cons",
   "List.Sublist.casesOn",
   "List.eq_nil_of_sublist_nil",
   "HEq",
   "List.Perm.refl",
   "eq_of_heq",
   "List.exists_perm_sublist.match_1",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Perm.rec",
   "Exists.intro",
   "List.Perm.swap",
   "List.Sublist.slnil",
   "List.Perm.cons",
   "Eq",
   "List.Perm",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Eq.rec",
   "List.Sublist.cons₂",
   "List.Perm.trans",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.exists_perm_sublist",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ l₂' : List α}, List.Sublist l₁ l₂ → l₂ ~ l₂' → ∃ l₁', ∃ (_ : l₁' ~ l₁), List.Sublist l₁' l₂'",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "Option.none",
   "List",
   "Unit",
   "PUnit",
   "Option.some",
   "List.erase.match_1",
   "List.nil",
   "Bool",
   "List.isEmpty.match_1",
   "Option"],
  "name": "List.find?",
  "constType": "{α : Type u} → (α → Bool) → List α → Option α",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl", "eq_true", "List", "List.Sublist", "True", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.30",
  "constType": "∀ {α : Type u_1} (l : List α), List.Sublist l l = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "LE.le.trans",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "le_iSup_of_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α} (i : ι), a ≤ f i → a ≤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_6",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_4",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "semiOutParam"],
  "name": "MonadReaderOf.mk",
  "constType":
  "{ρ : semiOutParam (Type u)} → {m : Type u → Type v} → m ρ → MonadReaderOf ρ m",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage_iUnion₂",
   "Set.sUnion_eq_biUnion",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "Set.sUnion",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.preimage_sUnion",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set (Set β)}, f ⁻¹' ⋃₀ s = ⋃ t ∈ s, f ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "sSupHom.dual.proof_3",
   "OrderDual.toDual",
   "sSupHom.mk",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHomClass.toFunLike",
   "sSupHom.instSSupHomClassSSupHom",
   "OrderDual.ofDual",
   "sSupHom.dual.proof_1",
   "sSupHom.dual.proof_2",
   "Equiv.mk",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : SupSet α] → [inst_1 : SupSet β] → sSupHom α β ≃ sInfHom αᵒᵈ βᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "HasSubset.Subset",
   "List.subset_nil.match_1",
   "rfl",
   "Eq",
   "Iff.intro",
   "Iff.mp",
   "List.Subset.refl",
   "List",
   "List.Mem.head",
   "List.not_mem_nil.match_1",
   "List.nil",
   "List.subset_nil.match_2"],
  "name": "List.eq_nil_of_subset_nil",
  "constType": "∀ {α : Type u_1} {l : List α}, l ⊆ [] → l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "iSup",
   "iSup_subtype''",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "Eq.mpr",
   "CompleteLattice",
   "Eq.ndrec",
   "Set.Elem",
   "iSup_range'",
   "Eq.symm",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "iSup_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_5} [inst : CompleteLattice α] {g : β → α} {f : ι → β},\n  ⨆ b ∈ Set.range f, g b = ⨆ i, g (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_5",
   "Lean.Name.str._override"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSet_ofLowerSet",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithLowerSet α),\n  ↑Topology.WithLowerSet.toLowerSet (↑Topology.WithLowerSet.ofLowerSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.count_pos_iff_mem",
   "Membership.mem",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "List.instMembershipList",
   "instBEq",
   "instLTNat",
   "LE.le",
   "Iff.mpr",
   "Eq",
   "List.Nodup",
   "Iff.mp",
   "instLENat",
   "DecidableEq",
   "StrictOrderedSemiring.toPartialOrder",
   "List",
   "LT.lt",
   "List.nodup_iff_count_le_one",
   "instOfNatNat",
   "Nat",
   "le_antisymm",
   "List.count",
   "Nat.strictOrderedSemiring"],
  "name": "List.count_eq_one_of_mem",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, List.Nodup l → a ∈ l → List.count a l = 1",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "IsTop",
  "constType": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Bind"],
  "name": "Bind.bind",
  "constType":
  "{m : Type u → Type v} → [self : Bind m] → {α β : Type u} → m α → (α → m β) → m β",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage", "Set", "Continuous", "TopologicalSpace", "IsOpen"],
  "name": "Continuous.isOpen_preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ (s : Set β), IsOpen s → IsOpen (f ⁻¹' s)",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.some", "Option.casesOn", "Option"],
  "name": "Option.getD.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : Option α → α → Sort u_2) →\n    (x : Option α) → (x_1 : α) → ((x x_2 : α) → motive (some x) x_2) → ((e : α) → motive none e) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Eq.ndrec", "Eq"],
  "name": "Eq.subst",
  "constType":
  "∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.forall_mem_nil.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (a : α) → a ∈ [] → Prop) (a : α) (a_1 : a ∈ []), motive a a_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "inf_of_le_left",
   "le_top",
   "SemilatticeInf.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_top_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] {a : α}, a ⊓ ⊤ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "And",
   "Set.preimage_univ",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "Set.univ",
   "isOpen_univ",
   "IsOpen",
   "Eq"],
  "name": "TopologicalSpace.induced.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (t : TopologicalSpace β), ∃ s', IsOpen s' ∧ f ⁻¹' s' = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "or_imp.match_1",
   "Function.comp",
   "And.intro",
   "Or.rec"],
  "name": "or_imp",
  "constType": "∀ {a b c : Prop}, a ∨ b → c ↔ (a → c) ∧ (b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "LE.mk",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "LE.le",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : Filter α), a ≤ b → b ≤ c → c.sets ⊆ a.sets",
  "constCategory": "Theorem"},
 {"references": ["and_comm", "And", "propext", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.11",
  "constType": "∀ {a b : Prop}, (a ∧ b) = (b ∧ a)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat"],
  "name": "List.findIdx.go",
  "constType": "{α : Type u_1} → (α → Bool) → List α → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "OfNat.ofNat",
   "List.mem_replicate.match_1",
   "Std.Data.List.Lemmas._auxLemma.2",
   "false_and",
   "List.instMembershipList",
   "Std.Data.Nat.Lemmas._auxLemma.3",
   "Eq.refl",
   "implies_congr",
   "True",
   "instDecidableEqNat",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "PProd",
   "Iff",
   "instDecidableNot",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "Nat.succ",
   "Membership.mem",
   "Ne",
   "Or",
   "List.cons",
   "Nat.below",
   "Nat.brecOn",
   "False",
   "Unit",
   "Std.Logic._auxLemma.5",
   "implies_true",
   "eq_false_of_decide",
   "Std.Logic._auxLemma.23",
   "Std.Logic._auxLemma.21",
   "And",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "List.replicate",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.mem_replicate",
  "constType":
  "∀ {α : Type u_1} {a b : α} {n : ℕ}, b ∈ List.replicate n a ↔ n ≠ 0 ∧ b = a",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quot.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.ind",
  "constType":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop},\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quotient s), motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderBot.toBot",
   "Prod.orderBot",
   "inferInstanceAs",
   "Prod.instLEProd",
   "OrderBot.bot_le",
   "LE",
   "Prod",
   "OrderBot",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "Prod.boundedOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : LE α] [inst_1 : LE β] [inst_2 : BoundedOrder α] [inst_3 : BoundedOrder β]\n  (a : α × β), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Fintype.equivFin", "Finite.intro", "Finite", "Fintype.card"],
  "name": "Fintype.finite",
  "constType": "∀ {α : Type u_4}, Fintype α → Finite α",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.binary",
  "constType":
  "Lean.Name → Lean.ParserDescr → Lean.ParserDescr → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.preimage",
   "Iff.rfl",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "mem_nhds_induced",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Filter.ext",
   "TopologicalSpace.induced",
   "Filter.mem_comap",
   "instMembershipSetFilter",
   "id"],
  "name": "nhds_induced",
  "constType":
  "∀ {α : Type u} {β : Type v} [T : TopologicalSpace α] (f : β → α) (a : β), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Set.Elem",
   "Iff.rfl",
   "propext",
   "Set",
   "Finite",
   "Eq.refl",
   "Set.finite_def",
   "finite_iff_nonempty_fintype",
   "Nonempty",
   "Set.Finite",
   "Eq",
   "id"],
  "name": "Set.finite_coe_iff",
  "constType": "∀ {α : Type u} {s : Set α}, Finite ↑s ↔ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "GeneralizedBooleanAlgebra.sup_inf_sdiff",
   "Eq"],
  "name": "sup_inf_sdiff",
  "constType":
  "∀ {α : Type u} [inst : GeneralizedBooleanAlgebra α] (x y : α), x ⊓ y ⊔ x \\ y = x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And", "Or", "Iff", "False", "Not", "or_imp"],
  "name": "not_or",
  "constType": "∀ {p q : Prop}, ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.univ_sets",
   "Membership.mem",
   "Inhabited",
   "Set",
   "Filter",
   "Set.univ",
   "Inhabited.mk",
   "Subtype.mk",
   "Subtype",
   "instMembershipSetFilter"],
  "name": "Filter.inhabitedMem",
  "constType": "{α : Type u} → {f : Filter α} → Inhabited { s // s ∈ f }",
  "constCategory": "Definition"},
 {"references": ["LowerSet", "IsLowerSet", "LE", "LowerSet.carrier"],
  "name": "LowerSet.lower'",
  "constType":
  "∀ {α : Type u_6} [inst : LE α] (self : LowerSet α), IsLowerSet self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.drop.match_1",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.drop",
  "constType": "{α : Type u} → ℕ → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1",
   "Topology.IsClosed_of._closed_1"],
  "name": "Topology.IsClosed_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.eq",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["GeneralizedHeytingAlgebra", "HImp"],
  "name": "GeneralizedHeytingAlgebra.toHImp",
  "constType": "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "eq_true",
   "List",
   "List.Sublist",
   "List.Sublist.cons",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.39",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist l₁ (a :: l₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.rec",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLowerSet α → Sort u} →\n        ((topology_eq_lowerSetTopology : t = Topology.lowerSet α) → motive (_ : Topology.IsLowerSet α)) →\n          (t : Topology.IsLowerSet α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Iff",
   "Iff.rfl",
   "Set",
   "LT.lt",
   "Not",
   "Filter",
   "LT.mk",
   "instMembershipSetFilter"],
  "name": "Filter.instPartialOrderFilter.proof_3",
  "constType": "∀ {α : Type u_1} (a b : Filter α), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_1",
   "String.toSubstring'"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["SeqRight", "Unit"],
  "name": "SeqRight.mk",
  "constType":
  "{f : Type u → Type v} → ({α β : Type u} → f α → (Unit → f β) → f β) → SeqRight f",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Mathlib.Logic.Basic._auxLemma.32",
   "Set",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Set.range",
   "And",
   "Iff",
   "of_eq_true",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.exists_range_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {p : α → Prop}, (∃ a ∈ Set.range f, p a) ↔ ∃ i, p (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.iUnion",
   "iSup_congr_Prop",
   "Iff",
   "Set",
   "Set.instSupSetSet",
   "Iff.mpr",
   "Eq"],
  "name": "Set.iUnion_congr_Prop",
  "constType":
  "∀ {α : Type u_1} {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q),\n  (∀ (x : q), f₁ (_ : p) = f₂ x) → Set.iUnion f₁ = Set.iUnion f₂",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM"],
  "name": "EStateM.get",
  "constType": "{ε σ : Type u} → EStateM ε σ σ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisConnection.dual",
   "Function.comp",
   "Monotone",
   "OrderDual",
   "FunLike.coe",
   "Monotone.dual",
   "Preorder",
   "GaloisConnection.monotone_u",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisConnection.monotone_l",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → Monotone l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.63",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {b : β} {f : α → β} {l : List α}, (b ∈ List.map f l) = ∃ a ∈ l, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Array.mkArray1",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node1",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Std.Data.List.Basic._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) = ((∀ a' ∈ l, R a a') ∧ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.out"],
  "name": "Trunc.out",
  "constType": "{α : Sort u_1} → Trunc α → α",
  "constCategory": "Definition"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{α : Sort u} → Nonempty α → α",
  "constCategory": "Axiom"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_10",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "GaloisInsertion.gc",
   "Set",
   "LE.le.trans",
   "Monotone.mem_upperBounds_image",
   "Preorder",
   "GaloisConnection.monotone_u",
   "And.left",
   "GaloisInsertion",
   "IsLUB",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "And.right",
   "upperBounds",
   "GaloisInsertion.le_l_u",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "And.intro",
   "Set.image",
   "Set.mem_image_of_mem"],
  "name": "GaloisInsertion.isLUB_of_u_image",
  "constType":
  "∀ {α : Type u} {β : Type v} {l : α → β} {u : β → α} [inst : Preorder α] [inst_1 : Preorder β],\n  GaloisInsertion l u → ∀ {s : Set β} {a : α}, IsLUB (u '' s) a → IsLUB s (l a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[_]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.Sublist",
  "constType": "{α : Type u_1} → List α → List α → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["List", "List.Mem", "Membership.mk", "Membership"],
  "name": "List.instMembershipList",
  "constType": "{α : Type u} → Membership α (List α)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Eq.ndrec", "Bool", "Bool.noConfusionType", "Eq"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.symm",
   "List.Perm",
   "List",
   "List.nil",
   "List.Perm.eq_nil",
   "Eq.symm",
   "Eq"],
  "name": "List.Perm.nil_eq",
  "constType": "∀ {α : Type uu} {l : List α}, [] ~ l → [] = l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_4"],
  "name": "Topology.«term𝓝[_]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Iff",
   "Iff.rfl",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Filter",
   "Filter.mkOfClosure",
   "Filter.ext",
   "Eq.symm",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure_sets",
  "constType":
  "∀ {α : Type u} {s : Set (Set α)} {hs : (Filter.generate s).sets = s}, Filter.mkOfClosure s hs = Filter.generate s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Setoid.r",
   "Iff",
   "List",
   "List.mem_pmap",
   "List.isSetoid",
   "Multiset",
   "Multiset.pmap",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Quot.mk",
   "Eq"],
  "name": "Multiset.mem_pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {s : Multiset α} {H : ∀ a ∈ s, p a} {b : β},\n  b ∈ Multiset.pmap f s H ↔ ∃ a, ∃ (h : a ∈ s), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "Bot.bot",
   "IsCompl.disjoint",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "OrderBot.toBot",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "Lattice",
   "Disjoint.eq_bot",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "Eq",
   "BoundedOrder"],
  "name": "IsCompl.inf_eq_bot",
  "constType":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → x ⊓ y = ⊥",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "not_and_or", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Prod._auxLemma.18",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (¬a ∨ ¬b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "And",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Eq",
   "Set.prod_nonempty_iff"],
  "name": "Mathlib.Data.Set.Prod._auxLemma.27",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, Set.Nonempty (s ×ˢ t) = (Set.Nonempty s ∧ Set.Nonempty t)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "List.Mem.head",
   "List.Mem.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "List.append_of_mem.match_2",
  "constType":
  "∀ {α : Type u_1} {a : α} (motive : (l : List α) → a ∈ l → Prop) (l : List α) (x : a ∈ l),\n  (∀ (l : List α), motive (a :: l) (_ : List.Mem a (a :: l))) →\n    (∀ (b : α) (as : List α) (h : List.Mem a as), motive (b :: as) (_ : List.Mem a (b :: as))) → motive l x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.hasMacroScopes.match_1",
  "constType":
  "(motive : Lean.Name → Sort u_1) →\n  (x : Lean.Name) →\n    ((pre : Lean.Name) → (s : String) → motive (Lean.Name.str pre s)) →\n      ((p : Lean.Name) → (i : ℕ) → motive (Lean.Name.num p i)) → ((x : Lean.Name) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.4",
  "constType": "∀ {α : Type u} [inst : LE α] {a b : α}, (a ≥ b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "List.cons",
   "Iff",
   "List.forall_mem_cons.match_1",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "List.Mem",
   "List.Mem.head",
   "And.intro",
   "List.forall_mem_cons.match_2"],
  "name": "List.forall_mem_cons",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["UpperSet.instSetLikeUpperSet",
   "LE",
   "IsUpperSet",
   "UpperSet.upper'",
   "UpperSet",
   "SetLike.coe"],
  "name": "UpperSet.upper",
  "constType": "∀ {α : Type u_1} [inst : LE α] (s : UpperSet α), IsUpperSet ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.casesOn",
   "Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.noConfusionType",
  "constType":
  "{α : Type u_1} →\n  {t : TopologicalSpace α} → {inst : Preorder α} → Sort u → Topology.IsUpper α → Topology.IsUpper α → Sort u",
  "constCategory": "Definition"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.allEq",
  "constType": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.eq_sInf_of_mem_iff_exists_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {S : Set (Filter α)} (x : Set α) (motive : (∃ f ∈ S, x ∈ f) → Prop) (x_1 : ∃ f ∈ S, x ∈ f),\n  (∀ (w : Filter α) (hf : w ∈ S) (hs : x ∈ w), motive (_ : ∃ f ∈ S, x ∈ f)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Multiset.Nodup.map_on",
   "Function.Injective",
   "Multiset",
   "Multiset.Nodup",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.Nodup.map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Multiset α},\n  Function.Injective f → Multiset.Nodup s → Multiset.Nodup (Multiset.map f s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Macro.Context",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.removeNeutrals.loop.match_2",
  "constType":
  "(motive : List ℕ → Sort u_1) →\n  (x : List ℕ) → ((x : ℕ) → (xs : List ℕ) → motive (x :: xs)) → (Unit → motive []) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.mk",
   "Finset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.Subtype.fintype",
  "constType": "{α : Type u_1} → (s : Finset α) → Fintype { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "sInfHom.toFun",
   "sInfHomClass.mk",
   "sInfHom.instSInfHomClassSInfHom.proof_1",
   "sInfHom.map_sInf'",
   "FunLike.mk",
   "InfSet",
   "sInfHomClass"],
  "name": "sInfHom.instSInfHomClassSInfHom",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : InfSet α] → [inst_1 : InfSet β] → sInfHomClass (sInfHom α β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "List.Perm.cons_inv",
   "List.cons",
   "Iff",
   "List.Perm",
   "List",
   "List.Perm.cons"],
  "name": "List.perm_cons",
  "constType":
  "∀ {α : Type uu} (a : α) {l₁ l₂ : List α}, a :: l₁ ~ a :: l₂ ↔ l₁ ~ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "BEq",
   "LawfulBEq",
   "of_decide_eq_true",
   "Eq.refl",
   "ne_eq",
   "instDecidableIff",
   "Eq",
   "beq_iff_eq",
   "Eq.mpr",
   "BEq.beq",
   "Bool.casesOn",
   "Iff",
   "Eq.ndrec",
   "instDecidableNot",
   "Bool.false",
   "propext",
   "Bool.true",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableEqBool",
   "id"],
  "name": "beq_eq_false_iff_ne",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a b : α), (a == b) = false ↔ a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "Top.top",
   "HNot.hnot",
   "SDiff.sdiff",
   "BiheytingAlgebra.toSDiff",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "GeneralizedHeytingAlgebra.toTop",
   "Eq"],
  "name": "BiheytingAlgebra.top_sdiff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Inhabited",
   "Set",
   "Set.instEmptyCollectionSet",
   "Inhabited.mk"],
  "name": "Set.instInhabitedSet",
  "constType": "{α : Type u} → Inhabited (Set α)",
  "constCategory": "Definition"},
 {"references": ["outParam", "EStateM.Backtrackable"],
  "name": "EStateM.Backtrackable.restore",
  "constType":
  "{δ : outParam (Type u)} → {σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ → σ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["InfSet.mk",
   "Prod.snd",
   "Prod.mk",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "Prod",
   "Prod.fst",
   "Set.image"],
  "name": "Prod.infSet",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : InfSet α] → [inst : InfSet β] → InfSet (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GE.ge",
   "Mathlib.Order.Basic._auxLemma.4",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "sup_of_le_left",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun"],
  "name": "sup_inf_self",
  "constType": "∀ {α : Type u} [inst : Lattice α] {a b : α}, a ⊔ a ⊓ b = a",
  "constCategory": "Theorem"},
 {"references": ["Char", "List", "String.mk", "String", "congrArg", "Eq"],
  "name": "String.decEq.proof_1",
  "constType":
  "∀ (s₁ s₂ : List Char), s₁ = s₂ → { data := s₁ } = { data := s₂ }",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMapClass.map_continuous",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "FunLike.coe",
   "Continuous.comp'",
   "ContinuousMap",
   "ContinuousMap.toContinuousMapClass",
   "ContinuousMapClass.toFunLike",
   "id"],
  "name": "ContinuousMap.comp.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (f : C(β, γ)) (g : C(α, β)), Continuous (↑f ∘ ↑g)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List.rec", "List", "List.nil"],
  "name": "List.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    (t : List α) → motive [] → ((head : α) → (tail : List α) → motive (head :: tail)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Set.ball_image_of_ball",
   "Set",
   "Monotone",
   "Set.image",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Monotone.mem_upperBounds_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, a ∈ upperBounds s → f a ∈ upperBounds (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "TopologicalSpace.ext",
   "Preorder.le_refl",
   "FunLike.coe",
   "Prop.partialOrder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "TopologicalSpace",
   "OrderDual",
   "IsOpen"],
  "name": "TopologicalSpace.instPartialOrderTopologicalSpace.proof_1",
  "constType": "∀ {α : Type u_1} (a : TopologicalSpace α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "cond",
   "False",
   "Eq.refl",
   "eq_true_of_decide",
   "eq_false_of_decide",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "instDecidableFalse",
   "Bool.casesOn",
   "Eq.ndrec",
   "of_eq_true",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "instDecidableEqBool"],
  "name": "Bool.cond_eq_ite",
  "constType":
  "∀ {α : Type u_1} (b : Bool) (t e : α), (bif b then t else e) = if b = true then t else e",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "rfl",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton",
  "constType": "∀ {α : Type u} (a : α), a ∈ {a}",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.hasDecEq.match_3",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → List α → Sort u_2) →\n    (x x_1 : List α) →\n      (Unit → motive [] []) →\n        ((head : α) → (tail : List α) → motive (head :: tail) []) →\n          ((head : α) → (tail : List α) → motive [] (head :: tail)) →\n            ((a : α) → (as : List α) → (b : α) → (bs : List α) → motive (a :: as) (b :: bs)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["Char.val", "UInt32", "Char", "Char.val_eq_of_eq.match_1", "rfl", "Eq"],
  "name": "Char.val_eq_of_eq",
  "constType": "∀ {c d : Char}, c = d → c.val = d.val",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.term𝓝._closed_4",
   "Topology.term𝓝._closed_2"],
  "name": "Topology.term𝓝._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.gt_of_not_le.match_1",
  "constType":
  "∀ {n m : ℕ} (motive : m < n ∨ m ≥ n → Prop) (x : m < n ∨ m ≥ n),\n  (∀ (h₁ : m < n), motive (_ : m < n ∨ m ≥ n)) → (∀ (h₁ : m ≥ n), motive (_ : m < n ∨ m ≥ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Acc.intro", "Acc"],
  "name": "Acc.rec",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : (a : α) → Acc r a → Sort u_1} →\n      ((x : α) →\n          (h : ∀ (y : α), r y x → Acc r y) →\n            ((y : α) → (a : r y x) → motive y (_ : Acc r y)) → motive x (_ : Acc r x)) →\n        {a : α} → (t : Acc r a) → motive a t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.sUnion",
   "Set.instMembershipSet"],
  "name": "Set.mem_sUnion",
  "constType":
  "∀ {α : Type u_1} {x : α} {S : Set (Set α)}, x ∈ ⋃₀ S ↔ ∃ t ∈ S, x ∈ t",
  "constCategory": "Theorem"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive (Nat.succ n)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "List.Mem.tail",
   "List.casesOn",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "HEq.refl",
   "List",
   "Bool.true",
   "List.Mem.head",
   "List.Mem.casesOn",
   "Bool",
   "List.nil",
   "List.noConfusion"],
  "name": "List.exists_of_eraseP.match_3",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} (motive : (x : List α) → (x_1 : α) → x_1 ∈ x → p x_1 = true → Prop) (x : List α)\n  (x_1 : α) (x_2 : x_1 ∈ x) (x_3 : p x_1 = true),\n  (∀ (b : α) (l : List α) (a : α) (al : a ∈ b :: l) (pa : p a = true), motive (b :: l) a al pa) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "False", "List", "Not", "List.noConfusion", "absurd", "Eq"],
  "name": "List.hasDecEq.proof_6",
  "constType":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), ¬a = b → a :: as = b :: bs → False",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec", "List", "Eq.refl", "List.casesOn", "List.noConfusionType", "Eq"],
  "name": "List.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {v1 v2 : List α} → v1 = v2 → List.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "lowerBounds",
   "Preorder",
   "Set.instMembershipSet"],
  "name": "IsLeast",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1"],
  "name": "List.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "OrderDual.ofDual_toDual",
  "constType":
  "∀ {α : Type u_1} (a : α), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) → OrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Std.Data.List.Count._auxLemma.8",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Sup",
   "Continuous",
   "TopologicalSpace",
   "Sup.sup",
   "Prod",
   "Prod.fst",
   "ContinuousSup"],
  "name": "ContinuousSup.mk",
  "constType":
  "∀ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L], (Continuous fun p ↦ p.1 ⊔ p.2) → ContinuousSup L",
  "constCategory": "Other"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "Nat.decLt",
   "Eq.refl",
   "Classical.em",
   "instLTNat",
   "True",
   "ite",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.List.two_step_induction",
   "List.nil",
   "Nat",
   "Eq.trans",
   "if_neg",
   "id",
   "eq_self",
   "List.cons",
   "Or",
   "False",
   "Lean.Data.AC.insert",
   "Or.casesOn",
   "ite_congr",
   "instDecidableFalse",
   "Lean.Data.AC.Context.op",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "of_eq_true",
   "List",
   "LT.lt",
   "Lean.IsCommutative",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Not",
   "congrArg",
   "Lean.IsCommutative.comm",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_insert",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α),\n  Lean.IsCommutative ctx.op →\n    ∀ (x : ℕ) (xs : List ℕ),\n      Lean.Data.AC.evalList α ctx (Lean.Data.AC.insert x xs) = Lean.Data.AC.evalList α ctx (x :: xs)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable",
   "Lean.Data.AC.Context",
   "List"],
  "name": "Lean.Data.AC.Context.vars",
  "constType":
  "{α : Sort u} → (self : Lean.Data.AC.Context α) → List (Lean.Data.AC.Variable self.op)",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_1",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_2",
   "GeneralizedBooleanAlgebra",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toBot",
   "GeneralizedBooleanAlgebra.mk",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra",
  "constType":
  "{α : Type u} → [inst : BooleanAlgebra α] → GeneralizedBooleanAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Topology.Basic._auxLemma.43",
   "funext",
   "nhds",
   "Set",
   "Set.Nonempty",
   "Eq.refl",
   "Inter.inter",
   "Mathlib.Topology.Basic._auxLemma.42",
   "implies_congr",
   "ClusterPt",
   "Filter.Frequently",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Topology.Basic._auxLemma.41",
   "Filter.principal",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "TopologicalSpace",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "clusterPt_principal_iff_frequently",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {x : α} {s : Set α},\n  ClusterPt x (Filter.principal s) ↔ ∃ᶠ (y : α) in nhds x, y ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Inf.inf",
   "SupSet.sSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet"],
  "name": "CompleteAtomicBooleanAlgebra.inf_sSup_le_iSup_inf",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpper", "Nonempty"],
  "name": "Topology.WithUpper.instNonemptyWithUpper",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α], Nonempty (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Applicative",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "setOf",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "UpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe",
   "Eq"],
  "name": "Topology.IsLower.lowerBasis",
  "constType": "(α : Type u_1) → [inst : Preorder α] → Set (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["List",
   "Lean.SourceInfo",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax",
   "Substring"],
  "name": "Lean.Syntax.ident",
  "constType":
  "Lean.SourceInfo → Substring → Lean.Name → List Lean.Syntax.Preresolved → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["BEq.beq",
   "List.Perm",
   "DecidableEq",
   "List",
   "instBEq",
   "List.Perm.countP_eq",
   "Nat",
   "List.count",
   "Eq"],
  "name": "List.Perm.count_eq",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {l₁ l₂ : List α}, l₁ ~ l₂ → ∀ (a : α), List.count a l₁ = List.count a l₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "TopologicalSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[<]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x x_3 0) → (∀ (n m k : ℕ), motive n m (Nat.succ k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "List.filterMap_cons.match_1",
  "constType":
  "{β : Type u_1} →\n  (motive : Option β → Sort u_2) → (x : Option β) → (Unit → motive none) → ((b : β) → motive (some b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.sdiff_le_iff",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedCoheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPreorderProd",
   "inferInstanceAs",
   "Prod",
   "Preorder.le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (a b c : α × β), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "forall_eq_or_imp", "propext", "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.8",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∀ (a : α), a = a' ∨ q a → p a) = (p a' ∧ ∀ (a : α), q a → p a)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "interior",
   "IsOpen",
   "Set.subset_sUnion_of_mem"],
  "name": "interior_maximal",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, t ⊆ s → IsOpen t → t ⊆ interior s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references": ["forall_true_iff", "propext", "True", "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.19",
  "constType": "∀ {α : Sort u_2}, (α → True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Lattice._auxLemma.12",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, b ≤ a → a ⊓ b = b",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["MonadReaderOf", "Monad", "ReaderT", "ReaderT.read", "MonadReaderOf.mk"],
  "name": "instMonadReaderOfReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadReaderOf ρ (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_4",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation", "Nat"],
  "name": "Lean.Data.AC.EvalInformation.mk",
  "constType":
  "{α : Sort u} → {β : Sort v} → (α → β) → (α → β → β → β) → (α → ℕ → β) → Lean.Data.AC.EvalInformation α β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "instLTNat",
   "Eq",
   "List.mem_range'_1",
   "And",
   "instLENat",
   "propext",
   "List",
   "LT.lt",
   "instOfNatNat",
   "Nat"],
  "name": "Std.Data.List.Lemmas._auxLemma.108",
  "constType": "∀ {m s n : ℕ}, (m ∈ List.range' s n) = (s ≤ m ∧ m < s + n)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.termΩ._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Array", "List"],
  "name": "Array.data",
  "constType": "{α : Type u} → Array α → List α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_4",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b : (i : ι) → α' i), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.lift₂.proof_1",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.lift₂.proof_2",
   "Eq"],
  "name": "Quotient.lift₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          (f : α → β → φ) →\n            (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n              Quotient s₁ → Quotient s₂ → φ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "sup_of_le_right",
   "Sup.sup",
   "OrderBot",
   "bot_le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "bot_sup_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : OrderBot α] {a : α}, ⊥ ⊔ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.orderBot",
   "Topology.instIsLowerProd",
   "OrderDual.instPreorder",
   "Topology.IsLower.topology_eq_lowerTopology",
   "instTopologicalSpaceProd",
   "Prod.instPreorderProd",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "OrderTop",
   "TopologicalSpace",
   "Prod",
   "instTopologicalSpaceOrderDual",
   "Topology.IsUpper.mk",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.instIsUpperProd.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α]\n  [inst_3 : OrderTop α] [inst_4 : Preorder β] [inst_5 : TopologicalSpace β] [inst_6 : Topology.IsUpper β]\n  [inst_7 : OrderTop β], Topology.IsUpper (α × β)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "flip"],
  "name": "imp.swap",
  "constType":
  "∀ {a : Sort u_1} {b : Sort u_2} {c : Prop}, a → b → c ↔ b → a → c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.exists_subset_inter",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s → ∀ t₁ ∈ s, ∀ t₂ ∈ s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃ ∈ s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.finRange.proof_1",
   "List.pmap",
   "List.mem_range",
   "List.instMembershipList",
   "Fin.val",
   "List.mem_pmap",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "Nat",
   "Eq.symm",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "Fin.casesOn",
   "List.range"],
  "name": "List.mem_finRange",
  "constType": "∀ {n : ℕ} (a : Fin n), a ∈ List.finRange n",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "TopologicalSpace.isOpen_univ",
   "TopologicalSpace.coinduced.proof_2",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.coinduced.proof_1",
   "IsOpen"],
  "name": "TopologicalSpace.coinduced",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → TopologicalSpace α → TopologicalSpace β",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_1",
  "constType": "∀ (a : ℕ), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.mainModule",
  "constType": "Lean.MacroScopesView → Lean.Name",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "HeytingAlgebra.bot_le",
  "constType": "∀ {α : Type u_4} [self : HeytingAlgebra α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "Mathlib.Data.Set.Lattice._auxLemma.28",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion₂_eq_univ_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_7} {s : (i : ι) → κ i → Set α},\n  ⋃ i, ⋃ j, s i j = Set.univ ↔ ∀ (a : α), ∃ i, ∃ j, a ∈ s i j",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Prod.snd",
   "Iff.rfl",
   "LT.lt",
   "Not",
   "Prod",
   "Prod.fst",
   "LT.mk",
   "Preorder"],
  "name": "Prod.instPreorderProd.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Preorder α] [inst_1 : Preorder β] (a b : α × β), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpper.toUpper._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (α → Sort u_3)} → (coe : F → (a : α) → β a) → Function.Injective coe → FunLike F α β",
  "constCategory": "Other"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.intro",
   "OfNat.ofNat",
   "Or",
   "Nat.lt_wfRel.match_1",
   "Nat.lt",
   "Acc",
   "instLTNat",
   "Eq",
   "Nat.rec",
   "Eq.ndrec",
   "Nat.le_of_succ_le_succ",
   "Acc.inv",
   "LT.lt",
   "WellFounded",
   "instOfNatNat",
   "Nat",
   "Acc.intro",
   "absurd",
   "Nat.not_lt_zero",
   "Nat.succ",
   "Nat.eq_or_lt_of_le"],
  "name": "Nat.lt_wfRel.proof_1",
  "constType": "WellFounded Nat.lt",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Lean.IsIdempotent",
   "Option"],
  "name": "Lean.Data.AC.Context.idem",
  "constType":
  "{α : Sort u} → (self : Lean.Data.AC.Context α) → Option (Lean.IsIdempotent self.op)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "funext",
   "Iff.rfl",
   "TopologicalSpace.ext",
   "Set",
   "Topology.lowerSet",
   "Eq.refl",
   "Topology.upperSet",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq",
   "Topology.IsLowerSet.mk",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "TopologicalSpace",
   "OrderDual",
   "Topology.IsUpperSet.topology_eq",
   "IsOpen",
   "id"],
  "name": "OrderDual.instIsLowerSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α],\n  Topology.IsLowerSet αᵒᵈ",
  "constCategory": "Theorem"},
 {"references": ["False", "Not", "id"],
  "name": "not_false",
  "constType": "¬False",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Inf.inf",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toDistribLattice : DistribLattice α] →\n    [toSDiff : SDiff α] →\n      [toBot : Bot α] →\n        (∀ (a b : α), a ⊓ b ⊔ a \\ b = a) → (∀ (a b : α), a ⊓ b ⊓ a \\ b = ⊥) → GeneralizedBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "HEq",
   "List.instMembershipList",
   "List.Sublist.below.cons",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "List.Sublist.slnil",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.casesOn",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.below.cons₂",
   "List.Sublist.cons₂",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.below",
   "List.Sublist.below.slnil",
   "List.Sublist.below.casesOn"],
  "name": "List.Pairwise.sublist.match_1._@.Std.Data.List.Lemmas._hyg.28830",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop}\n  (motive : (l₂ l₁ : List α) → (x : List.Sublist l₁ l₂) → List.Pairwise R l₂ → List.Sublist.below x → Prop)\n  (l₂ l₁ : List α) (x : List.Sublist l₁ l₂) (x_1 : List.Pairwise R l₂) (h_below : List.Sublist.below x),\n  (∀ (h : List.Pairwise R []),\n      motive [] [] (_ : List.Sublist [] []) h (_ : List.Sublist.below (_ : List.Sublist [] []))) →\n    (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (a_1 : ∀ a' ∈ l₂, R a a') (h₂ : List.Pairwise R l₂)\n        (h : List.Sublist.below s) (a_2 : ∀ {R : α → α → Prop}, List.Pairwise R l₂ → List.Pairwise R l₁),\n        motive (a :: l₂) l₁ (_ : List.Sublist l₁ (a :: l₂)) (_ : List.Pairwise R (a :: l₂))\n          (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (h₁ : ∀ a' ∈ l₂, R a a') (h₂ : List.Pairwise R l₂)\n          (h : List.Sublist.below s) (a_1 : ∀ {R : α → α → Prop}, List.Pairwise R l₂ → List.Pairwise R l₁),\n          motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂)) (_ : List.Pairwise R (a :: l₂))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        motive l₂ l₁ x x_1 h_below",
  "constCategory": "Definition"},
 {"references":
  ["Function.Surjective",
   "compl_involutive",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Function.Involutive.surjective",
   "BooleanAlgebra"],
  "name": "compl_surjective",
  "constType":
  "∀ {α : Type u} [inst : BooleanAlgebra α], Function.Surjective compl",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "False",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.ne_of_beq_eq_false.match_1",
   "Nat.zero",
   "Bool.false",
   "Nat.noConfusion",
   "PUnit",
   "Not",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = false → ¬n = m",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Nat.le.refl", "Nat", "LE.le"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "compl_le_compl",
   "compl_compl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Iff.intro",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Iff",
   "Eq.mp",
   "congr",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "congrArg",
   "HeytingAlgebra.toHasCompl"],
  "name": "compl_le_compl_iff_le",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], yᶜ ≤ xᶜ ↔ x ≤ y",
  "constCategory": "Theorem"},
 {"references": ["Quot", "Quot.mk"],
  "name": "Quot.ind",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop}, (∀ (a : α), β (Quot.mk r a)) → ∀ (q : Quot r), β q",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Data.AC.Variable",
  "constType": "{α : Sort u} → (α → α → α) → Type u",
  "constCategory": "Other"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_eq_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "ContravariantClass",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.to_contravariantClass_le_left.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α], ContravariantClass α α (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nonempty.intro",
   "Exists",
   "Iff",
   "nonempty_subtype.match_1",
   "nonempty_subtype.match_2",
   "Exists.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty"],
  "name": "nonempty_subtype",
  "constType":
  "∀ {α : Sort u_2} {p : α → Prop}, Nonempty (Subtype p) ↔ ∃ a, p a",
  "constCategory": "Theorem"},
 {"references":
  ["not_and_of_not_or_not",
   "Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "dite",
   "Not",
   "And.intro"],
  "name": "Decidable.not_and",
  "constType": "∀ {a b : Prop} [inst : Decidable a], ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteSemilatticeInf",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Filter.GenerateSets.inter",
   "setOf",
   "Filter.GenerateSets",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ"],
  "name": "Filter.generate",
  "constType": "{α : Type u} → Set (Set α) → Filter α",
  "constCategory": "Definition"},
 {"references": ["Set", "LE", "UpperSet"],
  "name": "UpperSet.carrier",
  "constType": "{α : Type u_6} → [inst : LE α] → UpperSet α → Set α",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Preorder"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpperSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Topology.IsUpperSet",
   "Equiv.refl",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsUpperSet α] → Topology.WithUpperSet α ≃ₜ α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_le_iff_le_comap",
   "PartialOrder.toPreorder",
   "Filter.map_map",
   "Function.comp",
   "Eq.refl",
   "LE.le",
   "Filter.Tendsto.comp",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.tendsto_comap",
   "Iff.mp",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "id"],
  "name": "Filter.tendsto_comap_iff",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {f : α → β} {g : β → γ} {a : Filter α} {c : Filter γ},\n  Filter.Tendsto f a (Filter.comap g c) ↔ Filter.Tendsto (g ∘ f) a c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "DistribLattice",
   "Prop.heytingAlgebra",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Not",
   "And.intro",
   "And.casesOn",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice"],
  "name": "Prop.booleanAlgebra.match_1",
  "constType":
  "∀ (p : Prop),\n  let src := Prop.heytingAlgebra;\n  let src_1 := GeneralizedHeytingAlgebra.toDistribLattice;\n  ∀ (motive : p ⊓ pᶜ → Prop) (x : p ⊓ pᶜ), (∀ (Hp : p) (Hpc : pᶜ), motive (_ : p ∧ pᶜ)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddLeftCancelMonoid.add_zero",
   "AddCommMonoid.mk",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddCancelCommMonoid.add_comm",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddMonoid.mk",
   "AddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCommMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddCommMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "OfNat.ofNat",
   "instHMod",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMod.hMod",
   "instOfNatNat",
   "Fin.ofNat.proof_1",
   "Nat",
   "Nat.succ",
   "Fin",
   "Fin.mk"],
  "name": "Fin.ofNat",
  "constType": "{n : ℕ} → ℕ → Fin (Nat.succ n)",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_or_ge.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : m = n ∨ m < n → Prop) (x : m = n ∨ m < n),\n  (∀ (h1 : m = n), motive (_ : m = n ∨ m < n)) → (∀ (h1 : m < n), motive (_ : m = n ∨ m < n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.throw",
  "constType":
  "{ε : semiOutParam (Type u)} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set.insert_eq",
   "Set",
   "Union.union",
   "Eq.refl",
   "Insert.insert",
   "IsLUB",
   "Eq",
   "SemilatticeSup",
   "Eq.mpr",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "isLUB_singleton",
   "Sup.sup",
   "Singleton.singleton",
   "IsLUB.union",
   "SemilatticeSup.toPartialOrder",
   "Set.instUnionSet",
   "Set.instInsertSet",
   "id"],
  "name": "IsLUB.insert",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] (a : γ) {b : γ} {s : Set γ}, IsLUB s b → IsLUB (insert a s) (a ⊔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.18",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Data.Finset.Basic._auxLemma.4",
   "Set.instMembershipSet",
   "Set.ext",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset.toSet",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.coe_empty",
  "constType": "∀ {α : Type u_1}, ↑∅ = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.instInfFilter.proof_3",
   "Membership.mem",
   "And",
   "Exists",
   "Inf.mk",
   "Filter.instInfFilter.proof_1",
   "setOf",
   "Inf",
   "Filter.mk",
   "Set",
   "Inter.inter",
   "Filter",
   "Filter.instInfFilter.proof_2",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instInfFilter",
  "constType": "{α : Type u} → Inf (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "Set.instBooleanAlgebraSet",
   "Set.preimage",
   "congr_fun",
   "Set.compl_image",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq"],
  "name": "Set.compl_image_set_of",
  "constType":
  "∀ {α : Type u_1} {p : Set α → Prop}, compl '' {s | p s} = {s | p sᶜ}",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Iff.rfl",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "inf_assoc",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "disjoint_iff_inf_le",
   "propext",
   "OrderBot.toBot",
   "SemilatticeInf",
   "id"],
  "name": "disjoint_assoc",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b c : α}, Disjoint (a ⊓ b) c ↔ Disjoint a (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references": ["Equiv"],
  "name": "Equiv.invFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Prop.heytingAlgebra",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "HasCompl.compl",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "imp_iff_or_not",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "propext",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Not",
   "Lattice.toSemilatticeSup"],
  "name": "Prop.booleanAlgebra.proof_4",
  "constType": "∀ (p q : Prop), p ⇨ q = q ⊔ pᶜ",
  "constCategory": "Theorem"},
 {"references": ["Order.Frame", "CompleteDistribLattice"],
  "name": "CompleteDistribLattice.toFrame",
  "constType":
  "{α : Type u_1} → [self : CompleteDistribLattice α] → Order.Frame α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "List.Perm", "List", "List.Sublist"],
  "name": "List.Subperm",
  "constType": "{α : Type uu} → List α → List α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "nhds_basis_opens.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] (a : α) (t : Set α) (motive : t ∈ {s | a ∈ s ∧ IsOpen s} → Prop)\n  (x : t ∈ {s | a ∈ s ∧ IsOpen s}), (∀ (hat : a ∈ t) (ht : IsOpen t), motive (_ : a ∈ t ∧ IsOpen t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "Eq.refl",
   "List.Mem",
   "instBEq",
   "beq_self_eq_true",
   "List.elem",
   "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
   "List.Mem.rec",
   "True",
   "instLawfulBEqInstBEq",
   "Eq",
   "BEq.beq",
   "Eq.ndrec",
   "DecidableEq",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "Bool",
   "List.erase.match_1",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "id",
   "congrFun"],
  "name": "List.elem_eq_true_of_mem",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {as : List α}, a ∈ as → List.elem a as = true",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Set.Finite.exists_finset_coe",
   "Finset",
   "CanLift.mk",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite.proof_1",
  "constType":
  "∀ {α : Type u_1}, CanLift (Set α) (Finset α) Finset.toSet Set.Finite",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Prod.snd",
   "Prod",
   "And.intro",
   "Prod.fst",
   "Iff.mpr",
   "Prod.ext_iff",
   "Eq"],
  "name": "Prod.ext",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} {p q : α × β}, p.1 = q.1 → p.2 = q.2 → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → ZeroHom M N",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "False", "Or.inr", "Or.casesOn", "True", "Eq"],
  "name": "Classical.em.match_1",
  "constType":
  "∀ (p u v : Prop),\n  let U := fun x ↦ x = True ∨ p;\n  let V := fun x ↦ x = False ∨ p;\n  ∀ (motive : U u → V v → Prop) (u_def : U u) (v_def : V v),\n    (∀ (h : p) (x : V v), motive (_ : u = True ∨ p) x) →\n      (∀ (x : U u) (h : p), motive x (_ : v = False ∨ p)) →\n        (∀ (hut : u = True) (hvf : v = False), motive (_ : u = True ∨ p) (_ : v = False ∨ p)) → motive u_def v_def",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.decLt",
   "Array.appendCore.loop.match_1",
   "Unit",
   "HAdd.hAdd",
   "Array.get",
   "Array.push",
   "dite",
   "Array.size",
   "instLTNat",
   "Array",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "LT.lt",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Fin.mk"],
  "name": "Array.extract.loop",
  "constType": "{α : Type u_1} → Array α → ℕ → ℕ → Array α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_sup_left",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "le_of_eq",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "OrderDual",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Eq.symm"],
  "name": "OrderDual.distribLattice.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : DistribLattice α] (x x_1 x_2 : αᵒᵈ), (x ⊔ x_1) ⊓ (x ⊔ x_2) ≤ x ⊔ x_1 ⊓ x_2",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "GaloisInsertion", "Preorder.toLE"],
  "name": "GaloisInsertion.le_l_u",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisInsertion l u → ∀ (x : β), x ≤ l (u x)",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.mk",
  "constType": "{α : Type u} → (α → α → α) → Union α",
  "constCategory": "Other"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Setoid.refl",
   "Quotient.ind",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Eq"],
  "name": "Quotient.lift₂.proof_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₂ : Quotient s₂) (a b : α),\n  a ≈ b →\n    (fun a₁ ↦ Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) a =\n      (fun a₁ ↦ Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.64",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "coinduced_le_iff_le_induced.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {tβ : TopologicalSpace β} (_s : Set α) (motive : IsOpen _s → Prop)\n  (x : IsOpen _s),\n  (∀ (_t : Set β) (ht : IsOpen _t) (hst : f ⁻¹' _t = _s), motive (_ : ∃ s', IsOpen s' ∧ f ⁻¹' s' = _s)) → motive x",
  "constCategory": "Definition"},
 {"references": ["GaloisConnection", "GaloisCoinsertion", "Preorder"],
  "name": "GaloisCoinsertion.gc",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisCoinsertion l u → GaloisConnection l u",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "iSup_range",
   "Set",
   "OrderDual.completeLattice",
   "OrderDual",
   "Set.instMembershipSet",
   "Eq"],
  "name": "iInf_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_5} [inst : CompleteLattice α] {g : β → α} {f : ι → β},\n  ⨅ b ∈ Set.range f, g b = ⨅ i, g (f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "setOf",
   "EmptyCollection.emptyCollection",
   "Set",
   "Mathlib.Order.Bounds.Basic._auxLemma.19",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "upperBounds",
   "Mathlib.Order.Bounds.Basic._auxLemma.18",
   "of_eq_true",
   "Mathlib.Order.Bounds.Basic._auxLemma.17",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "upperBounds_empty",
  "constType": "∀ {α : Type u} [inst : Preorder α], upperBounds ∅ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "List.cons",
   "Lean.MacroScopesView",
   "Lean.Name.num",
   "String",
   "_private.Init.Prelude.0.Lean.extractMainModule",
   "_private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1",
   "Lean.MacroScope",
   "PProd",
   "PProd.fst",
   "Lean.Name.rec",
   "List",
   "PUnit",
   "panic",
   "List.nil",
   "Lean.Name",
   "Nat",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMacroScopesAux",
  "constType": "Lean.Name → List Lean.MacroScope → Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["Set.nonempty_iff_ne_empty",
   "Ne",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "or_iff_not_imp_left",
   "Iff.mpr",
   "Eq"],
  "name": "Set.eq_empty_or_nonempty",
  "constType": "∀ {α : Type u} (s : Set α), s = ∅ ∨ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Iff.mpr", "Set.Finite"],
  "name": "Set.Finite.to_subtype",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Finite s → Finite ↑s",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Sort u) → Trans Eq r r",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Data.Set.Image._auxLemma.4",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "And.right",
   "setOf",
   "Set",
   "LE.le.trans",
   "Exists.imp",
   "And.intro",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperClosure.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (s : Set α) (x x_1 : α), x ≤ x_1 → x ∈ {x | ∃ a ∈ s, a ≤ x} → ∃ a ∈ s, a ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["sInf_insert",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Insert.insert",
   "Set.sInter",
   "Set.instInterSet",
   "Set.instInsertSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_insert",
  "constType":
  "∀ {α : Type u_1} (s : Set α) (T : Set (Set α)), ⋂₀ insert s T = s ∩ ⋂₀ T",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.GenerateSets", "Set", "Inter.inter", "Set.instInterSet"],
  "name": "Filter.GenerateSets.inter",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {s t : Set α},\n  Filter.GenerateSets g s → Filter.GenerateSets g t → Filter.GenerateSets g (s ∩ t)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.eq_of_mem_singleton",
  "constType": "∀ {α : Type u} {x y : α}, x ∈ {y} → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["AddCancelCommMonoid",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "flip",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "ge_antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteBooleanAlgebra",
   "BooleanAlgebra.le_top",
   "Order.Frame.mk",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.sInf_le",
   "CompleteBooleanAlgebra.toSupSet",
   "CompleteLattice.mk",
   "BooleanAlgebra.toBot",
   "CompleteBooleanAlgebra.toInfSet",
   "DistribLattice.toLattice",
   "CompleteDistribLattice.mk",
   "CompleteBooleanAlgebra.iInf_sup_le_sup_sInf",
   "CompleteDistribLattice",
   "CompleteBooleanAlgebra.sSup_le",
   "CompleteBooleanAlgebra.le_sInf",
   "CompleteBooleanAlgebra.le_sSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toTop",
   "CompleteBooleanAlgebra.inf_sSup_le_iSup_inf"],
  "name": "CompleteBooleanAlgebra.toCompleteDistribLattice",
  "constType":
  "{α : Type u_1} → [self : CompleteBooleanAlgebra α] → CompleteDistribLattice α",
  "constCategory": "Definition"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Inter.inter",
   "IsUpperSet",
   "IsUpperSet.inter",
   "Preorder",
   "Preorder.toLE",
   "Set.instInterSet"],
  "name": "Topology.upperSet.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] (x x_1 : Set α), IsUpperSet x → IsUpperSet x_1 → IsUpperSet (x ∩ x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["namedPattern",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.mod.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    ((x : ℕ) → motive 0 x) →\n      ((x n : ℕ) → (h : x = n + 1) → (y : ℕ) → motive (namedPattern x (Nat.succ n) h) y) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["add_left_inj",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Defs._auxLemma.4",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G) {b c : G}, (b + a = c + a) = (b = c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Lattice.toInf",
   "Order.Frame.toCompleteLattice",
   "CompleteLattice.toLattice",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "iSup",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Frame.inf_sSup_le_iSup_inf",
  "constType":
  "∀ {α : Type u_1} [self : Order.Frame α] (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Bool.decEq", "Bool"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "Eq.ndrec",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.add_sub_add_left",
   "Eq.refl",
   "Nat.zero_sub",
   "instOfNatNat",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.sub_self_add",
  "constType": "∀ (n m : ℕ), n - (n + m) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.sSup_le",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_8",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["le_of_not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«term𝓝[≤]_»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[≤]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Bool.of_not_eq_true",
   "List.eraseP",
   "List.cons",
   "cond",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "Not",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.eraseP_cons_of_neg",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} (p : α → Bool), ¬p a = true → List.eraseP p (a :: l) = a :: List.eraseP p l",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousMap.continuous_toFun",
   "ContinuousMap.toContinuousMapClass.proof_1",
   "ContinuousMapClass",
   "FunLike.mk",
   "TopologicalSpace",
   "ContinuousMap",
   "ContinuousMapClass.mk",
   "ContinuousMap.toFun"],
  "name": "ContinuousMap.toContinuousMapClass",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : TopologicalSpace α] → [inst_1 : TopologicalSpace β] → ContinuousMapClass C(α, β) α β",
  "constCategory": "Definition"},
 {"references": ["Lean.IsNeutral", "Eq"],
  "name": "Lean.IsNeutral.right_neutral",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} {neutral : α} [self : Lean.IsNeutral op neutral] (a : α), op a neutral = a",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Or",
   "List.mem_union_iff",
   "Multiset.ndunion",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.induction_on₂",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.mem_ndunion",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Multiset α} {a : α}, a ∈ Multiset.ndunion s t ↔ a ∈ s ∨ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.hash.match_1",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "OfNat.ofNat",
   "UInt64.size",
   "Lean.Name.num",
   "Lean.Name.hash.proof_2",
   "Nat.decLt",
   "Unit",
   "String",
   "dite",
   "instLTNat",
   "PProd",
   "PProd.fst",
   "Lean.Name.rec",
   "LT.lt",
   "String.hash",
   "PUnit",
   "Not",
   "instOfNatNat",
   "UInt64",
   "Lean.Name.hash.proof_1",
   "Lean.Name",
   "Lean.Name.anonymous",
   "UInt64.ofNatCore",
   "Nat",
   "mixHash",
   "Lean.Name.str"],
  "name": "Lean.Name.hash",
  "constType": "Lean.Name → UInt64",
  "constCategory": "Definition"},
 {"references":
  ["Set.ext",
   "Membership.mem",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ext_iff",
  "constType": "∀ {α : Type u} {s t : Set α}, s = t ↔ ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Topology.IsUpperSet.closure_eq_lowerClosure",
   "LowerSet.Iic",
   "Set",
   "Eq.refl",
   "Set.Iic",
   "Preorder",
   "lowerClosure_singleton",
   "Preorder.toLE",
   "Eq",
   "LowerSet",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "LowerSet.instSetLikeLowerSet",
   "TopologicalSpace",
   "Singleton.singleton",
   "lowerClosure",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsUpperSet.closure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α] {a : α},\n  closure {a} = Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "EStateM.tryCatch",
   "EStateM.Backtrackable",
   "MonadExceptOf",
   "EStateM.throw",
   "MonadExceptOf.mk"],
  "name": "EStateM.instMonadExceptOfEStateM",
  "constType":
  "{ε σ δ : Type u} → [inst : EStateM.Backtrackable δ σ] → MonadExceptOf ε (EStateM ε σ)",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.preorder",
   "Preorder.le_refl",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_1",
  "constType":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → PartialOrder (π i)] (a : (i : ι) → π i), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Set.image_univ",
   "Set.univ",
   "and_true",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "And",
   "Eq.mpr",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "Set.image",
   "Std.Logic._auxLemma.52",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "Subtype.coe_image",
   "Subtype.mk",
   "Subtype",
   "exists_prop_congr'",
   "congrFun",
   "id"],
  "name": "Subtype.range_coe",
  "constType": "∀ {α : Type u_1} {s : Set α}, Set.range Subtype.val = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "SupSet.sSup",
   "iSup",
   "iSup_subtype''",
   "Eq",
   "Set.instMembershipSet",
   "sSup_image'",
   "Eq.mpr",
   "CompleteLattice",
   "Eq.ndrec",
   "Set.Elem",
   "Set.image",
   "Eq.symm",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "sSup_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {s : Set β} {f : β → α}, sSup (f '' s) = ⨆ a ∈ s, f a",
  "constCategory": "Theorem"},
 {"references":
  ["instTopologicalSpaceProd",
   "Topology.IsLower",
   "Prod.instPreorderProd",
   "TopologicalSpace",
   "Prod",
   "OrderBot",
   "Preorder",
   "Topology.instIsLowerProd.proof_1",
   "Preorder.toLE"],
  "name": "Topology.instIsLowerProd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α]\n  [inst_3 : OrderBot α] [inst_4 : Preorder β] [inst_5 : TopologicalSpace β] [inst_6 : Topology.IsLower β]\n  [inst_7 : OrderBot β], Topology.IsLower (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeSup.le_sSup",
  "constType":
  "∀ {α : Type u_9} [self : CompleteSemilatticeSup α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.compare",
  "constType": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "isClosed_Ici",
   "Set.Finite.isClosed_biUnion",
   "funext",
   "UpperSet.coe_iInf",
   "UpperSet.Ici",
   "Topology.IsLower.instClosedIciTopology",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Preorder",
   "UpperSet",
   "Set.Finite",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Eq.mpr",
   "Set.iUnion",
   "iInf",
   "Topology.IsLower",
   "upperClosure",
   "TopologicalSpace",
   "IsClosed",
   "congrArg",
   "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.1",
   "Eq.trans",
   "SetLike.coe",
   "id"],
  "name": "Topology.IsLower.isClosed_upperClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Order.Preimage",
  "constType":
  "{α : Sort u_3} → {β : Sort u_4} → (α → β) → (β → β → Prop) → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["lcProof", "PLift", "ULift", "Eq"],
  "name": "unsafeCast.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2}, ULift.{max u_1 u_2, u_1} (PLift α) = ULift.{max u_1 u_2, u_2} (PLift β)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "if_pos",
   "Eq.mpr",
   "Or",
   "Eq.ndrec",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "Eq.refl",
   "Not",
   "Or.casesOn",
   "Eq.symm",
   "if_neg",
   "id",
   "ite",
   "Eq"],
  "name": "ite_congr",
  "constType":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references": ["MonadLiftT"],
  "name": "MonadLiftT.monadLift",
  "constType":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadLiftT m n] → {α : Type u} → m α → n α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "iSup_le.match_1",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "CompleteLattice",
   "Eq.rec",
   "CompleteSemilatticeSup.toPartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sSup_le",
   "CompleteLattice.toSupSet"],
  "name": "iSup_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (∀ (i : ι), f i ≤ a) → iSup f ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Sup.sup",
   "sup_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.semilatticeSup.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → SemilatticeSup (α' i)] (x x_1 x_2 : (i : ι) → α' i),\n  x ≤ x_2 → x_1 ≤ x_2 → ∀ (i : ι), x i ⊔ x_1 i ≤ x_2 i",
  "constCategory": "Theorem"},
 {"references":
  ["instIsCommutative.proof_1",
   "Lean.IsCommutative",
   "Lean.IsCommutative.mk",
   "IsCommutative"],
  "name": "instIsCommutative",
  "constType":
  "{α : Type u_1} → {op : α → α → α} → [inst : IsCommutative α op] → Lean.IsCommutative op",
  "constCategory": "Definition"},
 {"references":
  ["cond",
   "CompleteSemilatticeInf.toPartialOrder",
   "Order.Frame.mk",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "instInhabitedPUnit",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "dite",
   "iSup",
   "le_iSup",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Iff.of_eq",
   "Mathlib.Data.Subtype._auxLemma.1",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "iSup_congr_Prop",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Bool.true",
   "iSup_const",
   "PUnit",
   "iSup_subtype",
   "le_trans",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Subtype",
   "iInf_congr_Prop",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "Classical.propDecidable",
   "Set.instMembershipSet",
   "iSup_bool_eq",
   "Order.Frame.toCompleteLattice",
   "Mathlib.Order.Lattice._auxLemma.1",
   "iInf",
   "of_eq_true",
   "Eq.mp",
   "instTransEq",
   "Not",
   "iInf_iSup_eq",
   "congrArg",
   "exists_prop_congr'",
   "congrFun",
   "iInf_subtype",
   "Exists",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_2",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "True",
   "Lattice.toInf",
   "Subtype.property",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.1",
   "Bool.not_eq_false",
   "Std.Logic._auxLemma.65",
   "Lattice.toSemilatticeSup",
   "iInf_le",
   "instNonempty",
   "id",
   "Membership.mem",
   "eq_self",
   "funext",
   "SupSet.sSup",
   "iSup_le",
   "LE.le",
   "iInf_bool_eq",
   "Bool.false",
   "CompleteLattice.toInfSet",
   "sSup_eq_iSup",
   "le_refl",
   "Sup.sup",
   "Bool",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Subtype.mk"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CompletelyDistribLattice α] (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Unit.unit",
   "Bool",
   "optParam"],
  "name": "Lean.SourceInfo.fromRef.match_2",
  "constType":
  "(motive : optParam Bool false → Sort u_1) →\n  (canonical : optParam Bool false) → (Unit → motive true) → (Unit → motive) → motive canonical",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.rec",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.Result.casesOn",
  "constType":
  "{ε σ α : Type u} →\n  {motive : EStateM.Result ε σ α → Sort u_1} →\n    (t : EStateM.Result ε σ α) →\n      ((a : α) → (a_1 : σ) → motive (EStateM.Result.ok a a_1)) →\n        ((a : ε) → (a_1 : σ) → motive (EStateM.Result.error a a_1)) → motive t",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_true_left", "propext", "True", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.41",
  "constType": "∀ (p : True → Prop), (∀ (x : True), p x) = p True.intro",
  "constCategory": "Theorem"},
 {"references": ["List.Subset", "List", "HasSubset", "HasSubset.mk"],
  "name": "List.instHasSubsetList",
  "constType": "{α : Type u_1} → HasSubset (List α)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "instDecidableNot",
   "Bool.false",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_true",
  "constType": "∀ (b : Bool), (¬b = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Inf"],
  "name": "InfHomClass",
  "constType":
  "Type u_7 →\n  (α : outParam (Type u_8)) → (β : outParam (Type u_9)) → [inst : Inf α] → [inst : Inf β] → Type (max (max u_7 u_8) u_9)",
  "constCategory": "Other"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "GaloisInsertion.liftCompleteLattice.proof_1",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "GaloisInsertion.liftCompleteLattice.proof_2",
   "GaloisInsertion.liftBoundedOrder",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice.proof_4",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "GaloisInsertion.liftCompleteLattice.proof_6",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "GaloisInsertion.choice",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.liftCompleteLattice.proof_5",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "GaloisInsertion.liftCompleteLattice.proof_7",
   "OrderBot.toBot",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisInsertion.liftCompleteLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : CompleteLattice α] → GaloisInsertion l u → CompleteLattice β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Fintype.subtype",
   "Set.instMembershipSet"],
  "name": "Fintype.ofFinset",
  "constType":
  "{α : Type u_1} → {p : Set α} → (s : Finset α) → (∀ (x : α), x ∈ s ↔ x ∈ p) → Fintype ↑p",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "instLENat",
   "Nat.lt_of_le_of_lt",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "instLTNat",
   "absurd",
   "Nat.succ",
   "rfl",
   "LE.le",
   "Eq",
   "Nat.le_antisymm.match_1"],
  "name": "Nat.le_antisymm",
  "constType": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "PartialOrder.toPreorder",
   "GaloisInsertion.liftBoundedOrder.proof_1",
   "GaloisInsertion.liftBoundedOrder.proof_2",
   "OrderBot",
   "Preorder",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "OrderTop.toTop",
   "GaloisInsertion.liftBoundedOrder.proof_3",
   "GaloisInsertion.liftOrderTop",
   "BoundedOrder.mk",
   "OrderBot.toBot",
   "GaloisConnection.liftOrderBot",
   "OrderTop",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "GaloisInsertion.liftBoundedOrder",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder β] →\n          [inst_1 : Preorder α] → [inst_2 : BoundedOrder α] → GaloisInsertion l u → BoundedOrder β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.term𝓝._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.term𝓝._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "instDecidableOr.proof_1",
   "Or.inl",
   "Or.inr",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableOr",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∨ q)",
  "constCategory": "Definition"},
 {"references":
  ["Set.eq_of_mem_singleton",
   "Membership.mem",
   "upperBounds",
   "Set.instSingletonSet",
   "Set.mem_singleton",
   "Set",
   "IsGreatest",
   "Singleton.singleton",
   "And.intro",
   "Preorder",
   "le_of_eq",
   "Set.instMembershipSet"],
  "name": "isGreatest_singleton",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, IsGreatest {a} a",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.mk",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "Inducing.rec",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [tα : TopologicalSpace α] →\n      [tβ : TopologicalSpace β] →\n        {f : α → β} →\n          {motive : Inducing f → Sort u} →\n            ((induced : tα = TopologicalSpace.induced f tβ) → motive (_ : Inducing f)) → (t : Inducing f) → motive t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "compl_compl",
   "Inf.inf",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Mathlib.Order.Filter.Basic._auxLemma.62",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "Filter.isCompl_principal",
   "Preorder.toLE",
   "True",
   "iff_self",
   "CompleteLattice.toLattice",
   "Set.compl_inter",
   "Filter.principal",
   "Iff",
   "Mathlib.Order.Filter.Basic._auxLemma.61",
   "Filter",
   "IsCompl.le_right_iff",
   "Filter.inf_principal",
   "Eq.symm",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Union.union",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "DistribLattice.toLattice",
   "IsCompl.le_left_iff",
   "Filter.instDistribLatticeFilter",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "propext",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "congr",
   "congrArg",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_principal'",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f ⊓ Filter.principal t ↔ tᶜ ∪ s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLowerSet.ofLowerSet_inj",
  "constType":
  "∀ {α : Type u_1} {a b : Topology.WithLowerSet α},\n  ↑Topology.WithLowerSet.ofLowerSet a = ↑Topology.WithLowerSet.ofLowerSet b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "And",
   "Top",
   "Prod.snd",
   "Top.top",
   "le_top",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Prod.top",
   "Top.mk",
   "LE.le"],
  "name": "Prod.orderTop.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : LE α] [inst_1 : LE β] [inst_2 : OrderTop α] [inst_3 : OrderTop β] (x : α × β),\n  x.1 ≤ ⊤.1 ∧ x.2 ≤ ⊤.2",
  "constCategory": "Theorem"},
 {"references": ["Multiset.Mem", "Multiset", "Membership.mk", "Membership"],
  "name": "Multiset.instMembershipMultiset",
  "constType": "{α : Type u_1} → Membership α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.frequently_iff",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Filter",
   "Filter.Frequently",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.42",
  "constType":
  "∀ {α : Type u} {f : Filter α} {P : α → Prop}, (∃ᶠ (x : α) in f, P x) = ∀ {U : Set α}, U ∈ f → ∃ x ∈ U, P x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "inferInstanceAs",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "PartialOrder"],
  "name": "OrderDual.semilatticeInf.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : SemilatticeSup α] (a b : αᵒᵈ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "le_of_add_le_add_left",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ s₃ : Multiset α), s₁ + s₂ ≤ s₁ + s₃ → s₂ ≤ s₃",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Classical.arbitrary",
  "constType": "(α : Sort u_2) → [h : Nonempty α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "Exists.intro",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Set.Subset.refl",
   "And",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "IsOpen.mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, IsOpen s → a ∈ s → s ∈ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "String",
   "instBEq",
   "Lean.Name.hasMacroScopes.match_1",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "Lean.Name.rec",
   "Bool.false",
   "PUnit",
   "Bool",
   "Lean.Name",
   "Nat",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "Lean.Name.hasMacroScopes",
  "constType": "Lean.Name → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.sets_of_superset",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_of_superset",
  "constType":
  "∀ {α : Type u} {f : Filter α} {x y : Set α}, x ∈ f → x ⊆ y → y ∈ f",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff"],
  "name": "Iff.refl",
  "constType": "∀ (a : Prop), a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "eq_true",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.11",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Std.Logic._auxLemma.34",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "implies_congr",
   "True",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "List",
   "forall_congr",
   "List.nil",
   "Eq.trans",
   "List.TFAE"],
  "name": "List.tfae_singleton",
  "constType": "∀ (p : Prop), List.TFAE [p]",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite",
   "Set.Finite.casesOn"],
  "name": "Set.finite_def.match_1",
  "constType":
  "∀ {α : Type u_1} {s : Set α} (motive : Set.Finite s → Prop) (x : Set.Finite s),\n  (∀ (h : Fintype ↑s), motive (_ : Set.Finite s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Or",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "GE.ge",
   "HSub.hSub",
   "Nat.mod_eq_sub_mod.match_1",
   "instDecidableAnd",
   "LE.le",
   "rfl",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "ite",
   "Eq",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "if_pos",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "LT.lt",
   "Eq.rec",
   "HMod.hMod",
   "Nat.sub_zero",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Eq.symm",
   "Nat.decLe"],
  "name": "Nat.mod_eq_sub_mod",
  "constType": "∀ {a b : ℕ}, a ≥ b → a % b = (a - b) % b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Iff", "RelIso", "FunLike.coe", "Equiv.instFunLikeEquiv"],
  "name": "RelIso.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (toEquiv : α ≃ β) → (∀ {a b : α}, s (↑toEquiv a) (↑toEquiv b) ↔ r a b) → r ≃r s",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Codisjoint",
   "SemilatticeSup",
   "OrderDual.semilatticeInf",
   "OrderDual.orderBot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderDual",
   "OrderTop",
   "Sup.sup",
   "Disjoint.eq_bot",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Codisjoint.eq_top",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α] [inst_1 : OrderTop α] {a b : α}, Codisjoint a b → a ⊔ b = ⊤",
  "constCategory": "Theorem"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.eq_or_lt_of_le.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : n = m ∨ n < m → Prop) (x : n = m ∨ n < m),\n  (∀ (h : n = m), motive (_ : n = m ∨ n < m)) → (∀ (h : n < m), motive (_ : n = m ∨ n < m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "le_antisymm",
   "mt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "propext", "or_iff_left_iff_imp", "Eq"],
  "name": "Std.Logic._auxLemma.21",
  "constType": "∀ {a b : Prop}, (a ∨ b ↔ a) = (b → a)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_top",
   "CompleteBooleanAlgebra",
   "CompleteLattice.le_sSup",
   "CompleteAtomicBooleanAlgebra.le_sup_inf",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteAtomicBooleanAlgebra.inf_sSup_le_iSup_inf",
   "CompleteAtomicBooleanAlgebra.top_le_sup_compl",
   "CompleteLattice.bot_le",
   "DistribLattice.mk",
   "CompleteLattice.sInf_le",
   "CompleteLattice.toBot",
   "CompleteAtomicBooleanAlgebra.toHImp",
   "CompleteBooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "BooleanAlgebra.mk",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "CompleteLattice.sSup_le",
   "CompleteAtomicBooleanAlgebra.sdiff_eq",
   "CompleteLattice.toInfSet",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toTop",
   "CompleteAtomicBooleanAlgebra.iInf_sup_le_sup_sInf",
   "CompleteAtomicBooleanAlgebra.toSDiff",
   "CompleteAtomicBooleanAlgebra.inf_compl_le_bot",
   "CompleteLattice.toSupSet",
   "CompleteAtomicBooleanAlgebra.himp_eq"],
  "name": "CompleteAtomicBooleanAlgebra.toCompleteBooleanAlgebra",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompleteBooleanAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "List.cons",
   "Iff",
   "List",
   "List.cons_sublist_cons.match_1",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.sublist_of_cons_sublist"],
  "name": "List.cons_sublist_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, List.Sublist (a :: l₁) (a :: l₂) ↔ List.Sublist l₁ l₂",
  "constCategory": "Theorem"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : ContravariantClass M N μ r],\n  Contravariant M N μ r",
  "constCategory": "Definition"},
 {"references": ["IsTrans", "IsTrans.trans"],
  "name": "trans",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "Eq.ge",
   "Eq.le",
   "Filter.instPartialOrderFilter",
   "le_of_nhds_le_nhds",
   "TopologicalSpace",
   "Filter",
   "le_antisymm",
   "Eq"],
  "name": "eq_of_nhds_eq_nhds",
  "constType":
  "∀ {α : Type u_1} {t₁ t₂ : TopologicalSpace α}, (∀ (x : α), nhds x = nhds x) → t₁ = t₂",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → (α → β) → Singleton α β",
  "constCategory": "Other"},
 {"references": ["Or", "propext", "or_comm", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.7",
  "constType": "∀ {a b : Prop}, (a ∨ b) = (b ∨ a)",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.32",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a b : α), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["IsAssociative.mk",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsAssociative",
   "sup_assoc",
   "Sup.sup"],
  "name": "instIsAssociativeSupToSup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α], IsAssociative α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "Prod.snd",
   "Prod.mk",
   "Set",
   "SupSet.mk",
   "Prod",
   "Prod.fst",
   "SupSet.sSup",
   "Set.image"],
  "name": "Prod.supSet",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : SupSet α] → [inst : SupSet β] → SupSet (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : ℕ) → List (Fin n)",
  "constCategory": "Definition"},
 {"references": ["PSigma", "PSigma.mk", "Quot", "Quot.mk"],
  "name": "Quot.indep",
  "constType":
  "{α : Sort u} → {r : α → α → Prop} → {motive : Quot r → Sort v} → ((a : α) → motive (Quot.mk r a)) → α → PSigma motive",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Lean.Data.AC.Context.unwrap_isNeutral.match_1",
   "Unit",
   "Lean.IsNeutral",
   "Lean.Data.AC.Context.var",
   "Eq",
   "Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable.neutral",
   "Lean.Data.AC.instEvalInformationContext",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.false",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Lean.Data.AC.Variable.value",
   "Option.some",
   "Bool",
   "Nat",
   "Option.toBool.match_1",
   "Lean.Data.AC.ContextInformation.isNeutral",
   "Lean.Data.AC.EvalInformation.evalOp",
   "id",
   "Option"],
  "name": "Lean.Data.AC.Context.unwrap_isNeutral",
  "constType":
  "{α : Sort u_1} →\n  {ctx : Lean.Data.AC.Context α} →\n    {x : ℕ} →\n      Lean.Data.AC.ContextInformation.isNeutral ctx x = true →\n        Lean.IsNeutral (Lean.Data.AC.EvalInformation.evalOp ctx) (Lean.Data.AC.EvalInformation.evalVar ctx x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_17",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (n : ℕ) (x : α),\n  AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instTopologicalSpaceWithUpper._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → (toFun : M → N) → toFun 0 = 0 → ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "List.cons",
   "PUnit.unit",
   "List.rec",
   "List.below",
   "List",
   "PUnit",
   "List.nil",
   "PProd.mk"],
  "name": "List.brecOn",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Array.empty",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "Lean.SourceInfo",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getArgs",
  "constType": "Lean.Syntax → Array Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.append",
   "Eq.refl",
   "True",
   "Eq",
   "instHAppend",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "List.append_nil",
  "constType": "∀ {α : Type u} (as : List α), as ++ [] = as",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_preimage_of_inverse.match_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {f : α → β} (s : Set α) (x : β) (motive : x ∈ f '' s → Prop) (x_1 : x ∈ f '' s),\n  (∀ (a : α) (h : a ∈ s) (e : f a = x), motive (_ : ∃ a ∈ s, f a = x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["Lean.IsCommutative", "Eq"],
  "name": "Lean.IsCommutative.comm",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : Lean.IsCommutative op] (a b : α), op a b = op b a",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Fintype", "Nonempty", "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_2",
  "constType":
  "∀ (α : Type u_1) (motive : Nonempty (Fintype α) → Prop) (x : Nonempty (Fintype α)),\n  (∀ (val : Fintype α), motive (_ : Nonempty (Fintype α))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "LT.lt", "Nat", "LE.le", "Nat.le_of_succ_le", "instLTNat"],
  "name": "Nat.le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero",
   "Bool.true",
   "Nat.beq",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.eq_of_beq_eq_true.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → Nat.beq x x_1 = true → Prop) (x x_1 : ℕ) (x_2 : Nat.beq x x_1 = true),\n  (∀ (x : Nat.beq Nat.zero Nat.zero = true), motive Nat.zero Nat.zero x) →\n    (∀ (n : ℕ) (h : Nat.beq Nat.zero (Nat.succ n) = true), motive Nat.zero (Nat.succ n) h) →\n      (∀ (n : ℕ) (h : Nat.beq (Nat.succ n) Nat.zero = true), motive (Nat.succ n) Nat.zero h) →\n        (∀ (n m : ℕ) (h : Nat.beq (Nat.succ n) (Nat.succ m) = true), motive (Nat.succ n) (Nat.succ m) h) →\n          motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "instHSub",
   "PSigma.casesOn",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "dite",
   "instSizeOfNat",
   "instDecidableAnd",
   "WellFounded.fix",
   "instLTNat",
   "LE.le",
   "instWellFoundedRelation",
   "And",
   "instLENat",
   "invImage",
   "Nat.div_rec_lemma",
   "LT.lt",
   "SizeOf.sizeOf",
   "PSigma.mk",
   "instOfNatNat",
   "Not",
   "Nat",
   "Nat.decLe"],
  "name": "Nat.div.inductionOn._unary",
  "constType":
  "{motive : ℕ → ℕ → Sort u} →\n  (_x :\n      (_ : ℕ) ×'\n        (_ : ℕ) ×'\n          (_ : (x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) ×'\n            ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y)) →\n    motive _x.1 _x.2.1",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "Lattice.toSemilatticeInf",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "HeytingAlgebra.bot_le",
   "OrderBot.mk",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "HeytingAlgebra.toBoundedOrder",
  "constType": "{α : Type u_2} → [inst : HeytingAlgebra α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq",
   "id"],
  "name": "induced_id.match_1",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α] (s : Set α) (motive : IsOpen s → Prop) (x : IsOpen s),\n  (∀ (w : Set α) (hs : IsOpen w) (h : id ⁻¹' w = s), motive (_ : ∃ s', IsOpen s' ∧ id ⁻¹' s' = s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Iff.intro",
   "Membership.mem",
   "Iff.mp",
   "Iff",
   "List.instMembershipList",
   "List",
   "List.Pairwise.imp_of_mem",
   "Iff.mpr"],
  "name": "List.Pairwise.iff_of_mem",
  "constType":
  "∀ {α : Type u_1} {R S : α → α → Prop} {l : List α},\n  (∀ {a b : α}, a ∈ l → b ∈ l → (R a b ↔ S a b)) → (List.Pairwise R l ↔ List.Pairwise S l)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LE.le",
   "ge_antisymm",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm'",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.mem_iUnion.match_2",
   "Set.mem_iUnion.match_1",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Iff.intro",
   "Set.range",
   "And",
   "Set.iUnion",
   "Iff",
   "Eq.rec",
   "And.intro",
   "Eq.symm"],
  "name": "Set.mem_iUnion",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, x ∈ ⋃ i, s i ↔ ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["instDecidableAnd.proof_2",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "And.intro",
   "instDecidableAnd.proof_1"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.nil",
   "List.noConfusion",
   "List.noConfusionType",
   "Eq"],
  "name": "List.hasDecEq.proof_3",
  "constType":
  "∀ {α : Type u_1} (head : α) (tail : List α), [] = head :: tail → List.noConfusionType False [] (head :: tail)",
  "constCategory": "Theorem"},
 {"references": ["InfSet.mk", "SupSet", "InfSet", "OrderDual", "SupSet.sSup"],
  "name": "OrderDual.infSet",
  "constType": "(α : Type u_9) → [inst : SupSet α] → InfSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.prod",
   "nhds_induced",
   "nhds_inf",
   "TopologicalSpace.induced",
   "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
   "id"],
  "name": "nhds_prod_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {a : α} {b : β},\n  nhds (a, b) = nhds a ×ˢ nhds b",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.RightInverse",
   "EquivLike.coe_injective'",
   "Eq.rec",
   "Function.LeftInverse.eq_rightInverse",
   "EquivLike.right_inv",
   "Eq.symm",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Eq"],
  "name": "EquivLike.toEmbeddingLike.proof_1",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → e = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "mem_interior",
   "Set.instMembershipSet",
   "Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "interior",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_interior_iff_mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {a : α}, a ∈ interior s ↔ s ∈ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat.add_lt_add_left",
   "Nat",
   "instLTNat"],
  "name": "Nat.lt_add_of_pos_right",
  "constType": "∀ {n k : ℕ}, 0 < k → n < n + k",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Filter.instCompleteLatticeFilter.proof_10",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Filter.instCompleteLatticeFilter.proof_11",
   "Filter.instCompleteLatticeFilter.proof_2",
   "Inf.inf",
   "Set",
   "Filter.instCompleteLatticeFilter.proof_4",
   "CompleteLattice.mk",
   "SupSet.mk",
   "Filter.generate",
   "CompleteLattice.toBot",
   "Lattice.mk",
   "Filter.join",
   "Filter.instCompleteLatticeFilter.proof_7",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Preorder.toLT",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.mem_inf_of_right",
   "Filter.instCompleteLatticeFilter.proof_5",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.proof_12",
   "Membership.mem",
   "Filter.sets",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPartialOrder",
   "Filter.instCompleteLatticeFilter.proof_8",
   "Top.top",
   "Function.comp",
   "SemilatticeSup.mk",
   "Filter.instCompleteLatticeFilter.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter.instCompleteLatticeFilter.proof_9",
   "Filter.instCompleteLatticeFilter.proof_1",
   "Filter.instCompleteLatticeFilter.proof_6",
   "Top.mk",
   "Filter.mem_inf_of_left"],
  "name": "Filter.instCompleteLatticeFilter",
  "constType": "{α : Type u} → CompleteLattice (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Disjoint.le_bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Function.comp",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "bot_unique",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Disjoint.eq_bot",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b → a ⊓ b = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["Set.instSingletonSet",
   "Set",
   "IsGreatest.isLUB",
   "isGreatest_singleton",
   "Singleton.singleton",
   "Preorder",
   "IsLUB"],
  "name": "isLUB_singleton",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, IsLUB {a} a",
  "constCategory": "Theorem"},
 {"references": ["Top", "top_nonempty.proof_1", "Nonempty"],
  "name": "top_nonempty",
  "constType": "∀ (α : Type u) [inst : Top α], Nonempty α",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.mk",
  "constType":
  "{m : Type → Type} → m Lean.Syntax → ({α : Type} → Lean.Syntax → m α → m α) → Lean.MonadRef m",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Filter.HasBasis",
   "Equiv.surjective",
   "Function.comp",
   "Set",
   "Filter",
   "FunLike.coe",
   "Filter.HasBasis.comp_surjective",
   "Equiv.instFunLikeEquiv"],
  "name": "Filter.HasBasis.comp_equiv",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ (e : ι' ≃ ι), Filter.HasBasis l (p ∘ ↑e) (s ∘ ↑e)",
  "constCategory": "Theorem"},
 {"references": ["BEq", "Bool"],
  "name": "BEq.beq",
  "constType": "{α : Type u} → [self : BEq α] → α → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["isLowerSet_univ", "IsLowerSet", "Preorder", "Set.univ", "Preorder.toLE"],
  "name": "Topology.lowerSet.proof_1",
  "constType": "∀ (α : Type u_1) [inst : Preorder α], IsLowerSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Nat.sub_lt_left_of_lt_add",
   "instSubNat",
   "Nat.add_sub_cancel'",
   "List.instMembershipList",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat.add_lt_add_left",
   "instLTNat",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "List.mem_range'_1.match_2",
   "Eq.rec",
   "instOfNatNat",
   "Nat",
   "Std.Data.List.Lemmas._auxLemma.107",
   "List.mem_range'_1.match_1",
   "Eq.symm",
   "Eq.trans",
   "id",
   "instHSub",
   "Membership.mem",
   "funext",
   "instAddNat",
   "List.range'",
   "Nat.le_add_right",
   "instHAdd",
   "HSub.hSub",
   "LE.le",
   "Iff.intro",
   "And",
   "instHMul",
   "Nat.one_mul",
   "List",
   "LT.lt",
   "HMul.hMul",
   "And.intro",
   "instMulNat",
   "congrArg",
   "congrFun"],
  "name": "List.mem_range'_1",
  "constType": "∀ {m s n : ℕ}, m ∈ List.range' s n ↔ s ≤ m ∧ m < s + n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "id"],
  "name": "Set.Subset.refl",
  "constType": "∀ {α : Type u} (a : Set α), a ⊆ a",
  "constCategory": "Theorem"},
 {"references": ["IsRefl", "IsRefl.refl"],
  "name": "refl",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [inst : IsRefl α r] (a : α), r a a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Iff",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : Topology.WithUpperSet α},\n  ↑Topology.WithUpperSet.ofUpperSet a ≤ ↑Topology.WithUpperSet.ofUpperSet b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_7",
   "List.cons",
   "_obj",
   "_neutral",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_5"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "LE",
   "Inter.inter",
   "And.imp",
   "IsUpperSet",
   "LE.le",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "IsUpperSet.inter",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s t : Set α}, IsUpperSet s → IsUpperSet t → IsUpperSet (s ∩ t)",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Eq"],
  "name": "Eq.ndrecOn",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → {b : α} → a = b → motive a → motive b",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "Not", "not_and", "Eq"],
  "name": "Std.Logic._auxLemma.24",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (a → ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "PartialOrder.le_antisymm",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_4",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CoheytingAlgebra",
   "Mathlib.Order.Heyting.Basic._auxLemma.27",
   "Top.top",
   "Inf.inf",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "True",
   "sdiff_inf_distrib",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Lattice.toInf",
   "Eq.mpr",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "CoheytingAlgebra.toHNot",
   "congrFun",
   "id"],
  "name": "hnot_inf_distrib",
  "constType":
  "∀ {α : Type u_2} [inst : CoheytingAlgebra α] (a b : α), ￢(a ⊓ b) = ￢a ⊔ ￢b",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "himp_eq",
   "HasCompl.compl",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "BooleanAlgebra.toBiheytingAlgebra",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice"],
  "name": "Pi.booleanAlgebra.proof_7",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → BooleanAlgebra (α i)] (x x_1 : (i : ι) → α i), x ⇨ x_1 = x_1 ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "List.elem",
   "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "Decidable.decide",
   "PProd",
   "BEq.beq",
   "List.rec",
   "Bool.true",
   "PUnit",
   "List.nil",
   "List.erase.match_1",
   "Eq.symm",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Membership.mem",
   "List.cons",
   "False",
   "decide_eq_true_eq",
   "Unit",
   "List.Mem.tail",
   "instBEq",
   "eq_false_of_decide",
   "List.mem_of_elem_eq_true.match_1",
   "PProd.fst",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "Bool.false",
   "List",
   "Eq.mp",
   "List.Mem.head",
   "Bool"],
  "name": "List.mem_of_elem_eq_true",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {as : List α}, List.elem a as = true → a ∈ as",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Homeomorph._hyg.17",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "Prod",
   "Prod.boundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_8",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (a : α × β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false",
   "Unit",
   "Bool.true",
   "Bool",
   "Option.toBool.match_1",
   "Option"],
  "name": "Option.isSome",
  "constType": "{α : Type u_1} → Option α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.exists_mem_subset_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {f : Filter α} {s : Set α} (motive : (∃ t ∈ f, t ⊆ s) → Prop) (x : ∃ t ∈ f, t ⊆ s),\n  (∀ (w : Set α) (ht : w ∈ f) (ts : w ⊆ s), motive (_ : ∃ t ∈ f, t ⊆ s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Nodup",
   "List.not_nodup_cons_of_mem",
   "Not",
   "List.nil",
   "List.mem_singleton_self"],
  "name": "List.not_nodup_pair",
  "constType": "∀ {α : Type u} (a : α), ¬List.Nodup [a, a]",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "funext",
   "Function.comp",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "Eq",
   "id",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.self_comp_symm",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), ↑e ∘ ↑e.symm = id",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.14",
  "constType": "∀ {α : Type u} (x : α), (x ∈ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Iff.intro",
   "Filter.filter_eq",
   "Iff",
   "congr_arg",
   "Set",
   "Filter",
   "Eq"],
  "name": "Filter.filter_eq_iff",
  "constType": "∀ {α : Type u} {f g : Filter α}, f = g ↔ f.sets = g.sets",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "namedPattern",
  "constType": "{α : Sort u} → (x a : α) → x = a → α",
  "constCategory": "Definition"},
 {"references":
  ["List.forall_mem_ne",
   "Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.1",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, (∀ a' ∈ l, ¬a = a') = ¬a ∈ l",
  "constCategory": "Theorem"},
 {"references": ["Order.Frame", "CompleteLattice"],
  "name": "Order.Frame.toCompleteLattice",
  "constType": "{α : Type u_1} → [self : Order.Frame α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Fintype.ofBijective",
   "Fintype",
   "Equiv.bijective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Fintype.ofEquiv",
  "constType":
  "{β : Type u_2} → (α : Type u_4) → [inst : Fintype α] → α ≃ β → Fintype β",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Set.instSingletonSet",
   "of_eq_true",
   "Set",
   "Singleton.singleton",
   "Set.image_insert_eq",
   "Set.image",
   "Set.image_singleton",
   "congrArg",
   "Insert.insert",
   "Eq.trans",
   "True",
   "congrFun",
   "Set.instInsertSet",
   "Eq"],
  "name": "Set.image_pair",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a b : α), f '' {a, b} = {f a, f b}",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.Perm.subperm_left.match_1",
  "constType":
  "∀ {α : Type u_1} {l l₁ : List α} (motive : l <+~ l₁ → Prop) (x : l <+~ l₁),\n  (∀ (_u : List α) (pu : _u ~ l) (su : List.Sublist _u l₁), motive (_ : ∃ l_1, ∃ (_ : l_1 ~ l), List.Sublist l_1 l₁)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_9",
   "List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_11",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "String.Pos.mk",
   "String",
   "instOfNatNat",
   "Substring.mk",
   "Nat",
   "Substring",
   "String.endPos"],
  "name": "String.toSubstring",
  "constType": "String → Substring",
  "constCategory": "Definition"},
 {"references": ["List", "List.Chain.imp'", "List.Chain"],
  "name": "List.Chain.imp",
  "constType":
  "∀ {α : Type u_1} {R S : α → α → Prop},\n  (∀ (a b : α), R a b → S a b) → ∀ {a : α} {l : List α}, List.Chain R a l → List.Chain S a l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context.idem",
   "Lean.Data.AC.Variable.neutral",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.Context.comm",
   "Lean.IsCommutative",
   "Lean.Data.AC.Variable.value",
   "Lean.Data.AC.ContextInformation",
   "Lean.Data.AC.ContextInformation.mk",
   "Lean.IsNeutral",
   "Nat",
   "Lean.IsIdempotent",
   "Lean.Data.AC.Context.var",
   "Option.isSome"],
  "name": "Lean.Data.AC.instContextInformationContext",
  "constType":
  "{α : Sort u_1} → Lean.Data.AC.ContextInformation (Lean.Data.AC.Context α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Iff",
   "List.mem_of_elem_eq_true",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Bool.true",
   "instBEq",
   "Bool",
   "List.elem",
   "List.elem_eq_true_of_mem",
   "Eq"],
  "name": "List.instDecidableMemListInstMembershipList.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (as : List α), List.elem a as = true ↔ a ∈ as",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Not", "mt", "Iff.mpr"],
  "name": "not_congr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.ilast'.match_1",
   "List.nil"],
  "name": "List.ilast'",
  "constType": "{α : Type u_1} → α → List α → α",
  "constCategory": "Definition"},
 {"references": ["Top", "outParam", "Inf"],
  "name": "InfTopHomClass",
  "constType":
  "Type u_7 →\n  (α : outParam (Type u_8)) →\n    (β : outParam (Type u_9)) →\n      [inst : Inf α] → [inst : Inf β] → [inst : Top α] → [inst : Top β] → Type (max (max u_7 u_8) u_9)",
  "constCategory": "Other"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.rec",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpper α → Sort u} →\n        ((topology_eq_upperTopology : t = Topology.upper α) → motive (_ : Topology.IsUpper α)) →\n          (t : Topology.IsUpper α) → motive t",
  "constCategory": "Other"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x, ∃ y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references": ["List.Pairwise", "List"],
  "name": "List.Pairwise.below",
  "constType":
  "{α : Type u_1} →\n  {R : α → α → Prop} → {motive : (a : List α) → List.Pairwise R a → Prop} → {a : List α} → List.Pairwise R a → Prop",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Set",
   "Topology.IsUpper",
   "Eq.refl",
   "IsUpperSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "Topology.IsUpper.isUpperSet_of_isOpen",
   "IsOpen",
   "id"],
  "name": "Topology.IsUpperSet.upperSet_le_upper",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {t₁ t₂ : TopologicalSpace α} [inst_1 : Topology.IsUpperSet α]\n  [inst : Topology.IsUpper α], t₁ ≤ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.le_of_lt_succ",
  "constType": "∀ {m n : ℕ}, m < Nat.succ n → m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Exists.intro",
   "Quot",
   "rfl",
   "Quot.inductionOn",
   "Quot.mk",
   "Eq"],
  "name": "Quot.exists_rep",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (q : Quot r), ∃ a, Quot.mk r a = q",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet.toDualHomeomorph._lambda_1",
   "_obj",
   "Function.comp._rarg",
   "_neutral",
   "Topology.WithLowerSet.map._elambda_1"],
  "name": "Topology.WithLowerSet.map._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«termI^_»._closed_2",
   "Topology.«termI^_»._closed_1"],
  "name": "Topology.«termI^_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.attach.proof_1",
   "Multiset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Subtype"],
  "name": "Finset.attach",
  "constType": "{α : Type u_1} → (s : Finset α) → Finset { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "Lattice",
   "LE.le",
   "Pi.semilatticeInf",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.lattice.proof_6",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b c : (i : ι) → α' i),\n  a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "SupSet",
   "sInfHom.toFun",
   "Set",
   "sInfHom.map_sInf'",
   "InfSet.sInf",
   "OrderDual.infSet",
   "OrderDual",
   "Set.image",
   "Eq"],
  "name": "sSupHom.dual.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SupSet α] [inst_1 : SupSet β] (f : sInfHom αᵒᵈ βᵒᵈ) (s : Set αᵒᵈ),\n  sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Continuous_of._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Continuous_of._closed_10"],
  "name": "Topology.Continuous_of._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection", "Preorder", "LE.le", "Preorder.toLE", "Iff.mpr"],
  "name": "GaloisConnection.l_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ {a : α} {b : β}, a ≤ u b → l a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["String.Pos.mk", "String", "String.utf8ByteSize", "String.Pos"],
  "name": "String.endPos",
  "constType": "String → String.Pos",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "SemilatticeInf.toPartialOrder",
   "Pi.heytingAlgebra.proof_2",
   "OrderBot",
   "Pi.generalizedHeytingAlgebra",
   "Pi.heytingAlgebra.proof_4",
   "Pi.heytingAlgebra.proof_3",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Pi.hasCompl",
   "Pi.orderBot",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.mk",
   "Pi.hasLe",
   "GeneralizedHeytingAlgebra",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot",
   "Pi.heytingAlgebra.proof_1",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Pi.heytingAlgebra",
  "constType":
  "{ι : Type u_1} → {α : ι → Type u_4} → [inst : (i : ι) → HeytingAlgebra (α i)] → HeytingAlgebra ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.left_mem_Ici",
   "Set",
   "LE.le.trans",
   "HasSubset.Subset",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Ici_subset_Ici",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Ici a ⊆ Set.Ici b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Seq", "Applicative", "SeqRight", "Functor", "Pure", "SeqLeft"],
  "name": "Applicative.mk",
  "constType":
  "{f : Type u → Type v} →\n  [toFunctor : Functor f] →\n    [toPure : Pure f] → [toSeq : Seq f] → [toSeqLeft : SeqLeft f] → [toSeqRight : SeqRight f] → Applicative f",
  "constCategory": "Other"},
 {"references":
  ["eq_true", "List.Perm", "List.Perm.refl", "List", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.1",
  "constType": "∀ {α : Type uu} (l : List α), (l ~ l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "nhdsAdjoint.proof_1",
   "Set",
   "TopologicalSpace",
   "Filter",
   "nhdsAdjoint.proof_2",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint",
  "constType": "{α : Type u} → α → Filter α → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["funext", "FunLike", "FunLike.coe", "FunLike.coe_injective'", "Eq"],
  "name": "FunLike.ext",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : FunLike F α β] (f g : F), (∀ (x : α), ↑f x = ↑g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.generalizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.heytingAlgebra.proof_2",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → HeytingAlgebra (α i)] (a b c : (i : ι) → α i),\n  a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "OrderDual",
   "OrderBot.bot_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "OrderDual.boundedOrder"],
  "name": "OrderDual.completeLattice.proof_5",
  "constType": "∀ (α : Type u_1) [inst : CompleteLattice α] (a : αᵒᵈ), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "Iff",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "LE.le",
   "sup_le_iff",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b ⊓ c ↔ a ≤ b ∧ a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Std.Logic._auxLemma.34",
   "List.instMembershipList",
   "List.Sublist",
   "List.casesOn",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "List.map_get_sublist",
   "implies_congr",
   "instLTNat",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "false_implies",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "Std.Data.List.Basic._auxLemma.3",
   "Iff",
   "and_false",
   "eq_false'",
   "forall_congr",
   "List.sublist_eq_map_get",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "List.cons",
   "False",
   "Fin.val",
   "implies_true",
   "List.length",
   "and_true",
   "instLTFin",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "eq_true",
   "False.elim",
   "Eq.ndrec",
   "of_eq_true",
   "Fin.lt_def",
   "propext",
   "List",
   "LT.lt",
   "Eq.mp",
   "List.pairwise_iff_get.match_1",
   "congr",
   "List.map",
   "List.noConfusion",
   "List.get",
   "congrArg",
   "List.cons.injEq",
   "and_self",
   "Fin",
   "List.pairwise_iff_forall_sublist"],
  "name": "List.pairwise_iff_get",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {l : List α},\n  List.Pairwise R l ↔ ∀ (i j : Fin (List.length l)), i < j → R (List.get l i) (List.get l j)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_toLowerSet",
  "constType":
  "∀ {α : Type u_1} (a : α), ↑Topology.WithLowerSet.ofLowerSet (↑Topology.WithLowerSet.toLowerSet a) = a",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_false_of_eq_true.match_1",
  "constType":
  "∀ (motive : (x : Bool) → x = true → Prop) (x : Bool) (x_1 : x = true),\n  (∀ (x : true = true), motive true x) → (∀ (h : false = true), motive false h) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_2",
  "constType":
  "∀ {α : Type u_1} (f : Filter (Filter α)) {x y : Set α}, x ∈ {s | {t | s ∈ t} ∈ f} → x ⊆ y → {t | y ∈ t} ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["BEq.beq",
   "Lean.Syntax.isOfKind",
   "and",
   "Lean.Syntax.getNumArgs",
   "Lean.SyntaxNodeKind",
   "instBEqNat",
   "Bool",
   "Nat",
   "Lean.Syntax"],
  "name": "Lean.Syntax.isNodeOf",
  "constType": "Lean.Syntax → Lean.SyntaxNodeKind → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_left",
  "constType": "∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "and_assoc.match_1",
  "constType":
  "∀ {a b c : Prop} (motive : (a ∧ b) ∧ c → Prop) (x : (a ∧ b) ∧ c),\n  (∀ (ha : a) (hb : b) (hc : c), motive (_ : (a ∧ b) ∧ c)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "sSupHom.mk",
   "OrderDual.toDual",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "rfl",
   "Eq",
   "sSupHom.ext",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "OrderDual.ofDual",
   "sInfHom.map_sInf'",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : SupSet α] [inst_1 : SupSet β] (x : sSupHom α β),\n  (fun f ↦\n        { toFun := ↑OrderDual.ofDual ∘ ↑f ∘ ↑OrderDual.toDual,\n          map_sSup' := (_ : ∀ (s : Set αᵒᵈ), sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)) })\n      ((fun f ↦\n          { toFun := ↑OrderDual.toDual ∘ ↑f ∘ ↑OrderDual.ofDual,\n            map_sInf' := (_ : ∀ (s : Set α), sSupHom.toFun f (sSup s) = sSup (f.toFun '' s)) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_16",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "IsLowerSet",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "lowerClosure_min.match_1",
   "HasSubset.Subset",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "lowerClosure_min",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s t : Set α}, s ⊆ t → IsLowerSet t → ↑(lowerClosure s) ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "Filter.rec",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.casesOn",
  "constType":
  "{α : Type u_1} →\n  {motive : Filter α → Sort u} →\n    (t : Filter α) →\n      ((sets : Set (Set α)) →\n          (univ_sets : Set.univ ∈ sets) →\n            (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets) →\n              (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) →\n                motive\n                  { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset,\n                    inter_sets := inter_sets }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.mk",
   "SemilatticeInf.toPartialOrder",
   "Lattice.mk",
   "OrderDual.distribLattice",
   "Lattice.le_inf",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DistribLattice.le_sup_inf",
   "OrderDual",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "DistribLattice.ofInfSupLe.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Lattice α] (inf_sup_le : ∀ (a b c : α), a ⊓ (b ⊔ c) ≤ a ⊓ b ⊔ a ⊓ c) (x y z : αᵒᵈᵒᵈ),\n  (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.casesOn",
   "Eq"],
  "name": "Topology.IsLowerSet.noConfusionType",
  "constType":
  "{α : Type u_4} →\n  {t : TopologicalSpace α} → {inst : Preorder α} → Sort u → Topology.IsLowerSet α → Topology.IsLowerSet α → Sort u",
  "constCategory": "Definition"},
 {"references": ["OrderedCancelAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedCancelAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.rec", "le_refl", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff.rfl",
   "antitone_comp_ofDual_iff",
   "Function.comp",
   "Eq.refl",
   "FunLike.coe",
   "Preorder",
   "Iff.mpr",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "monotone_toDual_comp_iff",
   "Monotone",
   "OrderDual",
   "Antitone",
   "id"],
  "name": "Monotone.dual",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → Monotone (↑OrderDual.toDual ∘ f ∘ ↑OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Syntax.Preresolved",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["HEq",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Iff.rfl",
   "Eq.refl",
   "True",
   "Eq",
   "Iff",
   "true_or",
   "List.Mem.casesOn",
   "Iff.trans",
   "And.casesOn",
   "Eq.symm",
   "Eq.trans",
   "List.TFAE",
   "Membership.mem",
   "eq_self",
   "Or",
   "List.cons",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Iff.symm",
   "Iff.intro",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "List",
   "List.Mem.head",
   "And.intro",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "List.tfae_cons_of_mem",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, b ∈ l → (List.TFAE (a :: l) ↔ (a ↔ b) ∧ List.TFAE l)",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsAssociative", "Eq"],
  "name": "Lean.IsAssociative.mk",
  "constType":
  "{α : Sort u} → {op : α → α → α} → (∀ (a b c : α), op (op a b) c = op a (op b c)) → Lean.IsAssociative op",
  "constCategory": "Other"},
 {"references":
  ["FinsetCoe.fintype",
   "Finset.cons_induction_on",
   "Membership.mem",
   "Exists",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set",
   "CanLift.prf",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Insert.insert",
   "Exists.casesOn",
   "Set.toFinite",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.Elem",
   "Finset.toSet",
   "Finset",
   "Finset.cons",
   "Not",
   "Finset.coe_empty",
   "Finset.coe_cons",
   "Finite.of_fintype",
   "id",
   "Set.instInsertSet"],
  "name": "Set.Finite.induction_on",
  "constType":
  "∀ {α : Type u} {C : Set α → Prop} {s : Set α},\n  Set.Finite s → C ∅ → (∀ {a : α} {s : Set α}, ¬a ∈ s → Set.Finite s → C s → C (insert a s)) → C s",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "LE.le",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder β] (f : α → β),\n  Function.Injective f → ∀ (x x_1 : α), x ≤ x_1 → x_1 ≤ x → x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAppend",
   "Or",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_append",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {a : α} {s t : List α}, (a ∈ s ++ t) = (a ∈ s ∨ a ∈ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "IsLowerSet",
   "Topology.WithLowerSet",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.isLowerSet_toLowerSet_preimage",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set (Topology.WithLowerSet α)},\n  IsLowerSet (↑Topology.WithLowerSet.toLowerSet ⁻¹' s) ↔ IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Subtype.rec", "Subtype.mk", "Subtype"],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive { val := val, property := property }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_3",
   "_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Membership.mem",
   "isClosed_Ici",
   "Topology.IsLower.instClosedIciTopology",
   "Set",
   "Eq.ge",
   "Preorder",
   "Set.Ici",
   "subset_closure",
   "rfl",
   "Eq",
   "Set.instMembershipSet",
   "isClosed_closure",
   "Set.instSingletonSet",
   "Topology.IsLower",
   "TopologicalSpace",
   "Singleton.singleton",
   "closure_minimal",
   "IsUpperSet.Ici_subset",
   "Set.Subset.antisymm",
   "Topology.IsLower.isUpperSet_of_isClosed"],
  "name": "Topology.IsLower.closure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α] (a : α),\n  closure {a} = Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.rec",
   "Nat.zero",
   "Nat.pred",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "congrArg",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_sub_succ_eq_sub",
  "constType": "∀ (n m : ℕ), Nat.succ n - Nat.succ m = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.ble_succ_eq_true.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → Nat.ble x x_1 = true → Prop) (x x_1 : ℕ) (x_2 : Nat.ble x x_1 = true),\n  (∀ (x : ℕ) (x_3 : Nat.ble 0 x = true), motive 0 x x_3) →\n    (∀ (n n_1 : ℕ) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) →\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.29",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Char.mk", "UInt32", "Char", "UInt32.isValidChar", "Char.rec"],
  "name": "Char.casesOn",
  "constType":
  "{motive : Char → Sort u} →\n  (t : Char) → ((val : UInt32) → (valid : UInt32.isValidChar val) → motive { val := val, valid := valid }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Bool",
   "absurd",
   "rfl",
   "decide_eq_true.match_1",
   "Eq"],
  "name": "decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], p → decide p = true",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Fin.val",
   "Iff.rfl",
   "LT.lt",
   "Nat",
   "instLTNat",
   "instLTFin",
   "Fin"],
  "name": "Fin.lt_def",
  "constType": "∀ {n : ℕ} {a b : Fin n}, a < b ↔ ↑a < ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "False",
   "List.brecOn",
   "List.below",
   "Lean.Data.AC.EvalInformation",
   "Unit",
   "Eq.refl",
   "Eq",
   "PProd",
   "PUnit.unit",
   "Eq.mpr",
   "PProd.fst",
   "Lean.Data.AC.evalList",
   "List.rec",
   "List",
   "PUnit",
   "Lean.Data.AC.EvalInformation.evalVar",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList.match_1.eq_3",
   "List.nil",
   "Nat",
   "Lean.Data.AC.EvalInformation.arbitrary",
   "congrArg",
   "Lean.Data.AC.evalList.match_1",
   "PProd.mk",
   "Lean.Data.AC.EvalInformation.evalOp",
   "congrFun",
   "id"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
  "constType":
  "∀ {α : Sort u_1} (β : Sort u) [inst : Lean.Data.AC.EvalInformation α β] (ctx : α) (x_1 : ℕ) (xs : List ℕ),\n  (xs = [] → False) →\n    Lean.Data.AC.evalList β ctx (x_1 :: xs) =\n      Lean.Data.AC.EvalInformation.evalOp ctx (Lean.Data.AC.EvalInformation.evalVar ctx x_1)\n        (Lean.Data.AC.evalList β ctx xs)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.«termI^_»._closed_9"],
  "name": "Topology.«termI^_»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.length_le",
   "List.filter",
   "instLENat",
   "List",
   "List.filter_sublist",
   "Bool",
   "List.length",
   "Nat",
   "LE.le"],
  "name": "List.length_filter_le",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (l : List α), List.length (List.filter p l) ≤ List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "himp_eq",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.filterMap",
   "List.Perm",
   "List.filterMap_eq_map",
   "List.filterMap",
   "List",
   "Function.comp",
   "Eq.rec",
   "Option.some",
   "List.map",
   "Eq",
   "Option"],
  "name": "List.Perm.map",
  "constType":
  "∀ {α : Type uu} {β : Type vv} (f : α → β) {l₁ l₂ : List α}, l₁ ~ l₂ → List.map f l₁ ~ List.map f l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_le",
   "IsGLB",
   "upperBounds",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "le_sInf",
   "And.intro",
   "CompleteSemilatticeInf",
   "Set.instMembershipSet"],
  "name": "isGLB_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] (s : Set α), IsGLB s (sInf s)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "EmptyCollection.emptyCollection",
   "and_iff_left",
   "Set.Subset.antisymm_iff",
   "Set",
   "Set.empty_subset",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Set.subset_empty_iff",
  "constType": "∀ {α : Type u} {s : Set α}, s ⊆ ∅ ↔ s = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt.match_1",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "le_refl",
   "LinearOrder.toPartialOrder",
   "Not",
   "le_of_lt",
   "absurd",
   "LE.le",
   "Preorder.toLE",
   "lt_trichotomy",
   "Eq"],
  "name": "le_of_not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "Or", "Not", "And.left", "mt", "Or.elim"],
  "name": "not_and_of_not_or_not",
  "constType": "∀ {a b : Prop}, ¬a ∨ ¬b → ¬(a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddMonoidHom.rec",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.casesOn",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {motive : (M →+ N) → Sort u} →\n          (t : M →+ N) →\n            ((toZeroHom : ZeroHom M N) →\n                (map_add' :\n                    ∀ (x y : M),\n                      ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n                  motive { toZeroHom := toZeroHom, map_add' := map_add' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references": ["Function.comp", "rfl", "Eq", "id"],
  "name": "Function.comp.left_id",
  "constType": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), id ∘ f = f",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_5"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.gc_map_comap",
   "GaloisConnection.l_u_le",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.map_comap_le",
  "constType":
  "∀ {α : Type u} {β : Type v} {g : Filter β} {m : α → β}, Filter.map m (Filter.comap m g) ≤ g",
  "constCategory": "Theorem"},
 {"references": ["String", "UInt64"],
  "name": "String.hash",
  "constType": "String → UInt64",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "∀ {α : Type u_1} (x y : Set α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "eq_true", "List.Perm", "List", "List.Perm.swap", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.14",
  "constType":
  "∀ {α : Type uu} (x y : α) (l : List α), (y :: x :: l ~ x :: y :: l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.completeLattice.proof_8",
   "CompleteSemilatticeInf.toPartialOrder",
   "Prod.completeLattice.proof_4",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Prod.completeLattice.proof_3",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Prod.infSet",
   "Prod.supSet",
   "Prod.completeLattice.proof_5",
   "Prod.boundedOrder",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "Prod.completeLattice.proof_2",
   "Prod.lattice",
   "Prod.completeLattice.proof_7",
   "InfSet",
   "SupSet.sSup",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderBot.toBot",
   "Prod.completeLattice.proof_6",
   "Prod",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Prod.completeLattice.proof_9",
   "Prod.completeLattice.proof_1"],
  "name": "Prod.completeLattice",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : CompleteLattice α] → [inst : CompleteLattice β] → CompleteLattice (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "Eq.rec",
   "exists_eq_left.match_1",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq"],
  "name": "exists_eq_left",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "OfNat",
   "instOfNatNat",
   "OfNat.mk",
   "Nat",
   "Fin",
   "Fin.ofNat"],
  "name": "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
  "constType": "{n i : ℕ} → OfNat (Fin (n + 1)) i",
  "constCategory": "Definition"},
 {"references":
  ["Option.some.injEq",
   "Exists",
   "False",
   "HEq",
   "List.get?_len_le",
   "Eq.refl",
   "Option.noConfusion",
   "Exists.intro",
   "List.length",
   "List.get?_eq_get",
   "List.get?_eq_some.match_1",
   "LE.le",
   "instLTNat",
   "Eq",
   "Iff.intro",
   "Iff",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Option.none",
   "List",
   "Eq.rec",
   "LT.lt",
   "Eq.mp",
   "Option.some",
   "Eq.casesOn",
   "Nat.lt_of_not_le",
   "Nat",
   "List.get?",
   "List.get",
   "Fin.mk",
   "Option"],
  "name": "List.get?_eq_some",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} {n : ℕ},\n  List.get? l n = some a ↔ ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "List.instMembershipList",
   "List",
   "List.attach",
   "True",
   "Subtype",
   "Eq",
   "List.mem_attach"],
  "name": "Mathlib.Data.List.Basic._auxLemma.62",
  "constType":
  "∀ {α : Type u} (l : List α) (x : { x // x ∈ l }), (x ∈ List.attach l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "List.cons",
   "List.filterMap",
   "Unit",
   "Eq.refl",
   "List.Perm.rec",
   "Option.casesOn",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "True",
   "Eq",
   "Mathlib.Data.List.Perm._auxLemma.13",
   "eq_true",
   "List.Perm",
   "Eq.ndrec",
   "of_eq_true",
   "Mathlib.Data.List.Perm._auxLemma.14",
   "List.filterMap_cons.match_1",
   "List.filterMap_cons_none",
   "List",
   "Option.none",
   "congr",
   "List.Perm.trans",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option"],
  "name": "List.Perm.filterMap",
  "constType":
  "∀ {α : Type uu} {β : Type vv} (f : α → Option β) {l₁ l₂ : List α}, l₁ ~ l₂ → List.filterMap f l₁ ~ List.filterMap f l₂",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "Preorder",
   "LE.le",
   "bot_le",
   "Preorder.toLE",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisConnection.liftOrderBot.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : OrderBot α] [inst_2 : PartialOrder β] {l : α → β}\n  {u : β → α}, GaloisConnection l u → ∀ (x : β), l ⊥ ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower.toDualHomeomorph._lambda_1", "_obj"],
  "name": "Topology.WithLower.toDualHomeomorph._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "le_sup_left",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod",
   "Sup.sup",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] (x x_1 : α × β),\n  x.1 ≤ (x ⊔ x_1).1 ∧ x.2 ≤ (x ⊔ x_1).2",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.casesOn",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.bind.match_1",
  "constType":
  "{ε σ α : Type u_1} →\n  (motive : EStateM.Result ε σ α → Sort u_2) →\n    (x : EStateM.Result ε σ α) →\n      ((a : α) → (s : σ) → motive (EStateM.Result.ok a s)) →\n        ((e : ε) → (s : σ) → motive (EStateM.Result.error e s)) → motive x",
  "constCategory": "Definition"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.Equiv",
  "constType": "{α : Sort u} → [self : HasEquiv α] → α → α → Sort v",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsCommutative",
  "constType": "{α : Sort u} → (α → α → α) → Type",
  "constCategory": "Other"},
 {"references":
  ["Not.elim",
   "List.pwFilter_subset",
   "List.find?_some",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "Or.resolve_right",
   "dite",
   "Std.Logic._auxLemma.64",
   "Std.Logic._auxLemma.45",
   "implies_congr",
   "Eq",
   "Decidable.decide",
   "Std.Data.List.Pairwise._auxLemma.14",
   "Eq.mpr",
   "List.pairwise_filterMap.match_1",
   "Iff",
   "Iff.mp",
   "List.rec",
   "List.decidableBAll",
   "List.pwFilter_cons_of_pos",
   "Option.none",
   "instDecidableNot",
   "forall_congr",
   "Bool.true",
   "Eq.rec",
   "Option.some",
   "Bool.not_eq_true'",
   "List.pwFilter",
   "List.nil",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Option",
   "Membership.mem",
   "List.cons",
   "Or",
   "not",
   "List.not_mem_nil",
   "Std.Logic._auxLemma.23",
   "List.pwFilter_cons_of_neg",
   "decide_not",
   "Iff.intro",
   "List.find?",
   "And",
   "Eq.ndrec",
   "False.elim",
   "List.find?_eq_none",
   "propext",
   "Bool.false",
   "List",
   "Eq.mp",
   "Std.Logic._auxLemma.58",
   "Not",
   "Bool",
   "And.intro",
   "congrArg",
   "decide_eq_true_iff",
   "List.mem_of_find?_eq_some",
   "congrFun",
   "DecidableRel"],
  "name": "List.forall_mem_pwFilter",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R],\n  (∀ {x y z : α}, R x z → R x y ∨ R y z) → ∀ (a : α) (l : List α), (∀ b ∈ List.pwFilter R l, R a b) ↔ ∀ b ∈ l, R a b",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.length_le",
   "List.filter",
   "List.Sublist",
   "List.Sublist.filter",
   "List.length",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "List",
   "congr",
   "Bool",
   "Nat",
   "List.countP",
   "congrArg",
   "id",
   "List.countP_eq_length_filter"],
  "name": "List.Sublist.countP_le",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.countP p l₁ ≤ List.countP p l₂",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsUpperSet.WithUpperSetHomeomorph._rarg", "_neutral"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "BEq",
   "List.brecOn",
   "List.below",
   "Unit",
   "List.beq.match_1",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "List.rec",
   "List",
   "and",
   "Bool.false",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil"],
  "name": "List.beq",
  "constType": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Set.instHasSubsetSet",
   "Eq.rec",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter.generate",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), (Filter.generate s).sets = s → ∀ {x y : Set α}, x ∈ s → x ⊆ y → y ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.rec"],
  "name": "List.Sublist.casesOn",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop} {a a_1 : List α} (t : List.Sublist a a_1),\n  motive [] [] (_ : List.Sublist [] []) →\n    (∀ {l₁ l₂ : List α} (a : α) (a_2 : List.Sublist l₁ l₂), motive l₁ (a :: l₂) (_ : List.Sublist l₁ (a :: l₂))) →\n      (∀ {l₁ l₂ : List α} (a : α) (a_2 : List.Sublist l₁ l₂),\n          motive (a :: l₁) (a :: l₂) (_ : List.Sublist (a :: l₁) (a :: l₂))) →\n        motive a a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "SDiff.sdiff",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toSDiff",
   "LE.le",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "BiheytingAlgebra.sdiff_le_iff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Definition"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_4",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (s : Set β), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "not_lt",
   "List.Sublist",
   "instBEq",
   "List.nodup_iff_sublist",
   "instLTNat",
   "LE.le",
   "Iff.symm",
   "Nat.linearOrder",
   "Iff",
   "List.Nodup",
   "instLENat",
   "DecidableEq",
   "not_congr",
   "List",
   "LT.lt",
   "List.replicate",
   "List.le_count_iff_replicate_sublist",
   "Iff.trans",
   "Not",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.count",
   "forall_congr'"],
  "name": "List.nodup_iff_count_le_one",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {l : List α}, List.Nodup l ↔ ∀ (a : α), List.count a l ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["add_left_cancel",
   "add_comm",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "IsRightCancelAdd.mk",
   "Eq.trans",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "OrderTop.mk",
   "PartialOrder.toPreorder",
   "Top.top",
   "GaloisInsertion.liftOrderTop.proof_1",
   "GaloisInsertion.liftOrderTop.proof_2",
   "OrderTop",
   "Preorder",
   "GaloisInsertion.choice",
   "Top.mk",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftOrderTop",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder β] → [inst_1 : Preorder α] → [inst_2 : OrderTop α] → GaloisInsertion l u → OrderTop β",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M →+ N) (x y : M),\n  ZeroHom.toFun (↑self) (x + y) = ZeroHom.toFun (↑self) x + ZeroHom.toFun (↑self) y",
  "constCategory": "Definition"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → SProd α β γ",
  "constCategory": "Other"},
 {"references": ["OrderHom", "Monotone", "Preorder"],
  "name": "OrderHom.mk",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (toFun : α → β) → Monotone toFun → α →o β",
  "constCategory": "Other"},
 {"references": ["Bool.casesOn", "Bool"],
  "name": "Bool.noConfusionType",
  "constType": "Sort u → Bool → Bool → Sort u",
  "constCategory": "Definition"},
 {"references": ["BiheytingAlgebra", "SDiff"],
  "name": "BiheytingAlgebra.toSDiff",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["IsAntisymm", "HasSubset.Subset", "HasSubset", "antisymm", "Eq"],
  "name": "subset_antisymm",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsAntisymm α fun x x_1 ↦ x ⊆ x_1], a ⊆ b → b ⊆ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "Set",
   "Inter.inter",
   "and_self_iff",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_self",
  "constType": "∀ {α : Type u} (a : Set α), a ∩ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "HAppend.hAppend",
   "List.Sublist.trans",
   "List",
   "List.append_sublist_append_left",
   "List.Sublist",
   "List.Sublist.append_right",
   "Iff.mpr"],
  "name": "List.Sublist.append",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ r₁ r₂ : List α}, List.Sublist l₁ l₂ → List.Sublist r₁ r₂ → List.Sublist (l₁ ++ r₁) (l₂ ++ r₂)",
  "constCategory": "Theorem"},
 {"references":
  ["List.instHasSubsetList",
   "List.cons",
   "List",
   "List.casesOn",
   "HasSubset.Subset",
   "List.nil"],
  "name": "List.subset_nil.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l : List α) → l ⊆ [] → Prop) (l : List α) (h : l ⊆ []),\n  (∀ (h : [] ⊆ []), motive [] h) →\n    (∀ (head : α) (tail : List α) (h : head :: tail ⊆ []), motive (head :: tail) h) → motive l h",
  "constCategory": "Definition"},
 {"references":
  ["LE.le.antisymm",
   "Iff.intro",
   "Iff",
   "PartialOrder.toPreorder",
   "Eq.le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.le_iff_eq",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → (b ≤ a ↔ b = a)",
  "constCategory": "Theorem"},
 {"references": ["PSigma", "PSigma.fst"],
  "name": "PSigma.snd",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (self : PSigma β) → β self.fst",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "Preorder.toLE",
   "True",
   "SetLike.instMembership",
   "Iff.of_eq",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "upperClosure",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "SetLike.coe",
   "exists_prop_congr'"],
  "name": "coe_upperClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (s : Set α), ↑(upperClosure s) = ⋃ a ∈ s, Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis.to_hasBasis'.match_1",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "Filter.HasBasis.mem_iff",
   "LE.le",
   "Preorder.toLE",
   "Iff.intro",
   "Filter.HasBasis",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.ge_iff",
  "constType":
  "∀ {α : Type u_1} {ι' : Sort u_5} {l l' : Filter α} {p' : ι' → Prop} {s' : ι' → Set α},\n  Filter.HasBasis l' p' s' → (l ≤ l' ↔ ∀ (i' : ι'), p' i' → s' i' ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["Acc.rec", "Acc"],
  "name": "WellFounded.fixF",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} → {C : α → Sort v} → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → Acc r x → C x",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Or",
   "Iff",
   "Decidable.not_or_of_imp",
   "Decidable",
   "Not",
   "Or.neg_resolve_left"],
  "name": "Decidable.imp_iff_not_or",
  "constType": "∀ {a b : Prop} [inst : Decidable a], a → b ↔ ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.17",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["Seq", "Applicative"],
  "name": "Applicative.toSeq",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → Seq f",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "isGLB_pair",
   "InfSet.sInf",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Set.instSingletonSet",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Singleton.singleton",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instInsertSet"],
  "name": "sInf_pair",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a b : α}, sInf {a, b} = a ⊓ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "Top.top", "Top.mk"],
  "name": "Pi.instTopForAll",
  "constType":
  "{ι : Type u_3} → {α' : ι → Type u_4} → [inst : (i : ι) → Top (α' i)] → Top ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["List.mem_map.match_1",
   "List.filter",
   "List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.brecOn",
   "List.below",
   "_private.Std.Data.List.Lemmas.0.List.erase.match_1.splitter",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.slnil",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "Std.Data.List.Lemmas._auxLemma.57",
   "Eq",
   "PProd",
   "PProd.fst",
   "eq_true",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "of_eq_true",
   "Bool.false",
   "List",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil",
   "List.erase.match_1",
   "Eq.symm",
   "id"],
  "name": "List.filter_sublist",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} (l : List α), List.Sublist (List.filter p l) l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.IsOpen",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.isOpen_sUnion",
  "constType":
  "∀ {α : Type u} [self : TopologicalSpace α] (s : Set (Set α)),\n  (∀ t ∈ s, TopologicalSpace.IsOpen t) → TopologicalSpace.IsOpen (⋃₀ s)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.inter_sets",
  "constType":
  "∀ {α : Type u_1} (self : Filter α) {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Iff.mp", "Iff", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.subtype.proof_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α), (∀ (x : α), x ∈ s ↔ p x) → ∀ x ∈ s, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.mk",
  "constType":
  "∀ {α : Type u_4} [t : TopologicalSpace α] [inst : Preorder α], t = Topology.lowerSet α → Topology.IsLowerSet α",
  "constCategory": "Other"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Trans", "Iff", "Iff.trans", "Trans.mk"],
  "name": "instTransPropIff_1",
  "constType": "Trans Iff Iff Iff",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "and_assoc",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_assoc",
  "constType": "∀ {α : Type u} (a b c : Set α), a ∩ b ∩ c = a ∩ (b ∩ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "propext",
   "Set",
   "Topology.IsUpperSet.isOpen_iff_isUpperSet",
   "TopologicalSpace",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α] {s : Set α},\n  IsOpen s = IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≠]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "le_inf",
   "SemilatticeInf.toPartialOrder",
   "sup_le_sup_left",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "sup_inf_le",
  "constType":
  "∀ {α : Type u} [inst : Lattice α] {a b c : α}, a ⊔ b ⊓ c ≤ (a ⊔ b) ⊓ (a ⊔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "True",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.19",
  "constType": "∀ (n : ℕ), (0 < Nat.succ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "cond",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.countP.go",
   "True",
   "Eq",
   "Nat.zero_add",
   "Bool.of_not_eq_true",
   "of_eq_true",
   "List",
   "Bool.false",
   "Bool.true",
   "congr",
   "Not",
   "instOfNatNat",
   "Bool",
   "List.countP",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.countP_cons_of_neg",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {a : α} (l : List α), ¬p a = true → List.countP p (a :: l) = List.countP p l",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "absurd",
   "rfl",
   "Eq"],
  "name": "dif_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32", "UInt32.mk", "LT.lt", "UInt32.size", "Nat", "instLTNat", "Fin.mk"],
  "name": "UInt32.ofNatCore",
  "constType": "(n : ℕ) → n < UInt32.size → UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Subtype.val",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Subtype.coe_image.match_2",
   "Subtype.coe_image.match_1",
   "Eq.rec",
   "And.intro",
   "Set.image",
   "Subtype",
   "Subtype.mk"],
  "name": "Subtype.coe_image",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {s : Set (Subtype p)},\n  Subtype.val '' s = {x | ∃ (h : p x), { val := x, property := h } ∈ s}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "And.right",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_right",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "False", "List", "Not", "List.noConfusion", "absurd", "Eq"],
  "name": "List.hasDecEq.proof_5",
  "constType":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), ¬as = bs → a :: as = b :: bs → False",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "Set.mem_preimage",
   "Eq.refl",
   "HasSubset.Subset",
   "Exists.intro",
   "rfl",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.mem_comap'.match_1",
   "Filter.comap",
   "Filter",
   "And.intro",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap'",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {l : Filter β} {s : Set α},\n  s ∈ Filter.comap f l ↔ {y | ∀ ⦃x : α⦄, f x = y → x ∈ s} ∈ l",
  "constCategory": "Theorem"},
 {"references": ["WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.mk",
  "constType":
  "{α : Sort u} → (rel : α → α → Prop) → WellFounded rel → WellFoundedRelation α",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.add",
   "List.cons",
   "OfNat.ofNat",
   "HEq",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "Eq.refl",
   "List.casesOn",
   "instOfNatNat",
   "Eq.casesOn",
   "List.nil",
   "List.length",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "List.eq_nil_of_length_eq_zero.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (l : List α) → List.length l = 0 → Prop) (l : List α) (x : List.length l = 0),\n  (∀ (x : List.length [] = 0), motive [] x) → motive l x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper.WithUpperHomeomorph.proof_1",
   "Homeomorph",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Topology.WithUpper.ofUpper"],
  "name": "Topology.IsUpper.WithUpperHomeomorph",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsUpper α] → Topology.WithUpper α ≃ₜ α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.mk",
  "constType":
  "∀ {α : Type u_4} [t : TopologicalSpace α] [inst : Preorder α], t = Topology.upperSet α → Topology.IsUpperSet α",
  "constCategory": "Other"},
 {"references": ["IsAntisymm", "Eq"],
  "name": "IsAntisymm.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b : α), r a b → r b a → a = b) → IsAntisymm α r",
  "constCategory": "Other"},
 {"references": ["Lean.MonadRef", "Lean.Syntax"],
  "name": "Lean.MonadRef.getRef",
  "constType": "{m : Type → Type} → [self : Lean.MonadRef m] → m Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.Perm", "List"],
  "name": "List.Perm.cons",
  "constType":
  "∀ {α : Type uu} (x : α) {l₁ l₂ : List α}, l₁ ~ l₂ → x :: l₁ ~ x :: l₂",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "EStateM.get",
   "EStateM.set",
   "EStateM.modifyGet",
   "MonadStateOf",
   "MonadStateOf.mk"],
  "name": "EStateM.instMonadStateOfEStateM",
  "constType": "{ε σ : Type u} → MonadStateOf σ (EStateM ε σ)",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_wfRel.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : m = n ∨ m < n → Prop) (this : m = n ∨ m < n),\n  (∀ (e : m = n), motive (_ : m = n ∨ m < n)) → (∀ (e : m < n), motive (_ : m = n ∨ m < n)) → motive this",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "OrderDual.instIsLower.proof_1",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "OrderDual.instIsLower",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], Topology.IsLower αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "TopologicalSpace.isOpen_inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "IsOpen.inter",
  "constType":
  "∀ {α : Type u} {s₁ s₂ : Set α} [inst : TopologicalSpace α], IsOpen s₁ → IsOpen s₂ → IsOpen (s₁ ∩ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "Set",
   "LE",
   "Set.sUnion",
   "Exists.imp",
   "And.intro",
   "IsUpperSet",
   "And.left",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isUpperSet_sUnion",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {S : Set (Set α)}, (∀ s ∈ S, IsUpperSet s) → IsUpperSet (⋃₀ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_1",
  "constType":
  "∀ (motive : Nat.succ 0 ≤ 0 → Prop) (h : Nat.succ 0 ≤ 0), motive h",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["List.Perm", "List.nil"],
  "name": "List.Perm.nil",
  "constType": "∀ {α : Type uu}, [] ~ []",
  "constCategory": "Other"},
 {"references": ["Inhabited", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_4",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_comap",
  "constType":
  "∀ {α : Type u} {β : Type v} {g : Filter β} {m : α → β} {s : Set α}, s ∈ Filter.comap m g ↔ ∃ t ∈ g, m ⁻¹' t ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List.Chain.casesOn",
   "List",
   "eq_of_heq",
   "List.Chain.nil",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Chain",
   "Eq",
   "List.Chain.cons"],
  "name": "List.Chain.pairwise.match_1",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} (motive : (x : α) → (x_1 : List α) → List.Chain R x x_1 → Prop) (x : α)\n  (x_1 : List α) (x_2 : List.Chain R x x_1),\n  (∀ (a : α), motive a [] (_ : List.Chain R a [])) →\n    (∀ (a b : α) (l : List α) (h : R a b) (hb : List.Chain R b l), motive a (b :: l) (_ : List.Chain R a (b :: l))) →\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Acc.recOn", "Acc"],
  "name": "Acc.inv.proof_1",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} {x y : α}, Acc r x → r y x → Acc r y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "WellFoundedRelation",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": [],
  "name": "SeqRight",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "GaloisConnection",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Function.comp",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisConnection.dual",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u →\n    GaloisConnection (↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Disjoint",
   "IsCompl",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.disjoint",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → Disjoint x y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.forall_image2_iff",
   "Set.image2",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.image2_subset_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {u : Set γ},\n  Set.image2 f s t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, f x y ∈ u",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Eq",
   "Filter.mem_principal",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.11",
  "constType":
  "∀ {α : Type u} {s t : Set α}, (s ∈ Filter.principal t) = (t ⊆ s)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Sup",
   "Prod.instSupProd",
   "Prod.fst",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod",
   "Sup.sup",
   "le_sup_right",
   "And.intro",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] (x x_1 : α × β),\n  x_1.1 ≤ (x ⊔ x_1).1 ∧ x_1.2 ≤ (x ⊔ x_1).2",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.comm.match_2",
  "constType":
  "∀ {a b : Prop} (motive : b ∧ a → Prop) (h : b ∧ a), (∀ (h₁ : b) (h₂ : a), motive (_ : b ∧ a)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Subsingleton.intro",
   "Decidable.isFalse",
   "Subsingleton",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "Eq"],
  "name": "instSubsingletonDecidable.proof_1",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.Homotopy.«termΩ^»._closed_2",
   "Topology.Homotopy.«termΩ^»._closed_4"],
  "name": "Topology.Homotopy.«termΩ^»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EStateM.Backtrackable",
  "constType": "outParam (Type u) → Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references": ["Inter"],
  "name": "Inter.mk",
  "constType": "{α : Type u} → (α → α → α) → Inter α",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["Lean.Name._impl"],
  "name": "Lean.Name.anonymous._impl",
  "constType": "Lean.Name._impl",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_2",
  "constType":
  "∀ (n : ℕ) (motive : Nat.succ (Nat.succ n) ≤ 0 → Prop) (h : Nat.succ (Nat.succ n) ≤ 0), motive h",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Iff",
   "le_compl_iff_disjoint_right",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "disjoint_comm",
   "Iff.trans",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "le_compl_iff_disjoint_left",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, a ≤ bᶜ ↔ Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.rec",
  "constType":
  "{α : Type u} →\n  {motive : TopologicalSpace α → Sort u_1} →\n    ((IsOpen : Set α → Prop) →\n        (isOpen_univ : IsOpen Set.univ) →\n          (isOpen_inter : ∀ (s t : Set α), IsOpen s → IsOpen t → IsOpen (s ∩ t)) →\n            (isOpen_sUnion : ∀ (s : Set (Set α)), (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)) →\n              motive\n                { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter,\n                  isOpen_sUnion := isOpen_sUnion }) →\n      (t : TopologicalSpace α) → motive t",
  "constCategory": "Other"},
 {"references": ["False", "False.rec"],
  "name": "False.casesOn",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Eq.refl",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.ball_image_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set α} {p : β → Prop}, (∀ y ∈ f '' s, p y) ↔ ∀ x ∈ s, p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u_1} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.ofUpperSet._cstage1",
  "constType": "{α : Type u_1} → Topology.WithUpperSet α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "SemilatticeSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.toSup",
   "Mathlib.Order.Basic._auxLemma.1",
   "of_eq_true",
   "sup_of_le_left",
   "Sup.sup",
   "congrArg",
   "LE.le",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "True",
   "congrFun",
   "Eq"],
  "name": "sup_idem",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a : α}, a ⊔ a = a",
  "constCategory": "Theorem"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Char.utf8Size.proof_2",
   "Char.val",
   "UInt32",
   "OfNat.ofNat",
   "Char.utf8Size.proof_4",
   "UInt32.ofNatCore",
   "Char.utf8Size.proof_7",
   "Char.utf8Size.proof_3",
   "LE.le",
   "ite",
   "Char",
   "Char.utf8Size.proof_6",
   "Char.utf8Size.proof_5",
   "instLEUInt32",
   "instOfNatNat",
   "Nat",
   "Char.utf8Size.proof_1",
   "instDecidableLeUInt32InstLEUInt32"],
  "name": "Char.utf8Size",
  "constType": "Char → UInt32",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "BEq",
   "List.brecOn",
   "List.below",
   "Unit",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "List.rec",
   "List",
   "Bool.false",
   "Bool.true",
   "PUnit",
   "Bool",
   "List.nil",
   "List.erase.match_1",
   "List.isEmpty.match_1"],
  "name": "List.elem",
  "constType": "{α : Type u} → [inst : BEq α] → α → List α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references": [],
  "name": "PLift",
  "constType": "Sort u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "HasSubset.Subset",
   "Filter.mkOfClosure",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "Filter.le_generate_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "Filter.instPartialOrderFilter",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "Filter.mkOfClosure_sets"],
  "name": "Filter.giGenerate.proof_3",
  "constType":
  "∀ (α : Type u_1) (x : Set (Set α)) (x_1 : (Filter.generate x).sets ≤ x),\n  Filter.mkOfClosure x (_ : (Filter.generate x).sets = x) = Filter.generate x",
  "constCategory": "Theorem"},
 {"references":
  ["compl_compl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Function.Involutive",
   "BooleanAlgebra"],
  "name": "compl_involutive",
  "constType":
  "∀ {α : Type u} [inst : BooleanAlgebra α], Function.Involutive compl",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_4",
  "constType": "2 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "SeqRight"],
  "name": "Applicative.toSeqRight",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → SeqRight f",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable", "Subsingleton", "instSubsingletonDecidable.proof_1"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike",
   "Function.LeftInverse",
   "outParam",
   "Function.RightInverse",
   "Eq"],
  "name": "EquivLike.mk",
  "constType":
  "{E : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      (coe : E → α → β) →\n        (inv : E → β → α) →\n          (∀ (e : E), Function.LeftInverse (inv e) (coe e)) →\n            (∀ (e : E), Function.RightInverse (inv e) (coe e)) →\n              (∀ (e g : E), coe e = coe g → inv e = inv g → e = g) → EquivLike E α β",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Ne",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "instBEq",
   "List.erase",
   "Eq",
   "ite",
   "Eq.mpr",
   "List.count_erase",
   "Eq.ndrec",
   "DecidableEq",
   "List",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "List.count",
   "if_neg",
   "id"],
  "name": "List.count_erase_of_ne",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α},\n  a ≠ b → ∀ (l : List α), List.count a (List.erase l b) = List.count a l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.Sublist.below.cons₂",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.Sublist.below.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.rec",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop}\n  {motive_1 : {a a_1 : List α} → (x : List.Sublist a a_1) → List.Sublist.below x → Prop},\n  motive_1 (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] [])) →\n    (∀ {l₁ l₂ : List α} (a : α) {a_1 : List.Sublist l₁ l₂} (a_2 : List.Sublist.below a_1) (a_3 : motive l₁ l₂ a_1),\n        motive_1 a_1 a_2 →\n          motive_1 (_ : List.Sublist l₁ (a :: l₂)) (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ {l₁ l₂ : List α} (a : α) {a_1 : List.Sublist l₁ l₂} (a_2 : List.Sublist.below a_1) (a_3 : motive l₁ l₂ a_1),\n          motive_1 a_1 a_2 →\n            motive_1 (_ : List.Sublist (a :: l₁) (a :: l₂))\n              (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        ∀ {a a_1 : List α} {x : List.Sublist a a_1} (t : List.Sublist.below x), motive_1 x t",
  "constCategory": "Other"},
 {"references": ["Nonempty.intro", "Classical.arbitrary", "Nonempty"],
  "name": "Pi.Nonempty.proof_1",
  "constType":
  "∀ {ι : Sort u_1} {α : ι → Sort u_2} [inst : ∀ (i : ι), Nonempty (α i)], Nonempty ((i : ι) → α i)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "UpperSet.instSetLikeUpperSet",
   "SetLike.ext'",
   "LE",
   "UpperSet",
   "SetLike.coe",
   "Eq"],
  "name": "UpperSet.ext",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s t : UpperSet α}, ↑s = ↑t → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "instDecidableForAll.proof_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "absurd"],
  "name": "instDecidableForAll",
  "constType":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p → q)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_himp_iff",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] {a b c : α}, a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithUpper.rec._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Nonempty"],
  "name": "Topology.WithLowerSet.instNonemptyWithLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α], Nonempty (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed",
   "And.left",
   "isClosed_sInter"],
  "name": "isClosed_closure",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsClosed (closure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "And",
   "Exists.intro",
   "And.intro",
   "Exists.casesOn",
   "And.casesOn"],
  "name": "exists_and_left.match_2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop} (motive : (b ∧ ∃ x, p x) → Prop) (x : b ∧ ∃ x, p x),\n  (∀ (h : b) (x : α) (hp : p x), motive (_ : b ∧ ∃ x, p x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "eq_false",
   "False",
   "Finset.not_mem_empty",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.18",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ ∅) = False",
  "constCategory": "Theorem"},
 {"references":
  ["List.decidableBAll.match_2",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "Unit",
   "List.Mem"],
  "name": "List.decidableBAll.proof_2",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α), p x → (∀ x ∈ xs, p x) → ∀ x_1 ∈ x :: xs, p x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "eq_true_of_decide",
   "instDecidableEqNat",
   "True",
   "Eq",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "Nat.pred",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.zero_sub",
  "constType": "∀ (n : ℕ), 0 - n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Bot.bot",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.NeBot.mk",
  "constType": "∀ {α : Type u} {f : Filter α}, f ≠ ⊥ → Filter.NeBot f",
  "constCategory": "Other"},
 {"references": ["Equiv"],
  "name": "Equiv.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.mem_map.match_1",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Sublist",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.nil_sublist",
  "constType": "∀ {α : Type u_1} (l : List α), List.Sublist [] l",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "List.Perm.symm",
   "Iff.intro",
   "List.exists_perm_sublist",
   "Exists",
   "Iff",
   "List.Perm",
   "List",
   "List.exists_perm_sublist.match_1",
   "List.Subperm",
   "List.Sublist",
   "List.Perm.trans",
   "Exists.intro"],
  "name": "List.Perm.subperm_left",
  "constType":
  "∀ {α : Type uu} {l l₁ l₂ : List α}, l₁ ~ l₂ → (l <+~ l₁ ↔ l <+~ l₂)",
  "constCategory": "Theorem"},
 {"references": ["Decidable.isFalse", "Decidable", "Decidable.isTrue", "Not"],
  "name": "Decidable.rec",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → (t : Decidable p) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Set.image_comp",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.image_id",
   "Function.comp",
   "Set",
   "compl_comp_compl",
   "Eq.refl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq.symm",
   "BooleanAlgebra",
   "id",
   "Eq"],
  "name": "Set.compl_compl_image",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (S : Set α), compl '' (compl '' S) = S",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Eq.refl", "Nat", "Nat.instMaxNat", "Eq"],
  "name": "Nat.linearOrder.proof_2",
  "constType": "∀ (a b : ℕ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references":
  ["isClosed_compl_iff",
   "Membership.mem",
   "closure",
   "False",
   "setOf",
   "Set",
   "Set.Nonempty",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "by_contradiction",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "mem_closure_iff.match_2",
   "IsClosed.isOpen_compl",
   "TopologicalSpace",
   "Not",
   "And.intro",
   "IsClosed",
   "closure_minimal",
   "mem_closure_iff.match_1",
   "IsOpen",
   "Set.instInterSet"],
  "name": "mem_closure_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {a : α},\n  a ∈ closure s ↔ ∀ (o : Set α), IsOpen o → a ∈ o → Set.Nonempty (o ∩ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.mem_preimage",
   "Mathlib.Order.Filter.Bases._auxLemma.59",
   "Eq.refl",
   "HasSubset.Subset",
   "exists_congr",
   "Filter.HasBasis.mem_iff",
   "rfl",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "Filter.HasBasis",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "propext",
   "Filter.comap",
   "Filter",
   "congrArg",
   "Iff.and",
   "Eq.trans",
   "Filter.HasBasis.mk",
   "congrFun",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.comap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} (f : β → α),\n  Filter.HasBasis l p s → Filter.HasBasis (Filter.comap f l) p fun i ↦ f ⁻¹' s i",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Codisjoint",
   "SemilatticeSup",
   "OrderDual.semilatticeInf",
   "OrderDual.orderBot",
   "SemilatticeSup.toSup",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "disjoint_iff",
   "OrderDual",
   "OrderTop",
   "Sup.sup",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "codisjoint_iff",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α] [inst_1 : OrderTop α] {a b : α}, Codisjoint a b ↔ a ⊔ b = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_le",
   "Set.instHasSubsetSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.sInter_subset_of_mem",
  "constType":
  "∀ {α : Type u_1} {S : Set (Set α)} {t : Set α}, t ∈ S → ⋂₀ S ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "flip",
  "constType":
  "{α : Sort u} → {β : Sort v} → {φ : Sort w} → (α → β → φ) → β → α → φ",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String.mk", "String", "String.casesOn"],
  "name": "String.utf8ByteSize.match_1",
  "constType":
  "(motive : String → Sort u_1) → (x : String) → ((s : List Char) → motive { data := s }) → motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.MacroScopesView", "List", "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.scopes",
  "constType": "Lean.MacroScopesView → List Lean.MacroScope",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsCommutative.mk",
   "Sup.sup",
   "sup_comm",
   "IsCommutative"],
  "name": "instIsCommutativeSupToSup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α], IsCommutative α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.Mem.head"],
  "name": "List.mem_cons_self",
  "constType": "∀ {α : Type u_1} (a : α) (l : List α), a ∈ a :: l",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "List.ilast'_mem",
   "Function.comp",
   "Eq.refl",
   "Mathlib.Data.List.TFAE._auxLemma.2",
   "implies_congr",
   "True",
   "Eq",
   "Iff.intro",
   "Mathlib.Data.List.TFAE._auxLemma.6",
   "And",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "List.rec",
   "List.ilast'",
   "forall_congr",
   "List",
   "Eq.mp",
   "List.Mem.head",
   "Mathlib.Data.List.TFAE._auxLemma.1",
   "Mathlib.Data.List.TFAE._auxLemma.4",
   "And.intro",
   "List.nil",
   "And.casesOn",
   "List.Chain",
   "congrArg",
   "Eq.trans",
   "List.TFAE",
   "id",
   "Mathlib.Data.List.TFAE._auxLemma.5"],
  "name": "List.tfae_of_cycle",
  "constType":
  "∀ {a b : Prop} {l : List Prop},\n  List.Chain (fun x x_1 ↦ x → x_1) a (b :: l) → (List.ilast' b l → a) → List.TFAE (a :: b :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.instMembershipList",
   "List",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "List.length_pos_iff_exists_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} (motive : (∃ a, a ∈ l) → Prop) (x : ∃ a, a ∈ l),\n  (∀ (w : α) (h : w ∈ l), motive (_ : ∃ a, a ∈ l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Bot.bot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.inf_inf_sdiff",
  "constType":
  "∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\ b = ⊥",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "TopologicalSpace",
   "Preorder",
   "AlexandrovDiscrete",
   "Topology.IsUpperSet.toAlexandrovDiscrete.proof_1"],
  "name": "Topology.IsUpperSet.toAlexandrovDiscrete",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsUpperSet α], AlexandrovDiscrete α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "rfl",
   "Quot.inductionOn",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Quot.mk",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
  "constType": "∀ {α : Type u_1} (s : Multiset α), 0 + s = s",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.atom",
  "constType": "Lean.SourceInfo → String → Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Bool.false",
   "decide_eq_true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "Not",
   "Bool",
   "absurd",
   "ne_false_of_eq_true",
   "Eq"],
  "name": "of_decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = false → ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add",
   "Function.Injective.eq_iff",
   "Eq",
   "add_left_injective"],
  "name": "add_left_inj",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G) {b c : G}, b + a = c + a ↔ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.basic",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)}, ∀ s ∈ g, TopologicalSpace.GenerateOpen g s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "funext",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "implies_congr",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "forall_congr",
   "Set.Finite.isOpen_biInter",
   "Eq.mp",
   "TopologicalSpace",
   "Set.iInter",
   "IsClosed",
   "Mathlib.Topology.Basic._auxLemma.8",
   "congrArg",
   "IsOpen",
   "Eq.trans",
   "Set.compl_iUnion",
   "id"],
  "name": "Set.Finite.isClosed_biUnion",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] {s : Set β} {f : β → Set α},\n  Set.Finite s → (∀ i ∈ s, IsClosed (f i)) → IsClosed (⋃ i ∈ s, f i)",
  "constCategory": "Theorem"},
 {"references": ["sInfHom", "InfSet"],
  "name": "sInfHom.toFun",
  "constType":
  "{α : Type u_8} → {β : Type u_9} → [inst : InfSet α] → [inst_1 : InfSet β] → sInfHom α β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "SemilatticeSup.sup_le",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b c : (i : ι) → α' i),\n  a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Iff.mp", "Finite", "finite_iff_nonempty_fintype", "Nonempty"],
  "name": "nonempty_fintype",
  "constType": "∀ (α : Type u_4) [inst : Finite α], Nonempty (Fintype α)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Set.range_const.match_1",
  "constType":
  "∀ {α : Type u_2} {ι : Sort u_1} (motive : Nonempty ι → α → Prop) (x : Nonempty ι) (x_1 : α),\n  (∀ (x : ι) (x_2 : α), motive (_ : Nonempty ι) x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.ofUpperSet_inj",
  "constType":
  "∀ {α : Type u_1} {a b : Topology.WithUpperSet α},\n  ↑Topology.WithUpperSet.ofUpperSet a = ↑Topology.WithUpperSet.ofUpperSet b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Set",
   "Union.union",
   "Or.casesOn",
   "And.left",
   "LE.le",
   "IsLUB",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SemilatticeSup",
   "And.right",
   "upperBounds",
   "Or.inl",
   "SemilatticeSup.toSup",
   "le_sup_of_le_right",
   "lowerBounds",
   "sup_le",
   "Sup.sup",
   "And.intro",
   "le_sup_of_le_left",
   "SemilatticeSup.toPartialOrder",
   "Set.instUnionSet"],
  "name": "IsLUB.union",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {a b : γ} {s t : Set γ}, IsLUB s a → IsLUB t b → IsLUB (s ∪ t) (a ⊔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.cons",
   "List.get._sunfold.proof_1",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "List.instMembershipList",
   "HAdd.hAdd",
   "List.Mem.tail",
   "List.length",
   "instLTNat",
   "List.get?_eq_get.match_1",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "List.Mem.head",
   "instOfNatNat",
   "Nat",
   "List.get",
   "Fin.mk"],
  "name": "List.get_mem",
  "constType":
  "∀ {α : Type u_1} (l : List α) (n : ℕ) (h : n < List.length l), List.get l { val := n, isLt := h } ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.rec._cstage1",
  "constType":
  "{α : Type u_1} →\n  {β : Topology.WithLowerSet α → Sort u_4} →\n    ((a : α) → β (↑Topology.WithLowerSet.toLowerSet a)) → (a : Topology.WithLowerSet α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "nhds",
   "Set",
   "Eq.refl",
   "nhdsAdjoint",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "le_nhds_iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "instMembershipSetFilter",
   "id"],
  "name": "gc_nhds",
  "constType":
  "∀ {α : Type u} (a : α), GaloisConnection (nhdsAdjoint a) fun t ↦ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "Setoid.r",
   "Iff",
   "Function.Injective",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.mem_map_of_injective",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.mem_map_of_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β},\n  Function.Injective f → ∀ {a : α} {s : Multiset α}, f a ∈ Multiset.map f s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Inter",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower.topology_eq_lowerTopology",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLower.topology_eq",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α],\n  inst_1 = Topology.lower α",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl.mk", "IsRefl", "le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "instIsReflLeToLE.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], IsRefl α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Iff", "forall_exists_index"],
  "name": "exists_imp",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x) → b ↔ ∀ (x : α), p x → b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set.preimage",
   "Set",
   "implies_true",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Set.preimage_iUnion",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {f : α → β} {s : ι → Set β}, f ⁻¹' ⋃ i, s i = ⋃ i, f ⁻¹' s i",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "List.foldl.match_1"],
  "name": "List.foldl",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → α → List β → α",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "sSupHom.mk",
   "Eq.ndrec",
   "sSupHom",
   "Eq.rec",
   "Set",
   "Eq.refl",
   "sSupHom.casesOn",
   "sSupHom.toFun",
   "SupSet.sSup",
   "Set.image",
   "Eq.symm",
   "Eq"],
  "name": "sSupHom.instSSupHomClassSSupHom.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : SupSet α] [inst_1 : SupSet β] (f g : sSupHom α β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.generateFrom",
   "Set",
   "TopologicalSpace",
   "Eq",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s → t = TopologicalSpace.generateFrom s",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Pi.preorder.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α : ι → Type u_1} [inst : (i : ι) → Preorder (α i)] (a : (i : ι) → α i) (i : ι), a i ≤ a i",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "GE.ge", "LE", "LE.le"],
  "name": "ge_iff_le",
  "constType": "∀ {α : Type u} [inst : LE α] {a b : α}, a ≥ b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b : α × β), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Option.some.injEq",
   "List.cons",
   "List.brecOn",
   "List.below",
   "Unit",
   "dite",
   "Eq",
   "PProd",
   "List.find?",
   "Bool.of_not_eq_true",
   "PProd.fst",
   "List.rec",
   "Bool.false",
   "List",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "List.find?_some.match_1",
   "Eq.mp",
   "Not",
   "Option.some",
   "Bool",
   "List.erase.match_1",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option",
   "instDecidableEqBool"],
  "name": "List.find?_some",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {a : α} {l : List α}, List.find? p l = some a → p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "disjoint_iff",
   "Disjoint",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "IsCompl.inf_left_eq_bot_iff",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "DistribLattice",
   "Iff",
   "propext",
   "OrderBot.toBot",
   "BoundedOrder.toOrderBot",
   "id",
   "BoundedOrder"],
  "name": "IsCompl.disjoint_left_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y z : α}, IsCompl y z → (Disjoint x y ↔ x ≤ z)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "GetElem"],
  "name": "GetElem.mk",
  "constType":
  "{cont : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {dom : outParam (cont → idx → Prop)} → ((xs : cont) → (i : idx) → dom xs i → elem) → GetElem cont idx elem dom",
  "constCategory": "Other"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Topology.IsUpper.rec",
   "Eq"],
  "name": "Topology.IsUpper.casesOn",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpper α → Sort u} →\n        (t_1 : Topology.IsUpper α) →\n          ((topology_eq_upperTopology : t = Topology.upper α) → motive (_ : Topology.IsUpper α)) → motive t_1",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpper.ofUpper._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "OfNat.ofNat",
   "List.instMembershipList",
   "Std.Data.List.Count._auxLemma.7",
   "instBEq",
   "instLTNat",
   "True",
   "iff_self",
   "instLawfulBEqInstBEq",
   "Std.Data.List.Count._auxLemma.6",
   "Eq",
   "And",
   "BEq.beq",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Bool.true",
   "LT.lt",
   "Std.Data.List.Count._auxLemma.8",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "List.count",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.count_pos_iff_mem",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, 0 < List.count a l ↔ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.filterMap",
   "Unit",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.rec",
   "Std.Data.List.Lemmas._auxLemma.57",
   "Eq",
   "Std.Data.List.Lemmas._auxLemma.30",
   "eq_true",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "_private.Std.Data.List.Lemmas.0.List.filterMap_cons.match_1.splitter",
   "List.filterMap_cons.match_1",
   "Option.none",
   "Option.some",
   "List.nil",
   "Eq.symm",
   "Option",
   "id"],
  "name": "List.Sublist.filterMap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l₁ l₂ : List α} (f : α → Option β),\n  List.Sublist l₁ l₂ → List.Sublist (List.filterMap f l₁) (List.filterMap f l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.3",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, (a ⊔ b ≤ c) = (a ≤ c ∧ b ≤ c)",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod", "Eq"],
  "name": "Prod.noConfusionType",
  "constType":
  "{α : Type u} → {β : Type v} → Sort u_1 → α × β → α × β → Sort u_1",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_2",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_3",
   "_obj",
   "Lean.Name.mkStr4",
   "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_1",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_3"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : DistribLattice α] (a b : αᵒᵈ), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "instDiscreteTopologyProdInstTopologicalSpaceProd.match_1",
   "Set",
   "Filter.NeBot",
   "True",
   "iff_self",
   "Eq",
   "Set.ext",
   "Mathlib.Topology.Constructions._auxLemma.27",
   "Eq.mpr",
   "Iff",
   "SProd.sprod",
   "TopologicalSpace",
   "Filter",
   "nhdsWithin",
   "Eq.trans",
   "id",
   "Membership.mem",
   "Set.instSProd",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Mathlib.Topology.Constructions._auxLemma.28",
   "Prod.fst",
   "Filter.instSProd",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "Prod.mk",
   "congr",
   "nhdsWithin_prod_eq",
   "Prod",
   "congrArg",
   "Mathlib.Topology.Constructions._auxLemma.26",
   "congrFun"],
  "name": "closure_prod_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β},\n  closure (s ×ˢ t) = closure s ×ˢ closure t",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.toLower",
  "constType": "{α : Type u_1} → α ≃ Topology.WithLower α",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Lean.identKind",
   "Lean.Name.mkSimple",
   "List",
   "String",
   "Unit",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax.getKind.match_1",
   "Substring",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getKind",
  "constType": "Lean.Syntax → Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "OrderDual", "LE", "LE.le"],
  "name": "OrderDual.instLEOrderDual",
  "constType": "(α : Type u_3) → [inst : LE α] → LE αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "Unit", "Alternative"],
  "name": "Alternative.mk",
  "constType":
  "{f : Type u → Type v} →\n  [toApplicative : Applicative f] → ({α : Type u} → f α) → ({α : Type u} → f α → (Unit → f α) → f α) → Alternative f",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.mk",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "SemilatticeSup.mk",
   "GaloisInsertion.liftSemilatticeSup.proof_1",
   "Sup.sup",
   "GaloisInsertion.liftSemilatticeSup.proof_3",
   "Sup.mk",
   "GaloisInsertion",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftSemilatticeSup.proof_2",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : SemilatticeSup α] → GaloisInsertion l u → SemilatticeSup β",
  "constCategory": "Definition"},
 {"references": ["Inf.mk", "Inf", "Inf.inf"],
  "name": "Pi.instInfForAll",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → Inf (α' i)] → Inf ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Disjoint",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "le_compl_iff_disjoint_right",
   "propext",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "le_compl_iff_disjoint_left",
   "BoundedOrder.toOrderBot",
   "id"],
  "name": "le_compl_comm",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, a ≤ bᶜ ↔ b ≤ aᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.instMembershipList",
   "Eq.refl",
   "Exists.intro",
   "List.exists_erase_eq.match_1",
   "beq_self_eq_true",
   "List.erase",
   "Eq",
   "instLawfulBEqInstBEq",
   "Decidable.decide",
   "BEq.beq",
   "List.eraseP",
   "Eq.mpr",
   "Bool.true",
   "Eq.rec",
   "Eq.symm",
   "id",
   "Membership.mem",
   "List.cons",
   "List.exists_of_eraseP",
   "List.erase_eq_eraseP",
   "instBEq",
   "instHAppend",
   "And",
   "List.instAppendList",
   "Eq.ndrec",
   "DecidableEq",
   "HAppend.hAppend",
   "List",
   "LawfulBEq.eq_of_beq",
   "Not",
   "Bool",
   "And.intro"],
  "name": "List.exists_erase_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α},\n  a ∈ l → ∃ l₁, ∃ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ List.erase l a = l₁ ++ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "Equiv.mk"],
  "name": "Equiv.symm",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Option.none", "Option.some", "Option.casesOn", "String.Pos", "Option"],
  "name": "Lean.replaceRef.match_1",
  "constType":
  "(motive : Option String.Pos → Sort u_1) →\n  (x : Option String.Pos) → ((val : String.Pos) → motive (some val)) → ((x : Option String.Pos) → motive x) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Prelude.0.Lean.extractMacroScopesAux",
   "cond.match_1",
   "Lean.MacroScopesView",
   "Unit",
   "Lean.MacroScopesView.mk",
   "Lean.Name.hasMacroScopes",
   "List.nil",
   "Bool",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.MacroScope"],
  "name": "Lean.extractMacroScopes",
  "constType": "Lean.Name → Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.IsUpper.mk",
   "Preorder",
   "Topology.IsUpper.rec",
   "Eq"],
  "name": "Topology.IsUpper.recOn",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsUpper α → Sort u} →\n        (t_1 : Topology.IsUpper α) →\n          ((topology_eq_upperTopology : t = Topology.upper α) → motive (_ : Topology.IsUpper α)) → motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Prod.snd",
   "Prod.mk",
   "Prod.instLEProd",
   "inferInstanceAs",
   "LE",
   "Prod",
   "And.intro",
   "Prod.fst",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.instPreorderProd.match_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Preorder α] [inst_1 : Preorder β] (c : α) (d : β) (e : α) (f : β),\n  let src := inferInstanceAs (LE (α × β));\n  ∀ (motive : (c, d) ≤ (e, f) → Prop) (x : (c, d) ≤ (e, f)),\n    (∀ (hce : (c, d).1 ≤ (e, f).1) (hdf : (c, d).2 ≤ (e, f).2),\n        motive (_ : (c, d).1 ≤ (e, f).1 ∧ (c, d).2 ≤ (e, f).2)) →\n      motive x",
  "constCategory": "Definition"},
 {"references":
  ["instMonadExcept",
   "tryCatchThe",
   "ReaderT",
   "liftM",
   "instMonadLiftT",
   "MonadExcept.throw",
   "ReaderT.instMonadLiftReaderT",
   "MonadExceptOf.mk",
   "MonadExceptOf",
   "instMonadLiftT_1"],
  "name": "ReaderT.instMonadExceptOfReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → (ε : Type u_1) → [inst : MonadExceptOf ε m] → MonadExceptOf ε (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references": ["PUnit", "semiOutParam", "MonadStateOf"],
  "name": "MonadStateOf.set",
  "constType":
  "{σ : semiOutParam (Type u)} → {m : Type u → Type v} → [self : MonadStateOf σ m] → σ → m PUnit.{u + 1}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "sSup_image",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Set",
   "InfSet.sInf",
   "OrderDual",
   "Set.image",
   "Set.instMembershipSet",
   "Eq"],
  "name": "sInf_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {s : Set β} {f : β → α}, sInf (f '' s) = ⨅ a ∈ s, f a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_principal",
  "constType": "∀ {α : Type u} {s t : Set α}, s ∈ Filter.principal t ↔ t ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.inductionOn",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r), (∀ (a : α), motive (Quot.mk r a)) → motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective", "Function.Embedding.mk", "Function.Embedding"],
  "name": "Function.Embedding.rec",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : (α ↪ β) → Sort u} →\n      ((toFun : α → β) → (inj' : Function.Injective toFun) → motive { toFun := toFun, inj' := inj' }) →\n        (t : α ↪ β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.not_and", "And", "Or", "Iff", "Classical.propDecidable", "Not"],
  "name": "not_and_or",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "List.filter_cons_of_pos",
   "eq_true_of_decide",
   "Std.Logic._auxLemma.45",
   "iff_false",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "List.rec",
   "forall_congr",
   "Eq.rec",
   "Bool.true",
   "List.nil",
   "Nat",
   "Eq.symm",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "eq_self",
   "Membership.mem",
   "List.filter",
   "List.cons",
   "Or",
   "False",
   "List.filter_cons_of_neg",
   "implies_true",
   "List.length",
   "eq_false_of_decide",
   "List.length_filter_le",
   "LE.le",
   "And",
   "Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "Nat.lt_irrefl",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "List.cons.injEq",
   "congrFun"],
  "name": "List.filter_eq_self",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {l : List α}, List.filter p l = l ↔ ∀ a ∈ l, p a = true",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_exists_eq_and", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.32",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_2} {f : α → β} {p : β → Prop}, (∃ b, (∃ a, f a = b) ∧ p b) = ∃ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": ["Set.insert", "Set", "Insert", "Insert.mk"],
  "name": "Set.instInsertSet",
  "constType": "{α : Type u_1} → Insert α (Set α)",
  "constCategory": "Definition"},
 {"references": ["Quot"],
  "name": "Quot.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → α → Quot r",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Or", "Iff", "False", "or_false", "iff_of_eq"],
  "name": "or_false_iff",
  "constType": "∀ (p : Prop), p ∨ False ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddMonoidHomClass (M →+ N) M N",
  "constCategory": "Definition"},
 {"references": ["List.append", "List", "Append.mk", "Append"],
  "name": "List.instAppendList",
  "constType": "{α : Type u} → Append (List α)",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "EquivLike.toEmbeddingLike",
   "EquivLike.surjective",
   "FunLike.coe",
   "And.intro",
   "EquivLike.injective"],
  "name": "EquivLike.bijective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Bijective ↑e",
  "constCategory": "Theorem"},
 {"references": ["Setoid"],
  "name": "Setoid.r",
  "constType": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ.injEq",
   "implies_congr",
   "Eq",
   "Nat.zero_add",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "id"],
  "name": "Nat.add_left_cancel",
  "constType": "∀ {n m k : ℕ}, n + m = n + k → m = k",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.not_mem_zero",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.7",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Or.inl",
   "Or.inr",
   "List.instMembershipList",
   "List",
   "Or.casesOn",
   "Eq"],
  "name": "List.mem_insert_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α} (motive : a = b ∨ a ∈ l → Prop) (x : a = b ∨ a ∈ l),\n  (∀ (h' : a = b), motive (_ : a = b ∨ a ∈ l)) → (∀ (h' : a ∈ l), motive (_ : a = b ∨ a ∈ l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "propext",
   "And.intro",
   "And.left",
   "True",
   "Eq"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.name",
  "constType": "Lean.MacroScopesView → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Applicative", "SeqLeft"],
  "name": "Applicative.toSeqLeft",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → SeqLeft f",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "instOfNatNat",
   "Lean.SourceInfo",
   "Nat",
   "Array.size",
   "Lean.Syntax"],
  "name": "Lean.Syntax.getNumArgs",
  "constType": "Lean.Syntax → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "Iff",
   "List.Perm",
   "List.Perm.pairwise_iff",
   "List",
   "Ne.symm"],
  "name": "List.Perm.nodup_iff",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ~ l₂ → (List.Nodup l₁ ↔ List.Nodup l₂)",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "And.intro", "And.casesOn"],
  "name": "and_or_left.match_1",
  "constType":
  "∀ {a b c : Prop} (motive : a ∧ (b ∨ c) → Prop) (x : a ∧ (b ∨ c)),\n  (∀ (ha : a) (hbc : b ∨ c), motive (_ : a ∧ (b ∨ c))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_true",
   "List.insert",
   "List.Perm",
   "DecidableEq",
   "List.Perm.insert",
   "List",
   "True",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.31",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] (a : α) {l₁ l₂ : List α}, l₁ ~ l₂ → (List.insert a l₁ ~ List.insert a l₂) = True",
  "constCategory": "Theorem"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSet._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.closure_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.closure_of._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "List.cons",
   "List.instMembershipList",
   "Mathlib.Data.List.Nodup._auxLemma.1",
   "True",
   "iff_self",
   "Eq",
   "List.Pairwise",
   "And",
   "List.Nodup",
   "Iff",
   "of_eq_true",
   "List",
   "Mathlib.Data.List.Nodup._auxLemma.3",
   "Not",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.nodup_cons",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, List.Nodup (a :: l) ↔ ¬a ∈ l ∧ List.Nodup l",
  "constCategory": "Theorem"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray2",
  "constType": "{α : Type u} → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.succ_pos",
  "constType": "∀ (n : ℕ), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.not_nonempty_iff_eq_empty",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Eq",
   "Iff.symm",
   "And",
   "Iff",
   "of_eq_true",
   "propext",
   "Mathlib.Data.Set.Prod._auxLemma.27",
   "SProd.sprod",
   "congr",
   "Prod",
   "Not",
   "Mathlib.Data.Set.Prod._auxLemma.18",
   "congrArg",
   "Eq.trans"],
  "name": "Set.prod_eq_empty_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, s ×ˢ t = ∅ ↔ s = ∅ ∨ t = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_1"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Set.Nonempty", "Preorder"],
  "name": "BddBelow",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "propext",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Topology.WithUpperSet.toUpperSet_le_iff",
   "Equiv.instFunLikeEquiv"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  (↑Topology.WithUpperSet.toUpperSet a ≤ ↑Topology.WithUpperSet.toUpperSet b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists"],
  "name": "Directed",
  "constType": "{α : Type u} → {ι : Sort w} → (α → α → Prop) → (ι → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "sup_compl_eq_top",
   "IsCompl.of_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "IsCompl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "inf_compl_eq_bot'",
   "BooleanAlgebra"],
  "name": "isCompl_compl",
  "constType": "∀ {α : Type u} {x : α} [inst : BooleanAlgebra α], IsCompl x xᶜ",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool"],
  "name": "_private.Init.Data.List.Basic.0.List.erase.match_1.splitter",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → motive true → motive false → motive x",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "isClosed_closure",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.Subset.trans",
   "closure_minimal",
   "subset_closure"],
  "name": "closure_mono",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ⊆ t → closure s ⊆ closure t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.12",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {b : β} {f : α → β} {l : List α}, (b ∈ List.map f l) = ∃ a ∈ l, f a = b",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "iSup_subtype.match_1",
  "constType":
  "∀ {ι : Sort u_1} {p : ι → Prop} (motive : Subtype p → Prop) (x : Subtype p),\n  (∀ (i : ι) (h : p i), motive { val := i, property := h }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Iff",
   "nhds",
   "Filter.inf_principal_neBot_iff",
   "Set",
   "Set.Nonempty",
   "TopologicalSpace",
   "Inter.inter",
   "Filter",
   "ClusterPt",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "clusterPt_principal_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {x : α} {s : Set α},\n  ClusterPt x (Filter.principal s) ↔ ∀ U ∈ nhds x, Set.Nonempty (U ∩ s)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "propext", "bex_imp", "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.8",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {P : (x : α) → p x → Prop} {b : Prop},\n  ((∃ x, ∃ (h : p x), P x h) → b) = ∀ (x : α) (h : p x), P x h → b",
  "constCategory": "Theorem"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iInter.match_1",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_2} {s : ι → Set α} (x : Set α) (motive : (x ∈ Set.range fun i ↦ s i) → Prop)\n  (x_1 : x ∈ Set.range fun i ↦ s i), (∀ (a : ι) (eq : s a = x), motive (_ : ∃ y, (fun i ↦ s i) y = x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.mk",
  "constType":
  "{α : Type u} →\n  (IsOpen : Set α → Prop) →\n    IsOpen Set.univ →\n      (∀ (s t : Set α), IsOpen s → IsOpen t → IsOpen (s ∩ t)) →\n        (∀ (s : Set (Set α)), (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)) → TopologicalSpace α",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Antitone",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{α : Type u_1} → List α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.SourceInfo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Fin.val", "Eq.rec", "Nat", "rfl", "Fin", "Eq"],
  "name": "Fin.val_eq_of_eq",
  "constType": "∀ {n : ℕ} {i j : Fin n}, i = j → ↑i = ↑j",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "isLUB_pair",
   "Set.image_pair",
   "PartialOrder.toPreorder",
   "Set",
   "GaloisConnection.isLUB_l_image",
   "Insert.insert",
   "True",
   "IsLUB",
   "Eq",
   "SemilatticeSup",
   "IsLUB.unique",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "Mathlib.Order.GaloisConnection._auxLemma.1",
   "Singleton.singleton",
   "Sup.sup",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun",
   "Set.instInsertSet"],
  "name": "GaloisConnection.l_sup",
  "constType":
  "∀ {α : Type u} {β : Type v} {a₁ a₂ : α} [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] {l : α → β} {u : β → α},\n  GaloisConnection l u → l (a₁ ⊔ a₂) = l a₁ ⊔ l a₂",
  "constCategory": "Theorem"},
 {"references": ["cond.match_1", "Bool.true", "Unit", "Bool"],
  "name": "or",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references": ["upperBounds", "Set", "Set.Nonempty", "Preorder"],
  "name": "BddAbove",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.23",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "List", "List.nil", "Inhabited.mk"],
  "name": "instInhabitedList",
  "constType": "{α : Type u_1} → Inhabited (List α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "mem_of_mem_nhds.match_1",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "mem_of_mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, s ∈ nhds a → a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_4",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
  "constType": "{α : Type u_3} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "List.pmap",
   "List.Perm.pmap",
   "List.instMembershipList",
   "List.isSetoid",
   "Eq.refl",
   "Multiset.instMembershipMultiset",
   "Eq",
   "List.Perm.subset",
   "Setoid.r",
   "List.Perm",
   "Eq.ndrec",
   "List",
   "Eq.rec",
   "Multiset",
   "Quot",
   "Multiset.ofList",
   "Eq.trans",
   "Quot.mk",
   "Quot.sound"],
  "name": "Multiset.pmap.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : (a : α) → p a → β) (l₁ l₂ : List α) (pp : l₁ ~ l₂),\n  Eq.ndrec (motive := fun x ↦ (∀ a ∈ x, p a) → Multiset β) (fun H ↦ ↑(List.pmap f l₁ H))\n      (_ : Quot.mk Setoid.r l₁ = Quot.mk Setoid.r l₂) =\n    fun H ↦ ↑(List.pmap f l₂ H)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_inf_iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.31",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, (a ≤ b ⊓ c) = (a ≤ b ∧ a ≤ c)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Iff",
   "Iff.rfl",
   "Function.comp",
   "OrderDual",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "Antitone",
   "Equiv.instFunLikeEquiv"],
  "name": "monotone_toDual_comp_iff",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone (↑OrderDual.toDual ∘ f) ↔ Antitone f",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.le_sup_inf",
  "constType":
  "∀ {α : Type u_1} [self : DistribLattice α] (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Iff.trans",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a → a ⊔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.find?",
   "List.cons",
   "HEq",
   "HEq.refl",
   "Option.none",
   "List",
   "Eq.refl",
   "List.casesOn",
   "Option.noConfusion",
   "Option.some",
   "Eq.casesOn",
   "List.nil",
   "Bool",
   "Option",
   "Eq"],
  "name": "List.find?_some.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {a : α} (motive : (x : List α) → List.find? p x = some a → Prop) (x : List α)\n  (x_1 : List.find? p x = some a),\n  (∀ (b : α) (l : List α) (H : List.find? p (b :: l) = some a), motive (b :: l) H) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.wf",
   "WellFoundedRelation.rel",
   "InvImage.wf",
   "WellFoundedRelation",
   "WellFounded",
   "InvImage"],
  "name": "invImage.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (h : WellFoundedRelation β),\n  WellFounded (InvImage WellFoundedRelation.rel f)",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "FunLike", "Function.Injective", "EmbeddingLike", "FunLike.coe"],
  "name": "EmbeddingLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      [toFunLike : FunLike F α fun x ↦ β] → (∀ (f : F), Function.Injective ↑f) → EmbeddingLike F α β",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "List.get._sunfold.proof_1",
   "List.brecOn",
   "instAddNat",
   "List.below",
   "instHAdd",
   "Fin.val",
   "HAdd.hAdd",
   "List.get_cons_drop.match_1",
   "List.drop",
   "List.length",
   "rfl",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "List.get",
   "Nat",
   "Fin.mk",
   "Fin"],
  "name": "List.get_cons_drop",
  "constType":
  "∀ {α : Type u_1} (l : List α) (i : Fin (List.length l)), List.get l i :: List.drop (↑i + 1) l = List.drop (↑i) l",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Surjective", "Exists.intro", "Function.Involutive", "Eq"],
  "name": "Function.Involutive.surjective",
  "constType":
  "∀ {α : Sort u} {f : α → α}, Function.Involutive f → Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["Subtype.val", "NonemptyType", "Nonempty"],
  "name": "NonemptyType.type",
  "constType": "NonemptyType → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLower.toDualHomeomorph.proof_2",
   "Topology.WithLower.toDualHomeomorph.proof_1",
   "Homeomorph",
   "Topology.WithLower.toDualHomeomorph.proof_3",
   "OrderDual",
   "Equiv.mk",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithLower α ≃ₜ Topology.WithUpper αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "forall_eq_or_imp", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.45",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∀ (a : α), a = a' ∨ q a → p a) = (p a' ∧ ∀ (a : α), q a → p a)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Iff",
   "Classical.propDecidable",
   "Not",
   "Decidable.or_iff_not_imp_left"],
  "name": "or_iff_not_imp_left",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Data.AC.ContextInformation",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«term𝓝[≥]_»._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.«term𝓝[≥]_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.Finite.induction_on",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.sInter_empty",
   "IsOpen.inter",
   "Eq.refl",
   "Inter.inter",
   "Set.instEmptyCollectionSet",
   "And.left",
   "Insert.insert",
   "Set.univ",
   "isOpen_univ",
   "Set.Finite",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "And.right",
   "Eq.mpr",
   "Set.sInter_insert",
   "Eq.ndrec",
   "Eq.mp",
   "TopologicalSpace",
   "Not",
   "congrArg",
   "Set.sInter",
   "Mathlib.Topology.Basic._auxLemma.3",
   "IsOpen",
   "Set.instInterSet",
   "Set.instInsertSet",
   "id"],
  "name": "Set.Finite.isOpen_sInter",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set (Set α)}, Set.Finite s → (∀ t ∈ s, IsOpen t) → IsOpen (⋂₀ s)",
  "constCategory": "Theorem"},
 {"references": ["AddLeftCancelSemigroup", "AddSemigroup"],
  "name": "AddLeftCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddLeftCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MacroScopesView",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "Finset.mem_map'",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Iff.mpr"],
  "name": "Finset.mem_map_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α ↪ β) {a : α} {s : Finset α}, a ∈ s → ↑f a ∈ Finset.map f s",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike", "RelHomClass", "FunLike.coe"],
  "name": "RelHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} →\n          [toFunLike : FunLike F α fun x ↦ β] → (∀ (f : F) {a b : α}, r a b → s (↑f a) (↑f b)) → RelHomClass F r s",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "IsUpperSet",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "Preorder",
   "IsOpen",
   "Preorder.toLE"],
  "name": "Topology.IsUpper.isUpperSet_of_isOpen",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] {s : Set α},\n  IsOpen s → IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "Iff",
   "forall_swap",
   "PartialOrder.toPreorder",
   "Disjoint",
   "OrderBot.toBot",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "forall_congr'",
   "PartialOrder"],
  "name": "disjoint_comm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "continuous_coinduced_rng",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.coinduced",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α],\n  Continuous\n    { toFun := ↑OrderDual.toDual, invFun := ↑OrderDual.ofDual,\n        left_inv := (_ : ∀ (a : αᵒᵈ), ↑OrderDual.toDual (↑OrderDual.ofDual a) = a),\n        right_inv := (_ : ∀ (a : Topology.WithUpper αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Logic._auxLemma.40",
   "And",
   "Exists",
   "funext",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self"],
  "name": "exists_and_right",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x ∧ b) ↔ (∃ x, p x) ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "HEq",
   "compl_compl",
   "Set",
   "eq_of_heq",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "HEq.refl",
   "LE",
   "Eq.casesOn",
   "IsLowerSet.compl",
   "Eq.symm",
   "IsUpperSet.compl",
   "id"],
  "name": "isLowerSet_compl",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s : Set α}, IsLowerSet sᶜ ↔ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.singleton_subset_iff",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.132",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, ({a} ⊆ s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "∀ {α : Sort u}, α → Nonempty α",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.lt_or_ge.match_2",
  "constType":
  "∀ (n m : ℕ) (motive : n < m ∨ n ≥ m → Prop) (x : n < m ∨ n ≥ m),\n  (∀ (h : n < m), motive (_ : n < m ∨ n ≥ m)) → (∀ (h : n ≥ m), motive (_ : n < m ∨ n ≥ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "Iff.mp",
   "List.Perm",
   "List.instMembershipList",
   "List",
   "List.Perm.mem_iff",
   "HasSubset.Subset"],
  "name": "List.Perm.subset",
  "constType": "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ~ l₂ → l₁ ⊆ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["List.forall_mem_ne",
   "Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.1",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, (∀ a' ∈ l, ¬a = a') = ¬a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd.proof_1",
  "constType": "∀ (M : Type u_1) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Theorem"},
 {"references": ["outParam", "InfSet"],
  "name": "sInfHomClass",
  "constType":
  "Type u_8 →\n  (α : outParam (Type u_9)) →\n    (β : outParam (Type u_10)) → [inst : InfSet α] → [inst : InfSet β] → Type (max (max u_10 u_8) u_9)",
  "constCategory": "Other"},
 {"references": ["PLift", "Finite", "instFinitePLift.proof_1"],
  "name": "instFinitePLift",
  "constType": "∀ {α : Sort u_1} [inst : Finite α], Finite (PLift α)",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse", "funext", "Function.comp", "Eq", "id"],
  "name": "Function.LeftInverse.comp_eq_id",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.LeftInverse f g → f ∘ g = id",
  "constCategory": "Theorem"},
 {"references": ["Set.iUnion", "Set", "LE", "isUpperSet_iUnion", "IsUpperSet"],
  "name": "isUpperSet_iUnion₂",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_5} [inst : LE α] {f : (i : ι) → κ i → Set α},\n  (∀ (i : ι) (j : κ i), IsUpperSet (f i j)) → IsUpperSet (⋃ i, ⋃ j, f i j)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Iff.symm",
   "Exists",
   "Iff",
   "Subtype.exists",
   "Subtype.val",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists'",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop}, (∃ x, ∃ (h : p x), q x h) ↔ ∃ x, q ↑x (_ : p ↑x)",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "ReaderT.bind",
   "ReaderT.instApplicativeReaderT",
   "Monad.mk",
   "Bind.mk"],
  "name": "ReaderT.instMonadReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → Monad (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Set.inter_isComm.proof_1",
   "Inter.inter",
   "Set.instInterSet",
   "IsCommutative"],
  "name": "Set.inter_isComm",
  "constType": "∀ {α : Type u}, IsCommutative (Set α) fun x x_1 ↦ x ∩ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Decidable.isFalse",
   "propext",
   "instDecidableEqProp.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqProp.proof_1",
   "Eq"],
  "name": "instDecidableEqProp",
  "constType": "{p q : Prop} → [d : Decidable (p ↔ q)] → Decidable (p = q)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Set.univ_inter",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_right",
  "constType": "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ g → s ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references": ["nhds", "TopologicalSpace", "Filter", "Eq"],
  "name": "Inseparable",
  "constType": "{X : Type u_1} → [inst : TopologicalSpace X] → X → X → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_iff",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ f ⊓ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, s = t₁ ∩ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "PLift.up", "propext", "PLift.exists", "PLift", "Eq"],
  "name": "Mathlib.Data.ULift._auxLemma.3",
  "constType":
  "∀ {α : Sort u} {p : PLift α → Prop}, (∃ x, p x) = ∃ x, p { down := x }",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Bot.bot",
   "Pi.orderBot.proof_1",
   "OrderBot.toBot",
   "Bot.mk",
   "inferInstanceAs",
   "LE",
   "OrderBot.mk",
   "OrderBot",
   "Pi.hasLe",
   "Pi.instBotForAll"],
  "name": "Pi.orderBot",
  "constType":
  "{ι : Type u_3} →\n  {α' : ι → Type u_4} → [inst : (i : ι) → LE (α' i)] → [inst_1 : (i : ι) → OrderBot (α' i)] → OrderBot ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Top",
   "setOf",
   "Filter.mk",
   "Filter.instTopFilter.proof_2",
   "Set",
   "Filter.instTopFilter.proof_1",
   "Filter",
   "Set.mem_univ",
   "Top.mk",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter",
  "constType": "{α : Type u} → Top (Filter α)",
  "constCategory": "Definition"},
 {"references": ["OrderTop", "LE", "OrderBot", "BoundedOrder"],
  "name": "BoundedOrder.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toOrderTop : OrderTop α] → [toOrderBot : OrderBot α] → BoundedOrder α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "Nat.sub_lt.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → 0 < x → 0 < x_1 → Prop) (x x_1 : ℕ) (x_2 : 0 < x) (x_3 : 0 < x_1),\n  (∀ (x : ℕ) (h1 : 0 < 0) (x_4 : 0 < x), motive 0 x h1 x_4) →\n    (∀ (n : ℕ) (x : 0 < n + 1) (h2 : 0 < 0), motive (Nat.succ n) 0 x h2) →\n      (∀ (n m : ℕ) (x : 0 < n + 1) (x_4 : 0 < m + 1), motive (Nat.succ n) (Nat.succ m) x x_4) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.error",
  "constType": "{ε σ α : Type u} → ε → σ → EStateM.Result ε σ α",
  "constCategory": "Other"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.toLowerSet",
  "constType": "{α : Type u_1} → α ≃ Topology.WithLowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "instTopologicalSpaceProd",
   "CompleteLattice.toBoundedOrder",
   "ConditionallyCompleteLattice.toLattice",
   "Prod.completeLattice",
   "ContinuousInf",
   "Preorder.toLE",
   "Lattice.toInf",
   "Topology.instIsLowerProd",
   "CompleteLattice",
   "Topology.IsLower",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "ContinuousInf.mk",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sInfHom.continuous",
   "BoundedOrder.toOrderBot",
   "infsInfHom"],
  "name": "Topology.IsLower.toContinuousInf.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], ContinuousInf α",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Prod.semilatticeSup",
   "SemilatticeSup.sup_le",
   "inferInstanceAs",
   "Sup.sup",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.lattice.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b c : α × β), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["PSigma", "PSigma.mk"],
  "name": "PSigma.rec",
  "constType":
  "{α : Sort u} →\n  {β : α → Sort v} →\n    {motive : PSigma β → Sort u_1} →\n      ((fst : α) → (snd : β fst) → motive { fst := fst, snd := snd }) → (t : PSigma β) → motive t",
  "constCategory": "Other"},
 {"references": ["PProd", "List.rec", "List", "PUnit"],
  "name": "List.below",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max 1 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "dite",
   "List.pwFilter_cons_of_neg",
   "Iff.mpr",
   "Eq",
   "List.Pairwise",
   "PProd",
   "And",
   "PProd.fst",
   "List.pwFilter_cons_of_pos",
   "List.rec",
   "List.decidableBAll",
   "List.pairwise_cons",
   "List",
   "List.pwFilter_map.match_1",
   "Eq.rec",
   "PUnit",
   "Not",
   "List.pwFilter",
   "And.intro",
   "List.nil",
   "Eq.symm",
   "DecidableRel"],
  "name": "List.pairwise_pwFilter",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R] (l : List α), List.Pairwise R (List.pwFilter R l)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Set.inter_univ",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_left",
  "constType": "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ f → s ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Expr", "Nat"],
  "name": "Lean.Data.AC.Expr.var",
  "constType": "ℕ → Lean.Data.AC.Expr",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "Set.preimage",
   "isOpen_biUnion",
   "Function.sometimes",
   "Set",
   "Eq.refl",
   "Set.iUnion₂_congr",
   "Exists.intro",
   "And.left",
   "Function.sometimes_spec",
   "Set.instMembershipSet",
   "Eq",
   "Set.sUnion_eq_biUnion",
   "Set.preimage_iUnion₂",
   "And",
   "And.right",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.iUnion",
   "Set.instInhabitedSet",
   "TopologicalSpace",
   "Set.sUnion",
   "And.intro",
   "IsOpen",
   "instNonempty",
   "id"],
  "name": "TopologicalSpace.induced.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (t : TopologicalSpace β) (S : Set (Set α)),\n  (∀ t_1 ∈ S, (fun s ↦ ∃ s', IsOpen s' ∧ f ⁻¹' s' = s) t_1) → ∃ s', IsOpen s' ∧ f ⁻¹' s' = ⋃₀ S",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm",
   "List",
   "List.nil",
   "List.eq_nil_of_length_eq_zero",
   "Eq"],
  "name": "List.Perm.eq_nil",
  "constType": "∀ {α : Type uu} {l : List α}, l ~ [] → l = []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "UInt64",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["List.cons", "List", "List.Sublist", "List.Sublist.cons₂"],
  "name": "List.Sublist.cons_cons",
  "constType":
  "∀ {α : Type u} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist (a :: l₁) (a :: l₂)",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Topology.Inseparable._auxLemma.20",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references": ["HAppend.mk", "HAppend", "Append", "Append.append"],
  "name": "instHAppend",
  "constType": "{α : Type u_1} → [inst : Append α] → HAppend α α α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_iInf",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_iInf₂",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {a : α} {f : (i : ι) → κ i → α},\n  (∀ (i : ι) (j : κ i), a ≤ f i j) → a ≤ ⨅ i, ⨅ j, f i j",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_1",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Nat",
   "Lean.Data.AC.Expr.casesOn",
   "Lean.Data.AC.Expr.var"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40",
  "constType":
  "(motive : Lean.Data.AC.Expr → Sort u_1) →\n  (x : Lean.Data.AC.Expr) →\n    ((a : ℕ) → motive (Lean.Data.AC.Expr.var a)) →\n      ((a a_1 : Lean.Data.AC.Expr) → motive (Lean.Data.AC.Expr.op a a_1)) → motive x",
  "constCategory": "Definition"},
 {"references": ["implies_dep_congr_ctx", "Eq"],
  "name": "implies_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Set.Subset", "Set", "LE"],
  "name": "Set.instLESet",
  "constType": "{α : Type u_1} → LE (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Lattice._auxLemma.2",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Eq",
   "SemilatticeSup",
   "And",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "le_antisymm",
   "congrArg",
   "Eq.trans",
   "and_self",
   "SemilatticeSup.toPartialOrder"],
  "name": "sup_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ⊔ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "Bool.false",
   "List",
   "Unit",
   "Bool.true",
   "Eq.refl",
   "Not",
   "List.erase.match_1",
   "Bool",
   "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
   "eq_false_of_ne_true",
   "id",
   "Eq"],
  "name": "List.filter_cons_of_neg",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {a : α} (l : List α), ¬p a = true → List.filter p (a :: l) = List.filter p l",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Nat.rec",
   "instLENat",
   "Nat.pred_le",
   "Nat.pred",
   "instSubNat",
   "Nat.le_refl",
   "HSub.hSub",
   "Nat.le_trans",
   "instOfNatNat",
   "Nat",
   "LE.le"],
  "name": "Nat.sub_le",
  "constType": "∀ (n m : ℕ), n - m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "of_eq_true",
   "List.rec",
   "List",
   "Function.comp",
   "List.nil",
   "List.map",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.map_map",
  "constType":
  "∀ {β : Type u_1} {γ : Type u_2} {α : Type u_3} (g : β → γ) (f : α → β) (l : List α),\n  List.map g (List.map f l) = List.map (g ∘ f) l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "CanLift",
  "constType":
  "(α : Sort u_1) → (β : Sort u_2) → outParam (β → α) → outParam (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[>]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["cond",
   "Nat.add_comm",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.countP.go",
   "Eq",
   "List.countP_go_eq_add",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "id"],
  "name": "List.countP_cons_of_pos",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {a : α} (l : List α), p a = true → List.countP p (a :: l) = List.countP p l + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.inf_compl_le_bot",
  "constType": "∀ {α : Type u} [self : BooleanAlgebra α] (x : α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Definition"},
 {"references": ["Exists", "False", "not_forall_of_exists_not.match_1", "Not"],
  "name": "not_forall_of_exists_not",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (∃ x, ¬p x) → ¬∀ (x : α), p x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "Directed.mono.match_1",
   "Directed"],
  "name": "Directed.mono",
  "constType":
  "∀ {α : Type u} {r s : α → α → Prop} {ι : Sort u_1} {f : ι → α},\n  (∀ (a b : α), r a b → s a b) → Directed r f → Directed s f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Topology.Bases._auxLemma.1",
   "funext",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff",
   "congrArg",
   "Eq.trans",
   "Filter.HasBasis.mk",
   "TopologicalSpace.IsTopologicalBasis",
   "instMembershipSetFilter"],
  "name": "TopologicalSpace.IsTopologicalBasis.nhds_hasBasis",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {b : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis b → ∀ {a : α}, Filter.HasBasis (nhds a) (fun t ↦ t ∈ b ∧ a ∈ t) fun t ↦ t",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_dedup",
   "eq_true",
   "List.Nodup",
   "DecidableEq",
   "List.dedup",
   "List",
   "True",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.30",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] (l : List α), List.Nodup (List.dedup l) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«termI^_»._closed_1",
   "Topology.termπ_._closed_1"],
  "name": "Topology.termπ_._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Multiset", "Finset", "Multiset.Nodup", "Finset.mk", "Finset.rec"],
  "name": "Finset.casesOn",
  "constType":
  "{α : Type u_4} →\n  {motive : Finset α → Sort u} →\n    (t : Finset α) →\n      ((val : Multiset α) → (nodup : Multiset.Nodup val) → motive { val := val, nodup := nodup }) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "Nat.rec",
   "OfNat.ofNat",
   "Nat.zero",
   "Nat.pred",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "absurd",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_pred",
  "constType": "∀ {a : ℕ}, a ≠ 0 → Nat.succ (Nat.pred a) = a",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "IsOpen.interior_eq",
   "Eq.rec",
   "Set",
   "TopologicalSpace",
   "isOpen_interior",
   "IsOpen",
   "interior",
   "Eq"],
  "name": "interior_eq_iff_isOpen",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, interior s = s ↔ IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (a b c : α × β),\n  a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet",
   "Equiv.toHomeomorphOfInducing",
   "Homeomorph",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.ofLowerSet",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.WithLowerSetHomeomorph.proof_1"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsLowerSet α] → Topology.WithLowerSet α ≃ₜ α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Or", "propext", "exists_or", "Eq"],
  "name": "Std.Logic._auxLemma.47",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∃ x, p x ∨ q x) = ((∃ x, p x) ∨ ∃ x, q x)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.MacroM",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["SupSet", "funext", "congr_arg", "iSup", "Eq"],
  "name": "iSup_congr",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : SupSet α] {f g : ι → α}, (∀ (i : ι), f i = g i) → ⨆ i, f i = ⨆ i, g i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Order.Frame.toCompleteLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteDistribLattice.iInf_sup_le_sup_sInf",
  "constType":
  "∀ {α : Type u_1} [self : CompleteDistribLattice α] (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Continuous_of._closed_4",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.Continuous_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.IsOpen_of._closed_1",
   "Topology.IsOpen_of._closed_2"],
  "name": "Topology.IsOpen_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Pi.le_def", "propext", "LE", "Pi.hasLe", "LE.le", "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.10",
  "constType":
  "∀ {ι : Type u} {α : ι → Type v} [inst : (i : ι) → LE (α i)] {x y : (i : ι) → α i}, (x ≤ y) = ∀ (i : ι), x i ≤ y i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Filter.comap.proof_1",
   "Filter",
   "Filter.comap.proof_3",
   "Filter.comap.proof_2",
   "instMembershipSetFilter"],
  "name": "Filter.comap",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Filter β → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "List.Pairwise.cons",
   "Mathlib.Data.List.Chain._auxLemma.8",
   "implies_congr",
   "True",
   "Eq",
   "Mathlib.Data.List.Chain._auxLemma.9",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "forall_congr",
   "PUnit",
   "List.nil",
   "List.Chain",
   "Mathlib.Data.List.Chain._auxLemma.7",
   "Eq.trans",
   "id",
   "Membership.mem",
   "trans",
   "List.cons",
   "Or",
   "List.pairwise_singleton",
   "List.Pairwise",
   "And",
   "eq_true",
   "PProd.fst",
   "List",
   "IsTrans",
   "congrArg",
   "List.Chain.pairwise.match_1",
   "List.rel_of_pairwise_cons",
   "congrFun"],
  "name": "List.Chain.pairwise",
  "constType":
  "∀ {α : Type u} {R : α → α → Prop} [inst : IsTrans α R] {a : α} {l : List α}, List.Chain R a l → List.Pairwise R (a :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Pi.booleanAlgebra",
   "Not",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_3",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.val",
   "LT.lt",
   "Fin.eq_of_val_eq.match_1",
   "Nat",
   "rfl",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Fin.eq_of_val_eq",
  "constType": "∀ {n : ℕ} {i j : Fin n}, ↑i = ↑j → i = j",
  "constCategory": "Theorem"},
 {"references": ["List.Pairwise", "Ne", "List"],
  "name": "List.Nodup",
  "constType": "{α : Type u_1} → List α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Order.Filter.Prod._auxLemma.20",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Subtype.val",
   "Set",
   "Mathlib.Order.Filter.Prod._auxLemma.28",
   "Eq.refl",
   "CompleteLattice.toBot",
   "Mathlib.Order.Filter.Prod._auxLemma.21",
   "True",
   "Mathlib.Order.Filter.Prod._auxLemma.23",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Mathlib.Order.Filter.Prod._auxLemma.24",
   "SProd.sprod",
   "Filter",
   "Mathlib.Order.Filter.Prod._auxLemma.27",
   "Eq.trans",
   "instNonempty",
   "Subtype",
   "id",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Set.instSProd",
   "Or",
   "Bot.bot",
   "funext",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Filter.instSProd",
   "Mathlib.Order.Filter.Prod._auxLemma.26",
   "Filter.inhabitedMem",
   "And",
   "Set.instHasSubsetSet",
   "Mathlib.Order.Filter.Prod._auxLemma.6",
   "of_eq_true",
   "Mathlib.Order.Filter.Prod._auxLemma.22",
   "congr",
   "Prod",
   "Mathlib.Order.Filter.Prod._auxLemma.29",
   "congrArg",
   "Subtype.mk",
   "Mathlib.Order.Filter.Prod._auxLemma.25",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Filter.prod_eq_bot",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : Filter α} {g : Filter β}, f ×ˢ g = ⊥ ↔ f = ⊥ ∨ g = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_9",
   "Topology.«term𝓝[≠]_»._closed_4"],
  "name": "Topology.«term𝓝[≠]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "closure",
   "Set.instSProd",
   "instTopologicalSpaceProd",
   "Set",
   "True",
   "Eq",
   "Iff.mp",
   "of_eq_true",
   "closure_prod_eq",
   "closure_eq_iff_isClosed",
   "SProd.sprod",
   "IsClosed.closure_eq",
   "congr",
   "TopologicalSpace",
   "Prod",
   "IsClosed",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "IsClosed.prod",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s₁ : Set α} {s₂ : Set β},\n  IsClosed s₁ → IsClosed s₂ → IsClosed (s₁ ×ˢ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "IsClosed.isOpen_compl",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed.mk",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "isOpen_compl_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen sᶜ ↔ IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_5",
   "List.cons",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "HasSubset.Subset",
   "le_rfl",
   "And.intro",
   "Exists.intro",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "subset_lowerClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, s ⊆ ↑(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gt_of_not_le",
   "instSubNat",
   "Nat.decLt",
   "Eq.refl",
   "instLTNat",
   "Nat.mod_eq_of_lt",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff.mp",
   "instOfNatNat",
   "Nat",
   "Decidable.not_and_iff_or_not",
   "Eq.symm",
   "absurd",
   "Nat.decLe",
   "id",
   "instHSub",
   "Or",
   "HSub.hSub",
   "LE.le",
   "Nat.mod.inductionOn",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "HMod.hMod",
   "Not",
   "Nat.mod_lt.match_1",
   "Nat.mod_eq_sub_mod"],
  "name": "Nat.mod_lt",
  "constType": "∀ (x : ℕ) {y : ℕ}, y > 0 → x % y < y",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "List.cons",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Function.RightInverse", "Function.comp", "Eq", "id"],
  "name": "Function.RightInverse.comp_eq_id",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.RightInverse f g → g ∘ f = id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Topology.WithUpper",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "isOpen_compl_iff",
   "Eq",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "isClosed_compl_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsClosed sᶜ ↔ IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "Mathlib.Topology.Basic._auxLemma.15",
   "Set",
   "HasSubset.Subset",
   "interior_eq_iff_isOpen",
   "True",
   "iff_self",
   "Eq",
   "Iff.symm",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "propext",
   "TopologicalSpace",
   "congrArg",
   "Mathlib.Topology.Basic._auxLemma.16",
   "interior",
   "IsOpen",
   "Eq.trans",
   "congrFun"],
  "name": "subset_interior_iff_isOpen",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, s ⊆ interior s ↔ IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithUpper", "Equiv.refl"],
  "name": "Topology.WithUpper.toUpper",
  "constType": "{α : Type u_1} → α ≃ Topology.WithUpper α",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.eq_of_length",
   "List.Sublist.length_le",
   "instLENat",
   "List",
   "List.Sublist",
   "List.length",
   "Nat",
   "Nat.le_antisymm",
   "LE.le",
   "Eq"],
  "name": "List.Sublist.eq_of_length_le",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.length l₂ ≤ List.length l₁ → l₁ = l₂",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "Equiv.toFun",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "sSupHom",
   "OrderDual.infSet",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "FunLike.coe",
   "sSupHom.dual",
   "instTopologicalSpaceOrderDual",
   "sSupHom.instSSupHomClassSSupHom",
   "sSupHomClass.toFunLike",
   "CompleteLattice",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Continuous",
   "ConditionallyCompleteLattice.toSupSet",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "sInfHom.continuous",
   "CompleteLattice.toSupSet"],
  "name": "sSupHom.continuous",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : CompleteLattice α] [inst_1 : CompleteLattice β] [inst_2 : TopologicalSpace α]\n  [inst_3 : Topology.IsUpper α] [inst_4 : TopologicalSpace β] [inst_5 : Topology.IsUpper β] (f : sSupHom α β),\n  Continuous ↑f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.mem_range'",
   "List.range'",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "instLTNat",
   "Eq",
   "And",
   "instHMul",
   "propext",
   "List",
   "LT.lt",
   "HMul.hMul",
   "Nat",
   "instMulNat"],
  "name": "Std.Data.List.Lemmas._auxLemma.107",
  "constType":
  "∀ {m s step n : ℕ}, (m ∈ List.range' s n step) = ∃ i < n, m = s + step * i",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsAssociative",
  "constType": "(α : Type u) → (α → α → α) → Prop",
  "constCategory": "Other"},
 {"references":
  ["UpperSet.casesOn",
   "Eq.ndrec",
   "Eq.rec",
   "Set",
   "UpperSet.carrier",
   "Eq.refl",
   "LE",
   "UpperSet.mk",
   "IsUpperSet",
   "Eq.symm",
   "UpperSet",
   "Eq"],
  "name": "UpperSet.instSetLikeUpperSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] (s t : UpperSet α), s.carrier = t.carrier → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "GaloisConnection.l_u_le",
   "LE.le.trans",
   "Monotone",
   "GaloisConnection.le_u",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "GaloisConnection.monotone_u",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → Monotone u",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.union_eq_self_of_subset_left",
   "Union.union",
   "Set",
   "Filter.mem_of_superset",
   "Eq.refl",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Set.subset_union_left",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.inter_union_distrib_right",
   "Filter",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Set.instUnionSet",
   "id",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α) {x y : Set α},\n  x ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} → x ⊆ y → y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk",
   "rfl",
   "Eq"],
  "name": "Equiv.pprodEquivProd.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (x : PProd α β),\n  (fun x ↦ { fst := x.1, snd := x.2 }) ((fun x ↦ (x.fst, x.snd)) x) =\n    (fun x ↦ { fst := x.1, snd := x.2 }) ((fun x ↦ (x.fst, x.snd)) x)",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.append",
   "List.instAppendList",
   "List.Perm",
   "List.Perm.refl",
   "HAppend.hAppend",
   "List",
   "List.Perm.trans",
   "List.nil",
   "List.Perm.rec",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.append_right",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α} (t₁ : List α), l₁ ~ l₂ → l₁ ++ t₁ ~ l₂ ++ t₁",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Unit",
   "Unit.unit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.hash.match_1",
  "constType":
  "(motive : Lean.Name → Sort u_1) →\n  (x : Lean.Name) →\n    (Unit → motive Lean.Name.anonymous) →\n      ((p : Lean.Name) → (s : String) → motive (Lean.Name.str p s)) →\n        ((p : Lean.Name) → (v : ℕ) → motive (Lean.Name.num p v)) → motive x",
  "constCategory": "Definition"},
 {"references": ["DistribLattice", "GeneralizedBooleanAlgebra"],
  "name": "GeneralizedBooleanAlgebra.toDistribLattice",
  "constType":
  "{α : Type u} → [self : GeneralizedBooleanAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual.instIsUpper.proof_1",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "OrderDual.instIsUpper",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], Topology.IsUpper αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Set.range", "InfSet.sInf", "InfSet"],
  "name": "iInf",
  "constType":
  "{α : Type u_1} → [inst : InfSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_of_forall",
  "constType": "∀ {α : Type u} {s : Set α}, (∀ (x : α), x ∈ s) → s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "propext",
   "Sup.sup",
   "Eq.symm",
   "sup_le_iff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.9",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, (a ≤ c ∧ b ≤ c) = (a ⊔ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Perm",
   "List.instMembershipList",
   "propext",
   "List",
   "List.Perm.mem_iff",
   "Eq"],
  "name": "Multiset.Mem.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (l₁ l₂ : List α), l₁ ~ l₂ → (fun l ↦ a ∈ l) l₁ = (fun l ↦ a ∈ l) l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "IsGLB",
   "Set.preimage",
   "Set",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "IsLUB",
   "Equiv.instFunLikeEquiv"],
  "name": "IsGLB.dual",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α},\n  IsGLB s a → IsLUB (↑OrderDual.ofDual ⁻¹' s) (↑OrderDual.toDual a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.iUnion",
   "isUpperSet_iUnion₂",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "LE",
   "UpperSet.upper",
   "IsUpperSet",
   "UpperSet",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "UpperSet.instInfSetUpperSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] (S : Set (UpperSet α)), IsUpperSet (⋃ i ∈ S, ↑i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List.Nodup.pmap",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.pmap",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Quot.mk",
   "Eq"],
  "name": "Multiset.Nodup.pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → Prop} {f : (a : α) → p a → β} {s : Multiset α} {H : ∀ a ∈ s, p a},\n  (∀ (a : α) (ha : p a) (b : α) (hb : p b), f a ha = f b hb → a = b) →\n    Multiset.Nodup s → Multiset.Nodup (Multiset.pmap f s H)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "IsLowerSet",
   "Set",
   "LE",
   "Set.sUnion",
   "Exists.imp",
   "And.intro",
   "And.left",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isLowerSet_sUnion",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {S : Set (Set α)}, (∀ s ∈ S, IsLowerSet s) → IsLowerSet (⋃₀ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Filter.HasBasis.comap",
   "And",
   "Filter.HasBasis",
   "Filter.HasBasis.inf",
   "Prod.snd",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Filter.comap",
   "Prod",
   "Filter",
   "Prod.fst",
   "Filter.instSProd"],
  "name": "Filter.HasBasis.prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {la : Filter α} {lb : Filter β} {ι : Type u_6} {ι' : Type u_7} {pa : ι → Prop}\n  {sa : ι → Set α} {pb : ι' → Prop} {sb : ι' → Set β},\n  Filter.HasBasis la pa sa →\n    Filter.HasBasis lb pb sb → Filter.HasBasis (la ×ˢ lb) (fun i ↦ pa i.1 ∧ pb i.2) fun i ↦ sa i.1 ×ˢ sb i.2",
  "constCategory": "Theorem"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.lift.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder β] (f : α → β) (x x_1 x_2 : α),\n  f x ≤ f x_1 → f x_1 ≤ f x_2 → f x ≤ f x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.plift", "PLift", "Finite", "Finite.of_equiv", "Equiv.symm"],
  "name": "instFinitePLift.proof_1",
  "constType": "∀ {α : Sort u_1} [inst : Finite α], Finite (PLift α)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.top_le_sup_compl",
  "constType": "∀ {α : Type u} [self : BooleanAlgebra α] (x : α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.Chain",
  "constType": "{α : Type u_1} → (α → α → Prop) → α → List α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Function.Surjective.exists",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Function.Surjective",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Filter",
   "Filter.HasBasis.mem_iff",
   "Filter.HasBasis.mk",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.comp_surjective",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ {g : ι' → ι}, Function.Surjective g → Filter.HasBasis l (p ∘ g) (s ∘ g)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.termΩ._closed_3",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.Homotopy.termΩ._closed_5"],
  "name": "Topology.Homotopy.termΩ._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.rec._cstage1",
  "constType":
  "{α : Type u_1} →\n  {β : Topology.WithUpperSet α → Sort u_4} →\n    ((a : α) → β (↑Topology.WithUpperSet.toUpperSet a)) → (a : Topology.WithUpperSet α) → β a",
  "constCategory": "Definition"},
 {"references": ["Lattice", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toLattice",
  "constType":
  "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Eq.refl",
   "Insert.insert",
   "True",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "Set.instSingletonSet",
   "InfHomClass.mk",
   "InfHomClass.toFunLike",
   "Set.image",
   "Eq.symm",
   "Eq.trans",
   "id",
   "eq_self",
   "sInfHomClass.map_sInf",
   "Set.image_pair",
   "Top.top",
   "sInfHomClass.toFunLike",
   "Set.instEmptyCollectionSet",
   "FunLike.coe",
   "sInf_empty",
   "sInfHomClass",
   "sInf_singleton",
   "sInf_insert",
   "CompleteLattice",
   "Eq.ndrec",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "CompleteLattice.toTop",
   "Singleton.singleton",
   "sInf_pair",
   "Set.image_empty",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Set.instInsertSet",
   "congrFun"],
  "name": "sInfHomClass.toInfTopHomClass.proof_2",
  "constType":
  "∀ {F : Type u_3} {α : Type u_2} {β : Type u_1} [inst : CompleteLattice α] [inst_1 : CompleteLattice β]\n  [inst_2 : sInfHomClass F α β] (f : F), ↑f ⊤ = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Iff.intro",
   "isClosed_closure",
   "Iff",
   "Eq.rec",
   "Set",
   "IsClosed.closure_eq",
   "TopologicalSpace",
   "IsClosed",
   "Eq"],
  "name": "closure_eq_iff_isClosed",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, closure s = s ↔ IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.below"],
  "name": "List.Sublist.below.cons₂",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop} {l₁ l₂ : List α} (a : α)\n  {a_1 : List.Sublist l₁ l₂},\n  List.Sublist.below a_1 → motive l₁ l₂ a_1 → List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂))",
  "constCategory": "Other"},
 {"references": [],
  "name": "Union",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "instMembershipSetFilter"],
  "name": "Filter.comap_principal.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : α → β} {t : Set β} (x : Set α)\n  (motive : x ∈ Filter.comap m (Filter.principal t) → Prop) (x_1 : x ∈ Filter.comap m (Filter.principal t)),\n  (∀ (_u : Set β) (hu : _u ∈ Filter.principal t) (b : m ⁻¹' _u ⊆ x),\n      motive (_ : ∃ t_1 ∈ Filter.principal t, m ⁻¹' t_1 ⊆ x)) →\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "sup_le_iff",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "Lattice.toInf",
   "Eq.mpr",
   "Iff",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "id",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "le_inf_iff",
   "Mathlib.Order.Heyting.Basic._auxLemma.14",
   "LE.le",
   "sdiff_le_comm",
   "And",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "congr",
   "Sup.sup",
   "GeneralizedCoheytingAlgebra.toLattice",
   "eq_of_forall_ge_iff",
   "congrArg",
   "congrFun"],
  "name": "sdiff_inf_distrib",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] (a b c : α), a \\ (b ⊓ c) = a \\ b ⊔ a \\ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "PLift.up",
   "PLift.down",
   "PLift.down_up",
   "PLift",
   "Equiv.mk",
   "PLift.up_down"],
  "name": "Equiv.plift",
  "constType": "{α : Sort u} → PLift α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "Nat.ne_of_lt",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "Iff.mpr",
   "Decidable.by_contradiction",
   "Eq",
   "Iff.intro",
   "lt_of_le_of_ne",
   "Iff",
   "Iff.mp",
   "List.indexOf_le_length",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "List",
   "LT.lt",
   "List.instDecidableMemListInstMembershipList",
   "List.indexOf_eq_length",
   "Not",
   "Nat",
   "Nat.strictOrderedSemiring"],
  "name": "List.indexOf_lt_length",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α}, List.indexOf a l < List.length l ↔ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Logic._auxLemma.34",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "eq_comm",
   "Eq.refl",
   "congrArg",
   "implies_congr",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_eq'",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a' = a → p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.eq_of_length",
   "Iff.intro",
   "Membership.mem",
   "List.filter",
   "Iff",
   "List.filter_eq_self",
   "List.instMembershipList",
   "List",
   "List.filter_sublist",
   "Bool.true",
   "Iff.trans",
   "Bool",
   "List.length",
   "Nat",
   "congrArg",
   "Eq"],
  "name": "List.filter_length_eq_length",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {l : List α}, List.length (List.filter p l) = List.length l ↔ ∀ a ∈ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.MonadRef.withRef",
   "Monad",
   "Lean.replaceRef",
   "Lean.MonadRef",
   "Bind.bind",
   "Lean.MonadRef.getRef",
   "Monad.toBind",
   "Lean.Syntax"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadRef m] → {α : Type} → Lean.Syntax → m α → m α",
  "constCategory": "Definition"},
 {"references": ["Array", "List"],
  "name": "Array.mk",
  "constType": "{α : Type u} → List α → Array α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Prod.semilatticeInf.proof_2",
   "SemilatticeInf.toInf",
   "Prod.semilatticeInf.proof_1",
   "Inf.inf",
   "Prod.semilatticeInf.proof_3",
   "SemilatticeInf.toPartialOrder",
   "Prod.instInfProd",
   "PartialOrder",
   "Prod.semilatticeInf.proof_4",
   "Inf.mk",
   "Inf",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "Prod",
   "SemilatticeInf",
   "SemilatticeInf.mk"],
  "name": "Prod.semilatticeInf",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : SemilatticeInf α] → [inst : SemilatticeInf β] → SemilatticeInf (α × β)",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Min", "minOfLe", "Nat", "Nat.decLe"],
  "name": "instMinNat",
  "constType": "Min ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_sub_add_right",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.add_sub_add_left",
  "constType": "∀ (k n m : ℕ), k + n - (k + m) = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_6",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Char", "List", "String"],
  "name": "String.mk",
  "constType": "List Char → String",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Lean.Data.AC.Expr",
   "Lean.Data.AC.eval",
   "Lean.Data.AC.Context.evalList_append",
   "Eq.refl",
   "Eq",
   "instHAppend",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.instEvalInformationContext",
   "List.instAppendList",
   "Lean.Data.AC.Context",
   "HAppend.hAppend",
   "List",
   "congr",
   "Lean.Data.AC.Expr.rec",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Lean.Data.AC.Expr.toList",
   "Lean.Data.AC.Expr.var",
   "Lean.Data.AC.EvalInformation.evalOp",
   "Lean.Data.AC.Context.toList_nonEmpty",
   "id"],
  "name": "Lean.Data.AC.Context.eval_toList",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α) (e : Lean.Data.AC.Expr),\n  Lean.Data.AC.evalList α ctx (Lean.Data.AC.Expr.toList e) = Lean.Data.AC.eval α ctx e",
  "constCategory": "Theorem"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.rec",
   "List.instMembershipList",
   "List",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.casesOn",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop} {a : List α}\n  (t : List.Pairwise R a),\n  motive [] (_ : List.Pairwise R []) →\n    (∀ {a : α} {l : List α} (a_1 : ∀ a' ∈ l, R a a') (a_2 : List.Pairwise R l),\n        motive (a :: l) (_ : List.Pairwise R (a :: l))) →\n      motive a t",
  "constCategory": "Definition"},
 {"references": ["_obj", "Lean.ParserDescr.symbol", "Topology.term𝓝._closed_3"],
  "name": "Topology.term𝓝._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "List",
   "LT.lt",
   "List.length",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "List.get.proof_1",
  "constType":
  "∀ {α : Type u_1} (head : α) (as : List α) (i : ℕ), Nat.succ i < List.length (head :: as) → Nat.succ i ≤ List.length as",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "iSup_le.match_1",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_2} {f : ι → α} (x : α) (motive : x ∈ Set.range f → Prop) (x_1 : x ∈ Set.range f),\n  (∀ (i : ι) (Eq : f i = x), motive (_ : ∃ y, f y = x)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "List.pairwise_map",
   "List.Pairwise.imp",
   "List",
   "List.map",
   "Iff.mpr"],
  "name": "List.Pairwise.map",
  "constType":
  "∀ {β : Type u_1} {α : Type u_2} {R : α → α → Prop} {l : List α} {S : β → β → Prop} (f : α → β),\n  (∀ (a b : α), R a b → S (f a) (f b)) → List.Pairwise R l → List.Pairwise S (List.map f l)",
  "constCategory": "Theorem"},
 {"references": ["List", "Lean.SyntaxNodeKind"],
  "name": "Lean.SyntaxNodeKinds",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List",
   "List.Perm.trans",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.swap'",
  "constType":
  "∀ {α : Type uu} (x y : α) {l₁ l₂ : List α}, l₁ ~ l₂ → y :: x :: l₁ ~ x :: y :: l₂",
  "constCategory": "Theorem"},
 {"references": ["RelIso", "LE", "LE.le"],
  "name": "OrderIso",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : LE α] → [inst : LE β] → Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": ["IsAntisymm", "IsAntisymm.antisymm", "Eq"],
  "name": "antisymm",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [inst : IsAntisymm α r] {a b : α}, r a b → r b a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf.proof_2",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → SemilatticeInf (α' i)] (x x_1 : (i : ι) → α' i) (x_2 : ι),\n  x x_2 ⊓ x_1 x_2 ≤ x_1 x_2",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.mk",
   "OrderHom",
   "OrderHomClass.monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.toOrderHom",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → [inst_2 : OrderHomClass F α β] → F → α →o β",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Function.Surjective.exists.match_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (motive : (∃ x, p (f x)) → Prop) (x : ∃ x, p (f x)),\n  (∀ (x : α) (hx : p (f x)), motive (_ : ∃ x, p (f x))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Exists",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "bex_imp",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {P : (x : α) → p x → Prop} {b : Prop},\n  (∃ x, ∃ (h : p x), P x h) → b ↔ ∀ (x : α) (h : p x), P x h → b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "IsGLB",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Set.preimage",
   "Inf.inf",
   "Set",
   "Union.union",
   "SemilatticeInf.toPartialOrder",
   "IsGLB.dual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "IsLUB.union",
   "SemilatticeInf",
   "Set.instUnionSet"],
  "name": "IsGLB.union",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] {a₁ a₂ : γ} {s t : Set γ}, IsGLB s a₁ → IsGLB t a₂ → IsGLB (s ∪ t) (a₁ ⊓ a₂)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List.Perm.subperm", "List.Perm.refl", "List", "List.Subperm"],
  "name": "List.Subperm.refl",
  "constType": "∀ {α : Type uu} (l : List α), l <+~ l",
  "constCategory": "Theorem"},
 {"references":
  ["List.Subperm.trans",
   "Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_2",
  "constType": "∀ {α : Type u_1} (a b c : Multiset α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Topology.WithLowerSet", "Equiv.refl"],
  "name": "Topology.WithLowerSet.ofLowerSet._cstage1",
  "constType": "{α : Type u_1} → Topology.WithLowerSet α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{α : Type u_4} → (elems : Finset α) → (∀ (x : α), x ∈ elems) → Fintype α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Order.Coframe",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "disjoint_iff_inf_le",
   "Inf.inf",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Disjoint.le_bot",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b → a ⊓ b ≤ ⊥",
  "constCategory": "Theorem"},
 {"references": ["String", "Substring", "String.Pos"],
  "name": "Substring.mk",
  "constType": "String → String.Pos → String.Pos → Substring",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "congr_arg",
   "List",
   "List.map",
   "mt",
   "List.Pairwise.of_map",
   "Eq"],
  "name": "List.Nodup.of_map",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) {l : List α}, List.Nodup (List.map f l) → List.Nodup l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Filter.iInf_sets_eq.match_1",
  "constType":
  "∀ {ι : Sort u_1} (motive : Nonempty ι → Prop) (ne : Nonempty ι), (∀ (i : ι), motive (_ : Nonempty ι)) → motive ne",
  "constCategory": "Definition"},
 {"references": ["GaloisConnection", "Preorder", "GaloisInsertion"],
  "name": "GaloisInsertion.gc",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisInsertion l u → GaloisConnection l u",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "Exists",
   "funext",
   "Filter.Frequently.exists",
   "False",
   "Filter.Eventually",
   "Mathlib.Order.Filter.Basic._auxLemma.85",
   "Mathlib.Order.Filter.Basic._auxLemma.86",
   "Filter.Frequently",
   "Iff.intro",
   "And",
   "Iff",
   "False.elim",
   "Eq.mp",
   "Filter",
   "Not",
   "congrArg",
   "Eq.trans"],
  "name": "Filter.frequently_iff_forall_eventually_exists_and",
  "constType":
  "∀ {α : Type u} {p : α → Prop} {f : Filter α},\n  (∃ᶠ (x : α) in f, p x) ↔ ∀ {q : α → Prop}, (∀ᶠ (x : α) in f, q x) → ∃ x, p x ∧ q x",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.le_of_ble_eq_true.match_1",
  "constType":
  "∀ (motive : (n m : ℕ) → Nat.ble n m = true → Prop) (n m : ℕ) (h : Nat.ble n m = true),\n  (∀ (x : ℕ) (h : Nat.ble 0 x = true), motive 0 x h) →\n    (∀ (n n_1 : ℕ) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) →\n      motive n m h",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["iInf", "Set", "Set.instInfSetSet"],
  "name": "Set.iInter",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Bool.true",
   "Decidable",
   "List.instDecidableMemListInstMembershipList.proof_1",
   "instBEq",
   "Bool",
   "List.elem",
   "instDecidableEqBool",
   "Eq",
   "decidable_of_decidable_of_iff"],
  "name": "List.instDecidableMemListInstMembershipList",
  "constType":
  "{α : Type u} → [inst : DecidableEq α] → (a : α) → (as : List α) → Decidable (a ∈ as)",
  "constCategory": "Definition"},
 {"references": ["EStateM.Result.ok", "EStateM"],
  "name": "EStateM.pure",
  "constType": "{ε σ α : Type u} → α → EStateM ε σ α",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "HasCompl.compl", "HasCompl.mk"],
  "name": "Pi.hasCompl",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → HasCompl (α i)] → HasCompl ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Exists", "propext", "exists_imp", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.48",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, ((∃ x, p x) → b) = ∀ (x : α), p x → b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Nonempty.elim",
   "Iff",
   "exists_const.match_1",
   "Exists.intro",
   "Nonempty"],
  "name": "exists_const",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∃ x, b) ↔ b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set",
   "Eq.refl",
   "BooleanAlgebra.toHasCompl",
   "True",
   "Eq",
   "_private.Mathlib.Topology.Basic.0.closure._eq_1",
   "Eq.mpr",
   "_private.Mathlib.Topology.Basic.0.interior._eq_1",
   "TopologicalSpace",
   "Set.image",
   "IsOpen",
   "interior",
   "Eq.trans",
   "id",
   "eq_self",
   "funext",
   "setOf",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "And",
   "Mathlib.Topology.Basic._auxLemma.5",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.compl_sUnion",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "Set.compl_image_set_of",
   "Mathlib.Topology.Basic._auxLemma.23",
   "congr",
   "Set.sUnion",
   "IsClosed",
   "Set.sInter",
   "congrArg"],
  "name": "closure_eq_compl_interior_compl",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, closure s = (interior sᶜ)ᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Lean.ParserDescr.symbol", "Topology.«term𝓝[≤]_»._closed_3"],
  "name": "Topology.«term𝓝[≤]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Iff.symm",
   "Iff",
   "Subtype.val",
   "Subtype.forall",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.forall'",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop},\n  (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : { a // p a }), q ↑x (_ : p ↑x)",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.lift₂",
   "HasEquiv.Equiv",
   "Quotient",
   "Eq"],
  "name": "Quotient.liftOn₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → φ) → (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) → φ",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Subtype.val",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "Subtype.ext.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (x x_1 : { x // p x }) → ↑x = ↑x_1 → Prop) (x x_1 : { x // p x })\n  (x_2 : ↑x = ↑x_1),\n  (∀ (val : α) (property property_1 : p val),\n      motive { val := val, property := property } { val := val, property := property_1 }\n        (_ : ↑{ val := val, property := (_ : p val) } = ↑{ val := val, property := (_ : p val) })) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "HEq",
   "Or.inr",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Or.casesOn",
   "Eq",
   "Or.inl",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "Eq.casesOn",
   "Eq.symm"],
  "name": "List.mem_cons.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} (motive : (b : α) → a = b ∨ a ∈ l → Prop) (b : α) (x : a = b ∨ a ∈ l),\n  (Unit → motive a (_ : a = a ∨ a ∈ l)) → (∀ (b : α) (h : a ∈ l), motive b (_ : a = b ∨ a ∈ l)) → motive b x",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Membership.mem",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Unit",
   "List.Sublist",
   "List.Sublist.cons",
   "dite",
   "List.pwFilter_cons_of_neg",
   "Eq",
   "PProd",
   "PProd.fst",
   "List.pwFilter_cons_of_pos",
   "List.rec",
   "List.decidableBAll",
   "List",
   "List.pwFilter_map.match_1",
   "Eq.rec",
   "PUnit",
   "List.Sublist.cons₂",
   "Not",
   "List.pwFilter",
   "List.nil",
   "Eq.symm",
   "DecidableRel"],
  "name": "List.pwFilter_sublist",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R] (l : List α), List.Sublist (List.pwFilter R l) l",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.mem_map.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (x : List α),\n  (Unit → motive []) → (∀ (head : α) (l : List α), motive (head :: l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Iff",
   "Iff.rfl",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_insert_iff",
  "constType":
  "∀ {α : Type u} {x a : α} {s : Set α}, x ∈ insert a s ↔ x = a ∨ x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Perm",
   "List.Perm.refl",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro"],
  "name": "List.Sublist.subperm",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → l₁ <+~ l₂",
  "constCategory": "Theorem"},
 {"references": ["BiheytingAlgebra", "HNot"],
  "name": "BiheytingAlgebra.toHNot",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → HNot α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "And",
   "PartialOrder.toPreorder",
   "And.intro",
   "And.casesOn",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_iff.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeSup α] {a b c : α} (motive : a ≤ c ∧ b ≤ c → Prop) (x : a ≤ c ∧ b ≤ c),\n  (∀ (h₁ : a ≤ c) (h₂ : b ≤ c), motive (_ : a ≤ c ∧ b ≤ c)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Bot", "Top", "Bot.bot", "OrderDual", "Top.mk"],
  "name": "OrderDual.top",
  "constType": "(α : Type u) → [inst : Bot α] → Top αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "sSup_image",
   "Set",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.image",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sUnion_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → Set β) (s : Set α), ⋃₀ (f '' s) = ⋃ x ∈ s, f x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["MonadLift", "semiOutParam"],
  "name": "MonadLift.mk",
  "constType":
  "{m : semiOutParam (Type u → Type v)} → {n : Type u → Type w} → ({α : Type u} → m α → n α) → MonadLift m n",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.«termI^_»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.rec",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop},\n  motive [] (_ : List.Pairwise R []) →\n    (∀ {a : α} {l : List α} (a_1 : ∀ a' ∈ l, R a a') (a_2 : List.Pairwise R l),\n        motive l a_2 → motive (a :: l) (_ : List.Pairwise R (a :: l))) →\n      ∀ {a : List α} (t : List.Pairwise R a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "FunLike.coe",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "inf_eq_left",
   "Eq.mpr",
   "InfHomClass.map_inf",
   "Eq.ndrec",
   "propext",
   "InfHomClass.toFunLike",
   "Eq.symm",
   "SemilatticeInf",
   "InfHomClass",
   "id"],
  "name": "InfHomClass.toOrderHomClass.proof_1",
  "constType":
  "∀ {F : Type u_3} {α : Type u_1} {β : Type u_2} [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β]\n  [inst_2 : InfHomClass F α β] (f : F) (a b : α), a ≤ b → ↑f a ≤ ↑f b",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Subtype.mk",
   "Subtype",
   "Set.instMembershipSet"],
  "name": "Subtype.coe_image.match_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {s : Set (Subtype p)} (a : α)\n  (motive : a ∈ {x | ∃ (h : p x), { val := x, property := h } ∈ s} → Prop)\n  (x : a ∈ {x | ∃ (h : p x), { val := x, property := h } ∈ s}),\n  (∀ (ha : p a) (in_s : { val := a, property := ha } ∈ s), motive (_ : ∃ (h : p a), { val := a, property := h } ∈ s)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.toLattice",
   "Order.Coframe",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Coframe.mk",
  "constType":
  "{α : Type u_1} →\n  [toCompleteLattice : CompleteLattice α] → (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → Order.Coframe α",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray3",
  "constType": "{α : Type u} → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Function.comp",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "induced_compose.match_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} [tγ : TopologicalSpace γ] {f : α → β} {g : β → γ} (x : Set α)\n  (motive : IsOpen x → Prop) (x_1 : IsOpen x),\n  (∀ (s : Set γ) (hs : IsOpen s) (h : g ∘ f ⁻¹' s = x), motive (_ : ∃ s', IsOpen s' ∧ g ∘ f ⁻¹' s' = x)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray6",
  "constType": "{α : Type u} → α → α → α → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "true_and",
   "And",
   "eq_true",
   "Iff",
   "and_congr_right",
   "Eq.mp",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun"],
  "name": "and_congr_right_iff",
  "constType": "∀ {a b c : Prop}, (a ∧ b ↔ a ∧ c) ↔ a → (b ↔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Macro.State.macroScope",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Macro.State.traceMsgs",
   "Lean.Macro.Context.mk",
   "Lean.MacroM",
   "HAdd.hAdd",
   "EStateM.instMonadStateOfEStateM",
   "Monad.toBind",
   "instMonadWithReaderOfReaderT",
   "Lean.Macro.State",
   "MonadState.modifyGet",
   "Lean.Macro.Exception",
   "ReaderT.instMonadLiftReaderT",
   "instOfNatNat",
   "Bind.bind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "instAddNat",
   "instHAdd",
   "Lean.Macro.Context.ref",
   "instMonadStateOf",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.Macro.Context.methods",
   "instMonadState",
   "instMonadWithReader",
   "Prod.mk",
   "Lean.Macro.Context.mainModule",
   "Lean.Macro.Context.maxRecDepth",
   "Lean.Macro.Context.currRecDepth",
   "Lean.Macro.State.mk",
   "MonadWithReader.withReader"],
  "name": "Lean.Macro.withFreshMacroScope",
  "constType": "{α : Type} → Lean.MacroM α → Lean.MacroM α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.subset_empty_iff",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.21",
  "constType": "∀ {α : Type u} {s : Set α}, (s ⊆ ∅) = (s = ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Pi.booleanAlgebra.proof_2",
  "constType":
  "∀ {ι : Type u_2} {α : ι → Type u_1} [inst : (i : ι) → BooleanAlgebra (α i)] (x : (i : ι) → α i) (x_1 : ι),\n  x x_1 ⊓ (x x_1)ᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_map.match_1",
   "List.cons",
   "List.append",
   "List.brecOn",
   "List.below",
   "List.cons_sublist_cons",
   "Iff.rfl",
   "Unit",
   "List.Sublist",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "Iff.trans",
   "List.nil"],
  "name": "List.append_sublist_append_left",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (l : List α), List.Sublist (l ++ l₁) (l ++ l₂) ↔ List.Sublist l₁ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "List.Perm.swap",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "true_or",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "or_self",
   "Membership.mem",
   "eq_self",
   "Mathlib.Data.List.Perm._auxLemma.2",
   "List.cons",
   "Or",
   "List.insert",
   "False",
   "Ne.symm",
   "or_true",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "ite_congr",
   "instDecidableFalse",
   "eq_true",
   "eq_false",
   "List.Perm",
   "of_eq_true",
   "DecidableEq",
   "List.insert_of_not_mem",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "congr",
   "Not",
   "List.insert_of_mem",
   "congrArg",
   "congrFun"],
  "name": "List.perm_insert_swap",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] (x y : α) (l : List α),\n  List.insert x (List.insert y l) ~ List.insert y (List.insert x l)",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkSimple",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Prop.heytingAlgebra",
   "Top.top",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "DistribLattice.mk",
   "HeytingAlgebra.bot_le",
   "Classical.em",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "BooleanAlgebra.mk",
   "Prop.booleanAlgebra.proof_4",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "DistribLattice",
   "SDiff.mk",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Prop.booleanAlgebra.proof_3",
   "Not",
   "Prop.booleanAlgebra.proof_1",
   "Prop.booleanAlgebra.proof_2"],
  "name": "Prop.booleanAlgebra",
  "constType": "BooleanAlgebra Prop",
  "constCategory": "Definition"},
 {"references":
  ["RelHomClass.map_rel",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.mono",
  "constType":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : OrderHomClass F α β]\n  (f : F), Monotone ↑f",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.false", "Lean.SourceInfo", "Bool", "optParam", "String.Pos"],
  "name": "Lean.SourceInfo.synthetic",
  "constType":
  "String.Pos → String.Pos → optParam Bool false → Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.sub_zero",
  "constType": "∀ (n : ℕ), n - 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "ite",
   "Eq"],
  "name": "if_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "LowerSet",
  "constType": "(α : Type u_6) → [inst : LE α] → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop", "Top.top", "le_top", "OrderTop", "LE", "LE.le"],
  "name": "Pi.orderTop.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → LE (α' i)] [inst_1 : (i : ι) → OrderTop (α' i)]\n  (x : (i : ι) → α' i) (x_1 : ι), x x_1 ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Finset.map.proof_1",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "FunLike.coe",
   "Finset.mk"],
  "name": "Finset.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "EmbeddingLike.toFunLike",
   "And",
   "Exists",
   "Function.instEmbeddingLikeEmbedding",
   "propext",
   "Finset",
   "Finset.mem_map",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} {b : β}, (b ∈ Finset.map f s) = ∃ a ∈ s, ↑f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_1",
  "constType": "∀ (α : Type u_1) [inst : Lattice α] (a b : αᵒᵈ), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "TopologicalSpace.GenerateOpen.rec",
   "setOf",
   "IsLowerSet",
   "isLowerSet_sUnion",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsLowerSet.inter",
   "Preorder.toLE",
   "Topology.IsLower.isOpen_iff_generate_Ici_compl",
   "Set.instMembershipSet",
   "Eq",
   "isLowerSet_univ",
   "Iff.mp",
   "Eq.ndrec",
   "isUpperSet_Ici",
   "Topology.IsLower",
   "TopologicalSpace",
   "IsOpen",
   "IsUpperSet.compl"],
  "name": "Topology.IsLower.isLowerSet_of_isOpen",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α] {s : Set α},\n  IsOpen s → IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.rec",
  "constType":
  "{motive : Lean.SourceInfo → Sort u} →\n  ((leading : Substring) →\n      (pos : String.Pos) →\n        (trailing : Substring) →\n          (endPos : String.Pos) → motive (Lean.SourceInfo.original leading pos trailing endPos)) →\n    ((pos endPos : String.Pos) → (canonical : Bool) → motive (Lean.SourceInfo.synthetic pos endPos canonical)) →\n      motive Lean.SourceInfo.none → (t : Lean.SourceInfo) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.le_himp_iff",
   "propext",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Eq.symm",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.6",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedHeytingAlgebra α] (a b c : α), (a ⊓ b ≤ c) = (a ≤ b ⇨ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "Char.mk",
   "UInt32",
   "Char",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Char.casesOn",
   "Eq.symm",
   "UInt32.isValidChar",
   "Eq"],
  "name": "Char.eq_of_val_eq.match_1",
  "constType":
  "∀ (motive : (x x_1 : Char) → x.val = x_1.val → Prop) (x x_1 : Char) (x_2 : x.val = x_1.val),\n  (∀ (val : UInt32) (valid valid_1 : UInt32.isValidChar val),\n      motive { val := val, valid := valid } { val := val, valid := valid_1 }\n        (_ :\n          { val := val, valid := (_ : UInt32.isValidChar val) }.val =\n            { val := val, valid := (_ : UInt32.isValidChar val) }.val)) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.toUpper_ofUpper",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithUpper α), ↑Topology.WithUpper.toUpper (↑Topology.WithUpper.ofUpper a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Continuous.tendsto.match_1",
   "Exists",
   "Filter.HasBasis.tendsto_iff",
   "Set.preimage",
   "nhds",
   "Set",
   "Exists.intro",
   "Set.Subset.rfl",
   "Iff.mpr",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "And",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "And.intro",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "Continuous.tendsto",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ (x : α), Filter.Tendsto f (nhds x) (nhds (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Filter.HasBasis.mem_iff",
   "Iff.mpr",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_of_superset",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {t : Set α} {i : ι},\n  Filter.HasBasis l p s → p i → s i ⊆ t → t ∈ l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubsetSet",
   "propext",
   "Set",
   "Set.Iic_subset_Iic",
   "HasSubset.Subset",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, (Set.Iic a ⊆ Set.Iic b) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteDistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["List.cons", "List.Perm", "List", "List.casesOn", "List.nil"],
  "name": "List.Perm.append_left.match_1",
  "constType":
  "∀ {α : Type u_1} {t₁ t₂ : List α} (motive : List α → t₁ ~ t₂ → Prop) (x : List α) (x_1 : t₁ ~ t₂),\n  (∀ (p : t₁ ~ t₂), motive [] p) → (∀ (x : α) (xs : List α) (p : t₁ ~ t₂), motive (x :: xs) p) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm",
   "List",
   "List.Subperm",
   "List.Subperm.length_le",
   "List.Subperm.perm_of_length_le"],
  "name": "List.Subperm.antisymm",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ <+~ l₂ → l₂ <+~ l₁ → l₁ ~ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.rec._cstage1",
  "constType":
  "{α : Type u_2} →\n  {β : Topology.WithUpper α → Sort u_1} →\n    ((a : α) → β (↑Topology.WithUpper.toUpper a)) → (a : Topology.WithUpper α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "Nat.pow.match_1", "Unit", "instOfNatNat", "Nat"],
  "name": "Nat.pred",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_false",
   "False",
   "List.instMembershipList",
   "List",
   "List.not_mem_nil",
   "List.nil",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.1",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ []) = False",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "instSubsingletonForAll.proof_1"],
  "name": "instSubsingletonForAll",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List"],
  "name": "List.Pairwise.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  (∀ a' ∈ l, R a a') → List.Pairwise R l → List.Pairwise R (a :: l)",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "of_decide_eq_self_eq_true.match_1",
  "constType":
  "∀ {α : Sort u_1} (a : α) (motive : Decidable (a = a) → Prop) (x : Decidable (a = a)),\n  (∀ (h : a = a), motive (isTrue h)) → (∀ (h₁ : ¬a = a), motive (isFalse h₁)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.prf",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {coe : outParam (β → α)} {cond : outParam (α → Prop)} [self : CanLift α β coe cond]\n  (x : α), cond x → ∃ y, coe y = x",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "Prod.orderBot.proof_1",
   "Bot.bot",
   "OrderBot.toBot",
   "Bot.mk",
   "Prod.instLEProd",
   "inferInstanceAs",
   "LE",
   "Prod",
   "OrderBot.mk",
   "OrderBot",
   "Prod.bot"],
  "name": "Prod.orderBot",
  "constType":
  "(α : Type u) →\n  (β : Type v) → [inst : LE α] → [inst_1 : LE β] → [inst_2 : OrderBot α] → [inst_3 : OrderBot β] → OrderBot (α × β)",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsLowerSet.rec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.recOn",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLowerSet α → Sort u} →\n        (t_1 : Topology.IsLowerSet α) →\n          ((topology_eq_lowerSetTopology : t = Topology.lowerSet α) → motive (_ : Topology.IsLowerSet α)) → motive t_1",
  "constCategory": "Definition"},
 {"references": ["List.Pairwise", "List.nil"],
  "name": "List.Pairwise.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop}, List.Pairwise R []",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Setoid.r",
   "OfNat.ofNat",
   "List.rec",
   "List",
   "Quot.ind",
   "Multiset.instZeroMultiset",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons",
   "Quot.mk"],
  "name": "Multiset.induction",
  "constType":
  "∀ {α : Type u_1} {p : Multiset α → Prop},\n  p 0 → (∀ ⦃a : α⦄ {s : Multiset α}, p s → p (a ::ₘ s)) → ∀ (s : Multiset α), p s",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.foldl_eq_foldr.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : α → List α → Prop) (x : α) (x_1 : List α),\n  (∀ (a : α), motive a []) → (∀ (a b : α) (l : List α), motive a (b :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "Not", "HasCompl.mk"],
  "name": "Prop.hasCompl",
  "constType": "HasCompl Prop",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "And",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Not",
   "And.intro",
   "Multiset.instMembershipMultiset",
   "Iff.mpr"],
  "name": "Finset.cons.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (s : Finset α), ¬a ∈ s → Multiset.Nodup (a ::ₘ s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["BiheytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HNot",
   "HNot.hnot",
   "SDiff.sdiff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Iff",
   "SemilatticeSup.toSup",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "SemilatticeSup.toPartialOrder"],
  "name": "BiheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toHeytingAlgebra : HeytingAlgebra α] →\n    [toSDiff : SDiff α] →\n      [toHNot : HNot α] → (∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) → (∀ (a : α), ⊤ \\ a = ￢a) → BiheytingAlgebra α",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Iff"],
  "name": "forall_comm",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {p : α → β → Prop}, (∀ (a : α) (b : β), p a b) ↔ ∀ (b : β) (a : α), p a b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Std.Logic._auxLemma.54",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "Std.Logic._auxLemma.35",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_apply_eq_imp_iff",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : β → Prop}, (∀ (b : β) (a : α), f a = b → p b) ↔ ∀ (a : α), p (f a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Equivalence",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a : α) (motive : _a ≤ _a ∧ ¬_a ≤ _a → Prop) (x : _a ≤ _a ∧ ¬_a ≤ _a),\n  (∀ (h1 : _a ≤ _a) (h2 : ¬_a ≤ _a), motive (_ : _a ≤ _a ∧ ¬_a ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["propext", "forall_apply_eq_imp_iff₂", "Eq"],
  "name": "Std.Logic._auxLemma.57",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) = ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references": ["OrderedCancelAddCommMonoid", "PartialOrder"],
  "name": "OrderedCancelAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u} → [self : OrderedCancelAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Set.forall_range_iff",
   "Set.instMembershipSet"],
  "name": "Set.range_subset_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {s : Set α}, Set.range f ⊆ s ↔ ∀ (y : ι), f y ∈ s",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "Topology.IsLowerSet",
  "constType":
  "(α : Type u_4) → [t : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_get",
   "List.nodup_iff_injective_get",
   "List.indexOf_lt_length",
   "Fin.val",
   "List.instMembershipList",
   "instBEq",
   "List.indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "Fin.veq_of_eq",
   "Iff.mp",
   "List.Nodup",
   "of_eq_true",
   "Function.Injective",
   "DecidableEq",
   "List",
   "LT.lt",
   "List.get_mem",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "congrFun"],
  "name": "List.get_indexOf",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {l : List α},\n  List.Nodup l → ∀ (i : Fin (List.length l)), List.indexOf (List.get l i) l = ↑i",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.topology_eq_upperTopology",
   "OrderDual.instPreorder",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLower.mk"],
  "name": "OrderDual.instIsLower.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], Topology.IsLower αᵒᵈ",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.symm", "Eq"],
  "name": "eq_comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.27",
  "constType": "∀ {α : Type u} {s : Set α}, (s = Set.univ) = ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.iInf_iSup_eq",
  "constType":
  "∀ {α : Type u} [self : CompletelyDistribLattice α] {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α),\n  ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.not_mem_zero",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.16",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper.instClosedIicTopology.proof_1",
   "ClosedIicTopology",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.IsUpper.instClosedIicTopology",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], ClosedIicTopology α",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise", "List.pairwise_map", "propext", "List", "List.map", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.18",
  "constType":
  "∀ {α : Type u_1} {α_1 : Type u_2} {f : α → α_1} {R : α_1 → α_1 → Prop} {l : List α},\n  List.Pairwise R (List.map f l) = List.Pairwise (fun a b ↦ R (f a) (f b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Lean.SourceInfo.fromRef.match_2",
   "Lean.Syntax.getTailPos?",
   "Lean.SourceInfo.fromRef.match_1",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "optParam",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.SourceInfo.fromRef",
  "constType": "Lean.Syntax → optParam Bool false → Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.cons",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.range.loop.match_1",
   "Nat",
   "Nat.succ"],
  "name": "List.range.loop",
  "constType": "ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Mathlib.Topology.Order._auxLemma.26",
   "Function.comp",
   "induced_compose",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Iff",
   "of_eq_true",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "TopologicalSpace.induced",
   "congrArg",
   "Eq.trans"],
  "name": "continuous_induced_rng",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type u_1} {f : α → β} {g : γ → α} {t₂ : TopologicalSpace β} {t₁ : TopologicalSpace γ},\n  Continuous g ↔ Continuous (f ∘ g)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "funext",
   "Eq.ndrec",
   "Iff",
   "propext",
   "Eq.rec",
   "Eq.refl",
   "iSup",
   "Iff.mpr",
   "Eq"],
  "name": "iSup_congr_Prop",
  "constType":
  "∀ {α : Type u_1} [inst : SupSet α] {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q),\n  (∀ (x : q), f₁ (_ : p) = f₂ x) → iSup f₁ = iSup f₂",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝ˢ»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.exists_erase_eq",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "List.erase",
   "Eq",
   "And",
   "instHAppend",
   "List.instAppendList",
   "List.Perm",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Eq.rec",
   "List.perm_middle",
   "Not",
   "List.perm_cons_erase.match_1",
   "Eq.symm"],
  "name": "List.perm_cons_erase",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {a : α} {l : List α}, a ∈ l → l ~ a :: List.erase l a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "setOf",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Topology.IsLower.topology_eq",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.IsLower",
   "Topology.lower",
   "TopologicalSpace",
   "IsOpen",
   "id"],
  "name": "Topology.IsLower.isOpen_iff_generate_Ici_compl",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α] {s : Set α},\n  IsOpen s ↔ TopologicalSpace.GenerateOpen {t | ∃ a, (Set.Ici a)ᶜ = t} s",
  "constCategory": "Theorem"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "AlexandrovDiscrete",
  "constType": "(α : Type u_1) → [inst : TopologicalSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.symm",
   "Equivalence.mk",
   "List.Perm",
   "List.Perm.refl",
   "Equivalence",
   "List",
   "List.Perm.trans"],
  "name": "List.Perm.eqv",
  "constType": "∀ (α : Type u_1), Equivalence List.Perm",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Topology.WithLowerSet.toLowerSet_le_iff",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → α ≃o Topology.WithLowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Or",
   "Iff",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "forall_and",
   "Set.instUnionSet",
   "or_imp",
   "forall_congr'",
   "Set.instMembershipSet"],
  "name": "Set.union_subset_iff",
  "constType": "∀ {α : Type u} {s t u : Set α}, s ∪ t ⊆ u ↔ s ⊆ u ∧ t ⊆ u",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "compl_anti",
   "HeytingAlgebra.toHasCompl",
   "LE.le",
   "Preorder.toLE"],
  "name": "compl_le_compl",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, a ≤ b → bᶜ ≤ aᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "And.right",
   "PartialOrder.toPreorder",
   "Set",
   "IsGreatest",
   "And.left",
   "le_antisymm",
   "Eq",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "IsGreatest.unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {s : Set α} {a b : α}, IsGreatest s a → IsGreatest s b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl.compl",
   "himp_eq",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "bot_sup_eq",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_2",
  "constType": "∀ {α : Type u_1} [inst : BooleanAlgebra α] (x : α), x ⇨ ⊥ = xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Filter.inter_mem",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (m : α → β) (f : Filter α) {x y : Set β},\n  x ∈ Set.preimage m ⁻¹' f.sets → y ∈ Set.preimage m ⁻¹' f.sets → ((fun x_1 ↦ x (m x_1)) ∩ fun x ↦ y (m x)) ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred", "Option.none", "Option.some", "Option", "ite"],
  "name": "Option.guard",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → α → Option α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Fin.val",
   "HAdd.hAdd",
   "Std.Data.Fin.Lemmas._auxLemma.14",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "Fin.val_succ",
   "instLTFin",
   "instLTNat",
   "True",
   "Std.Data.Fin.Lemmas._auxLemma.13",
   "of_eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Fin.succ",
   "Nat.succ",
   "Eq.trans",
   "Fin"],
  "name": "Fin.succ_pos",
  "constType": "∀ {n : ℕ} (a : Fin n), 0 < Fin.succ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set",
   "Filter",
   "Iff.mpr",
   "Filter.ext_iff",
   "instMembershipSetFilter",
   "Eq"],
  "name": "Filter.ext",
  "constType":
  "∀ {α : Type u} {f g : Filter α}, (∀ (s : Set α), s ∈ f ↔ s ∈ g) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 ↦ x < x_1",
  "constCategory": "Definition"},
 {"references": ["panicCore", "Inhabited", "String"],
  "name": "panic",
  "constType": "{α : Type u} → [inst : Inhabited α] → String → α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.upperSet",
   "Topology.instIsUpperSetUpperSet.proof_1",
   "Preorder"],
  "name": "Topology.instIsUpperSetUpperSet",
  "constType": "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpperSet α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.not_succ_le_self", "Not", "Nat", "instLTNat"],
  "name": "Nat.lt_irrefl",
  "constType": "∀ (n : ℕ), ¬n < n",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Elem",
   "Union.union",
   "Set",
   "Finite",
   "Finite.Set.finite_union.proof_1",
   "Set.instUnionSet"],
  "name": "Finite.Set.finite_union",
  "constType":
  "∀ {α : Type u} (s t : Set α) [inst : Finite ↑s] [inst : Finite ↑t], Finite ↑(s ∪ t)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "BEq.beq",
   "Iff",
   "Eq.ndrec",
   "BEq",
   "LawfulBEq.rfl",
   "Bool.true",
   "LawfulBEq",
   "LawfulBEq.eq_of_beq",
   "Bool",
   "Eq"],
  "name": "beq_iff_eq",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a b : α), (a == b) = true ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "TopologicalSpace",
   "ContinuousMap",
   "id",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.id",
  "constType": "(α : Type u_1) → [inst : TopologicalSpace α] → C(α, α)",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Iff.intro",
   "And",
   "And.right",
   "Iff",
   "SProd.sprod",
   "Set",
   "Set.Nonempty.prod",
   "Set.Nonempty",
   "Prod",
   "And.intro",
   "And.left",
   "Set.Nonempty.fst",
   "Set.Nonempty.snd"],
  "name": "Set.prod_nonempty_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, Set.Nonempty (s ×ˢ t) ↔ Set.Nonempty s ∧ Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "And",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "Nat.div.inductionOn",
   "LT.lt",
   "HSub.hSub",
   "Not",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod.inductionOn",
  "constType":
  "{motive : ℕ → ℕ → Sort u} →\n  (x y : ℕ) →\n    ((x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) →\n      ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y) → motive x y",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.Nodup",
   "Multiset.Nodup.proof_1",
   "List",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Nodup",
  "constType": "{α : Type u_1} → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "and_true",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Iff.trans",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_of_le_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → a ⊔ b = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Seq",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["PProd", "PProd.mk"],
  "name": "PProd.rec",
  "constType":
  "{α : Sort u} →\n  {β : Sort v} →\n    {motive : PProd α β → Sort u_1} →\n      ((fst : α) → (snd : β) → motive { fst := fst, snd := snd }) → (t : PProd α β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Finset.cons.proof_1",
   "Finset.instMembershipFinset",
   "Not",
   "Finset.mk"],
  "name": "Finset.cons",
  "constType": "{α : Type u_1} → (a : α) → (s : Finset α) → ¬a ∈ s → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.decEq.match_1",
   "Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Decidable",
   "Decidable.isTrue",
   "Bool",
   "rfl",
   "Eq"],
  "name": "Bool.decEq",
  "constType": "(a b : Bool) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "Eq.refl",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "isOpen_iff_mem_nhds",
   "instMembershipSetFilter",
   "id"],
  "name": "le_of_nhds_le_nhds",
  "constType":
  "∀ {α : Type u_1} {t₁ t₂ : TopologicalSpace α}, (∀ (x : α), nhds x ≤ nhds x) → t₁ ≤ t₂",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsRightCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "CoheytingAlgebra.toHNot",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "CoheytingAlgebra.top_sdiff",
  "constType":
  "∀ {α : Type u_4} [self : CoheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "Decidable.isFalse",
   "List",
   "instDecidableEqList",
   "String.mk",
   "String",
   "Decidable",
   "String.decEq.match_1",
   "Not",
   "Decidable.isTrue",
   "dite",
   "String.decEq.proof_2",
   "String.decEq.proof_1",
   "instDecidableEqChar",
   "Eq"],
  "name": "String.decEq",
  "constType": "(s₁ s₂ : String) → Decidable (s₁ = s₂)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Trunc.out",
   "Classical.decEq",
   "Fintype",
   "Fintype.truncEquivFin",
   "Fintype.card",
   "Fin"],
  "name": "Fintype.equivFin",
  "constType": "(α : Type u_4) → [inst : Fintype α] → α ≃ Fin (Fintype.card α)",
  "constCategory": "Definition"},
 {"references":
  ["Function.comp",
   "TopologicalSpace",
   "FunLike.coe",
   "ContinuousMap",
   "ContinuousMap.toContinuousMapClass",
   "ContinuousMap.comp.proof_1",
   "ContinuousMapClass.toFunLike",
   "ContinuousMap.mk"],
  "name": "ContinuousMap.comp",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] → [inst_2 : TopologicalSpace γ] → C(β, γ) → C(α, β) → C(α, γ)",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.Prelude.0.Lean.Macro.MethodsRefPointed", "NonemptyType.type"],
  "name": "_private.Init.Prelude.0.Lean.Macro.MethodsRef",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["cond.match_1",
   "Lean.Name.mkStr",
   "List.cons",
   "Lean.Name.instBEqName",
   "Lean.MacroScopesView",
   "Unit",
   "Lean.MacroScopesView.review",
   "Lean.Name.hasMacroScopes",
   "Lean.MacroScopesView.mainModule",
   "Lean.MacroScopesView.name",
   "List.foldl",
   "Lean.MacroScope",
   "BEq.beq",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.mk",
   "List.nil",
   "Bool",
   "Lean.MacroScopesView.imported",
   "Lean.Name.appendCore",
   "Lean.Name",
   "Lean.extractMacroScopes",
   "Nat",
   "Lean.MacroScopesView.scopes"],
  "name": "Lean.addMacroScope",
  "constType": "Lean.Name → Lean.Name → Lean.MacroScope → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "List.Subperm.trans",
   "Exists",
   "List.cons",
   "List.Sublist.casesOn",
   "HEq",
   "eq_of_heq",
   "List.Subperm",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons",
   "Exists.intro",
   "List.Sublist.slnil",
   "List.Perm.cons",
   "Iff.mpr",
   "List.sublist_cons",
   "Eq",
   "Iff.intro",
   "List.Perm.cons_inv",
   "Iff",
   "List.Perm",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.cons₂",
   "List.subperm_cons.match_1",
   "List.nil",
   "List.noConfusion",
   "Eq.symm",
   "List.Sublist.subperm",
   "List.Perm.subperm_left"],
  "name": "List.subperm_cons",
  "constType":
  "∀ {α : Type uu} (a : α) {l₁ l₂ : List α}, a :: l₁ <+~ a :: l₂ ↔ l₁ <+~ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty",
   "Subtype.casesOn",
   "Nonempty.casesOn"],
  "name": "nonempty_subtype.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : Nonempty (Subtype p) → Prop) (x : Nonempty (Subtype p)),\n  (∀ (a : α) (h : p a), motive (_ : Nonempty (Subtype p))) → motive x",
  "constCategory": "Definition"},
 {"references": ["_obj", "_neutral", "Topology.WithLowerSet.map._rarg"],
  "name": "Topology.WithLowerSet.map._cstage2",
  "constType": "_neutral → _neutral → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadExcept"],
  "name": "MonadExcept.mk",
  "constType":
  "{ε : outParam (Type u)} →\n  {m : Type v → Type w} → ({α : Type v} → ε → m α) → ({α : Type v} → m α → (ε → m α) → m α) → MonadExcept ε m",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.str"],
  "name": "Lean.Name.mkStr",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Not", "absurd"],
  "name": "Not.elim",
  "constType": "{a : Prop} → {α : Sort u_1} → ¬a → a → α",
  "constCategory": "Definition"},
 {"references": ["Fintype.finite", "Fintype", "Finite"],
  "name": "Finite.of_fintype",
  "constType": "∀ (α : Type u_4) [inst : Fintype α], Finite α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b : G), a + b = b + a) → AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "EmptyCollection.emptyCollection",
   "False",
   "false_and",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Std.Logic._auxLemma.32",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_empty",
  "constType": "∀ {α : Type u_1} {β : Type u_2} (f : α → β), f '' ∅ = ∅",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "forall_and.match_1",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} (motive : ((∀ (x : α), p x) ∧ ∀ (x : α), q x) → Prop)\n  (x : (∀ (x : α), p x) ∧ ∀ (x : α), q x),\n  (∀ (h₁ : ∀ (x : α), p x) (h₂ : ∀ (x : α), q x), motive (_ : (∀ (x : α), p x) ∧ ∀ (x : α), q x)) → motive x",
  "constCategory": "Definition"},
 {"references": ["List.Perm", "List"],
  "name": "List.Perm.trans",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ l₃ : List α}, l₁ ~ l₂ → l₂ ~ l₃ → l₁ ~ l₃",
  "constCategory": "Other"},
 {"references":
  ["Equiv", "Equiv.refl.proof_1", "Equiv.refl.proof_2", "Equiv.mk", "id"],
  "name": "Equiv.refl",
  "constType": "(α : Sort u_1) → α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "propext",
   "inseparable_iff_closure_eq",
   "Set",
   "TopologicalSpace",
   "Singleton.singleton",
   "Inseparable",
   "Eq"],
  "name": "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.2",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y = (closure {x} = closure {y})",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "eq_comm",
   "LE.le.le_iff_eq",
   "le_top",
   "OrderTop",
   "Iff.trans",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_le_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)) (t : Set α), (∀ b ∈ s, b ≤ t) → ∀ a ∈ sSup s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["isGLB_sInf",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Set",
   "Union.union",
   "Inf.inf",
   "InfSet.sInf",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "IsGLB.union",
   "IsGLB.sInf_eq",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instUnionSet"],
  "name": "sInf_union",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s t : Set α}, sInf (s ∪ t) = sInf s ⊓ sInf t",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references": ["And", "List", "And.intro", "And.casesOn", "List.Chain"],
  "name": "List.chain_cons.match_1",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α} (motive : R a b ∧ List.Chain R b l → Prop)\n  (x : R a b ∧ List.Chain R b l),\n  (∀ (n : R a b) (p : List.Chain R b l), motive (_ : R a b ∧ List.Chain R b l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instHasEquiv", "Setoid", "Setoid.refl", "HasEquiv.Equiv", "Eq"],
  "name": "Quotient.lift₂.proof_1",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_1} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ),\n  (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n    ∀ (a₁ : α) (a b : β), a ≈ b → f a₁ a = f a₁ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Topology.IsLower.t0Space",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "T0Space",
   "instTopologicalSpaceOrderDual",
   "PartialOrder"],
  "name": "Topology.IsUpper.t0Space.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsUpper α], T0Space αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Inter.inter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mk",
  "constType":
  "{α : Type u_1} →\n  (sets : Set (Set α)) →\n    Set.univ ∈ sets →\n      (∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets) → (∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) → Filter α",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "False",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "False.elim",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "List.get.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : (x : List α) → Fin (List.length x) → Sort u_2) →\n    (x : List α) →\n      (x_1 : Fin (List.length x)) →\n        ((a : α) →\n            (tail : List α) → (isLt : 0 < List.length (a :: tail)) → motive (a :: tail) { val := 0, isLt := isLt }) →\n          ((head : α) →\n              (as : List α) →\n                (i : ℕ) →\n                  (h : Nat.succ i < List.length (head :: as)) → motive (head :: as) { val := Nat.succ i, isLt := h }) →\n            motive x x_1",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "MonadReaderOf.read"],
  "name": "readThe",
  "constType":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadReaderOf ρ m] → m ρ",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLowerSet", "Inhabited"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "and.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive false) → (Unit → motive true) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "List.cons",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Array.mk",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.rec",
  "constType":
  "{motive_1 : Lean.Syntax → Sort u} →\n  {motive_2 : Array Lean.Syntax → Sort u} →\n    {motive_3 : List Lean.Syntax → Sort u} →\n      motive_1 Lean.Syntax.missing →\n        ((info : Lean.SourceInfo) →\n            (kind : Lean.SyntaxNodeKind) →\n              (args : Array Lean.Syntax) → motive_2 args → motive_1 (Lean.Syntax.node info kind args)) →\n          ((info : Lean.SourceInfo) → (val : String) → motive_1 (Lean.Syntax.atom info val)) →\n            ((info : Lean.SourceInfo) →\n                (rawVal : Substring) →\n                  (val : Lean.Name) →\n                    (preresolved : List Lean.Syntax.Preresolved) →\n                      motive_1 (Lean.Syntax.ident info rawVal val preresolved)) →\n              ((data : List Lean.Syntax) → motive_3 data → motive_2 { data := data }) →\n                motive_3 [] →\n                  ((head : Lean.Syntax) →\n                      (tail : List Lean.Syntax) → motive_1 head → motive_3 tail → motive_3 (head :: tail)) →\n                    (t : Lean.Syntax) → motive_1 t",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.le_of_ble_eq_true.match_1",
   "Nat.succ_le_succ",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.zero_le",
   "Nat.succ"],
  "name": "Nat.le_of_ble_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.ble n m = true → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["LowerSet", "IsLowerSet", "Set", "LE"],
  "name": "LowerSet.mk",
  "constType":
  "{α : Type u_6} → [inst : LE α] → (carrier : Set α) → IsLowerSet carrier → LowerSet α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "and_comm",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "Set.inter_comm",
  "constType": "∀ {α : Type u} (a b : Set α), a ∩ b = b ∩ a",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Membership.mem",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "Monotone.mem_upperBounds_image",
   "Preorder",
   "And.left",
   "IsLUB",
   "Eq",
   "Set.instMembershipSet",
   "GaloisConnection.l_le",
   "upperBounds",
   "And.right",
   "Eq.ndrec",
   "GaloisConnection.monotone_l",
   "lowerBounds",
   "Eq.mp",
   "And.intro",
   "GaloisConnection.upperBounds_l_image",
   "Set.image"],
  "name": "GaloisConnection.isLUB_l_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ {s : Set α} {a : α}, IsLUB s a → IsLUB (l '' s) (l a)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPartialOrder",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq",
   "PartialOrder"],
  "name": "Prod.semilatticeInf.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] (a b : α × β),\n  a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "propext",
   "Set",
   "Set.ext_iff",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.4",
  "constType":
  "∀ {α : Type u} {s t : Set α}, (s = t) = ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "Iff.mp",
   "List.pairwise_cons",
   "List.instMembershipList",
   "List",
   "And.left"],
  "name": "List.rel_of_pairwise_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} {R : α → α → Prop}, List.Pairwise R (a :: l) → ∀ {a' : α}, a' ∈ l → R a a'",
  "constCategory": "Theorem"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_on₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {s : β → β → Prop} {δ : Quot r → Quot s → Prop} (q₁ : Quot r)\n  (q₂ : Quot s), (∀ (a : α) (b : β), δ (Quot.mk r a) (Quot.mk s b)) → δ q₁ q₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_add_of_pos_right",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "List.chain_succ_range'",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "List.Chain.imp",
   "instOfNatNat",
   "Nat",
   "List.Chain",
   "Eq.symm",
   "instLTNat",
   "Eq"],
  "name": "List.chain_lt_range'",
  "constType":
  "∀ (s n : ℕ) {step : ℕ}, 0 < step → List.Chain (fun x x_1 ↦ x < x_1) s (List.range' (s + step) n step)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_lt_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.succ",
   "Fin.mk",
   "Fin",
   "Fin.succ.match_1"],
  "name": "Fin.succ",
  "constType": "{n : ℕ} → Fin n → Fin (Nat.succ n)",
  "constCategory": "Definition"},
 {"references": ["Continuous", "TopologicalSpace", "Continuous.comp"],
  "name": "Continuous.comp'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β}, Continuous g → Continuous f → Continuous fun x ↦ g (f x)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.monotone'",
   "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
   "FunLike.mk",
   "OrderHom",
   "OrderHom.toFun",
   "RelHomClass.mk",
   "Preorder",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → OrderHomClass (α →o β) α β",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Iff",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset",
   "List.subperm_append_left",
   "Quotient.inductionOn₃",
   "Multiset.instAddMultiset",
   "LE.le",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
  "constType": "∀ {α : Type u_1} {s t u : Multiset α}, s + t ≤ s + u ↔ t ≤ u",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Topology.WithUpperSet.isUpperSet_toUpperSet_preimage",
   "Set.preimage",
   "Topology.WithUpperSet",
   "Set",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.isOpen_ofUpperSet_preimage",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, IsOpen (↑Topology.WithUpperSet.ofUpperSet ⁻¹' s) ↔ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝ˢ»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["IsUpperSet", "isUpperSet_univ", "Preorder", "Set.univ", "Preorder.toLE"],
  "name": "Topology.upperSet.proof_1",
  "constType": "∀ (α : Type u_1) [inst : Preorder α], IsUpperSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["isLeast_singleton",
   "IsGLB",
   "Set.instSingletonSet",
   "Set",
   "IsLeast.isGLB",
   "Singleton.singleton",
   "Preorder"],
  "name": "isGLB_singleton",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, IsGLB {a} a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray4",
  "constType": "{α : Type u} → α → α → α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "_neutral", "Topology.WithLowerSet.map._elambda_1._rarg"],
  "name": "Topology.WithLowerSet.map._elambda_1._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Bot", "HeytingAlgebra"],
  "name": "HeytingAlgebra.toBot",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_sup_distrib_left",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_inf_distrib_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ (b ⊓ c) = a ⊓ b ⊓ (a ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Function.Surjective.forall.match_1",
   "Function.Surjective",
   "Eq.rec",
   "Function.Surjective.exists.match_1",
   "Function.Surjective.exists.match_2",
   "Exists.intro",
   "Eq.symm",
   "Eq"],
  "name": "Function.Surjective.exists",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Surjective f → ∀ {p : β → Prop}, (∃ y, p y) ↔ ∃ x, p (f x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "HasCompl"],
  "name": "HeytingAlgebra.toHasCompl",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "isOpen_sUnion",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.left",
   "interior",
   "IsOpen"],
  "name": "isOpen_interior",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen (interior s)",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom.mk",
   "sSupHom.rec",
   "sSupHom",
   "Set",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHom.casesOn",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : SupSet α] →\n      [inst_1 : SupSet β] →\n        {motive : sSupHom α β → Sort u} →\n          (t : sSupHom α β) →\n            ((toFun : α → β) →\n                (map_sSup' : ∀ (s : Set α), toFun (sSup s) = sSup (toFun '' s)) →\n                  motive { toFun := toFun, map_sSup' := map_sSup' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references": ["True.intro", "Iff", "iff_of_true", "True"],
  "name": "iff_true_intro",
  "constType": "∀ {a : Prop}, a → (a ↔ True)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«term𝓝[<]_»._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[<]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Fin.lt_def",
   "Fin.val",
   "propext",
   "LT.lt",
   "Nat",
   "instLTNat",
   "instLTFin",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.13",
  "constType": "∀ {n : ℕ} {a b : Fin n}, (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.map",
   "Eq"],
  "name": "List.exists_of_mem_map",
  "constType":
  "∀ {α : Type u_1} {b : α} {α_1 : Type u_2} {f : α_1 → α} {l : List α_1}, b ∈ List.map f l → ∃ a ∈ l, f a = b",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Or", "Iff", "Or.inl", "id", "Or.rec"],
  "name": "or_iff_left_of_imp",
  "constType": "∀ {b a : Prop}, (b → a) → (a ∨ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike",
   "UpperSet.instSetLikeUpperSet.proof_1",
   "SetLike.mk",
   "UpperSet.carrier",
   "LE",
   "UpperSet"],
  "name": "UpperSet.instSetLikeUpperSet",
  "constType": "{α : Type u_1} → [inst : LE α] → SetLike (UpperSet α) α",
  "constCategory": "Definition"},
 {"references": ["SizeOf", "measure", "WellFoundedRelation", "SizeOf.sizeOf"],
  "name": "sizeOfWFRel",
  "constType": "{α : Sort u} → [inst : SizeOf α] → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.preorder",
   "Preorder.le_trans",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_2",
  "constType":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → PartialOrder (π i)] (a b c : (i : ι) → π i), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Topology.WithLower"],
  "name": "Topology.WithLower.instInhabitedWithLower._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_2",
  "constType":
  "∀ {α : Type u_1} {g : Set (Set α)} {a : α} (s : Set α) (motive : s ∈ {s | a ∈ s ∧ IsOpen s} → Prop)\n  (x : s ∈ {s | a ∈ s ∧ IsOpen s}), (∀ (ha : a ∈ s) (hs : IsOpen s), motive (_ : a ∈ s ∧ IsOpen s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Prod.lattice",
   "Prod",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (a b : α × β), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.length_take.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : ℕ → List α → Prop) (x : ℕ) (x_1 : List α),\n  (∀ (l : List α), motive 0 l) →\n    (∀ (n : ℕ), motive (Nat.succ n) []) →\n      (∀ (n : ℕ) (head : α) (l : List α), motive (Nat.succ n) (head :: l)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.Continuous_of._closed_9",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13"],
  "name": "Topology.Continuous_of._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "Iff.mp", "Iff", "And.imp", "Iff.mpr"],
  "name": "and_congr",
  "constType": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8611",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Nat.linearOrderedCommSemiring.proof_4",
  "constType": "∀ (a b : ℕ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["List", "List.nil", "rfl", "Eq"],
  "name": "List.hasDecEq.proof_1",
  "constType": "∀ {α : Type u_1}, [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["and_comm", "And", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.7",
  "constType": "∀ {a b : Prop}, (a ∧ b) = (b ∧ a)",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "Eq.symm", "rfl", "Eq"],
  "name": "forall_eq",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Set.preimage",
   "Topology.WithUpperSet",
   "OrderHom.monotone",
   "Function.comp",
   "Set",
   "OrderHom",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Continuous",
   "IsUpperSet.preimage",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "IsOpen",
   "continuous_def",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β),\n  Continuous (↑Topology.WithUpperSet.toUpperSet ∘ ↑f ∘ ↑Topology.WithUpperSet.ofUpperSet)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Multiset",
   "Multiset.mem_map",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, (b ∈ Multiset.map f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝ˢ»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.instUnionList",
   "of_eq_true",
   "DecidableEq",
   "List",
   "Union.union",
   "List.nil",
   "Eq"],
  "name": "List.nil_union",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α), [] ∪ l = l",
  "constCategory": "Theorem"},
 {"references": ["HeytingAlgebra", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : BiheytingAlgebra α] → HeytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.indexOf_lt_length",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instBEq",
   "List.indexOf",
   "List.length",
   "Nat",
   "instLTNat",
   "Iff.mpr"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α), (∀ (x : α), x ∈ l) → ∀ (a : α), List.indexOf a l < List.length l",
  "constCategory": "Theorem"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.get",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "instLTNat",
   "Fin.mk",
   "Eq"],
  "name": "List.get?_eq_some.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} {n : ℕ}\n  (motive : (∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a) → Prop)\n  (x : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a),\n  (∀ (h : n < List.length l) (e : List.get l { val := n, isLt := h } = a),\n      motive (_ : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "IsGLB",
   "Set.preimage",
   "Set",
   "lowerBounds",
   "OrderDual",
   "IsGLB.dual",
   "Set.Iic",
   "FunLike.coe",
   "Preorder",
   "IsLUB.upperBounds_eq",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "IsGLB.lowerBounds_eq",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsGLB s a → lowerBounds s = Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get!.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → ℕ → Sort u_2) →\n    (x : List α) →\n      (x_1 : ℕ) →\n        ((a : α) → (tail : List α) → motive (a :: tail) 0) →\n          ((head : α) → (as : List α) → (n : ℕ) → motive (head :: as) (Nat.succ n)) →\n            ((x : List α) → (x_2 : ℕ) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "TopologicalSpace.GenerateOpen.inter",
   "Eq.rec",
   "Set",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)),\n  {u | TopologicalSpace.GenerateOpen s u} = s →\n    ∀ (s_1 t : Set α), (fun u ↦ u ∈ s) s_1 → (fun u ↦ u ∈ s) t → (fun u ↦ u ∈ s) (s_1 ∩ t)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Preorder"],
  "name": "Topology.WithUpper.instPreorderWithUpper",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.mem_Ici",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a x : α}, (x ∈ Set.Ici a) = (a ≤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.lattice.proof_4",
   "Prod.semilatticeSup",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Prod.lattice.proof_3",
   "Prod.lattice.proof_1",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Prod.lattice.proof_6",
   "SemilatticeSup",
   "Prod.lattice.proof_2",
   "SemilatticeSup.toSup",
   "inferInstanceAs",
   "Prod.lattice.proof_5",
   "Prod",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "Prod.semilatticeInf",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.lattice",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Lattice α] → [inst : Lattice β] → Lattice (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "eq_comm",
   "Eq.refl",
   "instBEq",
   "List.countP_cons",
   "ite_congr",
   "True",
   "instLawfulBEqInstBEq",
   "Eq",
   "ite",
   "BEq.beq",
   "DecidableEq",
   "of_eq_true",
   "propext",
   "List",
   "Bool.true",
   "Init.Core._auxLemma.1",
   "congr",
   "Not",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "List.count",
   "congrArg",
   "Eq.trans",
   "instDecidableEqBool"],
  "name": "List.count_cons",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : α) (l : List α),\n  List.count a (b :: l) = List.count a l + if a = b then 1 else 0",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set",
   "Finset",
   "Singleton.singleton",
   "Fintype.ofFinset",
   "Set.fintypeSingleton.proof_1",
   "Finset.instSingletonFinset"],
  "name": "Set.fintypeSingleton",
  "constType": "{α : Type u} → (a : α) → Fintype ↑{a}",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "UInt64.size",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "Nat",
   "instLTNat"],
  "name": "Lean.Name.hash.proof_2",
  "constType": "17 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.bot_le",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra.proof_1",
  "constType": "∀ {α : Type u_1} [inst : BiheytingAlgebra α] (a : α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.succ_le_succ", "Nat", "instLTNat", "Nat.succ"],
  "name": "Nat.succ_lt_succ",
  "constType": "∀ {n m : ℕ}, n < m → Nat.succ n < Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_trans",
   "LE.le",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, c ≤ a → c ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Set",
   "compl_le_compl_iff_le",
   "HasCompl.compl",
   "HasSubset.Subset",
   "BooleanAlgebra.toHasCompl"],
  "name": "Set.compl_subset_compl",
  "constType": "∀ {α : Type u} {s t : Set α}, sᶜ ⊆ tᶜ ↔ t ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet.toDualHomeomorph._lambda_1", "_obj"],
  "name": "Topology.WithUpperSet.toDualHomeomorph._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.mk",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {coe : outParam (β → α)} {cond : outParam (α → Prop)},\n  (∀ (x : α), cond x → ∃ y, coe y = x) → CanLift α β coe cond",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr",
   "List.instLawfulBEqListInstBEqList",
   "Lean.Data.AC.eval",
   "Eq.refl",
   "instBEqNat",
   "Eq",
   "BEq.beq",
   "List.instBEqList",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Lean.Data.AC.Context",
   "Nat.instLawfulBEqNatInstBEqNat",
   "List",
   "Bool.true",
   "LawfulBEq.eq_of_beq",
   "Lean.Data.AC.instContextInformationContext",
   "Eq.mp",
   "Lean.Data.AC.Context.eval_norm",
   "Bool",
   "Lean.Data.AC.norm",
   "Nat",
   "congrArg"],
  "name": "Lean.Data.AC.Context.eq_of_norm",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α) (a b : Lean.Data.AC.Expr),\n  (Lean.Data.AC.norm ctx a == Lean.Data.AC.norm ctx b) = true → Lean.Data.AC.eval α ctx a = Lean.Data.AC.eval α ctx b",
  "constCategory": "Theorem"},
 {"references": ["imp_intro", "Iff.intro", "Iff"],
  "name": "imp_iff_right",
  "constType": "∀ {b a : Prop}, a → (a → b ↔ b)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax"],
  "name": "Lean.Syntax.missing",
  "constType": "Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.ofLower._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Filter",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.mem_sets",
  "constType": "∀ {α : Type u} {f : Filter α} {s : Set α}, s ∈ f.sets ↔ s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.indexOf_lt_length",
   "Fin.val",
   "List.instMembershipList",
   "Eq.refl",
   "instBEq",
   "List.indexOf",
   "List.get_indexOf",
   "List.length",
   "instLTNat",
   "True",
   "Iff.mpr",
   "Eq",
   "eq_true",
   "Eq.ndrec",
   "List.Nodup",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Eq.rec",
   "LT.lt",
   "List.get",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin",
   "Fin.mk",
   "congrFun"],
  "name": "List.Nodup.getEquivOfForallMemList.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α),\n  List.Nodup l →\n    ∀ (h : ∀ (x : α), x ∈ l) (i : Fin (List.length l)),\n      { val := List.indexOf ((fun i ↦ List.get l i) i) l,\n          isLt := (_ : List.indexOf ((fun i ↦ List.get l i) i) l < List.length l) } =\n        i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.eq",
   "List.Nodup.map",
   "List.instMembershipList",
   "Subtype.val",
   "List.Nodup.of_map",
   "List.attach",
   "Eq",
   "Iff.intro",
   "List.Nodup",
   "Iff",
   "List",
   "Eq.rec",
   "List.attach_map_val",
   "List.map",
   "Eq.symm",
   "Subtype"],
  "name": "List.nodup_attach",
  "constType":
  "∀ {α : Type u} {l : List α}, List.Nodup (List.attach l) ↔ List.Nodup l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "HasSubset.Subset",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_sSup",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.subset_sUnion_of_mem",
  "constType":
  "∀ {α : Type u_1} {S : Set (Set α)} {t : Set α}, t ∈ S → t ⊆ ⋃₀ S",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.fst.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} (motive : Set.Nonempty (s ×ˢ t) → Prop)\n  (x : Set.Nonempty (s ×ˢ t)), (∀ (x : α × β) (hx : x ∈ s ×ˢ t), motive (_ : ∃ x, x ∈ s ×ˢ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.not_succ_le_zero.match_3",
   "Nat.not_succ_le_zero.match_2",
   "OfNat.ofNat",
   "False",
   "instLENat",
   "Nat.not_succ_le_zero.match_1",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.not_succ_le_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Pi.instHImpForAll",
   "LE.le",
   "True",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop",
   "iff_self",
   "Lattice.toInf",
   "Std.Logic._auxLemma.33",
   "HImp.himp",
   "Iff",
   "of_eq_true",
   "Pi.Nonempty",
   "Mathlib.Order.Heyting.Basic._auxLemma.1",
   "forall_congr",
   "Pi.lattice",
   "top_nonempty",
   "congr",
   "GeneralizedHeytingAlgebra.toLattice",
   "Mathlib.Order.Heyting.Basic._auxLemma.10",
   "GeneralizedHeytingAlgebra",
   "Pi.hasLe",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder"],
  "name": "Pi.generalizedHeytingAlgebra.proof_5",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] (i a a_1 : (i : ι) → α i),\n  i ≤ a ⇨ a_1 ↔ i ⊓ a ≤ a_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "TopologicalSpace.GenerateOpen.univ",
   "Eq.rec",
   "Set",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), {u | TopologicalSpace.GenerateOpen s u} = s → Set.univ ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Not"],
  "name": "not_not_intro",
  "constType": "∀ {p : Prop}, p → ¬¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[>]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "outParam",
   "FunLike",
   "Set",
   "sSupHomClass",
   "FunLike.coe",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHomClass.mk",
  "constType":
  "{F : Type u_8} →\n  {α : outParam (Type u_9)} →\n    {β : outParam (Type u_10)} →\n      [inst : SupSet α] →\n        [inst_1 : SupSet β] →\n          [toFunLike : FunLike F α fun x ↦ β] →\n            (∀ (f : F) (s : Set α), ↑f (sSup s) = sSup (↑f '' s)) → sSupHomClass F α β",
  "constCategory": "Other"},
 {"references": ["_obj", "_neutral", "Topology.WithUpperSet.rec._rarg"],
  "name": "Topology.WithUpperSet.rec._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.filterMap.match_1",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1",
   "Option"],
  "name": "List.filterMap",
  "constType": "{α : Type u} → {β : Type v} → (α → Option β) → List α → List β",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM.Result.casesOn",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.tryCatch.match_1",
  "constType":
  "{ε σ α : Type u_1} →\n  (motive : EStateM.Result ε σ α → Sort u_2) →\n    (x : EStateM.Result ε σ α) →\n      ((e : ε) → (s : σ) → motive (EStateM.Result.error e s)) → ((ok : EStateM.Result ε σ α) → motive ok) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "Iff",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "LE.le.le_iff_eq",
   "OrderBot",
   "LE.le",
   "bot_le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_bot_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≤ ⊥ ↔ a = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{α : Type u_1} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "propext",
   "Set",
   "Set.ball_insert_iff",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.3",
  "constType":
  "∀ {α : Type u} {P : α → Prop} {a : α} {s : Set α}, (∀ x ∈ insert a s, P x) = (P a ∧ ∀ x ∈ s, P x)",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Prop.booleanAlgebra.match_1",
   "Bot.bot",
   "Prop.heytingAlgebra",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Not",
   "HasCompl.mk",
   "GeneralizedHeytingAlgebra.toDistribLattice"],
  "name": "Prop.booleanAlgebra.proof_1",
  "constType": "∀ (p : Prop), p ⊓ pᶜ → ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Lean.Name.num",
   "List",
   "String",
   "List.casesOn",
   "List.nil",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.assembleParts.match_1",
  "constType":
  "(motive : List Lean.Name → Lean.Name → Sort u_1) →\n  (x : List Lean.Name) →\n    (x_1 : Lean.Name) →\n      ((acc : Lean.Name) → motive [] acc) →\n        ((pre : Lean.Name) →\n            (s : String) → (ps : List Lean.Name) → (acc : Lean.Name) → motive (Lean.Name.str pre s :: ps) acc) →\n          ((pre : Lean.Name) →\n              (n : ℕ) → (ps : List Lean.Name) → (acc : Lean.Name) → motive (Lean.Name.num pre n :: ps) acc) →\n            ((x : List Lean.Name) → (x_2 : Lean.Name) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_inter",
  "constType":
  "∀ {α : Type u} {x : α} {a b : Set α}, x ∈ a → x ∈ b → x ∈ a ∩ b",
  "constCategory": "Theorem"},
 {"references":
  ["iInf_subtype",
   "Subtype.property",
   "CompleteLattice",
   "iInf",
   "Subtype.val",
   "CompleteLattice.toInfSet",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "iInf_subtype'",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {p : ι → Prop} {f : (i : ι) → p i → α},\n  ⨅ i, ⨅ (h : p i), f i h = ⨅ x, f ↑x (_ : p ↑x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.insert",
   "List.instMembershipList",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Decidable",
   "Not",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "congrFun"],
  "name": "List.insert_of_not_mem",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, ¬a ∈ l → List.insert a l = a :: l",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadWithReader",
  "constType": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "Or",
   "setOf",
   "Iff.rfl",
   "Set",
   "Inf.inf",
   "Union.union",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Mathlib.Order.Filter.Basic._auxLemma.63",
   "Eq",
   "Set.instMembershipSet",
   "Filter.principal",
   "Eq.mpr",
   "Iff",
   "Mathlib.Order.Filter.Basic._auxLemma.64",
   "Filter.instInfFilter",
   "congr",
   "Not",
   "Filter",
   "congrArg",
   "Set.instUnionSet",
   "congrFun",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_principal",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f ⊓ Filter.principal t ↔ {x | x ∈ t → x ∈ s} ∈ f",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.le_refl", "Nat", "instLTNat", "Nat.succ"],
  "name": "Nat.lt.base",
  "constType": "∀ (n : ℕ), n < Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB",
   "EmptyCollection.emptyCollection",
   "lowerBounds_empty",
   "Set",
   "IsGreatest",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Mathlib.Order.Bounds.Basic._auxLemma.13",
   "Set.univ",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Iff",
   "of_eq_true",
   "lowerBounds",
   "IsTop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "isGLB_empty_iff",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a : α}, IsGLB ∅ a ↔ IsTop a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Eq.refl",
   "List.forall_mem_cons",
   "And.left",
   "Eq"],
  "name": "_private.Mathlib.Data.List.Basic.0.List.pmap._eq_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : (a : α) → p a → β) (a : α) (l : List α) (H : ∀ a_1 ∈ a :: l, p a_1),\n  List.pmap f (a :: l) H = f a (_ : p a) :: List.pmap f l (_ : ∀ x ∈ l, p x)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "False", "iff_of_eq", "false_or"],
  "name": "false_or_iff",
  "constType": "∀ (p : Prop), False ∨ p ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≥]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "And.casesOn"],
  "name": "Set.Subset.antisymm_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {a b : Set α} (motive : a ⊆ b ∧ b ⊆ a → Prop) (x : a ⊆ b ∧ b ⊆ a),\n  (∀ (h₁ : a ⊆ b) (h₂ : b ⊆ a), motive (_ : a ⊆ b ∧ b ⊆ a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.17",
  "constType": "∀ {α : Type u} {s : Set α}, (s = Set.univ) = ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go.match_1.splitter",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → ℕ → Sort u_2) →\n    (x : List α) →\n      (x_1 : ℕ) → ((n : ℕ) → motive [] n) → ((a : α) → (l : List α) → (n : ℕ) → motive (a :: l) n) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "le_compl_iff_disjoint_right",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "disjoint_comm",
   "Iff.trans",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "Disjoint.le_compl_left",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, Disjoint b a → a ≤ bᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.mem_of_mem_of_subset",
  "constType": "∀ {α : Type u} {x : α} {s t : Set α}, x ∈ s → s ⊆ t → x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Monad",
   "OfNat.ofNat",
   "instSubNat",
   "HSub.hSub",
   "dite",
   "Array.foldlM.proof_1",
   "optParam",
   "Array.size",
   "LE.le",
   "Array.foldlM.loop",
   "Array",
   "instLENat",
   "instOfNatNat",
   "Not",
   "Nat",
   "Nat.decLe"],
  "name": "Array.foldlM",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "False.elim", "False", "True", "Eq"],
  "name": "false_implies",
  "constType": "∀ (p : Prop), (False → p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm.symm",
   "List.Subperm.perm_of_length_le.match_1",
   "List.Perm",
   "instLENat",
   "List",
   "Eq.rec",
   "List.Subperm",
   "List.Sublist",
   "List.length",
   "Nat",
   "List.Sublist.eq_of_length_le",
   "LE.le",
   "Eq"],
  "name": "List.Subperm.perm_of_length_le",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ <+~ l₂ → List.length l₂ ≤ List.length l₁ → l₁ ~ l₂",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_prop.match_1",
  "constType":
  "∀ {b a : Prop} (motive : (∃ (_ : a), b) → Prop) (x : ∃ (_ : a), b),\n  (∀ (hp : a) (hq : b), motive (_ : ∃ (_ : a), b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Or.inl",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_union_left",
  "constType": "∀ {α : Type u} (s t : Set α), s ⊆ s ∪ t",
  "constCategory": "Theorem"},
 {"references": ["IsRefl"],
  "name": "IsRefl.refl",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsRefl α r] (a : α), r a a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MonadRef", "Lean.Name", "Lean.MonadQuotation", "Lean.MacroScope"],
  "name": "Lean.MonadQuotation.mk",
  "constType":
  "{m : Type → Type} →\n  [toMonadRef : Lean.MonadRef m] → m Lean.MacroScope → m Lean.Name → ({α : Type} → m α → m α) → Lean.MonadQuotation m",
  "constCategory": "Other"},
 {"references":
  ["WellFounded.apply",
   "WellFounded",
   "WellFounded.fixFEq",
   "WellFounded.fix",
   "Eq"],
  "name": "WellFounded.fix_eq",
  "constType":
  "∀ {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r) (F : (x : α) → ((y : α) → r y x → C y) → C x)\n  (x : α), WellFounded.fix hwf F x = F x fun y x ↦ WellFounded.fix hwf F y",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.Perm.map",
   "List",
   "List.isSetoid",
   "List.map",
   "Quot",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.map.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (_l₁ _l₂ : List α),\n  Setoid.r _l₁ _l₂ → Quot.mk Setoid.r (List.map f _l₁) = Quot.mk Setoid.r (List.map f _l₂)",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["InfSet"],
  "name": "sInfHom",
  "constType":
  "(α : Type u_8) → (β : Type u_9) → [inst : InfSet α] → [inst : InfSet β] → Type (max u_8 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn"],
  "name": "List.mem_attach.match_1",
  "constType":
  "∀ {α : Type u_1} (l : List α) (motive : { x // x ∈ l } → Prop) (x : { x // x ∈ l }),\n  (∀ (a : α) (h : a ∈ l), motive { val := a, property := h }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "propext",
   "LT.lt",
   "Nat.lt_succ",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.105",
  "constType": "∀ {m n : ℕ}, (m < Nat.succ n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Set.subset_univ",
  "constType": "∀ {α : Type u} (s : Set α), s ⊆ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "Iff",
   "le_rfl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_of_forall_ge_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, (∀ (c : α), a ≤ c ↔ b ≤ c) → a = b",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.toUpperSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.noConfusion",
   "Eq.symm",
   "Eq"],
  "name": "List.cons_sublist_cons.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α} (motive : List.Sublist (a :: l₁) (a :: l₂) → Prop)\n  (x : List.Sublist (a :: l₁) (a :: l₂)),\n  (∀ (s : List.Sublist (a :: l₁) l₂), motive (_ : List.Sublist (a :: l₁) (a :: l₂))) →\n    (∀ (s : List.Sublist l₁ l₂), motive (_ : List.Sublist (a :: l₁) (a :: l₂))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_right",
  "constType": "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), b ≤ a ⊔ b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff"],
  "name": "instDecidableIff.proof_1",
  "constType": "∀ {p q : Prop}, p → q → (p ↔ q)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_of_le_left",
   "GE.ge",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Basic._auxLemma.4",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "Mathlib.Order.Lattice._auxLemma.1",
   "SemilatticeSup.toSup",
   "of_eq_true",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "inf_sup_self",
  "constType": "∀ {α : Type u} [inst : Lattice α] {a b : α}, a ⊓ (a ⊔ b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.countP_map.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (x : List α),\n  (Unit → motive []) → (∀ (a : α) (l : List α), motive (a :: l)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["False", "Decidable", "Not", "Decidable.byContradiction", "absurd"],
  "name": "Decidable.of_not_not",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬¬p → p",
  "constCategory": "Theorem"},
 {"references": ["MonadWithReaderOf", "MonadWithReaderOf.withReader"],
  "name": "withTheReader",
  "constType":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "∀ {α : Type u_1} (x y z : Set α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "Multiset.ndunion",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "List.Nodup.union",
   "Quot.induction_on₂"],
  "name": "Multiset.Nodup.ndunion",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α) {t : Multiset α},\n  Multiset.Nodup t → Multiset.Nodup (Multiset.ndunion s t)",
  "constCategory": "Theorem"},
 {"references":
  ["Char",
   "False",
   "List",
   "String.mk",
   "String",
   "Not",
   "String.noConfusion",
   "absurd",
   "Eq"],
  "name": "String.decEq.proof_2",
  "constType":
  "∀ (s₁ s₂ : List Char), ¬s₁ = s₂ → { data := s₁ } = { data := s₂ } → False",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe"],
  "name": "ContinuousMapClass.mk",
  "constType":
  "{F : Type u_1} →\n  {α : outParam (Type u_2)} →\n    {β : outParam (Type u_3)} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] →\n          [toFunLike : FunLike F α fun x ↦ β] → (∀ (f : F), Continuous ↑f) → ContinuousMapClass F α β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.pmap",
   "propext",
   "List.instMembershipList",
   "List",
   "List.mem_pmap",
   "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.10",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a} {b : β},\n  (b ∈ List.pmap f l H) = ∃ a, ∃ (h : a ∈ l), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references": ["nhds", "TopologicalSpace", "Filter.Tendsto"],
  "name": "ContinuousAt",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "List.Perm.rec",
   "List.pmap._sunfold.proof_1",
   "Mathlib.Data.List.Perm._auxLemma.1",
   "List.pmap._sunfold.proof_2",
   "List.Perm.subset",
   "Mathlib.Data.List.Perm._auxLemma.13",
   "eq_true",
   "List.Perm",
   "of_eq_true",
   "List",
   "Mathlib.Data.List.Perm._auxLemma.14",
   "List.Perm.trans",
   "List.nil"],
  "name": "List.Perm.pmap",
  "constType":
  "∀ {α : Type uu} {β : Type vv} {p : α → Prop} (f : (a : α) → p a → β) {l₁ l₂ : List α},\n  l₁ ~ l₂ → ∀ {H₁ : ∀ a ∈ l₁, p a} {H₂ : ∀ a ∈ l₂, p a}, List.pmap f l₁ H₁ ~ List.pmap f l₂ H₂",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Inf.inf",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Preorder.le_trans",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.inter_mem",
   "Preorder.toLT",
   "Eq.rec",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.match_1",
   "Filter.sets",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "OrderDual.completeLattice",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "Filter.giGenerate",
   "Preorder.lt_iff_le_not_le",
   "Set.instInterSet"],
  "name": "Filter.instCompleteLatticeFilter.proof_8",
  "constType":
  "∀ {α : Type u_1} (x x_1 x_2 : Filter α), x ≤ x_1 → x ≤ x_2 → ∀ _s ∈ x_1 ⊓ x_2, _s ∈ x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.union",
  "constType": "{α : Type u_1} → Set α → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["GaloisCoinsertion", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisCoinsertion.choice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisCoinsertion l u → (x : β) → x ≤ l (u x) → α",
  "constCategory": "Definition"},
 {"references": ["SProd", "Set.prod", "SProd.mk", "Set", "Prod"],
  "name": "Set.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Set α) (Set β) (Set (α × β))",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "Prod.mk", "Bot.mk", "Prod"],
  "name": "Prod.bot",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Bot α] → [inst : Bot β] → Bot (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["List.length_pos_of_mem.match_1",
   "Membership.mem",
   "List.cons",
   "OfNat.ofNat",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "List.length",
   "Nat",
   "instLTNat"],
  "name": "List.length_pos_of_mem",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → 0 < List.length l",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "HasCompl.compl",
   "CompleteLattice.toBot",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.inf_compl_le_bot",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x : α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Definition"},
 {"references":
  ["IsLowerSet",
   "Set",
   "Inter.inter",
   "Preorder",
   "Preorder.toLE",
   "IsLowerSet.inter",
   "Set.instInterSet"],
  "name": "Topology.lowerSet.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] (x x_1 : Set α), IsLowerSet x → IsLowerSet x_1 → IsLowerSet (x ∩ x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHAppend",
   "List.cons",
   "List.instAppendList",
   "of_eq_true",
   "List.rec",
   "HAppend.hAppend",
   "List",
   "Eq.refl",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.append_assoc",
  "constType":
  "∀ {α : Type u} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpperSet", "Preorder"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.succ_sub.match_1",
  "constType":
  "∀ {m n : ℕ} (motive : (∃ k, n + k = m) → Prop) (x : ∃ k, n + k = m),\n  (∀ (k : ℕ) (hk : n + k = m), motive (_ : ∃ k, n + k = m)) → motive x",
  "constCategory": "Definition"},
 {"references": ["setOf", "Filter", "Filter.Eventually", "Filter.mp_mem"],
  "name": "Filter.Eventually.mp",
  "constType":
  "∀ {α : Type u} {p q : α → Prop} {f : Filter α},\n  (∀ᶠ (x : α) in f, p x) → (∀ᶠ (x : α) in f, p x → q x) → ∀ᶠ (x : α) in f, q x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Eq.ndrec",
   "List.rec",
   "List",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Lean.Data.AC.List.two_step_induction",
  "constType":
  "{motive : List ℕ → Sort u} →\n  (l : List ℕ) →\n    motive [] → ((a : ℕ) → motive [a]) → ((a b : ℕ) → (l : List ℕ) → motive (b :: l) → motive (a :: b :: l)) → motive l",
  "constCategory": "Theorem"},
 {"references":
  ["Order.Coframe.toCompleteLattice",
   "CompleteBooleanAlgebra",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.toSupSet",
   "le_iInf",
   "compl_le_compl",
   "Function.comp",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "iSup",
   "le_iSup",
   "iSup_le",
   "CompleteBooleanAlgebra.toCompleteDistribLattice",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Eq",
   "CompleteBooleanAlgebra.toInfSet",
   "BooleanAlgebra.toBiheytingAlgebra",
   "iInf",
   "compl_le_of_compl_le",
   "CompleteDistribLattice.toCoframe",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "le_antisymm"],
  "name": "compl_iInf",
  "constType":
  "∀ {α : Type u} {ι : Sort w} [inst : CompleteBooleanAlgebra α] {f : ι → α}, (iInf f)ᶜ = ⨆ i, (f i)ᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.instSupSetSet", "iSup"],
  "name": "Set.iUnion",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Pure.mk",
   "Set",
   "HasSubset.Subset",
   "Pure",
   "Filter",
   "Filter.instPureFilter.proof_1",
   "Set.instMembershipSet"],
  "name": "Filter.instPureFilter",
  "constType": "Pure Filter",
  "constCategory": "Definition"},
 {"references":
  ["Option.none", "Eq.refl", "Option.some", "Option.casesOn", "Eq", "Option"],
  "name": "List.pairwise_filterMap.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : Option α → Prop) (x : Option α),\n  (x = none → motive none) → (∀ (b : α), x = some b → motive (some b)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Set.preimage",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Iff.rfl",
   "Set",
   "Topology.upper",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.isOpen_preimage_ofUpper",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, IsOpen (↑Topology.WithUpper.ofUpper ⁻¹' s) ↔ TopologicalSpace.IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_true_of_eq_false.match_1",
  "constType":
  "∀ (motive : (x : Bool) → x = false → Prop) (x : Bool) (x_1 : x = false),\n  (∀ (h : true = false), motive true h) → (∀ (x : false = false), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "congr_arg",
   "Iff.mp",
   "Iff",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype.proof_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ p x),\n  Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x))",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.principal_eq_iff_eq",
   "Filter.principal",
   "propext",
   "Set",
   "Filter",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.19",
  "constType":
  "∀ {α : Type u} {s t : Set α}, (Filter.principal s = Filter.principal t) = (s = t)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.right_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Equiv.apply_symm_apply",
  "constType":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : β), ↑e (↑e.symm x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "Filter.mem_of_superset",
   "Filter.generate",
   "HasSubset.Subset",
   "LE.le",
   "Filter.GenerateSets.recOn",
   "Preorder.toLE",
   "Filter.univ_mem",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.inter_mem",
   "Filter.instPartialOrderFilter",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.le_generate_iff",
  "constType":
  "∀ {α : Type u} {s : Set (Set α)} {f : Filter α}, f ≤ Filter.generate s ↔ s ⊆ f.sets",
  "constCategory": "Theorem"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{α : Type u_1} → [inst : SupSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Trunc.instSubsingletonTrunc.proof_1", "Subsingleton", "Trunc"],
  "name": "Trunc.instSubsingletonTrunc",
  "constType": "∀ {α : Sort u_1}, Subsingleton (Trunc α)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "Eq.rec",
   "exists_exists_eq_and.match_1",
   "And.intro",
   "Exists.intro",
   "Eq.symm",
   "rfl",
   "exists_exists_eq_and.match_2",
   "Eq"],
  "name": "exists_exists_eq_and",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_2} {f : α → β} {p : β → Prop}, (∃ b, (∃ a, f a = b) ∧ p b) ↔ ∃ a, p (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.toHomeomorphOfInducing.proof_1",
   "Equiv.right_inv",
   "Homeomorph",
   "Equiv.toHomeomorphOfInducing.proof_2",
   "Equiv.left_inv",
   "Equiv.mk",
   "TopologicalSpace",
   "Inducing",
   "FunLike.coe",
   "Homeomorph.mk",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toHomeomorphOfInducing",
  "constType":
  "{X : Type u_1} →\n  {Y : Type u_2} → [inst : TopologicalSpace X] → [inst_1 : TopologicalSpace Y] → (f : X ≃ Y) → Inducing ↑f → X ≃ₜ Y",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.Perm",
   "of_eq_true",
   "List",
   "List.nil",
   "List.Perm.rec",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "rfl",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.Perm.length_eq",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ~ l₂ → List.length l₁ = List.length l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "CompleteBooleanAlgebra.toSupSet",
   "Set",
   "Inf.inf",
   "SupSet.sSup",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteBooleanAlgebra.inf_sSup_le_iSup_inf",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.nodup_cons",
   "Iff.mp",
   "List.Nodup",
   "List.instMembershipList",
   "List",
   "Not",
   "And.left"],
  "name": "List.Nodup.not_mem",
  "constType":
  "∀ {α : Type u} {l : List α} {a : α}, List.Nodup (a :: l) → ¬a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.cons",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.cons.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (x x_1 : List α), Setoid.r x x_1 → Quot.mk Setoid.r (a :: x) = Quot.mk Setoid.r (a :: x_1)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.num", "Nat", "Lean.Name"],
  "name": "Lean.Name.mkNum",
  "constType": "Lean.Name → ℕ → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["T0Space.casesOn",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "t0Space_iff_inseparable.match_1",
  "constType":
  "∀ (α : Type u_1) [inst : TopologicalSpace α] (motive : T0Space α → Prop) (x : T0Space α),\n  (∀ (h : ∀ ⦃x y : α⦄, Inseparable x y → x = y), motive (_ : T0Space α)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_inf_iff",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.20",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s : Set α}, (s ∈ f ⊓ g) = ∃ t₁ ∈ f, ∃ t₂ ∈ g, s = t₁ ∩ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.inj'",
   "Function.Embedding.toFun",
   "EmbeddingLike.mk",
   "Function.instEmbeddingLikeEmbedding.proof_1",
   "FunLike.mk",
   "EmbeddingLike",
   "Function.Embedding"],
  "name": "Function.instEmbeddingLikeEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → EmbeddingLike (α ↪ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["EStateM", "EStateM.bind.match_1", "EStateM.Result", "EStateM.Result.error"],
  "name": "EStateM.bind",
  "constType":
  "{ε σ α β : Type u} → EStateM ε σ α → (α → EStateM ε σ β) → EStateM ε σ β",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.64",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.mem_Iic",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {b x : α}, x ∈ Set.Iic b ↔ x ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["GeneralizedHeytingAlgebra.toDistribLattice.proof_1",
   "DistribLattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "DistribLattice.ofInfSupLe",
   "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toDistribLattice",
  "constType":
  "{α : Type u_2} → [inst : GeneralizedHeytingAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ConditionallyCompleteLattice",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.length_eq",
   "List.filter",
   "Eq.mpr",
   "Eq.ndrec",
   "List.Perm",
   "List",
   "Eq.refl",
   "Bool",
   "List.length",
   "List.countP",
   "Nat",
   "List.Perm.filter",
   "List.countP_eq_length_filter",
   "id",
   "Eq"],
  "name": "List.Perm.countP_eq",
  "constType":
  "∀ {α : Type uu} (p : α → Bool) {l₁ l₂ : List α}, l₁ ~ l₂ → List.countP p l₁ = List.countP p l₂",
  "constCategory": "Theorem"},
 {"references": ["Lean.TSyntax", "Array", "Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntaxArray",
  "constType": "Lean.SyntaxNodeKinds → Type",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpper.topology_eq_upperTopology",
   "Topology.upper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpper.topology_eq",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α],\n  inst_1 = Topology.upper α",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SDiff",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.Macro.Exception",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.33",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["SupSet",
   "sSupHom",
   "sSupHomClass.mk",
   "FunLike.mk",
   "sSupHom.toFun",
   "sSupHomClass",
   "sSupHom.map_sSup'",
   "sSupHom.instSSupHomClassSSupHom.proof_1"],
  "name": "sSupHom.instSSupHomClassSSupHom",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : SupSet α] → [inst_1 : SupSet β] → sSupHomClass (sSupHom α β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Quot.rec",
   "Subsingleton",
   "Quot.recOnSubsingleton'.proof_1",
   "Quot",
   "Quot.mk"],
  "name": "Quot.recOnSubsingleton'",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] → (q : Quot r) → ((a : α) → motive (Quot.mk r a)) → motive q",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "IsBot",
  "constType": "{α : Type u_1} → [inst : LE α] → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation"],
  "name": "Lean.Data.AC.ContextInformation.isIdem",
  "constType":
  "{α : Sort u} → [self : Lean.Data.AC.ContextInformation α] → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Filter.GenerateSets.inter",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.GenerateSets.rec",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.recOn",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {motive : (a : Set α) → Filter.GenerateSets g a → Prop} {a : Set α}\n  (t : Filter.GenerateSets g a),\n  (∀ {s : Set α} (a : s ∈ g), motive s (_ : Filter.GenerateSets g s)) →\n    motive Set.univ (_ : Filter.GenerateSets g Set.univ) →\n      (∀ {s t : Set α} (a : Filter.GenerateSets g s) (a_1 : s ⊆ t),\n          motive s a → motive t (_ : Filter.GenerateSets g t)) →\n        (∀ {s t : Set α} (a : Filter.GenerateSets g s) (a_1 : Filter.GenerateSets g t),\n            motive s a → motive t a_1 → motive (s ∩ t) (_ : Filter.GenerateSets g (s ∩ t))) →\n          motive a t",
  "constCategory": "Definition"},
 {"references": ["Array", "List.get", "Array.size", "Fin", "Array.data"],
  "name": "Array.get",
  "constType": "{α : Type u} → (a : Array α) → Fin (Array.size a) → α",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "And.intro",
   "Exists.intro",
   "Preorder",
   "And.casesOn",
   "Exists.casesOn",
   "lowerClosure",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "lowerClosure_min.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} (_a : α) (motive : _a ∈ ↑(lowerClosure s) → Prop)\n  (x : _a ∈ ↑(lowerClosure s)), (∀ (_b : α) (hb : _b ∈ s) (hab : _a ≤ _b), motive (_ : ∃ a ∈ s, _a ≤ a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_toUpperSet",
  "constType":
  "∀ {α : Type u_1} (a : α), ↑Topology.WithUpperSet.ofUpperSet (↑Topology.WithUpperSet.toUpperSet a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Or.inl",
   "Or.inr",
   "Exists.intro",
   "Or.casesOn",
   "Exists.casesOn"],
  "name": "exists_or.match_2",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} (motive : ((∃ x, p x) ∨ ∃ x, q x) → Prop) (x : (∃ x, p x) ∨ ∃ x, q x),\n  (∀ (x : α) (h : p x), motive (_ : (∃ x, p x) ∨ ∃ x, q x)) →\n    (∀ (x : α) (h : q x), motive (_ : (∃ x, p x) ∨ ∃ x, q x)) → motive x",
  "constCategory": "Definition"},
 {"references": ["forall_eq", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.34",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.add_succ",
   "Nat.sub_ne_zero_of_lt",
   "instSubNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.sub_succ",
   "True",
   "Eq",
   "Nat.succ_pred",
   "Eq.mpr",
   "instLENat",
   "Nat.pred",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "id",
   "instHSub",
   "eq_self",
   "Nat.succ_add",
   "Ne",
   "instAddNat",
   "instHAdd",
   "HSub.hSub",
   "Nat.le_of_succ_le",
   "LE.le",
   "Nat.zero_add",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "congrArg",
   "congrFun"],
  "name": "Nat.add_sub_of_le",
  "constType": "∀ {a b : ℕ}, a ≤ b → a + (b - a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "instTransLeToLE",
   "sup_comm",
   "LE.le",
   "Preorder.toLE",
   "inf_le_inf_left",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "sup_inf_right",
   "instTransEq_1",
   "Eq.mpr",
   "Eq.ndrec",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "le_refl",
   "sup_le_sup_left",
   "sup_le",
   "Sup.sup",
   "le_sup_right",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "sup_inf_left",
   "id"],
  "name": "le_of_inf_le_sup_le",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, x ⊓ z ≤ y ⊓ z → x ⊔ z ≤ y ⊔ z → x ≤ y",
  "constCategory": "Theorem"},
 {"references": ["Mod"],
  "name": "Mod.mk",
  "constType": "{α : Type u} → (α → α → α) → Mod α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Set.instSProd",
   "Mathlib.Topology.Constructions._auxLemma.11",
   "nhds_prod_eq",
   "instTopologicalSpaceProd",
   "nhds",
   "Set",
   "Inf.inf",
   "Filter.instSProd",
   "True",
   "Eq",
   "Filter.principal",
   "of_eq_true",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "congr",
   "TopologicalSpace",
   "Filter",
   "Prod",
   "nhdsWithin",
   "congrArg",
   "Filter.prod_principal_principal",
   "Eq.trans",
   "congrFun"],
  "name": "nhdsWithin_prod_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (a : α) (b : β) (s : Set α)\n  (t : Set β), nhdsWithin (a, b) (s ×ˢ t) = nhdsWithin a s ×ˢ nhdsWithin b t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap._sunfold.proof_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Std.Data.List.Pairwise._auxLemma.6",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "Eq.refl",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "List.Pairwise",
   "instHAppend",
   "And",
   "Eq.mpr",
   "Iff",
   "List.instAppendList",
   "Eq.ndrec",
   "of_eq_true",
   "forall_congr",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "List.pairwise_append",
   "List.nil",
   "List.append_assoc",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "List.pairwise_append_comm",
   "Std.Data.List.Pairwise._auxLemma.7",
   "id"],
  "name": "List.pairwise_middle",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop},\n  (∀ {x y : α}, R x y → R y x) →\n    ∀ {a : α} {l₁ l₂ : List α}, List.Pairwise R (l₁ ++ a :: l₂) ↔ List.Pairwise R (a :: (l₁ ++ l₂))",
  "constCategory": "Theorem"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "Fintype.subtype.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (motive : { x // p x } → Prop) (x : { x // p x }),\n  (∀ (x : α) (px : p x), motive { val := x, property := px }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "False",
   "List.instMembershipList",
   "List",
   "Not",
   "List.not_mem_nil.match_1",
   "List.nil"],
  "name": "List.not_mem_nil",
  "constType": "∀ {α : Type u_1} (a : α), ¬a ∈ []",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroM", "Lean.Syntax"],
  "name": "Lean.Macro",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.range",
   "Set.Elem",
   "of_eq_true",
   "Subtype.val",
   "Subtype.range_coe",
   "Set",
   "Set.iInter",
   "congrArg",
   "Set.sInter",
   "Eq.trans",
   "True",
   "Subtype",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.sInter_eq_iInter",
  "constType": "∀ {α : Type u_1} {s : Set (Set α)}, ⋂₀ s = ⋂ i, ↑i",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.length.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((head : α) → (as : List α) → motive (head :: as)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_4",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["semiOutParam", "MonadExceptOf"],
  "name": "MonadExceptOf.tryCatch",
  "constType":
  "{ε : semiOutParam (Type u)} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadReaderOf",
  "constType": "semiOutParam (Type u) → (Type u → Type v) → Type v",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpper",
   "Topology.IsUpper.upperBasis",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "TopologicalSpace.IsTopologicalBasis",
   "Topology.IsLower.isTopologicalBasis"],
  "name": "Topology.IsUpper.isTopologicalBasis",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α],\n  TopologicalSpace.IsTopologicalBasis (Topology.IsUpper.upperBasis α)",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "Id",
   "Pure.mk",
   "Unit",
   "Function.comp",
   "Unit.unit",
   "Function.const",
   "Seq.mk",
   "Functor.mk",
   "SeqRight.mk",
   "Applicative.mk",
   "Monad.mk",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "Id.instMonadId",
  "constType": "Monad Id",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Exists",
   "Finite",
   "Fin.fintype",
   "Fintype.ofEquiv",
   "Nonempty",
   "Iff.intro",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Iff",
   "finite_iff_nonempty_fintype.match_1",
   "Finite.exists_equiv_fin",
   "Nat",
   "finite_iff_nonempty_fintype.match_2",
   "Finite.of_fintype",
   "Fin",
   "Equiv.symm"],
  "name": "finite_iff_nonempty_fintype",
  "constType": "∀ (α : Type u_4), Finite α ↔ Nonempty (Fintype α)",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "Nat"],
  "name": "SizeOf.sizeOf",
  "constType": "{α : Sort u} → [self : SizeOf α] → α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["Seq", "Unit"],
  "name": "Seq.seq",
  "constType":
  "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
  "constCategory": "Definition"},
 {"references":
  ["eq_of_nhds_eq_nhds",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "nhds",
   "Eq.rec",
   "Eq.refl",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "nhds_induced",
   "TopologicalSpace.induced",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "induced_iff_nhds_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] (f : β → α),\n  tβ = TopologicalSpace.induced f tα ↔ ∀ (b : β), nhds b = Filter.comap f (nhds (f b))",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "OrderTop.toTop",
   "Top",
   "Prod.orderTop.proof_1",
   "Top.top",
   "Prod.instLEProd",
   "inferInstanceAs",
   "OrderTop",
   "LE",
   "Prod",
   "Top.mk",
   "Prod.top"],
  "name": "Prod.orderTop",
  "constType":
  "(α : Type u) →\n  (β : Type v) → [inst : LE α] → [inst_1 : LE β] → [inst_2 : OrderTop α] → [inst_3 : OrderTop β] → OrderTop (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List.singleton_sublist",
   "List.Sublist",
   "List.Nodup.cons",
   "List.Nodup.sublist",
   "Iff.mpr",
   "Iff.intro",
   "List.nodup_nil",
   "Iff",
   "List.Nodup",
   "List.rec",
   "List",
   "List.sublist_cons_of_sublist",
   "List.not_nodup_pair",
   "Not",
   "List.nil",
   "List.Sublist.cons_cons"],
  "name": "List.nodup_iff_sublist",
  "constType":
  "∀ {α : Type u} {l : List α}, List.Nodup l ↔ ∀ (a : α), ¬List.Sublist [a, a] l",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.succ_le_succ",
   "Nat.zero_le",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.zero_lt_succ",
  "constType": "∀ (n : ℕ), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection", "Iff.mp", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisConnection.le_u",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ {a : α} {b : β}, l a ≤ b → a ≤ u b",
  "constCategory": "Theorem"},
 {"references":
  ["and_assoc.match_2",
   "Iff.intro",
   "And",
   "Iff",
   "and_assoc.match_1",
   "And.intro"],
  "name": "and_assoc",
  "constType": "∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "FunLike.coe",
   "Set.image",
   "sInfHomClass",
   "Eq"],
  "name": "sInfHomClass.mk",
  "constType":
  "{F : Type u_8} →\n  {α : outParam (Type u_9)} →\n    {β : outParam (Type u_10)} →\n      [inst : InfSet α] →\n        [inst_1 : InfSet β] →\n          [toFunLike : FunLike F α fun x ↦ β] →\n            (∀ (f : F) (s : Set α), ↑f (sInf s) = sInf (↑f '' s)) → sInfHomClass F α β",
  "constCategory": "Other"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOn₂",
  "constType":
  "∀ {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Prop}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂),\n  (∀ (a : α) (b : β), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) → motive q₁ q₂",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.cons",
   "Finset.instMembershipFinset",
   "Not",
   "Finset.cons_induction"],
  "name": "Finset.cons_induction_on",
  "constType":
  "∀ {α : Type u_4} {p : Finset α → Prop} (s : Finset α),\n  p ∅ → (∀ ⦃a : α⦄ {s : Finset α} (h : ¬a ∈ s), p s → p (Finset.cons a s h)) → p s",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "exists_or.match_2",
   "exists_or.match_1",
   "Exists.intro"],
  "name": "exists_or",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ ∃ x, q x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "TopologicalSpace",
   "Preorder",
   "rfl",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name":
  "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpperSet (Topology.WithUpperSet α)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.nodup_zero",
   "Multiset.instZeroMultiset",
   "Finset",
   "Multiset",
   "Finset.mk"],
  "name": "Finset.empty",
  "constType": "{α : Type u_1} → Finset α",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_prop_of_true", "Iff", "True"],
  "name": "forall_true_left",
  "constType": "∀ (p : True → Prop), (∀ (x : True), p x) ↔ p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set",
   "Function.comp",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisCoinsertion.liftCompleteLattice",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.gciGenerateFrom",
   "IsOpen"],
  "name": "TopologicalSpace.instCompleteLatticeTopologicalSpace",
  "constType": "{α : Type u} → CompleteLattice (TopologicalSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisConnection",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "TopologicalSpace",
   "coinduced_le_iff_le_induced",
   "TopologicalSpace.induced",
   "TopologicalSpace.coinduced"],
  "name": "gc_coinduced_induced",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β),\n  GaloisConnection (TopologicalSpace.coinduced f) (TopologicalSpace.induced f)",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Inf.mk",
   "And.right",
   "Or",
   "DistribLattice",
   "Or.inl",
   "Prop.distribLattice.proof_3",
   "Or.inr",
   "Prop.distribLattice.proof_1",
   "DistribLattice.mk",
   "Prop.distribLattice.proof_2",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Prop.partialOrder",
   "And.left",
   "Sup.mk"],
  "name": "Prop.distribLattice",
  "constType": "DistribLattice Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "IsRightCancelAdd",
   "Add",
   "Eq"],
  "name": "add_right_cancel",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] {a b c : G}, a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Set.Elem", "Finset.toSet", "Finset", "Finset.Subtype.fintype"],
  "name": "FinsetCoe.fintype",
  "constType": "{α : Type u_1} → (s : Finset α) → Fintype ↑↑s",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.instHasSubsetSet",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "HasSubset.Subset",
   "Set.sUnion",
   "Set.Set.completeAtomicBooleanAlgebra",
   "sSup_le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet"],
  "name": "Set.sUnion_subset",
  "constType":
  "∀ {α : Type u_1} {S : Set (Set α)} {t : Set α}, (∀ t' ∈ S, t' ⊆ t) → ⋃₀ S ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "And.right",
   "Prod.snd",
   "SProd.sprod",
   "Set",
   "Set.Nonempty",
   "Prod",
   "Prod.fst",
   "Exists.intro",
   "Set.instMembershipSet",
   "Set.Nonempty.fst.match_1"],
  "name": "Set.Nonempty.snd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, Set.Nonempty (s ×ˢ t) → Set.Nonempty t",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec", "Exists", "Classical.choose", "Exists.intro"],
  "name": "Classical.axiomOfChoice",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)",
  "constCategory": "Theorem"},
 {"references": ["IsAssociative", "IsAssociative.assoc", "Eq"],
  "name": "instIsAssociative.proof_1",
  "constType":
  "∀ {α : Type u_1} {op : α → α → α} [inst : IsAssociative α op] (a b c : α), op (op a b) c = op a (op b c)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.nil"],
  "name": "List.rec",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    motive [] → ((head : α) → (tail : List α) → motive tail → motive (head :: tail)) → (t : List α) → motive t",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → (coe : A → Set B) → Function.Injective coe → SetLike A B",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.«termΩ^»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Exists", "False", "Exists.intro", "Exists.casesOn"],
  "name": "exists_false.match_1",
  "constType":
  "∀ {α : Sort u_1} (motive : (∃ _a, False) → Prop) (x : ∃ _a, False),\n  (∀ (w : α) (h : False), motive (_ : ∃ _a, False)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mpr",
   "Eq.ndrec",
   "Function.sometimes_eq",
   "Function.sometimes",
   "Eq.refl",
   "Nonempty",
   "Eq",
   "id"],
  "name": "Function.sometimes_spec",
  "constType":
  "∀ {p : Prop} {α : Sort u_1} [inst : Nonempty α] (P : α → Prop) (f : p → α) (a : p), P (f a) → P (Function.sometimes f)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "OrderedCancelAddCommMonoid",
   "le_of_add_le_add_left",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Eq.ge",
   "Eq.le",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.to_contravariantClass_le_left",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b c : α), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.Perm.dedup",
   "DecidableEq",
   "List.dedup",
   "List",
   "List.isSetoid",
   "Quot",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.dedup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (x x_1 : List α),\n  Setoid.r x x_1 → Quot.mk Setoid.r (List.dedup x) = Quot.mk Setoid.r (List.dedup x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "And.left",
   "implies_congr",
   "instLTNat",
   "Eq",
   "List.get_cons_drop",
   "Iff.mp",
   "List.Sublist.cons₂",
   "Nat",
   "Eq.trans",
   "Nat.min_eq_left",
   "List.nil_sublist",
   "Fin.val",
   "eq_of_heq",
   "List.length",
   "And",
   "instHAppend",
   "eq_true",
   "HEq.refl",
   "of_eq_true",
   "HAppend.hAppend",
   "LT.lt",
   "List.length_take",
   "Eq.mp",
   "congrArg",
   "Fin",
   "HEq",
   "List.instMembershipList",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.append",
   "List.Pairwise.of_cons",
   "List.nil_append",
   "List.take",
   "rfl",
   "True",
   "instLENat",
   "List.rec",
   "forall_congr",
   "Eq.rec",
   "instOfNatNat",
   "List.nil",
   "Eq.symm",
   "List.take_append_drop",
   "Fin.isLt",
   "id",
   "Std.Data.List.Lemmas._auxLemma.29",
   "eq_self",
   "Membership.mem",
   "List.drop_append_of_le_length",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "implies_true",
   "List.drop",
   "Init.Data.Nat.Basic._auxLemma.1",
   "LE.le",
   "List.Pairwise",
   "Eq.ndrec",
   "List.instAppendList",
   "List.pairwise_cons",
   "List",
   "List.Mem.head",
   "List.map",
   "Eq.casesOn",
   "Nat.le_of_lt",
   "List.get",
   "instMinNat"],
  "name": "List.map_get_sublist",
  "constType":
  "∀ {α : Type u_1} {l : List α} {is : List (Fin (List.length l))},\n  List.Pairwise (fun x x_1 ↦ ↑x < ↑x_1) is → List.Sublist (List.map (List.get l) is) l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "disjoint_assoc",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.62",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b c : α}, Disjoint (a ⊓ b) c = Disjoint a (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["IsLowerSet",
   "HEq",
   "compl_compl",
   "Set",
   "eq_of_heq",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "HEq.refl",
   "LE",
   "Eq.casesOn",
   "IsLowerSet.compl",
   "Eq.symm",
   "IsUpperSet.compl",
   "id"],
  "name": "isUpperSet_compl",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s : Set α}, IsUpperSet sᶜ ↔ IsLowerSet s",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toTop",
   "HasCompl.compl",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.top_le_sup_compl",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x : α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "List.pairwise_pwFilter",
   "DecidableEq",
   "List.dedup",
   "List",
   "instDecidableNot",
   "Eq"],
  "name": "List.nodup_dedup",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] (l : List α), List.Nodup (List.dedup l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Not"],
  "name": "List.decidableBAll.proof_3",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α), (¬∀ x ∈ xs, p x) → (∀ x_1 ∈ x :: xs, p x_1) → False",
  "constCategory": "Theorem"},
 {"references": ["Bot", "Bot.bot", "Bot.mk"],
  "name": "Pi.instBotForAll",
  "constType":
  "{ι : Type u_3} → {α' : ι → Type u_4} → [inst : (i : ι) → Bot (α' i)] → Bot ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "PartialOrder.toPreorder",
   "Disjoint",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.mk",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α},\n  Disjoint x y → Codisjoint x y → IsCompl x y",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.not_succ_le_self.match_1",
   "LE.le",
   "Nat.not_succ_le_zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.not_succ_le_self",
  "constType": "∀ (n : ℕ), ¬Nat.succ n ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "List.Pairwise.nil",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_zero",
  "constType": "∀ {α : Type u_1}, Multiset.Nodup 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "List.forall_mem_map_iff",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.69",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {P : β → Prop}, (∀ i ∈ List.map f l, P i) = ∀ j ∈ l, P (f j)",
  "constCategory": "Theorem"},
 {"references": ["Top", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toTop",
  "constType": "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "Function.comp",
   "Set",
   "Filter.Tendsto",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.Tendsto.comp",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {f : α → β} {g : β → γ} {x : Filter α} {y : Filter β} {z : Filter γ},\n  Filter.Tendsto g y z → Filter.Tendsto f x y → Filter.Tendsto (g ∘ f) x z",
  "constCategory": "Theorem"},
 {"references": ["Inf", "TopologicalSpace"],
  "name": "ContinuousInf",
  "constType":
  "(L : Type u_1) → [inst : TopologicalSpace L] → [inst : Inf L] → Prop",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Set", "LE", "LE.le", "Set.instMembershipSet"],
  "name": "IsUpperSet",
  "constType": "{α : Type u_1} → [inst : LE α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Array.mkArray2",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node2",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.33",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α}, (a ∈ b :: l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["False", "False.casesOn"],
  "name": "List.Sublist.eq_of_length.match_1",
  "constType": "∀ (motive : False → Prop) (x : False), motive x",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "List.erase.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpper.instInhabitedWithUpper._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.cons",
   "List.instMembershipList",
   "Unit",
   "HasSubset.Subset",
   "List.subset_nil.match_1",
   "rfl",
   "Eq",
   "Iff.intro",
   "Iff",
   "List.Subset.refl",
   "List",
   "List.Mem.head",
   "List.not_mem_nil.match_1",
   "List.nil",
   "List.subset_nil.match_2"],
  "name": "List.subset_nil",
  "constType": "∀ {α : Type u_1} {l : List α}, l ⊆ [] ↔ l = []",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "List.append_assoc",
   "Nat",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Multiset.instZeroMultiset",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "instHAppend",
   "Setoid.r",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
  "constType": "∀ {α : Type u_1} (s t : Multiset α), s + t = t + s",
  "constCategory": "Theorem"},
 {"references": ["Iff", "False", "Not", "iff_of_false", "id"],
  "name": "iff_false_intro",
  "constType": "∀ {a : Prop}, ¬a → (a ↔ False)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Exists",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Nat",
   "congrArg",
   "Eq.trans",
   "LE.le",
   "Eq"],
  "name": "Nat.add_le_add_left",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), k + n ≤ k + m",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "MonadReader",
  "constType": "outParam (Type u) → (Type u → Type v) → Type v",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "instOfNatNat",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "True",
   "Fin.succ_pos",
   "Fin",
   "Eq"],
  "name": "Std.Data.Fin.Lemmas._auxLemma.15",
  "constType": "∀ {n : ℕ} (a : Fin n), (0 < Fin.succ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_succ",
   "Nat.succ_le_of_lt",
   "instLENat",
   "Nat.lt_of_succ_le",
   "instAddNat",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Nat.add_le_add_left",
   "Eq"],
  "name": "Nat.add_lt_add_left",
  "constType": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), k + n < k + m",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "instHAppend",
   "PProd.fst",
   "List.cons",
   "List.instAppendList",
   "List.Perm",
   "List.rec",
   "List.below",
   "List.brecOn",
   "HAppend.hAppend",
   "List",
   "PUnit",
   "List.Perm.append_left.match_1",
   "List.nil",
   "List.Perm.cons"],
  "name": "List.Perm.append_left",
  "constType":
  "∀ {α : Type uu} {t₁ t₂ : List α} (l : List α), t₁ ~ t₂ → l ++ t₁ ~ l ++ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Unit",
   "Unit.unit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.beq.match_1",
  "constType":
  "(motive : Lean.Name → Lean.Name → Sort u_1) →\n  (x x_1 : Lean.Name) →\n    (Unit → motive Lean.Name.anonymous Lean.Name.anonymous) →\n      ((p₁ : Lean.Name) →\n          (s₁ : String) → (p₂ : Lean.Name) → (s₂ : String) → motive (Lean.Name.str p₁ s₁) (Lean.Name.str p₂ s₂)) →\n        ((p₁ : Lean.Name) →\n            (n₁ : ℕ) → (p₂ : Lean.Name) → (n₂ : ℕ) → motive (Lean.Name.num p₁ n₁) (Lean.Name.num p₂ n₂)) →\n          ((x x_2 : Lean.Name) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Fin.ne_of_val_ne",
   "instDecidableEqFin.match_1",
   "DecidableEq",
   "Fin.eq_of_val_eq",
   "Decidable.isFalse",
   "Fin.val",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Nat",
   "decEq",
   "instDecidableEqNat",
   "Fin",
   "Eq"],
  "name": "instDecidableEqFin",
  "constType": "(n : ℕ) → DecidableEq (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.to_contravariantClass_le_left.proof_1",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "OrderedCancelAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "ContravariantClass",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.to_contravariantClass_le_left",
  "constType":
  "∀ {α : Type u} [inst : OrderedCancelAddCommMonoid α], ContravariantClass α α (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Unit", "SeqLeft"],
  "name": "SeqLeft.seqLeft",
  "constType":
  "{f : Type u → Type v} → [self : SeqLeft f] → {α β : Type u} → f α → (Unit → f β) → f α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Topology.WithLower",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "Eq.rec", "rfl", "Eq"],
  "name": "List.hasDecEq.proof_4",
  "constType":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), a = b → as = bs → a :: as = b :: bs",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom", "Set", "InfSet.sInf", "sInfHom.mk", "InfSet", "Set.image", "Eq"],
  "name": "sInfHom.rec",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : InfSet α] →\n      [inst_1 : InfSet β] →\n        {motive : sInfHom α β → Sort u} →\n          ((toFun : α → β) →\n              (map_sInf' : ∀ (s : Set α), toFun (sInf s) = sInf (toFun '' s)) →\n                motive { toFun := toFun, map_sInf' := map_sInf' }) →\n            (t : sInfHom α β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "isOpen_induced_iff",
   "Set.preimage",
   "propext",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.15",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [t : TopologicalSpace β] {s : Set α} {f : α → β},\n  IsOpen s = ∃ t_1, IsOpen t_1 ∧ f ⁻¹' t_1 = s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_false_of_ne_true.match_1",
   "False.elim",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "rfl",
   "Eq"],
  "name": "eq_false_of_ne_true",
  "constType": "∀ {b : Bool}, ¬b = true → b = false",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "trivial", "Set", "Set.univ", "Set.instMembershipSet"],
  "name": "Set.mem_univ",
  "constType": "∀ {α : Type u} (x : α), x ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Lean.Data.AC.ContextInformation", "Bool", "Nat"],
  "name": "Lean.Data.AC.ContextInformation.mk",
  "constType":
  "{α : Sort u} → (α → ℕ → Bool) → (α → Bool) → (α → Bool) → Lean.Data.AC.ContextInformation α",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "OrderBot.bot_le",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "GaloisInsertion",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_7",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (a : β), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "eq_self",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "True",
   "Eq",
   "Nat.succ_sub_succ",
   "Nat.rec",
   "of_eq_true",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.add_sub_add_right",
  "constType": "∀ (n k m : ℕ), n + k - (m + k) = n - m",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.toLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.toLowerSet_le_iff",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α},\n  ↑Topology.WithLowerSet.toLowerSet a ≤ ↑Topology.WithLowerSet.toLowerSet b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Covariant",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "mem_lowerClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} {x : α}, x ∈ lowerClosure s ↔ ∃ a ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "setOf",
   "Set.subset_sInter",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed"],
  "name": "subset_closure",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, s ⊆ closure s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.num",
   "List",
   "String",
   "Lean.Name.anonymous",
   "Nat",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.MacroScope",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMacroScopesAux.match_1",
  "constType":
  "(motive : Lean.Name → List Lean.MacroScope → Sort u_1) →\n  (x : Lean.Name) →\n    (x_1 : List Lean.MacroScope) →\n      ((p : Lean.Name) → (scp : ℕ) → (acc : List Lean.MacroScope) → motive (Lean.Name.num p scp) acc) →\n        ((p : Lean.Name) → (str : String) → (acc : List Lean.MacroScope) → motive (Lean.Name.str p str) acc) →\n          ((x : Lean.Name) → (x_2 : List Lean.MacroScope) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.instPreorder",
   "Iff",
   "forall_swap",
   "Function.comp",
   "Monotone",
   "OrderDual",
   "FunLike.coe",
   "Preorder",
   "Antitone",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "antitone_comp_ofDual_iff",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Antitone (f ∘ ↑OrderDual.ofDual) ↔ Monotone f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.mkStr3",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.«termΩ^»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "propext",
   "Continuous",
   "continuous_iff_le_induced",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Topology.Order._auxLemma.26",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t₁ : TopologicalSpace α} {t₂ : TopologicalSpace β},\n  Continuous f = (t₁ ≤ TopologicalSpace.induced f t₂)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.mem_replicate.match_1",
   "Std.Data.List.Lemmas._auxLemma.2",
   "Std.Data.Nat.Lemmas._auxLemma.3",
   "HAdd.hAdd",
   "eq_true_of_decide",
   "optParam",
   "instLTNat",
   "instDecidableEqNat",
   "Eq",
   "PProd",
   "Eq.mpr",
   "Iff",
   "Bool.true",
   "PUnit",
   "Std.Logic._auxLemma.42",
   "or_false",
   "Nat",
   "Eq.trans",
   "false_or",
   "Nat.brecOn",
   "Or",
   "List.range'",
   "Std.Logic._auxLemma.48",
   "Std.Logic._auxLemma.38",
   "exists_comm",
   "And",
   "instHMul",
   "Std.Logic._auxLemma.30",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "of_eq_true",
   "propext",
   "Nat.noConfusion",
   "LT.lt",
   "instInhabitedNat",
   "congr",
   "congrArg",
   "congrFun",
   "Std.Data.List.Lemmas._auxLemma.105",
   "Nat.add_assoc",
   "Exists",
   "Nat.add_comm",
   "false_and",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.8",
   "Eq.refl",
   "True",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "instLENat",
   "Std.Data.List.Lemmas._auxLemma.103",
   "eq_false'",
   "instOfNatNat",
   "List.nil",
   "Eq.symm",
   "Nat.succ",
   "instNonempty",
   "id",
   "Membership.mem",
   "funext",
   "Nat.below",
   "List.cons",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "Init.Data.Nat.Basic._auxLemma.1",
   "Nat.succ.injEq",
   "LE.le",
   "Eq.ndrec",
   "Std.Data.List.Lemmas._auxLemma.106",
   "List",
   "HMul.hMul",
   "Bool",
   "instMulNat",
   "Std.Data.List.Lemmas._auxLemma.104",
   "Nat.casesOn"],
  "name": "List.mem_range'",
  "constType":
  "∀ {m s step n : ℕ}, m ∈ List.range' s n step ↔ ∃ i < n, m = s + step * i",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "LT.lt", "Nat", "Nat.succ", "LE.le", "instLTNat"],
  "name": "Nat.succ_le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → Nat.succ n ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["sInfHom",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Prod.infSet",
   "Prod.snd",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Inf.inf",
   "sInfHom.mk",
   "Prod",
   "infsInfHom.proof_1",
   "Prod.fst"],
  "name": "infsInfHom",
  "constType":
  "{α : Type u_2} → [inst : CompleteLattice α] → sInfHom (α × α) α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_6",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PLift.up",
   "Function.Surjective",
   "Equiv.surjective",
   "Equiv.plift",
   "PLift",
   "Equiv.symm"],
  "name": "PLift.up_surjective",
  "constType": "∀ {α : Sort u}, Function.Surjective PLift.up",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "bot_le", "IsBot"],
  "name": "isBot_bot",
  "constType": "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α], IsBot ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Filter.map.proof_2",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "Filter.map.proof_1",
   "Filter",
   "Filter.univ_mem"],
  "name": "Filter.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β",
  "constCategory": "Definition"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "OfNat.ofNat",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Eq",
   "Quot.liftOn",
   "Zero.toOfNat0",
   "Setoid.r",
   "AddZeroClass.toZero",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "List",
   "Multiset",
   "Nat"],
  "name": "Multiset.card.proof_1",
  "constType":
  "∀ {α : Type u_1},\n  (fun s ↦ Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂)) 0 =\n    (fun s ↦ Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), _l₁ ~ _l₂ → List.length _l₁ = List.length _l₂)) 0",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "∀ {α : Type u_1} (x : Set α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Set.instHasSubsetSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Or.rec",
   "Set.instMembershipSet"],
  "name": "Set.union_subset",
  "constType": "∀ {α : Type u} {s t r : Set α}, s ⊆ r → t ⊆ r → s ∪ t ⊆ r",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "Set",
   "Finset",
   "Function.Embedding.subtype",
   "Subtype",
   "Set.instMembershipSet"],
  "name": "Set.toFinset",
  "constType": "{α : Type u_1} → (s : Set α) → [inst : Fintype ↑s] → Finset α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Exists",
   "Nat.add_succ",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "Nat.add_sub_cancel_left",
   "instLENat",
   "Eq.ndrec",
   "Nat.le.dest",
   "Nat.succ_sub.match_1",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_sub",
  "constType": "∀ {m n : ℕ}, n ≤ m → Nat.succ m - n = Nat.succ (m - n)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_inf_iff",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.42",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s : Set α}, (s ∈ f ⊓ g) = ∃ t₁ ∈ f, ∃ t₂ ∈ g, s = t₁ ∩ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.iUnion_eq_univ_iff",
   "Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.univ",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.28",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → Set α}, (⋃ i, f i = Set.univ) = ∀ (x : α), ∃ i, x ∈ f i",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "LE.le", "Preorder.toLE", "Eq", "PartialOrder"],
  "name": "PartialOrder.le_antisymm",
  "constType":
  "∀ {α : Type u} [self : PartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.rec._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.mk", "ZeroHom", "Eq"],
  "name": "ZeroHom.rec",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : Zero M] →\n      [inst_1 : Zero N] →\n        {motive : ZeroHom M N → Sort u} →\n          ((toFun : M → N) → (map_zero' : toFun 0 = 0) → motive { toFun := toFun, map_zero' := map_zero' }) →\n            (t : ZeroHom M N) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "interior_eq_nhds",
   "instTransPropIff_1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "Iff.symm",
   "Filter.principal",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "interior",
   "subset_interior_iff_isOpen",
   "id"],
  "name": "isOpen_iff_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen s ↔ ∀ a ∈ s, nhds a ≤ Filter.principal s",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "True",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.1",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, (a ≤ a ⊔ b) = True",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "PartialOrder.toPreorder",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisConnection.monotone_u",
   "LE.le",
   "Preorder.toLE",
   "TopologicalSpace.gc_generateFrom",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "IsOpen"],
  "name": "TopologicalSpace.generateFrom_anti",
  "constType":
  "∀ {α : Type u_1} {g₁ g₂ : Set (Set α)}, g₁ ⊆ g₂ → TopologicalSpace.generateFrom g₂ ≤ TopologicalSpace.generateFrom g₁",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsClosed_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["EStateM", "EStateM.Result.error"],
  "name": "EStateM.throw",
  "constType": "{ε σ α : Type u} → ε → EStateM ε σ α",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α] [inst_2 : CovariantClass α α (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1]\n  {b c : α}, b ≤ c → ∀ (a : α), a + b ≤ a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≠]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Or",
   "Eq.refl",
   "Classical.em",
   "Or.casesOn",
   "LE.le",
   "ite_congr",
   "Eq",
   "ite",
   "Std.Data.Nat.Lemmas._auxLemma.5",
   "if_pos",
   "Eq.mpr",
   "instLENat",
   "congr",
   "Not",
   "Nat",
   "instMinNat",
   "congrArg",
   "Nat.succ",
   "if_neg",
   "Nat.decLe",
   "id",
   "congrFun"],
  "name": "Nat.min_succ_succ",
  "constType":
  "∀ (x y : ℕ), min (Nat.succ x) (Nat.succ y) = Nat.succ (min x y)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "PartialOrder.le_antisymm",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_4",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "nonempty_subtype.match_2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ a, p a) → Prop) (x : ∃ a, p a),\n  (∀ (a : α) (h : p a), motive (_ : ∃ a, p a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Char.val",
   "Char.mk",
   "UInt32",
   "Char",
   "Char.eq_of_val_eq.match_1",
   "rfl",
   "UInt32.isValidChar",
   "Eq"],
  "name": "Char.eq_of_val_eq",
  "constType": "∀ {c d : Char}, c.val = d.val → c = d",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "OrderDual.instPreorder",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "OrderDual",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Set.Ici_subset_Ici",
   "Preorder.toLE"],
  "name": "Set.Iic_subset_Iic",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Iic a ⊆ Set.Iic b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.modCore._unary", "PSigma.mk", "Nat"],
  "name": "Nat.modCore",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage", "Continuous", "Set", "TopologicalSpace", "IsOpen"],
  "name": "Continuous.mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  (∀ (s : Set β), IsOpen s → IsOpen (f ⁻¹' s)) → Continuous f",
  "constCategory": "Other"},
 {"references":
  ["Set.image_eq_preimage_of_inverse",
   "Set.instBooleanAlgebraSet",
   "Set.preimage",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Set.image",
   "Eq"],
  "name": "Set.compl_image",
  "constType": "∀ {α : Type u_1}, Set.image compl = Set.preimage compl",
  "constCategory": "Theorem"},
 {"references": ["Trunc.induction_on", "Trunc.mk", "Trunc"],
  "name": "Trunc.induction_on₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {C : Trunc α → Trunc β → Prop} (q₁ : Trunc α) (q₂ : Trunc β),\n  (∀ (a : α) (b : β), C (Trunc.mk a) (Trunc.mk b)) → C q₁ q₂",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd", "Sup", "Prod.mk", "Sup.sup", "Prod", "Prod.fst", "Sup.mk"],
  "name": "Prod.instSupProd",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Sup α] → [inst : Sup β] → Sup (α × β)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.instUnionSet",
   "Iff.mpr",
   "Set.union_eq_right",
   "Eq"],
  "name": "Set.union_eq_self_of_subset_left",
  "constType": "∀ {α : Type u} {s t : Set α}, s ⊆ t → s ∪ t = t",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_const.match_1",
  "constType":
  "∀ {b : Prop} (α : Sort u_1) (motive : (∃ x, b) → Prop) (x : ∃ x, b), (∀ (w : α) (h : b), motive (_ : ∃ x, b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithLowerSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLowerSet.toLowerSet_inj",
  "constType":
  "∀ {α : Type u_1} {a b : α}, ↑Topology.WithLowerSet.toLowerSet a = ↑Topology.WithLowerSet.toLowerSet b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["And.right",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«termI^_»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "Set.instSupSetSet",
   "And.intro",
   "Exists.intro",
   "SupSet.sSup",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.match_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)) (a : α) (motive : a ∈ sSup s → Prop) (x : a ∈ sSup s),\n  (∀ (t' : Set α) (t'_in : t' ∈ s) (a_in : a ∈ t'), motive (_ : ∃ t ∈ s, a ∈ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Unit",
   "Unit.unit",
   "EStateM.bind.match_1",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.seqRight",
  "constType":
  "{ε σ α β : Type u} → EStateM ε σ α → (Unit → EStateM ε σ β) → EStateM ε σ β",
  "constCategory": "Definition"},
 {"references":
  ["Codisjoint",
   "PartialOrder.toPreorder",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.codisjoint",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → Codisjoint x y",
  "constCategory": "Definition"},
 {"references": ["Bot", "CompleteLattice"],
  "name": "CompleteLattice.toBot",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Bot α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace"],
  "name": "Inducing",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [tα : TopologicalSpace α] → [tβ : TopologicalSpace β] → (α → β) → Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["List.nil_sublist",
   "Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "List.Sublist",
   "List.sublist_append_right",
   "Exists.casesOn",
   "Eq",
   "Iff.intro",
   "instHAppend",
   "Iff",
   "List.instAppendList",
   "Eq.ndrec",
   "List.Sublist.subset",
   "List.Sublist.trans",
   "List",
   "HAppend.hAppend",
   "List.Sublist.cons₂",
   "List.append_of_mem",
   "List.nil",
   "List.mem_singleton_self",
   "Eq.symm"],
  "name": "List.singleton_sublist",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α}, List.Sublist [a] l ↔ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Array.append._rarg",
   "Lean.Name.str._override",
   "Lean.Syntax.atom",
   "Lean.SourceInfo.fromRef",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.node"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_2._cstage2",
  "constType": "_obj → _obj → _obj → _obj → _obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Unit", "Bool"],
  "name": "cond",
  "constType": "{α : Type u} → Bool → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.mem_attach.match_1",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "Exists.casesOn",
   "List.attach",
   "Eq",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "List",
   "List.attach_map_val",
   "List.map",
   "And.casesOn",
   "Subtype",
   "Subtype.mk",
   "id",
   "Subtype.casesOn"],
  "name": "List.mem_attach",
  "constType":
  "∀ {α : Type u} (l : List α) (x : { x // x ∈ l }), x ∈ List.attach l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "UpperSet.Ici",
   "iInf",
   "UpperSet.instInfSetUpperSet",
   "upperClosure",
   "Set",
   "Preorder",
   "Eq.symm",
   "UpperSet",
   "Preorder.toLE",
   "Eq",
   "UpperSet.iInf_Ici",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Order.LowerUpperTopology._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (s : Set α), upperClosure s = ⨅ a ∈ s, UpperSet.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "not_forall_of_exists_not",
   "Decidable",
   "Not",
   "Exists.intro",
   "Decidable.not_imp_symm"],
  "name": "Decidable.not_forall",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} [inst : Decidable (∃ x, ¬p x)] [inst : (x : α) → Decidable (p x)],\n  (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.ndrec",
   "Bool.casesOn",
   "Bool.false",
   "and",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Bool",
   "instDecidableAnd",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.and_eq_true",
  "constType": "∀ (a b : Bool), ((a && b) = true) = (a = true ∧ b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_HomotopyGroup_Pi_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["NonemptyType"],
  "name": "_private.Init.Prelude.0.Lean.Macro.MethodsRefPointed",
  "constType": "NonemptyType",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_1"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "Set",
   "le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds_mono_mem",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} ⦃a b : α⦄, a ≤ b → a ∈ upperBounds s → b ∈ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "List.pmap",
   "List.instMembershipList",
   "Eq.refl",
   "List.pmap._sunfold.proof_1",
   "List.pmap._sunfold.proof_2",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.map_pmap",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type w} {p : α → Prop} (g : β → γ) (f : (a : α) → p a → β) (l : List α)\n  (H : ∀ a ∈ l, p a), List.map g (List.pmap f l H) = List.pmap (fun a h ↦ g (f a h)) l H",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Set", "LE", "UpperSet.mk", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.rec",
  "constType":
  "{α : Type u_6} →\n  [inst : LE α] →\n    {motive : UpperSet α → Sort u} →\n      ((carrier : Set α) → (upper' : IsUpperSet carrier) → motive { carrier := carrier, upper' := upper' }) →\n        (t : UpperSet α) → motive t",
  "constCategory": "Other"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Inhabited", "Topology.WithLower"],
  "name": "Topology.WithLower.instInhabitedWithLower",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.«termΩ^»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "IsAntisymm",
   "And.right",
   "Iff",
   "IsRefl",
   "HasSubset.Subset",
   "HasSubset.Subset.antisymm",
   "And.intro",
   "HasSubset",
   "Eq.superset",
   "And.left",
   "Eq.subset'",
   "Eq"],
  "name": "subset_antisymm_iff",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1]\n  [inst_2 : IsAntisymm α fun x x_1 ↦ x ⊆ x_1], a = b ↔ a ⊆ b ∧ b ⊆ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "SemilatticeInf.toPartialOrder",
   "OrderDual.semilatticeSup",
   "sup_le_sup",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c d : α}, a ≤ b → c ≤ d → a ⊓ c ≤ b ⊓ d",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace", "Inducing", "TopologicalSpace.induced", "Eq"],
  "name": "Inducing.mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\n  tα = TopologicalSpace.induced f tβ → Inducing f",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Topology.WithUpperSet",
   "Set",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.isUpperSet_toUpperSet_preimage",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set (Topology.WithUpperSet α)},\n  IsUpperSet (↑Topology.WithUpperSet.toUpperSet ⁻¹' s) ↔ IsOpen s",
  "constCategory": "Theorem"},
 {"references":
  ["isUpperSet_Ici",
   "UpperSet.mk",
   "Set.Ici",
   "Preorder",
   "UpperSet",
   "Preorder.toLE"],
  "name": "UpperSet.Ici",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → UpperSet α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Classical.axiomOfChoice",
   "Exists.intro",
   "Classical.skolem.match_1"],
  "name": "Classical.skolem",
  "constType":
  "∀ {α : Sort u} {b : α → Sort v} {p : (x : α) → b x → Prop}, (∀ (x : α), ∃ y, p x y) ↔ ∃ f, ∀ (x : α), p x (f x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Iff",
   "List.instMembershipList",
   "List",
   "Eq.rec",
   "Not",
   "Eq.symm",
   "rfl",
   "Eq"],
  "name": "List.forall_mem_ne",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, (∀ a' ∈ l, ¬a = a') ↔ ¬a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Finite.casesOn", "Finite.intro", "Finite", "Nat", "Fin"],
  "name": "finite_iff_exists_equiv_fin.match_1",
  "constType":
  "∀ {α : Sort u_1} (motive : Finite α → Prop) (x : Finite α),\n  (∀ (n : ℕ) (e : α ≃ Fin n), motive (_ : Finite α)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] →\n        [inst_1 : AddZeroClass N] →\n          [toAddHomClass : AddHomClass F M N] → (∀ (f : F), ↑f 0 = 0) → AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "List.erase_cons",
   "List.cons",
   "Eq.refl",
   "instBEq",
   "List.erase",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Not",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.erase_cons_head",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.erase (a :: l) a = l",
  "constCategory": "Theorem"},
 {"references": ["Lean.Data.AC.Variable", "Lean.IsNeutral", "Option"],
  "name": "Lean.Data.AC.Variable.mk",
  "constType":
  "{α : Sort u} → {op : α → α → α} → (value : α) → Option (Lean.IsNeutral op value) → Lean.Data.AC.Variable op",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_4",
  "constType": "∀ (α : Type u_1) [inst : Lattice α] (a b : αᵒᵈ), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.rec",
  "constType":
  "{α : Type u_2} →\n  {β : Topology.WithUpper α → Sort u_1} →\n    ((a : α) → β (↑Topology.WithUpper.toUpper a)) → (a : Topology.WithUpper α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "le_inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeInf",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeInf α],\n  GaloisInsertion l u → ∀ (a b : β), u (l (u a ⊓ u b)) ≤ u a ⊓ u b",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "BooleanAlgebra.sdiff_eq",
  "constType":
  "∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.casesOn",
   "List.nil"],
  "name": "List.pmap.match_1",
  "constType":
  "{α : Type u_1} →\n  {p : α → Prop} →\n    (motive : (x : List α) → (∀ a ∈ x, p a) → Sort u_2) →\n      (x : List α) →\n        (x_1 : ∀ a ∈ x, p a) →\n          ((x : ∀ a ∈ [], p a) → motive [] x) →\n            ((a : α) → (l : List α) → (H : ∀ a_1 ∈ a :: l, p a_1) → motive (a :: l) H) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Set.instAlternativeSet",
   "Fintype",
   "Set.Elem",
   "Set.fintypeSingleton",
   "Set",
   "Alternative.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "Set.fintypePure",
  "constType": "{α : Type u} → (a : α) → Fintype ↑(pure a)",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "Equiv",
   "OrderDual.toDual",
   "sSupHom.mk",
   "sSupHom",
   "Function.comp",
   "OrderDual.infSet",
   "sInfHomClass.toFunLike",
   "FunLike.coe",
   "sSupHom.map_sSup'",
   "rfl",
   "sInfHom.ext",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "SupSet",
   "sSupHomClass.toFunLike",
   "sSupHom.instSSupHomClassSSupHom",
   "OrderDual.ofDual",
   "sInfHom.map_sInf'",
   "OrderDual",
   "sInfHom.mk",
   "sInfHom.instSInfHomClassSInfHom"],
  "name": "sSupHom.dual.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : SupSet α] [inst_1 : SupSet β] (x : sInfHom αᵒᵈ βᵒᵈ),\n  (fun f ↦\n        { toFun := ↑OrderDual.toDual ∘ ↑f ∘ ↑OrderDual.ofDual,\n          map_sInf' := (_ : ∀ (s : Set α), sSupHom.toFun f (sSup s) = sSup (f.toFun '' s)) })\n      ((fun f ↦\n          { toFun := ↑OrderDual.ofDual ∘ ↑f ∘ ↑OrderDual.toDual,\n            map_sSup' := (_ : ∀ (s : Set αᵒᵈ), sInfHom.toFun f (sInf s) = sInf (f.toFun '' s)) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Topology.WithUpper.ofUpper",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpper.to_WithUpper_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithUpper.toUpper.symm = Topology.WithUpper.ofUpper",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "Unit",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Unit.unit",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.eq_of_mem_singleton.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} (motive : (b : α) → a ∈ [b] → Prop) (b : α) (x : a ∈ [b]),\n  (Unit → motive a (_ : List.Mem a [a])) → motive b x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.ball_image_iff",
   "Set",
   "Function.comp",
   "Set.forall_range_iff",
   "Set.image",
   "Set.mem_range_self",
   "Set.Subset.antisymm",
   "Iff.mpr",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.range_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} (g : α → β) (f : ι → α), Set.range (g ∘ f) = g '' Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Exists",
   "Equiv.toHomeomorphOfInducing",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "Equiv.refl",
   "Topology.IsLower",
   "lcProof",
   "Homeomorph",
   "Topology.WithLower.ofLower",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.IsLower.WithLowerHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsLower α] → Topology.WithLower α ≃ₜ α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_trans.match_1",
  "constType":
  "∀ {n m : ℕ} (motive : (k : ℕ) → n ≤ m → m ≤ k → Prop) (k : ℕ) (x : n ≤ m) (x_1 : m ≤ k),\n  (∀ (h : n ≤ m), motive m h (_ : Nat.le m m)) →\n    (∀ (h₁ : n ≤ m) (m_1 : ℕ) (h₂ : Nat.le m m_1), motive (Nat.succ m_1) h₁ (_ : Nat.le m (Nat.succ m_1))) →\n      motive k x x_1",
  "constCategory": "Definition"},
 {"references":
  ["sInf_singleton",
   "Set.instSingletonSet",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Singleton.singleton",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.sInter",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.sInter_singleton",
  "constType": "∀ {α : Type u_1} (s : Set α), ⋂₀ {s} = s",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u} → α → Top α",
  "constCategory": "Other"},
 {"references": ["BEq.beq", "BEq", "List", "Nat", "List.countP"],
  "name": "List.count",
  "constType": "{α : Type u_1} → [inst : BEq α] → α → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "IsOpen.preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ {s : Set β}, IsOpen s → IsOpen (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "superset_of_eq", "HasSubset.Subset", "HasSubset", "Eq"],
  "name": "Eq.superset",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1], a = b → b ⊆ a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_10",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "EmptyCollection.emptyCollection",
   "Set.instBooleanAlgebraSet",
   "inf_compl_eq_bot",
   "Set",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.inter_compl_self",
  "constType": "∀ {α : Type u} (s : Set α), s ∩ sᶜ = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "Decidable.not_and_iff_or_not.match_1",
  "constType":
  "∀ (p q : Prop) (motive : Decidable p → Decidable q → Prop) (d₁ : Decidable p) (d₂ : Decidable q),\n  (∀ (h₁ : p) (h₂ : q), motive (isTrue h₁) (isTrue h₂)) →\n    (∀ (x : Decidable p) (h₂ : ¬q), motive x (isFalse h₂)) →\n      (∀ (h₁ : ¬p) (x : Decidable q), motive (isFalse h₁) x) → motive d₁ d₂",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero",
   "Bool.false",
   "Nat.beq",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.ne_of_beq_eq_false.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → Nat.beq x x_1 = false → x = x_1 → Prop) (x x_1 : ℕ) (x_2 : Nat.beq x x_1 = false)\n  (x_3 : x = x_1),\n  (∀ (h₁ : Nat.beq Nat.zero Nat.zero = false) (x : Nat.zero = Nat.zero), motive Nat.zero Nat.zero h₁ x) →\n    (∀ (n : ℕ) (x : Nat.beq Nat.zero (Nat.succ n) = false) (h₂ : Nat.zero = Nat.succ n),\n        motive Nat.zero (Nat.succ n) x h₂) →\n      (∀ (n : ℕ) (x : Nat.beq (Nat.succ n) Nat.zero = false) (h₂ : Nat.succ n = Nat.zero),\n          motive (Nat.succ n) Nat.zero x h₂) →\n        (∀ (n m : ℕ) (h₁ : Nat.beq (Nat.succ n) (Nat.succ m) = false) (h₂ : Nat.succ n = Nat.succ m),\n            motive (Nat.succ n) (Nat.succ m) h₁ h₂) →\n          motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["UInt32.mk", "UInt32", "Eq.rec", "UInt32.size", "rfl", "Fin", "Eq"],
  "name": "UInt32.decEq.proof_1",
  "constType": "∀ (n m : Fin UInt32.size), n = m → { val := n } = { val := m }",
  "constCategory": "Theorem"},
 {"references":
  ["exists_comm.match_1",
   "Iff.intro",
   "Exists",
   "Iff",
   "exists_comm.match_2",
   "Exists.intro"],
  "name": "exists_comm",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {p : α → β → Prop}, (∃ a, ∃ b, p a b) ↔ ∃ b, ∃ a, p a b",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "outParam",
   "Function.RightInverse",
   "EquivLike.inv"],
  "name": "EquivLike.right_inv",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e : E),\n  Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Zero M] → [inst : Zero N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis",
   "Set",
   "Filter",
   "Set.Subset.rfl",
   "instMembershipSetFilter",
   "Filter.HasBasis.mem_of_superset"],
  "name": "Filter.HasBasis.mem_of_mem",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {i : ι},\n  Filter.HasBasis l p s → p i → s i ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeInf.mk",
  "constType":
  "{α : Type u_9} →\n  [toPartialOrder : PartialOrder α] →\n    [toInfSet : InfSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) → CompleteSemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Nat.decLt",
   "LT.lt",
   "Unit",
   "PUnit",
   "Lean.Data.AC.insert.match_1",
   "List.nil",
   "Nat",
   "instLTNat",
   "ite"],
  "name": "Lean.Data.AC.insert",
  "constType": "ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.Perm.symm",
   "Exists",
   "List.Perm",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro"],
  "name": "List.Perm.subperm",
  "constType": "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ ~ l₂ → l₁ <+~ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["ClosedIciTopology.isClosed_ge'",
   "TopologicalSpace",
   "IsClosed",
   "Set.Ici",
   "Preorder",
   "ClosedIciTopology"],
  "name": "isClosed_Ici",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : ClosedIciTopology α] {a : α}, IsClosed (Set.Ici a)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "sup_of_le_left",
   "Sup.sup",
   "OrderBot",
   "bot_le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "sup_bot_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : OrderBot α] {a : α}, a ⊔ ⊥ = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["UInt32.decEq", "UInt32", "DecidableEq"],
  "name": "instDecidableEqUInt32",
  "constType": "DecidableEq UInt32",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "Topology.isUpper_orderDual",
   "OrderDual.instPreorder",
   "Iff",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "Topology.isLower_orderDual",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α], Topology.IsLower αᵒᵈ ↔ Topology.IsUpper α",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsIdempotent", "Eq"],
  "name": "Lean.IsIdempotent.idempotent",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : Lean.IsIdempotent op] (x : α), op x x = x",
  "constCategory": "Definition"},
 {"references": ["Mod"],
  "name": "Mod.mod",
  "constType": "{α : Type u} → [self : Mod α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeSup.le_sSup",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "le_sSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, a ∈ s → a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "OrderDual.orderBot",
   "OrderBot.toBot",
   "inferInstanceAs",
   "OrderDual",
   "OrderBot.bot_le",
   "LE",
   "OrderBot",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "BoundedOrder"],
  "name": "OrderDual.boundedOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : LE α] [inst_1 : BoundedOrder α] (a : αᵒᵈ), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.casesOn", "Multiset", "Finset", "Multiset.Nodup", "Finset.mk"],
  "name": "Finset.cons_induction.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : Finset α → Prop) (x : Finset α),\n  (∀ (s : Multiset α) (nd : Multiset.Nodup s), motive { val := s, nodup := nd }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
   "AddSemigroup.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
   "nsmulRec",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
   "Multiset.instAddMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
   "AddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
   "Multiset",
   "OrderedCancelAddCommMonoid.mk",
   "Zero.mk",
   "Add.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset",
  "constType": "{α : Type u_1} → OrderedCancelAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "Decidable.byCases.match_1",
  "constType":
  "{p : Prop} →\n  (motive : Decidable p → Sort u_1) →\n    (dec : Decidable p) → ((h : p) → motive (isTrue h)) → ((h : ¬p) → motive (isFalse h)) → motive dec",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_7",
  "constType":
  "∀ {α : Type u_1} (a b c : (Filter α)ᵒᵈᵒᵈ), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "Equiv",
   "Equiv.toFun",
   "Equiv.right_inv",
   "Function.comp",
   "Inducing",
   "FunLike.coe",
   "Iff.mpr",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Equiv.invFun",
   "Inducing.continuous_iff",
   "Equiv.self_comp_symm",
   "Continuous",
   "TopologicalSpace",
   "Equiv.mk",
   "Equiv.left_inv",
   "congrArg",
   "Equiv.symm",
   "id"],
  "name": "Equiv.toHomeomorphOfInducing.proof_2",
  "constType":
  "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : X ≃ Y),\n  Inducing ↑f →\n    Continuous\n      { toFun := f.toFun, invFun := f.invFun, left_inv := (_ : Function.LeftInverse f.invFun f.toFun),\n          right_inv := (_ : Function.RightInverse f.invFun f.toFun) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝ˢ»._closed_3",
   "Topology.«term𝓝ˢ»._closed_5"],
  "name": "Topology.«term𝓝ˢ»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_private.Init.WF.0.InvImage.accAux", "InvImage", "Acc", "rfl"],
  "name": "InvImage.accessible.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : β → β → Prop} {a : α} (f : α → β), Acc r (f a) → Acc (InvImage r f) a",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references": ["UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.mk",
  "constType": "Fin UInt32.size → UInt32",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.ofLower._cstage1",
  "constType": "{α : Type u_1} → Topology.WithLower α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.comp",
   "Topology.WithLowerSet",
   "ContinuousMap.comp",
   "Topology.WithLowerSet.map",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderHom",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "Eq"],
  "name": "Topology.WithLowerSet.map_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ]\n  (g : β →o γ) (f : α →o β),\n  Topology.WithLowerSet.map (OrderHom.comp g f) =\n    ContinuousMap.comp (Topology.WithLowerSet.map g) (Topology.WithLowerSet.map f)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Sup",
   "SemilatticeInf.toInf",
   "OrderDual.semilatticeSup.proof_1",
   "SemilatticeInf.toPartialOrder",
   "instSupOrderDual",
   "SemilatticeSup.mk",
   "Sup.mk",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "SemilatticeSup",
   "SemilatticeInf.le_inf",
   "OrderDual",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "SemilatticeInf.inf_le_right",
   "Sup.sup",
   "SemilatticeInf"],
  "name": "OrderDual.semilatticeSup",
  "constType":
  "(α : Type u_1) → [inst : SemilatticeInf α] → SemilatticeSup αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[_]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.lift.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "Preorder",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : PartialOrder β] → (f : α → β) → Function.Injective f → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "DistribLattice.toLattice",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "IsCompl.disjoint_right_iff",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.le_left_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y z : α}, IsCompl x y → (z ≤ x ↔ Disjoint z y)",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Finset.val", "Multiset.Nodup"],
  "name": "Finset.nodup",
  "constType": "∀ {α : Type u_4} (self : Finset α), Multiset.Nodup self.val",
  "constCategory": "Definition"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.13",
  "constType": "∀ {a b c : Prop}, (a ∧ b ∧ c) = (b ∧ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Bot.bot",
   "propext",
   "SProd.sprod",
   "Prod",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.instSProd",
   "Filter.prod_eq_bot",
   "Filter.instCompleteLatticeFilter",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.31",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : Filter α} {g : Filter β}, (f ×ˢ g = ⊥) = (f = ⊥ ∨ g = ⊥)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[<]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Eq.rec",
   "Set.mem_image",
   "And.intro",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Set.image_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {s : Set α}, (∀ a ∈ s, f a = g a) → f '' s = g '' s",
  "constCategory": "Theorem"},
 {"references": ["Option.getD", "List", "List.get?", "Nat"],
  "name": "List.getD",
  "constType": "{α : Type u_1} → List α → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "exists_and_left.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop} (motive : (∃ x, b ∧ p x) → Prop) (x : ∃ x, b ∧ p x),\n  (∀ (x : α) (h : b) (hp : p x), motive (_ : ∃ x, b ∧ p x)) → motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "Top",
   "Top.top",
   "OrderBot.toBot",
   "OrderTop",
   "OrderDual.top",
   "inferInstanceAs",
   "OrderDual",
   "LE",
   "OrderBot",
   "bot_le",
   "Top.mk",
   "OrderDual.instLEOrderDual"],
  "name": "OrderDual.orderTop",
  "constType":
  "(α : Type u) → [inst : LE α] → [inst_1 : OrderBot α] → OrderTop αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Pure"],
  "name": "Applicative.toPure",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → Pure f",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Pairwise._auxLemma.4",
   "Eq",
   "Std.Data.List.Pairwise._auxLemma.5",
   "Iff.intro",
   "List.Pairwise",
   "instHAppend",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "List.instAppendList",
   "propext",
   "List",
   "HAppend.hAppend",
   "congr",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "List.pairwise_append_comm",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop},\n  (∀ {x y : α}, R x y → R y x) → ∀ {l₁ l₂ : List α}, List.Pairwise R (l₁ ++ l₂) ↔ List.Pairwise R (l₂ ++ l₁)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "T0Space",
  "constType": "(α : Type u) → [inst : TopologicalSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "Set.subset_univ",
   "Set.instMembershipSet"],
  "name": "Filter.principal",
  "constType": "{α : Type u} → Set α → Filter α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "TopologicalSpace",
   "IsClosed",
   "Set.sInter",
   "Eq"],
  "name": "_private.Mathlib.Topology.Basic.0.closure._eq_1",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), closure s = ⋂₀ {t | IsClosed t ∧ s ⊆ t}",
  "constCategory": "Theorem"},
 {"references": ["_obj", "Topology.WithLower.rec._rarg", "_neutral"],
  "name": "Topology.WithLower.rec._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "List.getD",
   "Lean.Data.AC.Context",
   "Option.none",
   "Lean.Data.AC.Context.arbitrary",
   "Lean.IsNeutral",
   "Nat",
   "Lean.Data.AC.Context.vars"],
  "name": "Lean.Data.AC.Context.var",
  "constType":
  "{α : Sort u_1} → (ctx : Lean.Data.AC.Context α) → ℕ → Lean.Data.AC.Variable ctx.op",
  "constCategory": "Definition"},
 {"references": ["False", "propext", "Not", "True", "Eq", "not_false_iff"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.17",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.eventually_of_forall",
   "Filter.Eventually.mp",
   "Filter",
   "Filter.Eventually"],
  "name": "Filter.Eventually.mono",
  "constType":
  "∀ {α : Type u} {p q : α → Prop} {f : Filter α}, (∀ᶠ (x : α) in f, p x) → (∀ (x : α), p x → q x) → ∀ᶠ (x : α) in f, q x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Or",
   "Iff",
   "forall_eq",
   "Set",
   "and_congr_left'",
   "Iff.trans",
   "Insert.insert",
   "ball_or_left",
   "Set.instInsertSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ball_insert_iff",
  "constType":
  "∀ {α : Type u} {P : α → Prop} {a : α} {s : Set α}, (∀ x ∈ insert a s, P x) ↔ P a ∧ ∀ x ∈ s, P x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Topology.IsUpper.toContinuousInf.proof_1",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Topology.IsUpper",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ContinuousSup"],
  "name": "Topology.IsUpper.toContinuousInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], ContinuousSup α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "iInf_range",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set",
   "Set.iInter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instMembershipSet",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.biInter_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {f : ι → α} {g : α → Set β}, ⋂ x ∈ Set.range f, g x = ⋂ y, g (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{α : Type u_1} → Singleton α (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Sup", "Inf", "Inf.inf", "OrderDual", "Sup.mk"],
  "name": "instSupOrderDual",
  "constType": "(α : Type u_1) → [inst : Inf α] → Sup αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Preorder.le_trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : (Filter α)ᵒᵈᵒᵈ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.val", "Subtype.eq.match_1", "rfl", "Subtype.mk", "Subtype", "Eq"],
  "name": "Subtype.eq",
  "constType":
  "∀ {α : Type u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Top",
   "HImp.himp",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "Inf.inf",
   "Lattice",
   "GeneralizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toLattice : Lattice α] →\n    [toTop : Top α] →\n      [toHImp : HImp α] → (∀ (a : α), a ≤ ⊤) → (∀ (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c) → GeneralizedHeytingAlgebra α",
  "constCategory": "Other"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Function.Surjective.forall.match_1",
   "Function.Surjective",
   "Eq.rec",
   "Eq"],
  "name": "Function.Surjective.forall",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.Surjective f → ∀ {p : β → Prop}, (∀ (y : β), p y) ↔ ∀ (x : α), p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "False", "imp.swap", "Not"],
  "name": "imp_not_comm",
  "constType": "∀ {a b : Prop}, a → ¬b ↔ b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_6",
  "constType": "3 < UInt32.size",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.insert.match_1",
  "constType":
  "(motive : List ℕ → Sort u_1) →\n  (x : List ℕ) → (Unit → motive []) → ((a : ℕ) → (as : List ℕ) → motive (a :: as)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.node4",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.erase_cons",
   "OfNat.ofNat",
   "List.below",
   "instSubNat",
   "List.brecOn",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "List.erase",
   "True",
   "ite",
   "Eq",
   "PProd",
   "Eq.mpr",
   "List.rec",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.add_zero",
   "Eq.symm",
   "Eq.trans",
   "if_neg",
   "id",
   "instHSub",
   "eq_self",
   "List.cons",
   "instAddNat",
   "List.count_cons",
   "instHAdd",
   "Unit",
   "eq_comm",
   "HSub.hSub",
   "instBEq",
   "Nat.zero_sub",
   "List.countP_map.match_1",
   "PProd.fst",
   "if_pos",
   "Eq.ndrec",
   "DecidableEq",
   "of_eq_true",
   "propext",
   "List",
   "Eq.mp",
   "Nat.sub_zero",
   "Not",
   "List.count",
   "congrArg",
   "Nat.add_sub_cancel"],
  "name": "List.count_erase",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : α) (l : List α),\n  List.count a (List.erase l b) = List.count a l - if a = b then 1 else 0",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "And.comm"],
  "name": "and_comm",
  "constType": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "And", "Exists", "Set", "Set.instMembershipSet"],
  "name": "DirectedOn",
  "constType": "{α : Type u} → (α → α → Prop) → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "GeneralizedHeytingAlgebra.le_top",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedHeytingAlgebra α] (a : α), a ≤ ⊤",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b : M), a + b = b + a) → AddCancelCommMonoid M",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.add_left_cancel",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsLeftCancelAdd G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk",
   "rfl",
   "Eq"],
  "name": "Equiv.pprodEquivProd.proof_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (x : α × β),\n  (fun x ↦ (x.fst, x.snd)) ((fun x ↦ { fst := x.1, snd := x.2 }) x) =\n    (fun x ↦ (x.fst, x.snd)) ((fun x ↦ { fst := x.1, snd := x.2 }) x)",
  "constCategory": "Theorem"},
 {"references":
  ["sInfHom",
   "sInfHom.casesOn",
   "sInfHom.toFun",
   "Eq.ndrec",
   "Eq.rec",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "sInfHom.mk",
   "InfSet",
   "Set.image",
   "Eq.symm",
   "Eq"],
  "name": "sInfHom.instSInfHomClassSInfHom.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : InfSet α] [inst_1 : InfSet β] (f g : sInfHom α β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.completeLattice.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (a b : αᵒᵈ), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_2",
  "constType": "1 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "Unit", "Eq.to_iff.match_1", "Eq"],
  "name": "Eq.to_iff",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List.Perm.refl",
   "List",
   "List.Perm.rec",
   "List.nil",
   "List.recOn"],
  "name": "List.perm_induction_on",
  "constType":
  "∀ {α : Type uu} {P : List α → List α → Prop} {l₁ l₂ : List α},\n  l₁ ~ l₂ →\n    P [] [] →\n      (∀ (x : α) (l₁ l₂ : List α), l₁ ~ l₂ → P l₁ l₂ → P (x :: l₁) (x :: l₂)) →\n        (∀ (x y : α) (l₁ l₂ : List α), l₁ ~ l₂ → P l₁ l₂ → P (y :: x :: l₁) (x :: y :: l₂)) →\n          (∀ (l₁ l₂ l₃ : List α), l₁ ~ l₂ → l₂ ~ l₃ → P l₁ l₂ → P l₂ l₃ → P l₁ l₃) → P l₁ l₂",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "_private.Std.Data.List.Count.0.List.findIdx.go.match_1.splitter",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → ℕ → Sort u_2) →\n    (x : List α) →\n      (x_1 : ℕ) → ((n : ℕ) → motive [] n) → ((a : α) → (l : List α) → (n : ℕ) → motive (a :: l) n) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le_of_le",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf₂_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {f : (i : ι) → κ i → α} (i : ι) (j : κ i),\n  ⨅ i, ⨅ j, f i j ≤ f i j",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff",
   "Topology.WithUpperSet",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpperSet.toUpperSet_inj",
  "constType":
  "∀ {α : Type u_1} {a b : α}, ↑Topology.WithUpperSet.toUpperSet a = ↑Topology.WithUpperSet.toUpperSet b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "exists_exists_eq_and.match_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : β → Prop} (motive : (∃ b, (∃ a, f a = b) ∧ p b) → Prop)\n  (x : ∃ b, (∃ a, f a = b) ∧ p b),\n  (∀ (w : β) (a : α) (ha : f a = w) (hb : p w), motive (_ : ∃ b, (∃ a, f a = b) ∧ p b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["forall_imp"],
  "name": "forall₂_imp",
  "constType":
  "∀ {α : Sort u_5} {β : α → Sort u_1} {p q : (a : α) → β a → Prop},\n  (∀ (a : α) (b : β a), p a b → q a b) → (∀ (a : α) (b : β a), p a b) → ∀ (a : α) (b : β a), q a b",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "ReaderT.read",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → ReaderT ρ m ρ",
  "constCategory": "Definition"},
 {"references":
  ["Set.image_pair",
   "Bool.univ_eq",
   "Set",
   "Eq.refl",
   "Set.image_univ",
   "Insert.insert",
   "Set.univ",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "Bool.false",
   "Bool.true",
   "Singleton.singleton",
   "Bool",
   "Set.image",
   "Eq.symm",
   "Set.instInsertSet",
   "id"],
  "name": "Bool.range_eq",
  "constType":
  "∀ {α : Type u_1} (f : Bool → α), Set.range f = {f false, f true}",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "Eq"],
  "name": "AddRightCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddRightCancelSemigroup : AddRightCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddRightCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Filter.join.proof_2",
   "Membership.mem",
   "setOf",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.join.proof_3",
   "Filter.join.proof_1",
   "instMembershipSetFilter"],
  "name": "Filter.join",
  "constType": "{α : Type u} → Filter (Filter α) → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "sup_assoc",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.Variable",
   "Iff",
   "SemilatticeSup.toSup",
   "SDiff.mk",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "inf_sdiff_self_left",
   "sup_of_le_left",
   "Nat",
   "instIsIdempotent",
   "SemilatticeSup.toPartialOrder",
   "instIsIdempotentSupToSup",
   "sup_le_sup_right",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_sup_self'",
   "Lean.Data.AC.eval",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "SDiff.sdiff",
   "sup_comm",
   "bot_le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "instIsAssociative",
   "bot_sup_eq",
   "OrderBot.toBot",
   "instTransEq",
   "congr",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "le_of_inf_le_sup_le",
   "Lean.Data.AC.Expr.op",
   "inf_of_le_right",
   "Eq.refl",
   "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
   "Lean.IsNeutral",
   "le_of_eq",
   "sup_idem",
   "Lattice.toInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Context",
   "instOfNatNat",
   "Option.some",
   "List.nil",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GeneralizedBooleanAlgebra.toBot",
   "id",
   "Bot.bot",
   "List.cons",
   "inf_sdiff_self_right",
   "instTransLeToLE",
   "SemilatticeInf.toPartialOrder",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "LE.le",
   "le_sup_left",
   "inf_sup_right",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "Lean.IsCommutative",
   "le_refl",
   "GeneralizedBooleanAlgebra",
   "inf_eq_right",
   "Sup.sup",
   "Bool",
   "instIsAssociativeSupToSup"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (y x z : α), y \\ x ≤ z ↔ y ≤ x ⊔ z",
  "constCategory": "Theorem"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation"],
  "name": "Lean.Data.AC.ContextInformation.isComm",
  "constType":
  "{α : Sort u} → [self : Lean.Data.AC.ContextInformation α] → α → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "List",
   "List.Mem.head",
   "Not"],
  "name": "List.decidableBAll.proof_4",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α), ¬p x → (∀ x_1 ∈ x :: xs, p x_1) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Continuous",
   "TopologicalSpace",
   "Iff.trans",
   "gc_coinduced_induced",
   "TopologicalSpace.induced",
   "LE.le",
   "Preorder.toLE",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "continuous_iff_le_induced",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t₁ : TopologicalSpace α} {t₂ : TopologicalSpace β},\n  Continuous f ↔ t₁ ≤ TopologicalSpace.induced f t₂",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«termI^_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsIdempotent.mk",
   "SemilatticeInf.toInf",
   "IsIdempotent",
   "Inf.inf",
   "inf_idem",
   "SemilatticeInf"],
  "name": "instIsIdempotentInfToInf.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α], IsIdempotent α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "iInf",
   "CompleteAtomicBooleanAlgebra",
   "CompleteLattice.toInfSet",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteAtomicBooleanAlgebra.iInf_sup_le_sup_sInf",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.IsLowerSet",
   "Preorder",
   "rfl",
   "Topology.IsLowerSet.mk"],
  "name":
  "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLowerSet (Topology.WithLowerSet α)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "sup_assoc",
   "Sup.sup",
   "sup_comm",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "sup_left_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] (a b c : α), a ⊔ (b ⊔ c) = b ⊔ (a ⊔ c)",
  "constCategory": "Theorem"},
 {"references": ["CompleteSemilatticeSup", "PartialOrder"],
  "name": "CompleteSemilatticeSup.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadExcept"],
  "name": "MonadExcept.throw",
  "constType":
  "{ε : outParam (Type u)} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → ε → m α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Multiset.Le",
   "List.Subperm.trans",
   "Iff.rfl",
   "List.isSetoid",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "Setoid.r",
   "And",
   "List",
   "List.Subperm.refl",
   "LT.lt",
   "Quot.ind",
   "List.Subperm.antisymm",
   "Multiset",
   "Not",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_4",
  "constType": "∀ {α : Type u_1} (a b : Multiset α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["and.match_1", "Bool.false", "Unit", "Bool"],
  "name": "and",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasEquiv",
  "constType": "Sort u → Sort (max u (v + 1))",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.namespace",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_4"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsAssociative.mk",
   "Set",
   "IsAssociative",
   "Inter.inter",
   "Set.inter_assoc",
   "Set.instInterSet"],
  "name": "Set.inter_isAssoc.proof_1",
  "constType": "∀ {α : Type u_1}, IsAssociative (Set α) fun x x_1 ↦ x ∩ x_1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u_1} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Set",
   "lowerBounds",
   "Monotone",
   "Set.image",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Monotone.mem_lowerBounds_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, a ∈ lowerBounds s → f a ∈ lowerBounds (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Fin.rec", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.casesOn",
  "constType":
  "{n : ℕ} →\n  {motive : Fin n → Sort u} →\n    (t : Fin n) → ((val : ℕ) → (isLt : val < n) → motive { val := val, isLt := isLt }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "rfl",
   "absurd",
   "ite",
   "Eq"],
  "name": "if_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "sdiff_eq",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["outParam", "RelHomClass", "FunLike.coe", "RelHomClass.toFunLike"],
  "name": "RelHomClass.map_rel",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} {r : outParam (α → α → Prop)}\n  {s : outParam (β → β → Prop)} [self : RelHomClass F r s] (f : F) {a b : α}, r a b → s (↑f a) (↑f b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "upperClosure.proof_1",
   "UpperSet.mk",
   "Preorder",
   "UpperSet",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperClosure",
  "constType": "{α : Type u_1} → [inst : Preorder α] → Set α → UpperSet α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "Nat.modCore",
   "HSub.hSub",
   "Eq.refl",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "Nat.instModNat",
   "And",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "instLENat",
   "LT.lt",
   "HMod.hMod",
   "Nat.modCore_eq_mod",
   "instOfNatNat",
   "Nat",
   "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
   "Eq.symm",
   "Nat.decLe",
   "id"],
  "name": "Nat.mod_eq",
  "constType": "∀ (x y : ℕ), x % y = if 0 < y ∧ y ≤ x then (x - y) % y else x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "upperClosure",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "mem_upperClosure",
   "Preorder",
   "LE.le",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.UpperLower.Basic._auxLemma.94",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} {x : α}, (x ∈ upperClosure s) = ∃ a ∈ s, a ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim.match_1", "Nonempty"],
  "name": "Nonempty.elim.proof_1",
  "constType": "∀ {α : Sort u_1} {p : Prop}, Nonempty α → (α → p) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
  "constType": "∀ {α : Type u_1} (x : Multiset α), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.instMembershipList",
   "List.Pairwise.rec",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil"],
  "name": "List.Pairwise.brecOn",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop} {a : List α}\n  (x : List.Pairwise R a), (∀ (a : List α) (x : List.Pairwise R a), List.Pairwise.below x → motive a x) → motive a x",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.sub_le_sub_right.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (z : ℕ), motive (Nat.succ z)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "And.right",
   "propext",
   "And.intro",
   "True",
   "Eq"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddLeftCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedHeytingAlgebra.le_top",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "BooleanAlgebra",
   "GeneralizedHeytingAlgebra.toTop"],
  "name": "Pi.booleanAlgebra.proof_4",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → BooleanAlgebra (α i)] (a : (i : ι) → α i), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithLowerSet.instInhabitedWithLowerSet._rarg", "_neutral"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["BEq.beq", "BEq", "LawfulBEq", "Bool.true", "Bool", "Eq"],
  "name": "LawfulBEq.mk",
  "constType":
  "∀ {α : Type u} [inst : BEq α], (∀ {a b : α}, (a == b) = true → a = b) → (∀ {a : α}, (a == a) = true) → LawfulBEq α",
  "constCategory": "Other"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "false_or.match_1",
  "constType":
  "∀ (p : Prop) (motive : False ∨ p → Prop) (x : False ∨ p), (∀ (h : p), motive (_ : False ∨ p)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Function.swap", "Iff"],
  "name": "forall_swap",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_2} {p : α → β → Prop}, (∀ (x : α) (y : β), p x y) ↔ ∀ (y : β) (x : α), p x y",
  "constCategory": "Theorem"},
 {"references": ["Iff", "imp_true_iff", "True"],
  "name": "forall_true_iff",
  "constType": "∀ {α : Sort u_2}, α → True ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "cond.match_1",
   "List.cons",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Lean.MacroScopesView",
   "String",
   "Unit",
   "instBEq",
   "Lean.MacroScope",
   "Eq",
   "_private.Init.Prelude.0.Lean.assembleParts",
   "PProd",
   "namedPattern",
   "Lean.Name.rec",
   "PProd.fst",
   "BEq.beq",
   "List",
   "PUnit",
   "Lean.MacroScopesView.mk",
   "panic",
   "Bool",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.extractImported.match_1",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractImported",
  "constType":
  "List Lean.MacroScope → Lean.Name → Lean.Name → List Lean.Name → Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "Quot.ind",
   "PSigma.fst",
   "Quot.indepCoherent",
   "Quot.lift",
   "Quot",
   "rfl",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.liftIndepPr1",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a))\n  (h : ∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) (q : Quot r),\n  (Quot.lift (Quot.indep f) (_ : ∀ (a b : α), r a b → Quot.indep f a = Quot.indep f b) q).fst = q",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "LawfulBEq",
   "LawfulBEq.mk",
   "of_decide_eq_true",
   "instBEq",
   "of_decide_eq_self_eq_true",
   "Eq"],
  "name": "instLawfulBEqInstBEq.proof_1",
  "constType": "∀ {α : Type u_1} [inst : DecidableEq α], LawfulBEq α",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "Mathlib.Topology.Order._auxLemma.27",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t₁ : TopologicalSpace α} {t₂ : TopologicalSpace β},\n  Continuous f = (TopologicalSpace.coinduced f t₁ ≤ t₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpperSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Decidable.decide",
   "propext",
   "decide_eq_true",
   "Bool.true",
   "of_decide_eq_true",
   "Decidable",
   "Bool",
   "Eq"],
  "name": "decide_eq_true_eq",
  "constType": "∀ {p : Prop} [inst : Decidable p], (decide p = true) = p",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Lattice.toInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Inf.inf",
   "OrderDual.completeLattice",
   "OrderDual",
   "iSup_sup_eq",
   "Eq"],
  "name": "iInf_inf_eq",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f g : ι → α}, ⨅ x, f x ⊓ g x = (⨅ x, f x) ⊓ ⨅ x, g x",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Prop.booleanAlgebra",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_16",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_9",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "DecidableEq",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Bool",
   "of_decide_eq_self_eq_true.match_1",
   "absurd",
   "rfl",
   "Eq"],
  "name": "of_decide_eq_self_eq_true",
  "constType":
  "∀ {α : Sort u_1} [inst : DecidableEq α] (a : α), decide (a = a) = true",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_6",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_4",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "DecidableEq",
   "PLift.down",
   "Function.comp",
   "Finset.image",
   "PLift",
   "Set.fintypeRange.proof_1",
   "Fintype.ofFinset"],
  "name": "Set.fintypeRange",
  "constType":
  "{α : Type u} → {ι : Sort w} → [inst : DecidableEq α] → (f : ι → α) → [inst : Fintype (PLift ι)] → Fintype ↑(Set.range f)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.le_inf",
  "constType":
  "∀ {α : Type u} [self : SemilatticeInf α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.IsOpen",
   "Set",
   "TopologicalSpace",
   "Inter.inter",
   "Set.instInterSet"],
  "name": "TopologicalSpace.isOpen_inter",
  "constType":
  "∀ {α : Type u} [self : TopologicalSpace α] (s t : Set α),\n  TopologicalSpace.IsOpen s → TopologicalSpace.IsOpen t → TopologicalSpace.IsOpen (s ∩ t)",
  "constCategory": "Definition"},
 {"references":
  ["supsSupHom",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "instTopologicalSpaceProd",
   "Topology.IsUpper",
   "CompleteLattice.toBoundedOrder",
   "ConditionallyCompleteLattice.toLattice",
   "Topology.instIsUpperProd",
   "Prod.completeLattice",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "CompleteLattice",
   "ContinuousSup.mk",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "sSupHom.continuous",
   "ContinuousSup"],
  "name": "Topology.IsUpper.toContinuousInf.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α], ContinuousSup α",
  "constCategory": "Theorem"},
 {"references": ["IsIdempotent", "IsIdempotent.idempotent", "Eq"],
  "name": "instIsIdempotent.proof_1",
  "constType":
  "∀ {α : Type u_1} {op : α → α → α} [inst : IsIdempotent α op] (a : α), op a a = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "funext",
   "Or",
   "Iff",
   "of_eq_true",
   "Std.Logic._auxLemma.47",
   "congrArg",
   "Eq.trans",
   "Std.Logic._auxLemma.46",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.38",
   "congrFun",
   "Eq"],
  "name": "exists_eq_or_imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∃ a, (a = a' ∨ q a) ∧ p a) ↔ p a' ∨ ∃ a, q a ∧ p a",
  "constCategory": "Theorem"},
 {"references": ["List", "String", "Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.decl",
  "constType": "Lean.Name → List String → Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references":
  ["Option.none", "Option.some", "Option.casesOn", "String.Pos", "Option"],
  "name": "Lean.SourceInfo.fromRef.match_1",
  "constType":
  "(motive : Option String.Pos → Option String.Pos → Sort u_1) →\n  (x x_1 : Option String.Pos) →\n    ((pos tailPos : String.Pos) → motive (some pos) (some tailPos)) →\n      ((x x_2 : Option String.Pos) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "Decidable.isTrue",
  "constType": "{p : Prop} → p → Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsLower.WithLowerHomeomorph._spec_1",
  "constType":
  "(α : Type u_1) →\n  (inst : Preorder α) →\n    (inst_1 : TopologicalSpace α) →\n      let _x_1 :=\n        { IsOpen := TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s},\n          isOpen_univ := (_ : TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} Set.univ),\n          isOpen_inter :=\n            (_ :\n              ∀ (s t : Set α),\n                TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} s →\n                  TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} t →\n                    TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} (Inter.inter✝ s t)),\n          isOpen_sUnion :=\n            (_ :\n              ∀ (S : Set (Set α)),\n                (∀ s ∈ S, TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} s) →\n                  TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Ici a) = s} (⋃₀ S)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithLower α ≃ α) → Inducing ↑f → Topology.WithLower α ≃ₜ α",
  "constCategory": "Axiom"},
 {"references": ["Multiset", "List.nil", "Multiset.ofList"],
  "name": "Multiset.zero",
  "constType": "{α : Type u_1} → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instLENat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "LE.le",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.112",
  "constType": "∀ (n : ℕ), (0 ≤ n) = True",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "or_imp.match_1",
  "constType":
  "∀ {a b c : Prop} (motive : (a → c) ∧ (b → c) → Prop) (x : (a → c) ∧ (b → c)),\n  (∀ (ha : a → c) (hb : b → c), motive (_ : (a → c) ∧ (b → c))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Iff.mpr",
   "continuous_def",
   "id"],
  "name": "continuous_id",
  "constType": "∀ {α : Type u_1} [inst : TopologicalSpace α], Continuous id",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PSigma",
  "constType": "{α : Sort u} → (α → Sort v) → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.WithLower.rec._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set.mem_singleton",
   "Set.Nonempty",
   "Inter.inter",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Filter.instPureFilter",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "mem_closure_iff",
   "Filter",
   "Iff.trans",
   "And.casesOn",
   "IsOpen",
   "HasCompl.compl",
   "HasSubset.Subset",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "nhds_basis_opens",
   "List.Chain.cons",
   "Set.instMembershipSet",
   "And",
   "isClosed_closure",
   "Specializes",
   "propext",
   "Filter.instPartialOrderFilter",
   "List.Chain.nil",
   "Not",
   "Singleton.singleton",
   "IsClosed",
   "closure",
   "Filter.HasBasis.ge_iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "IsOpen.mem_nhds",
   "of_not_not",
   "Pure.pure",
   "Filter.principal",
   "Set.instSingletonSet",
   "IsClosed.isOpen_compl",
   "TopologicalSpace",
   "List.nil",
   "Filter.principal_singleton",
   "List.TFAE",
   "id",
   "instMembershipSetFilter",
   "Membership.mem",
   "pure_le_nhds",
   "List.cons",
   "Set.singleton_subset_iff",
   "nhds",
   "LE.le.trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed.closure_subset_iff",
   "subset_closure",
   "LE.le",
   "mem_closure_iff_clusterPt",
   "ClusterPt",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "List.tfae_of_cycle",
   "Set.instInterSet"],
  "name": "specializes_TFAE",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] (x y : X),\n  List.TFAE\n    [x ⤳ y, pure x ≤ nhds y, ∀ (s : Set X), IsOpen s → y ∈ s → x ∈ s, ∀ (s : Set X), IsClosed s → x ∈ s → y ∈ s,\n      y ∈ closure {x}, closure {y} ⊆ closure {x}, ClusterPt y (pure x)]",
  "constCategory": "Theorem"},
 {"references":
  ["le_sInf_iff",
   "Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "propext",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.CompleteLattice._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (a ≤ sInf s) = ∀ b ∈ s, a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.instPureFilter",
   "Iff",
   "Iff.rfl",
   "Set",
   "Filter",
   "Pure.pure",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_pure",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, s ∈ pure a ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "inf_assoc",
   "Prod.fst",
   "Filter.instSProd",
   "inf_left_comm",
   "True",
   "Eq",
   "inf_comm",
   "CompleteLattice.toLattice",
   "of_eq_true",
   "SProd.sprod",
   "Filter.instInfFilter",
   "Filter.comap",
   "congr",
   "Filter",
   "Prod",
   "Filter.comap_inf",
   "congrArg",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.prod_inf_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f₁ f₂ : Filter α} {g₁ g₂ : Filter β}, f₁ ×ˢ g₁ ⊓ f₂ ×ˢ g₂ = (f₁ ⊓ f₂) ×ˢ (g₁ ⊓ g₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "Lean.Syntax.matchesNull",
   "cond",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "Nat.sub",
   "Lean.Syntax.node4",
   "Monad.toBind",
   "ite",
   "Eq",
   "instMonadExcept",
   "ReaderT.instMonadExceptOfReaderT",
   "Bool.true",
   "Array.append",
   "PUnit",
   "Bind.bind",
   "Nat",
   "Array.extract",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntaxArray.raw",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "Lean.Syntax",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "Lean.SourceInfo",
   "Array.mkArray0",
   "GE.ge",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "instLENat",
   "Unit.unit",
   "Lean.mkNullNode",
   "instOfNatNat",
   "List.nil",
   "Applicative.toPure",
   "Nat.decLe",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntaxArray",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.Syntax.getNumArgs",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.MacroScope",
   "Lean.Syntax.node",
   "EStateM.instMonadEStateM",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.EvalInformation.mk",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.EvalInformation",
   "Lean.Data.AC.Context.arbitrary",
   "Lean.Data.AC.Variable.value",
   "Nat",
   "Lean.Data.AC.Context.var"],
  "name": "Lean.Data.AC.instEvalInformationContext",
  "constType":
  "{α : Sort u_1} → Lean.Data.AC.EvalInformation (Lean.Data.AC.Context α) α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Topology.IsUpper.t0Space.proof_1",
   "Topology.IsUpper",
   "TopologicalSpace",
   "T0Space",
   "PartialOrder"],
  "name": "Topology.IsUpper.t0Space",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsUpper α], T0Space α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "forall_exists_index.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ x, p x) → Prop) (x : ∃ x, p x),\n  (∀ (x : α) (hpx : p x), motive (_ : ∃ x, p x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.IsOpen_of._closed_9"],
  "name": "Topology.IsOpen_of._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termΩ._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Finite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "closure_minimal",
   "Set.Subset.trans",
   "IsClosed",
   "subset_closure"],
  "name": "IsClosed.closure_subset_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsClosed t → (closure s ⊆ t ↔ s ⊆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "ClosedIciTopology",
   "LE.le",
   "Preorder.toLE"],
  "name": "ClosedIciTopology.mk",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α],\n  (∀ (a : α), IsClosed {b | a ≤ b}) → ClosedIciTopology α",
  "constCategory": "Other"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) (src : LE (α × β)) (x : α × β) (a : α) (b : β)\n  (motive : (x_1 : α × β) → x_1 ≤ x → (a, b) ≤ x_1 → Prop) (x_1 : α × β) (x_2 : x_1 ≤ x) (x_3 : (a, b) ≤ x_1),\n  (∀ (c : α) (d : β) (x : (c, d) ≤ x) (x_4 : (a, b) ≤ (c, d)), motive (c, d) x x_4) → motive x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace.GenerateOpen", "Set.univ"],
  "name": "TopologicalSpace.GenerateOpen.univ",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)}, TopologicalSpace.GenerateOpen g Set.univ",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "Membership.mem",
   "Filter.HasBasis",
   "Iff",
   "Set.Nonempty.mono",
   "Set",
   "Set.Nonempty",
   "Iff.trans",
   "Filter",
   "Filter.HasBasis.forall_iff",
   "Filter.NeBot",
   "Filter.forall_mem_nonempty_iff_neBot",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.neBot_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → (Filter.NeBot l ↔ ∀ {i : ι}, p i → Set.Nonempty (s i))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Sublist.subset",
   "List.instMembershipList",
   "List",
   "List.Sublist",
   "List.nil",
   "List.Pairwise.cons",
   "List.Pairwise.sublist.match_1._@.Std.Data.List.Lemmas._hyg.28830",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Pairwise.sublist",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {R : α → α → Prop}, List.Sublist l₁ l₂ → List.Pairwise R l₂ → List.Pairwise R l₁",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.le_top",
  "constType": "∀ {α : Type u} [self : BooleanAlgebra α] (a : α), a ≤ ⊤",
  "constCategory": "Definition"},
 {"references":
  ["UInt32.decEq.proof_1",
   "UInt32.mk",
   "UInt32",
   "Decidable.isFalse",
   "UInt32.decEq.proof_2",
   "Decidable",
   "instDecidableEqFin",
   "Not",
   "Decidable.isTrue",
   "dite",
   "UInt32.size",
   "UInt32.decEq.match_1",
   "Fin",
   "Eq"],
  "name": "UInt32.decEq",
  "constType": "(a b : UInt32) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Finset.mem_image",
   "DecidableEq",
   "propext",
   "Finset.image",
   "Finset",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.24",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},\n  (b ∈ Finset.image f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "Exists.intro",
   "Exists.casesOn",
   "List.erase",
   "Eq",
   "And",
   "instHAppend",
   "List.instAppendList",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Not",
   "And.intro",
   "And.casesOn"],
  "name": "List.perm_cons_erase.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}\n  (motive : (∃ l₁, ∃ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ List.erase l a = l₁ ++ l₂) → Prop)\n  (x : ∃ l₁, ∃ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ List.erase l a = l₁ ++ l₂),\n  (∀ (_l₁ _l₂ : List α) (left : ¬a ∈ _l₁) (e₁ : l = _l₁ ++ a :: _l₂) (e₂ : List.erase l a = _l₁ ++ _l₂),\n      motive (_ : ∃ l₁, ∃ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ List.erase l a = l₁ ++ l₂)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Monad", "ReaderT", "Bind.bind", "Monad.toBind"],
  "name": "ReaderT.bind",
  "constType":
  "{ρ : Type u} →\n  {m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → ReaderT ρ m α → (α → ReaderT ρ m β) → ReaderT ρ m β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set.instHasSubsetSet",
   "Mathlib.Order.Filter.Basic._auxLemma.120",
   "of_eq_true",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter"],
  "name": "Filter.comap.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (m : α → β) (f : Filter β), ∃ t ∈ f, m ⁻¹' t ⊆ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), l (sSup (u '' s)) ∈ lowerBounds (upperBounds s)",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Preorder"],
  "name": "Topology.WithUpper.instPreorderWithUpper._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.snd",
   "Prod.instLEProd",
   "Prod.fst",
   "Prod.instPreorderProd.proof_3",
   "Preorder",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Preorder.mk",
   "And",
   "Prod.instPreorderProd.proof_2",
   "LE",
   "inferInstanceAs",
   "Prod.instPreorderProd.proof_1",
   "Prod",
   "Not"],
  "name": "Prod.instPreorderProd",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : Preorder α] → [inst : Preorder β] → Preorder (α × β)",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Nat", "LE.le", "Nat.succ", "Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ Nat.succ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "if_pos",
   "List.decidableBAll",
   "List.instMembershipList",
   "List",
   "List.foldr",
   "List.pwFilter",
   "List.nil",
   "Eq",
   "ite",
   "DecidableRel"],
  "name": "List.pwFilter_cons_of_pos",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R] {a : α} {l : List α},\n  (∀ b ∈ List.pwFilter R l, R a b) → List.pwFilter R (a :: l) = a :: List.pwFilter R l",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Equiv.mk",
   "Topology.WithLower.toDualHomeomorph._closed_1",
   "_neutral"],
  "name": "Topology.WithLower.toDualHomeomorph._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsAntisymm",
   "Set.instHasSubsetSet",
   "Set",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet.proof_1",
   "HasSubset.Subset"],
  "name": "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
  "constType": "∀ {α : Type u}, IsAntisymm (Set α) fun x x_1 ↦ x ⊆ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Bool.of_not_eq_true.match_1",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "Eq"],
  "name": "Bool.of_not_eq_true",
  "constType": "∀ {b : Bool}, ¬b = true → b = false",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Finset.univ",
   "Fintype.ofBijective.proof_2",
   "Fintype.mk",
   "Fintype",
   "Function.Bijective",
   "Function.Embedding.mk",
   "Fintype.ofBijective.proof_1"],
  "name": "Fintype.ofBijective",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Fintype α] → (f : α → β) → Function.Bijective f → Fintype β",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "instSubNat",
   "HSub.hSub",
   "Nat",
   "Nat.succ",
   "Nat.succ_sub_succ_eq_sub",
   "Eq"],
  "name": "Nat.succ_sub_succ",
  "constType": "∀ (n m : ℕ), Nat.succ n - Nat.succ m = n - m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Pure"],
  "name": "Pure.pure",
  "constType":
  "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
  "constCategory": "Definition"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.86",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references": ["String", "String.toSubstring", "Substring"],
  "name": "String.toSubstring'",
  "constType": "String → Substring",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Std.Logic._auxLemma.34",
   "Or",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Std.Logic._auxLemma.43",
   "congrArg",
   "Std.Logic._auxLemma.44",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "forall_eq_or_imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∀ (a : α), a = a' ∨ q a → p a) ↔ p a' ∧ ∀ (a : α), q a → p a",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["lt_of_le_not_le",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "dite",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.lt_or_eq_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 ↦ x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.eq_nil_of_length_eq_zero.match_1",
   "List",
   "instOfNatNat",
   "List.nil",
   "List.length",
   "Nat",
   "rfl",
   "Eq"],
  "name": "List.eq_nil_of_length_eq_zero",
  "constType": "∀ {α : Type u_1} {l : List α}, List.length l = 0 → l = []",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "SDiff"],
  "name": "CompleteAtomicBooleanAlgebra.toSDiff",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references": ["UInt64"],
  "name": "mixHash",
  "constType": "UInt64 → UInt64 → UInt64",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "Option.none",
   "List",
   "PUnit",
   "Option.some",
   "Nat",
   "List.get!.match_1",
   "Option"],
  "name": "List.get?",
  "constType": "{α : Type u_1} → List α → ℕ → Option α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{α : Type u_1} → InfSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["UInt32",
   "Eq.ndrec",
   "UInt32.noConfusionType",
   "Eq.refl",
   "UInt32.size",
   "UInt32.casesOn",
   "Fin",
   "Eq"],
  "name": "UInt32.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : UInt32} → v1 = v2 → UInt32.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.68",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) = ((∀ a' ∈ l, R a a') ∧ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["Exists", "propext", "exists_const", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.30",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (∃ x, b) = b",
  "constCategory": "Theorem"},
 {"references": ["And", "Iff", "iff_of_eq", "and_self"],
  "name": "and_self_iff",
  "constType": "∀ (p : Prop), p ∧ p ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.ofLowerSet_le_iff",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithLowerSet α ≃o α",
  "constCategory": "Definition"},
 {"references": ["Set.iUnion", "Set", "Set.iUnion_congr", "Eq"],
  "name": "Set.iUnion₂_congr",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_7} {s t : (i : ι) → κ i → Set α},\n  (∀ (i : ι) (j : κ i), s i j = t i j) → ⋃ i, ⋃ j, s i j = ⋃ i, ⋃ j, t i j",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Not",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_3",
  "constType":
  "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelMonoid.toZero",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "And.right",
   "setOf",
   "Set",
   "LE.le.trans",
   "Exists.imp",
   "And.intro",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerClosure.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (s : Set α) (x x_1 : α), x_1 ≤ x → x ∈ {x | ∃ a ∈ s, x ≤ a} → ∃ a ∈ s, x_1 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_rfl",
   "sup_le_sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), a ⊔ c ≤ b ⊔ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "List.Mem",
   "Eq.refl",
   "Eq",
   "And",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Mem.head",
   "List.Mem.casesOn",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.forall_mem_cons.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {l : List α} (x : α) (motive : (a : α) → x ∈ a :: l → (p a ∧ ∀ x ∈ l, p x) → p a → Prop)\n  (a : α) (x_1 : x ∈ a :: l) (x_2 : p a ∧ ∀ x ∈ l, p x) (H₁ : p a),\n  (∀ (x_3 : p x ∧ ∀ x ∈ l, p x) (H₁ : p x), motive x (_ : List.Mem x (x :: l)) x_3 H₁) →\n    (∀ (a : α) (h : List.Mem x l) (x_3 : p a ∧ ∀ x ∈ l, p x) (H₁ : p a), motive a (_ : List.Mem x (a :: l)) x_3 H₁) →\n      motive a x_1 x_2 H₁",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff.mp",
   "Iff",
   "And.symm.match_1",
   "And.intro",
   "Iff.mpr"],
  "name": "and_congr_right",
  "constType": "∀ {a b c : Prop}, (a → (b ↔ c)) → (a ∧ b ↔ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "ite"],
  "name": "List.insert",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → List α",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Std.Data.List.Lemmas._auxLemma.2",
   "HAdd.hAdd",
   "List.casesOn",
   "dite",
   "List.Perm.cons",
   "List.erase",
   "instLTNat",
   "Eq",
   "List.perm_cons_erase",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "true_or",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "Or",
   "Mathlib.Algebra.Group.Defs._auxLemma.4",
   "Iff.intro",
   "DecidableEq",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Nat.noConfusion",
   "propext",
   "LT.lt",
   "Eq.mp",
   "congr",
   "List.Perm.trans",
   "Not",
   "List.count_erase_of_ne",
   "congrArg",
   "List.count",
   "congrFun",
   "List.count_pos_iff_mem",
   "instSubNat",
   "List.instMembershipList",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Eq.refl",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "List.Perm.symm",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "List.rec",
   "List.count_cons_of_ne",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "List.Perm.count_eq",
   "List.nil",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "List.cons",
   "False",
   "instAddNat",
   "List.Perm.refl",
   "instHAdd",
   "HSub.hSub",
   "instBEq",
   "List.count_cons_self",
   "eq_false",
   "List.Perm",
   "Eq.ndrec",
   "List",
   "List.count_erase_self"],
  "name": "List.perm_iff_count",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {l₁ l₂ : List α}, l₁ ~ l₂ ↔ ∀ (a : α), List.count a l₁ = List.count a l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Topology.WithUpper.toUpper",
   "rfl",
   "Eq",
   "Topology.WithUpper.ofUpper",
   "Equiv.symm"],
  "name": "Topology.WithUpper.of_WithUpper_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithUpper.ofUpper.symm = Topology.WithUpper.toUpper",
  "constCategory": "Theorem"},
 {"references":
  ["List.hasDecEq.match_1",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.hasDecEq.proof_2",
   "List.hasDecEq.match_3",
   "List.hasDecEq.proof_4",
   "Unit",
   "List.hasDecEq.match_2",
   "List.hasDecEq.proof_3",
   "Decidable.isTrue",
   "decEq",
   "Eq",
   "PProd",
   "PProd.fst",
   "List.rec",
   "DecidableEq",
   "List",
   "Decidable.isFalse",
   "PUnit",
   "Decidable",
   "Not",
   "List.nil",
   "List.hasDecEq.proof_1",
   "List.hasDecEq.proof_6",
   "List.hasDecEq.proof_5"],
  "name": "List.hasDecEq",
  "constType":
  "{α : Type u} → [inst : DecidableEq α] → (a b : List α) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeSup.sup_le",
   "OrderDual",
   "Sup.sup",
   "OrderDual.semilatticeSup",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] (a b c : αᵒᵈ), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.evalList.match_1",
  "constType":
  "(motive : List ℕ → Sort u_1) →\n  (x : List ℕ) → (Unit → motive []) → ((x : ℕ) → motive [x]) → ((x : ℕ) → (xs : List ℕ) → motive (x :: xs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet.instPreorderWithLowerSet._rarg", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Eq.ndrec",
   "Finite.Set.finite_union",
   "Set.Elem",
   "Union.union",
   "Set",
   "Eq.refl",
   "Eq.symm",
   "Finite.of_fintype",
   "Set.toFinite",
   "Set.instUnionSet",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.union",
  "constType":
  "∀ {α : Type u} {s t : Set α}, Set.Finite s → Set.Finite t → Set.Finite (s ∪ t)",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{α : Type u} → [self : Sub α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "Homeomorph",
  "constType":
  "(X : Type u_4) → (Y : Type u_5) → [inst : TopologicalSpace X] → [inst : TopologicalSpace Y] → Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "Set.mem_inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} {x y : Set α}, x ∈ {s | ∀ (x : α), x ∈ s} → y ∈ {s | ∀ (x : α), x ∈ s} → ∀ (x_1 : α), x_1 ∈ x ∩ y",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "ClosedIicTopology",
  "constType":
  "(α : Type u_1) → [inst : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.instSingletonSet",
   "Iff.mp",
   "Set.mem_singleton_iff",
   "Eq.rec",
   "Set",
   "Singleton.singleton",
   "Set.range_const_subset",
   "Eq.symm",
   "Set.mem_range_self",
   "Set.Subset.antisymm",
   "Set.range_const.match_1",
   "Nonempty",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.range_const",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} [inst : Nonempty ι] {c : α}, (Set.range fun x ↦ c) = {c}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.TSyntax",
   "Array",
   "List.cons",
   "Lean.SourceInfo.none",
   "Lean.SyntaxNodeKind",
   "Lean.TSyntax.mk",
   "List.nil",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.mkNode",
  "constType": "(k : Lean.SyntaxNodeKind) → Array Lean.Syntax → Lean.TSyntax k",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLower.toLower._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.WithUpperSet.instInhabitedWithUpperSet._rarg", "_neutral"],
  "name": "Topology.WithUpperSet.instInhabitedWithUpperSet._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "List.Chain.cons",
   "Iff.intro",
   "And",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Chain.casesOn",
   "List.Chain.nil",
   "List.nil",
   "And.intro",
   "List.noConfusion",
   "List.chain_cons.match_1",
   "List.Chain",
   "Eq.symm"],
  "name": "List.chain_cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, List.Chain R a (b :: l) ↔ R a b ∧ List.Chain R b l",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.elim.proof_1", "Nonempty"],
  "name": "Nonempty.elim",
  "constType": "∀ {α : Sort u} {p : Prop}, Nonempty α → (α → p) → p",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SProd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty.proof_1",
  "constType": "∀ {α : Sort u_1} [inst : Inhabited α], Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "closure",
   "mem_interior_iff_mem_nhds",
   "setOf",
   "Iff.rfl",
   "nhds",
   "Set",
   "closure_eq_compl_interior_compl",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "_private.Mathlib.Topology.Basic.0.Filter.Eventually._eq_1",
   "Filter.Eventually",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "_private.Mathlib.Topology.Basic.0.Filter.Frequently._eq_1",
   "Filter.Frequently",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Not",
   "Filter",
   "Eq.symm",
   "interior",
   "instMembershipSetFilter",
   "id"],
  "name": "mem_closure_iff_frequently",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {a : α}, a ∈ closure s ↔ ∃ᶠ (x : α) in nhds a, x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "LE.le.trans", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_le_of_eq",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "eq_true",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.12",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b ≤ b) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "SProd.sprod",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.mem_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {p : α × β}, p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_6",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] (a b c : αᵒᵈ), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype",
   "Multiset",
   "Finset.val",
   "Finset.mem_univ",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_univ_val",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ.val",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.below",
   "List.brecOn",
   "Eq.refl",
   "dite",
   "List.indexOf",
   "instLTNat",
   "True",
   "Eq",
   "ite",
   "PProd",
   "List.rec",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "List.indexOf_get.match_1",
   "instOfNatNat",
   "Nat",
   "List.indexOf_cons",
   "Eq.trans",
   "Nat.succ",
   "if_false",
   "Fin.mk",
   "eq_self",
   "List.cons",
   "False",
   "instBEq",
   "List.length",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "PProd.fst",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "List",
   "LT.lt",
   "congr",
   "Not",
   "List.get",
   "congrArg",
   "Fin",
   "congrFun"],
  "name": "List.indexOf_get",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {l : List α} (h : List.indexOf a l < List.length l),\n  List.get l { val := List.indexOf a l, isLt := h } = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "True",
   "Set.subset_univ",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.120",
  "constType": "∀ {α : Type u} (s : Set α), (s ⊆ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.empty", "EmptyCollection.mk", "Finset", "EmptyCollection"],
  "name": "Finset.instEmptyCollectionFinset",
  "constType": "{α : Type u_1} → EmptyCollection (Finset α)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.closure_of._closed_2",
   "Topology.closure_of._closed_6",
   "Lean.ParserDescr.node",
   "_obj"],
  "name": "Topology.closure_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "List.length", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "List.length_cons",
  "constType":
  "∀ {α : Type u_1} (a : α) (as : List α), List.length (a :: as) = Nat.succ (List.length as)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter.proof_1",
  "constType":
  "∀ {α : Type u_1} {x y : Set α}, x ∈ {s | ∀ (x : α), x ∈ s} → x ⊆ y → ∀ (a : α), a ∈ y",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_rfl",
   "sup_le_sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), c ⊔ a ≤ c ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr4",
   "Array.append._rarg",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "UInt8",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{α : Type u} → BooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["MonadWithReaderOf",
   "MonadWithReader",
   "withTheReader",
   "MonadWithReader.mk"],
  "name": "instMonadWithReader",
  "constType":
  "(ρ : Type u) → (m : Type u → Type v) → [inst : MonadWithReaderOf ρ m] → MonadWithReader ρ m",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.subperm_right",
   "instHasEquiv",
   "propext",
   "List",
   "List.Subperm",
   "List.isSetoid",
   "Iff.trans",
   "HasEquiv.Equiv",
   "Eq",
   "List.Perm.subperm_left"],
  "name": "Multiset.Le.proof_1",
  "constType":
  "∀ {α : Type u_1} (x x_1 x_2 x_3 : List α), x ≈ x_2 → x_1 ≈ x_3 → (x <+~ x_1) = (x_2 <+~ x_3)",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "DecidableEq",
   "List.dedup",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.dedup.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.dedup",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Continuous_of._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.Context", "Lean.Syntax"],
  "name": "Lean.Macro.Context.ref",
  "constType": "Lean.Macro.Context → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.39",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references":
  ["Exists", "propext", "Exists.intro", "forall_exists_index", "Eq"],
  "name": "Std.Logic._auxLemma.29",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q (_ : ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "setOf",
   "propext",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter",
   "Filter.mem_inf_principal",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.35",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, (s ∈ f ⊓ Filter.principal t) = ({x | x ∈ t → x ∈ s} ∈ f)",
  "constCategory": "Theorem"},
 {"references": ["IsRefl", "HasSubset.Subset", "HasSubset", "refl"],
  "name": "subset_rfl",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1], a ⊆ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "cond",
   "HAdd.hAdd",
   "Bool.cond_eq_ite",
   "Eq.refl",
   "List.indexOf",
   "List.findIdx",
   "True",
   "ite",
   "Eq",
   "instLawfulBEqInstBEq",
   "BEq.beq",
   "Bool.true",
   "instOfNatNat",
   "List.findIdx_cons",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "Mathlib.Data.List.Basic._auxLemma.32",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "instBEq",
   "ite_congr",
   "of_eq_true",
   "DecidableEq",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg"],
  "name": "List.indexOf_cons",
  "constType":
  "∀ {α : Type u} [inst : DecidableEq α] (a b : α) (l : List α),\n  List.indexOf a (b :: l) = if a = b then 0 else Nat.succ (List.indexOf a l)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Decidable",
   "Not",
   "not_not_intro",
   "Decidable.of_not_not"],
  "name": "Decidable.not_not",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬¬p ↔ p",
  "constCategory": "Theorem"},
 {"references": ["And", "Not", "And.intro", "And.casesOn"],
  "name": "and_not_self.match_1",
  "constType":
  "∀ {a : Prop} (motive : a ∧ ¬a → Prop) (x : a ∧ ¬a), (∀ (ha : a) (hn : ¬a), motive (_ : a ∧ ¬a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm", "Classical.not_not", "Iff", "Iff.trans", "Not", "Iff.not"],
  "name": "Iff.not_right",
  "constType": "∀ {a b : Prop}, (¬a ↔ b) → (a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet.proof_1",
   "Preorder",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name":
  "Topology.instIsUpperSetWithUpperSetInstTopologicalSpaceWithUpperSetInstPreorderWithUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpperSet (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "Set.image",
   "Eq.symm",
   "Finite.of_fintype",
   "Finite.Set.finite_image",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.image",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Set α} (f : α → β), Set.Finite s → Set.Finite (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "if_pos.match_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (h : c), motive (isTrue h)) → (∀ (hnc : ¬c), motive (isFalse hnc)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.symm",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "imp_iff_right",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.univ",
   "Set.univ_subset_iff",
   "forall_congr'",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_iff_forall",
  "constType": "∀ {α : Type u} {s : Set α}, s = Set.univ ↔ ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_def",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ s ↔ a ∈ s.val",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "_obj", "_neutral", "EStateM.Result.error"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM.Result", "EStateM.Result.error"],
  "name": "EStateM.Result.rec",
  "constType":
  "{ε σ α : Type u} →\n  {motive : EStateM.Result ε σ α → Sort u_1} →\n    ((a : α) → (a_1 : σ) → motive (EStateM.Result.ok a a_1)) →\n      ((a : ε) → (a_1 : σ) → motive (EStateM.Result.error a a_1)) → (t : EStateM.Result ε σ α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "OfNat.ofNat",
   "Array.mkEmpty",
   "Array.push",
   "instOfNatNat",
   "Nat"],
  "name": "Array.mkArray1",
  "constType": "{α : Type u} → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_8",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Exists.intro",
   "Filter.map_le_iff_le_comap.match_1",
   "LE.le",
   "Set.Subset.rfl",
   "Preorder.toLE",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter",
   "And.intro",
   "instMembershipSetFilter"],
  "name": "Filter.map_le_iff_le_comap",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {g : Filter β} {m : α → β}, Filter.map m f ≤ g ↔ f ≤ Filter.comap m g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Filter.Eventually",
   "implies_congr",
   "Filter.Frequently",
   "Set.instMembershipSet",
   "Eq",
   "and_comm",
   "And",
   "Eq.mpr",
   "Iff",
   "propext",
   "forall_congr",
   "Mathlib.Order.Filter.Basic._auxLemma.87",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "congrFun"],
  "name": "Filter.frequently_iff",
  "constType":
  "∀ {α : Type u} {f : Filter α} {P : α → Prop}, (∃ᶠ (x : α) in f, P x) ↔ ∀ {U : Set α}, U ∈ f → ∃ x ∈ U, P x",
  "constCategory": "Theorem"},
 {"references": ["Nat.le.step", "instLENat", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_step",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "Set.preimage",
   "Continuous",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Set.Iic",
   "IsClosed",
   "Topology.IsLower.continuous_of_Ici",
   "Preorder"],
  "name": "Topology.IsUpper.continuous_of_Iic",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α]\n  [inst_3 : TopologicalSpace β] {f : β → α}, (∀ (a : α), IsClosed (f ⁻¹' Set.Iic a)) → Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[_]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "LinearOrder.toPartialOrder",
   "Preorder.le_trans",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist", "List.Sublist.cons"],
  "name": "List.sublist_cons_of_sublist",
  "constType":
  "∀ {α : Type u} (a : α) {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.Sublist l₁ (a :: l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Or",
   "EmptyCollection.emptyCollection",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.instEmptyCollectionSet",
   "Prod",
   "Set.prod_eq_empty_iff",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.22",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β}, (s ×ˢ t = ∅) = (s = ∅ ∨ t = ∅)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Setoid",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
   "Multiset",
   "CovariantClass",
   "LE.le",
   "Multiset.instAddMultiset",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "∀ {α : Type u_1}, CovariantClass (Multiset α) (Multiset α) (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Topology.WithUpperSet",
   "RelIso.mk",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Topology.WithUpperSet.toUpperSet_le_iff"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → α ≃o Topology.WithUpperSet α",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.Sublist.length_le",
   "Nat.le",
   "List.cons",
   "Std.Data.List.Lemmas._auxLemma.39",
   "List.Sublist",
   "List.length_replicate",
   "List.length",
   "LE.le",
   "Nat.le.rec",
   "Iff.intro",
   "eq_true",
   "Iff",
   "instLENat",
   "of_eq_true",
   "List.replicate",
   "Eq.mp",
   "congr",
   "Nat",
   "congrArg"],
  "name": "List.replicate_sublist_replicate",
  "constType":
  "∀ {α : Type u_1} {m n : ℕ} (a : α), List.Sublist (List.replicate m a) (List.replicate n a) ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "Eq.refl",
   "sup_comm",
   "iSup",
   "SupSet.sSup",
   "sSup_pair",
   "Insert.insert",
   "Eq",
   "CompleteLattice.toLattice",
   "Set.range",
   "Bool.range_eq",
   "Set.instSingletonSet",
   "Eq.mpr",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "CompleteLattice",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "Bool.false",
   "Bool.true",
   "Singleton.singleton",
   "Sup.sup",
   "Bool",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "Set.instInsertSet",
   "id"],
  "name": "iSup_bool_eq",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {f : Bool → α}, ⨆ b, f b = f true ⊔ f false",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadReader"],
  "name": "MonadReader.read",
  "constType":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → [self : MonadReader ρ m] → m ρ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "LE",
   "Inter.inter",
   "And.imp",
   "LE.le",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "IsLowerSet.inter",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s t : Set α}, IsLowerSet s → IsLowerSet t → IsLowerSet (s ∩ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpper", "Topology.upper", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsUpper.mk",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α] [inst : Preorder α], t = Topology.upper α → Topology.IsUpper α",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.49",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Functor",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{α : Type u_1} → [toLattice : Lattice α] → (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) → DistribLattice α",
  "constCategory": "Other"},
 {"references": ["ULift"],
  "name": "ULift.up",
  "constType": "{α : Type s} → α → ULift.{r, s} α",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommSemigroup.add_comm",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Multiset",
   "Multiset.nodup_dedup",
   "Multiset.Nodup",
   "Multiset.dedup"],
  "name": "Multiset.toFinset.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α), Multiset.Nodup (Multiset.dedup s)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "eq_self",
   "Eq.refl",
   "LE.le",
   "instDecidableTrue",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "eq_true",
   "instLENat",
   "of_eq_true",
   "Not",
   "Nat",
   "instMinNat",
   "congrArg",
   "Eq.trans",
   "Nat.decLe",
   "congrFun"],
  "name": "Nat.min_eq_left",
  "constType": "∀ {a b : ℕ}, a ≤ b → min a b = a",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "LE"],
  "name": "Prop.le",
  "constType": "LE Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Mathlib.Order.Lattice._auxLemma.2",
   "and_true",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "SemilatticeSup",
   "And",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Iff.trans",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "le_antisymm_iff",
   "congrFun"],
  "name": "sup_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Filter.HasBasis.prod",
   "nhds_prod_eq",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Set",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Filter.HasBasis",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Prod.mk",
   "SProd.sprod",
   "TopologicalSpace",
   "Prod",
   "Filter",
   "id"],
  "name": "Filter.HasBasis.prod_nhds",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {ιa : Type u_5} {ιb : Type u_6}\n  {pa : ιa → Prop} {pb : ιb → Prop} {sa : ιa → Set α} {sb : ιb → Set β} {a : α} {b : β},\n  Filter.HasBasis (nhds a) pa sa →\n    Filter.HasBasis (nhds b) pb sb → Filter.HasBasis (nhds (a, b)) (fun i ↦ pa i.1 ∧ pb i.2) fun i ↦ sa i.1 ×ˢ sb i.2",
  "constCategory": "Theorem"},
 {"references": ["Pi.Nonempty.proof_1", "Nonempty"],
  "name": "Pi.Nonempty",
  "constType":
  "∀ {ι : Sort u_2} {α : ι → Sort u_3} [inst : ∀ (i : ι), Nonempty (α i)], Nonempty ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLower.instPreorderWithLower",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Preorder",
   "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower.proof_1"],
  "name":
  "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLower (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "HEq",
   "eq_of_heq",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "TopologicalSpace.casesOn",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "HEq.refl",
   "TopologicalSpace",
   "Set.sUnion",
   "Eq.casesOn",
   "Eq.symm",
   "IsOpen",
   "Set.instInterSet"],
  "name": "TopologicalSpace.ext.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x x_1 : TopologicalSpace α) → IsOpen = IsOpen → Prop) (x x_1 : TopologicalSpace α)\n  (x_2 : IsOpen = IsOpen),\n  (∀ (IsOpen : Set α → Prop) (isOpen_univ : IsOpen Set.univ)\n      (isOpen_inter : ∀ (s t : Set α), IsOpen s → IsOpen t → IsOpen (s ∩ t))\n      (isOpen_sUnion : ∀ (s : Set (Set α)), (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)) (isOpen_univ_1 : IsOpen Set.univ)\n      (isOpen_inter_1 : ∀ (s t : Set α), IsOpen s → IsOpen t → IsOpen (s ∩ t))\n      (isOpen_sUnion_1 : ∀ (s : Set (Set α)), (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)),\n      motive\n        { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter, isOpen_sUnion := isOpen_sUnion }\n        { IsOpen := IsOpen, isOpen_univ := isOpen_univ_1, isOpen_inter := isOpen_inter_1,\n          isOpen_sUnion := isOpen_sUnion_1 }\n        (_ : _root_.IsOpen = _root_.IsOpen)) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro", "Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.rec",
  "constType":
  "∀ {α : Type u} {s : Set α} {motive : Set.Finite s → Prop},\n  (∀ (a : Fintype ↑s), motive (_ : Set.Finite s)) → ∀ (t : Set.Finite s), motive t",
  "constCategory": "Other"},
 {"references":
  ["Codisjoint",
   "OrderTop.toTop",
   "Iff",
   "forall_swap",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "forall_congr'",
   "PartialOrder"],
  "name": "Codisjoint_comm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] {a b : α}, Codisjoint a b ↔ Codisjoint b a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsCommutative", "Eq"],
  "name": "Lean.IsCommutative.mk",
  "constType":
  "{α : Sort u} → {op : α → α → α} → (∀ (a b : α), op a b = op b a) → Lean.IsCommutative op",
  "constCategory": "Other"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.rfl"],
  "name": "Filter.instPartialOrderFilter.proof_1",
  "constType": "∀ {α : Type u_1} (a : Filter α), a.sets ⊆ a.sets",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.HasBasis",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mk",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  (∀ (t : Set α), t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t) → Filter.HasBasis l p s",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[>]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Substring",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.Syntax.casesOn",
   "Array",
   "Lean.Syntax.missing",
   "List",
   "String",
   "Unit",
   "Unit.unit",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.atom",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Substring",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.getKind.match_1",
  "constType":
  "(motive : Lean.Syntax → Sort u_1) →\n  (stx : Lean.Syntax) →\n    ((info : Lean.SourceInfo) →\n        (k : Lean.SyntaxNodeKind) → (args : Array Lean.Syntax) → motive (Lean.Syntax.node info k args)) →\n      (Unit → motive Lean.Syntax.missing) →\n        ((info : Lean.SourceInfo) → (v : String) → motive (Lean.Syntax.atom info v)) →\n          ((info : Lean.SourceInfo) →\n              (rawVal : Substring) →\n                (val : Lean.Name) →\n                  (preresolved : List Lean.Syntax.Preresolved) →\n                    motive (Lean.Syntax.ident info rawVal val preresolved)) →\n            motive stx",
  "constCategory": "Definition"},
 {"references": ["Set", "InfSet.sInf", "Set.instInfSetSet"],
  "name": "Set.sInter",
  "constType": "{α : Type u_1} → Set (Set α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "OrderDual",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.giGenerate.proof_2",
  "constType":
  "∀ (α : Type u_1) (x : (Filter α)ᵒᵈ), ∀ x_1 ∈ x, Filter.GenerateSets x.sets x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name._impl",
   "String.hash",
   "Lean.Name.str._impl",
   "String",
   "Lean.Name",
   "mixHash",
   "unsafeCast",
   "Lean.Name.hash"],
  "name": "Lean.Name.str._override",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.comm.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∧ b → Prop) (h : a ∧ b), (∀ (h₁ : a) (h₂ : b), motive (_ : a ∧ b)) → motive h",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Id",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["GaloisCoinsertion.choice",
   "Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "GaloisCoinsertion",
   "GaloisCoinsertion.choice_eq",
   "Function.comp",
   "OrderDual",
   "GaloisInsertion.mk",
   "GaloisCoinsertion.dual.proof_1",
   "FunLike.coe",
   "Preorder",
   "GaloisInsertion",
   "GaloisCoinsertion.u_l_le",
   "Equiv.instFunLikeEquiv"],
  "name": "GaloisCoinsertion.dual",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            GaloisCoinsertion l u →\n              GaloisInsertion (↑OrderDual.toDual ∘ u ∘ ↑OrderDual.ofDual) (↑OrderDual.toDual ∘ l ∘ ↑OrderDual.ofDual)",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableIff.proof_4",
   "instDecidableIff.proof_2",
   "Iff",
   "Decidable.isFalse",
   "instDecidableIff.proof_1",
   "instDecidableIff.proof_3",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite"],
  "name": "instDecidableIff",
  "constType":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Char.val_eq_of_eq.match_1",
  "constType":
  "∀ (motive : (x x_1 : Char) → x = x_1 → Prop) (x x_1 : Char) (x_2 : x = x_1),\n  (∀ (a : Char), motive a a (_ : a = a)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "List.cons",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "rfl",
   "Eq"],
  "name": "List.cons_append",
  "constType":
  "∀ {α : Type u} (a : α) (as bs : List α), a :: as ++ bs = a :: (as ++ bs)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    (Unit → motive Nat.zero Nat.zero) →\n      ((n : ℕ) → motive Nat.zero (Nat.succ n)) →\n        ((n : ℕ) → motive (Nat.succ n) Nat.zero) → ((n m : ℕ) → motive (Nat.succ n) (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace",
   "Filter",
   "wrapped._@.Mathlib.Topology.Basic._hyg.10536"],
  "name": "nhds",
  "constType": "{α : Type u_1} → [inst : TopologicalSpace α] → α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Topology.IsLower",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Topology.IsLower.toContinuousInf.proof_1",
   "CompleteLattice.toCompleteSemilatticeInf",
   "ContinuousInf"],
  "name": "Topology.IsLower.toContinuousInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], ContinuousInf α",
  "constCategory": "Definition"},
 {"references":
  ["inf_inf_sdiff",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "sdiff_inf_sdiff",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SDiff.sdiff",
   "Preorder.toLE",
   "Eq",
   "inf_comm",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "inf_sup_right",
   "sup_inf_sdiff",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "bot_sup_eq",
   "OrderBot.toBot",
   "GeneralizedBooleanAlgebra",
   "instTransEq",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "inf_sdiff_self_right",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : GeneralizedBooleanAlgebra α], x ⊓ y \\ x = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "le_rfl",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "GaloisConnection.l_le"],
  "name": "GaloisConnection.l_u_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ (a : β), l (u a) ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Continuous",
   "TopologicalSpace",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "continuous_iff_coinduced_le",
   "TopologicalSpace.coinduced"],
  "name": "continuous_coinduced_rng",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t : TopologicalSpace α}, Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "Inf.mk",
   "And",
   "Inf",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] (x x_1 : α × β),\n  (x ⊓ x_1).1 ≤ x.1 ∧ (x ⊓ x_1).2 ≤ x.2",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "IsLowerSet",
   "Set",
   "Set.instIsReflSetSubsetInstHasSubsetSet",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Topology.IsUpperSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "LowerSet.lower",
   "Iff.mp",
   "lowerClosure_min",
   "TopologicalSpace",
   "closure_minimal",
   "lowerClosure",
   "id",
   "HasSubset.Subset",
   "subset_antisymm_iff",
   "subset_lowerClosure",
   "Preorder",
   "subset_closure",
   "LowerSet",
   "And",
   "Set.instHasSubsetSet",
   "isClosed_closure",
   "Eq.ndrec",
   "propext",
   "LowerSet.instSetLikeLowerSet",
   "And.intro",
   "IsClosed",
   "Topology.IsUpperSet.isClosed_iff_isLower",
   "SetLike.coe"],
  "name": "Topology.IsUpperSet.closure_eq_lowerClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α] {s : Set α},\n  closure s = ↑(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM",
   "EStateM.bind.match_1",
   "EStateM.Result",
   "EStateM.Result.error"],
  "name": "EStateM.map",
  "constType": "{ε σ α β : Type u} → (α → β) → EStateM ε σ α → EStateM ε σ β",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.symbol",
  "constType": "String → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Inf.inf",
   "Set",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "Set.prod",
   "Iff",
   "SProd.sprod",
   "Filter",
   "And.casesOn",
   "Eq.symm",
   "instMembershipSetFilter",
   "id",
   "Filter.mem_prod_iff.match_1",
   "Set.instSProd",
   "Membership.mem",
   "Prod.snd",
   "Set.preimage",
   "HasSubset.Subset",
   "Prod.fst",
   "Filter.instSProd",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Filter.preimage_mem_comap",
   "Filter.mem_inf_of_inter",
   "Filter.instInfFilter",
   "Filter.comap",
   "Prod",
   "And.intro",
   "Set.instInterSet"],
  "name": "Filter.mem_prod_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set (α × β)} {f : Filter α} {g : Filter β},\n  s ∈ f ×ˢ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ×ˢ t₂ ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["GE.ge", "le_trans", "Preorder", "Preorder.toLE"],
  "name": "ge_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List.pmap",
   "Multiset.pmap.proof_1",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.recOn'",
   "Multiset.ofList",
   "Multiset.instMembershipMultiset",
   "Quot.mk"],
  "name": "Multiset.pmap",
  "constType":
  "{α : Type u_1} → {β : Type v} → {p : α → Prop} → ((a : α) → p a → β) → (s : Multiset α) → (∀ a ∈ s, p a) → Multiset β",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set",
   "TopologicalSpace",
   "closure_minimal",
   "IsClosed",
   "subset_closure",
   "Set.Subset.antisymm",
   "Eq",
   "Set.Subset.refl"],
  "name": "IsClosed.closure_eq",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsClosed s → closure s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "HEq",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "HEq.refl",
   "List",
   "Nat.noConfusion",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.exists_mem_of_length_pos.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → 0 < List.length x → Prop) (x : List α) (x_1 : 0 < List.length x),\n  (∀ (head : α) (tail : List α) (x : 0 < List.length (head :: tail)), motive (head :: tail) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["outParam", "FunLike", "Inf", "Inf.inf", "FunLike.coe", "InfHomClass", "Eq"],
  "name": "InfHomClass.mk",
  "constType":
  "{F : Type u_7} →\n  {α : outParam (Type u_8)} →\n    {β : outParam (Type u_9)} →\n      [inst : Inf α] →\n        [inst_1 : Inf β] →\n          [toFunLike : FunLike F α fun x ↦ β] → (∀ (f : F) (a b : α), ↑f (a ⊓ b) = ↑f a ⊓ ↑f b) → InfHomClass F α β",
  "constCategory": "Other"},
 {"references": ["Sup", "Sup.sup", "Sup.mk"],
  "name": "Pi.instSupForAll",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → Sup (α' i)] → Sup ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references": ["IsIdempotent", "Eq"],
  "name": "IsIdempotent.mk",
  "constType":
  "∀ {α : Type u} {op : α → α → α}, (∀ (a : α), op a a = a) → IsIdempotent α op",
  "constCategory": "Other"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{α : Type u_1} → {ι : Sort u_4} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["And", "OfNat.ofNat", "Or", "LT.lt", "instOfNatNat", "Nat", "instLTNat"],
  "name": "Nat.isValidChar",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.refl",
   "_obj",
   "_neutral",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsUpper.WithUpperHomeomorph._spec_1"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._rarg._cstage2",
  "constType": "_obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Bool.true",
   "Eq.refl",
   "Not",
   "Eq.casesOn",
   "And.intro",
   "Bool",
   "Eq.symm",
   "And.casesOn",
   "Eq"],
  "name": "List.mem_filter.match_2",
  "constType":
  "∀ {α : Type u_1} {x : α} {p : α → Bool} (motive : (a : α) → x = a ∧ p x = true → ¬p a = true → Prop) (a : α)\n  (x_1 : x = a ∧ p x = true) (h : ¬p a = true),\n  (∀ (h' : p x = true) (h : ¬p x = true), motive x (_ : x = x ∧ p x = true) h) → motive a x_1 h",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "Set.instMembershipSet"],
  "name": "Filter.instPureFilter.proof_1",
  "constType":
  "∀ {α : Type u_1} (x : α) {x_1 y : Set α}, x_1 ∈ {s | x ∈ s} → y ∈ {s | x ∈ s} → x_1 ∈ {s | x ∈ s} ∧ y ∈ {s | x ∈ s}",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "HImp"],
  "name": "CompleteAtomicBooleanAlgebra.toHImp",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_cons",
   "Or",
   "propext",
   "Multiset",
   "Multiset.cons",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {a b : α} {s : Multiset α}, (a ∈ b ::ₘ s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Nat.zero_lt_succ",
   "LE.le",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Nat.commSemiring",
   "instLENat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat.le_of_lt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.linearOrderedCommSemiring.proof_6",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] (a b c : (i : ι) → α i),\n  a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "List.cons",
   "Iff",
   "List",
   "List.Mem.head",
   "List.tfae_cons_of_mem",
   "List.TFAE"],
  "name": "List.tfae_cons_cons",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.TFAE (a :: b :: l) ↔ (a ↔ b) ∧ List.TFAE (b :: l)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Eq",
   "Nat.zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.add_sub_add_right",
   "Eq.mp",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "Nat.add_sub_cancel",
  "constType": "∀ (n m : ℕ), n + m - m = n",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "GE.ge",
   "Not",
   "Nat.lt_or_ge",
   "Or.resolve_right",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_of_not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd",
   "IsRightCancelAdd",
   "AddCommSemigroup.toAddSemigroup",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M], IsRightCancelAdd M",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references": ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ"],
  "name": "Nat.le.rec",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop},\n  motive n (_ : Nat.le n n) →\n    (∀ {m : ℕ} (a : Nat.le n m), motive m a → motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) →\n      ∀ {a : ℕ} (t : Nat.le n a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "Decidable.casesOn",
   "Eq.ndrec",
   "Decidable.isFalse",
   "not",
   "instDecidableNot",
   "Decidable",
   "Eq.refl",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "decide_not",
  "constType": "∀ {p : Prop} [h : Decidable p], (decide ¬p) = !decide p",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.closure_of._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "EmbeddingLike.toFunLike",
   "true_and",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set.toFinset",
   "Set",
   "Eq.refl",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset",
   "Function.Embedding",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "Membership.mem",
   "funext",
   "Std.Logic._auxLemma.39",
   "Finset.instMembershipFinset",
   "Function.Embedding.subtype",
   "FunLike.coe",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.map",
   "Mathlib.Data.Finset.Image._auxLemma.2",
   "Finset.univ",
   "And",
   "Function.instEmbeddingLikeEmbedding",
   "of_eq_true",
   "congrArg",
   "Subtype.mk",
   "congrFun",
   "exists_prop_congr'"],
  "name": "Set.mem_toFinset",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, a ∈ Set.toFinset s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
   "instOfNatNat",
   "Nat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3833",
   "autoParam",
   "AddSemigroup",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddMonoid M",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Eq.refl",
   "sup_assoc",
   "Sup.sup",
   "sup_left_comm",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "sup_sup_sup_comm",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] (a b c d : α), a ⊔ b ⊔ (c ⊔ d) = a ⊔ c ⊔ (b ⊔ d)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.sort.loop.match_1",
  "constType":
  "(motive : List ℕ → List ℕ → Sort u_1) →\n  (x x_1 : List ℕ) →\n    ((acc : List ℕ) → motive acc []) → ((acc : List ℕ) → (x : ℕ) → (xs : List ℕ) → motive acc (x :: xs)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.removeNeutrals.match_1",
  "constType":
  "(motive : List ℕ → Sort u_1) → (x : List ℕ) → (Unit → motive []) → ((ys : List ℕ) → motive ys) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Filter", "instMembershipSetFilter"],
  "name": "Filter.Eventually",
  "constType": "{α : Type u} → (α → Prop) → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "TopologicalSpace.rec",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "TopologicalSpace.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : TopologicalSpace α → Sort u_1} →\n    (t : TopologicalSpace α) →\n      ((IsOpen : Set α → Prop) →\n          (isOpen_univ : IsOpen Set.univ) →\n            (isOpen_inter : ∀ (s t : Set α), IsOpen s → IsOpen t → IsOpen (s ∩ t)) →\n              (isOpen_sUnion : ∀ (s : Set (Set α)), (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)) →\n                motive\n                  { IsOpen := IsOpen, isOpen_univ := isOpen_univ, isOpen_inter := isOpen_inter,\n                    isOpen_sUnion := isOpen_sUnion }) →\n        motive t",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "List.reverseAux.match_1"],
  "name": "List.append",
  "constType": "{α : Type u} → List α → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "propext",
   "Set.Subset.antisymm_iff",
   "Set",
   "HasSubset.Subset",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.15",
  "constType": "∀ {α : Type u} {a b : Set α}, (a = b) = (a ⊆ b ∧ b ⊆ a)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "List.instMembershipList", "List", "id"],
  "name": "List.attach.proof_1",
  "constType": "∀ {α : Type u_1} (l : List α), ∀ x ∈ l, x ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.le.dest.match_2",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ≤ x_1 → Prop) (x x_1 : ℕ) (x_2 : x ≤ x_1),\n  (∀ (x : Nat.zero ≤ Nat.zero), motive Nat.zero Nat.zero x) →\n    (∀ (n : ℕ) (x : Nat.zero ≤ Nat.succ n), motive Nat.zero (Nat.succ n) x) →\n      (∀ (n : ℕ) (h : Nat.succ n ≤ Nat.zero), motive (Nat.succ n) Nat.zero h) →\n        (∀ (n m : ℕ) (h : Nat.succ n ≤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["MonadLiftT.mk", "MonadLiftT"],
  "name": "instMonadLiftT_1",
  "constType": "(m : Type u_1 → Type u_2) → MonadLiftT m m",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "or_and_right", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.46",
  "constType": "∀ {a b c : Prop}, ((a ∨ b) ∧ c) = (a ∧ c ∨ b ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["Bool", "Lean.Data.AC.ContextInformation", "Nat"],
  "name": "Lean.Data.AC.ContextInformation.isNeutral",
  "constType":
  "{α : Sort u} → [self : Lean.Data.AC.ContextInformation α] → α → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Unit",
   "String",
   "instBEqNat",
   "Lean.Name.beq.match_1",
   "instBEq",
   "PProd",
   "BEq.beq",
   "PProd.fst",
   "Lean.Name.rec",
   "Bool.false",
   "and",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Lean.Name",
   "Lean.Name.anonymous",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "Lean.Name.beq",
  "constType": "Lean.Name → Lean.Name → Bool",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsLower.topology_eq_lowerTopology",
   "Topology.IsLower",
   "Topology.IsUpper",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsUpper.mk",
   "Preorder"],
  "name": "OrderDual.instIsUpper.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], Topology.IsUpper αᵒᵈ",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "inf_sdiff_self_right",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "SDiff.sdiff",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "inf_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "GeneralizedBooleanAlgebra.toBot",
   "id"],
  "name": "inf_sdiff_self_left",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : GeneralizedBooleanAlgebra α], y \\ x ⊓ x = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.Nodup",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "imp_not_comm",
   "Not",
   "List.Nodup.not_mem"],
  "name": "List.not_nodup_cons_of_mem",
  "constType":
  "∀ {α : Type u} {l : List α} {a : α}, a ∈ l → ¬List.Nodup (a :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "∀ {α : Type u_1} (a : Set α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.generateFrom",
   "setOf",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace.ext",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.GenerateOpen",
   "Eq.symm",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure_sets",
  "constType":
  "∀ {α : Type u} {s : Set (Set α)} {hs : {u | TopologicalSpace.GenerateOpen s u} = s},\n  TopologicalSpace.mkOfClosure s hs = TopologicalSpace.generateFrom s",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Classical.propDecidable", "Not", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.instMembershipSet"],
  "name": "Set.mem_preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set β} {a : α}, a ∈ f ⁻¹' s ↔ f a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM",
  "constType": "Type u → Type u → Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "GaloisInsertion.liftSemilatticeSup",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "GaloisInsertion",
   "PartialOrder",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "SemilatticeSup.le_sup_right",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.inf_le_right",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "GaloisInsertion.liftSemilatticeInf",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "GaloisInsertion.liftLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} → {u : β → α} → [inst : PartialOrder β] → [inst_1 : Lattice α] → GaloisInsertion l u → Lattice β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLower.instPreorderWithLower",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.mk",
   "rfl"],
  "name":
  "Topology.instIsLowerWithLowerInstTopologicalSpaceWithLowerInstPreorderWithLower.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLower (Topology.WithLower α)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Function.comp", "Or.elim"],
  "name": "Or.imp",
  "constType": "∀ {a c b d : Prop}, (a → c) → (b → d) → a ∨ b → c ∨ d",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.39",
   "Or",
   "Set",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "True",
   "iff_self",
   "Mathlib.Data.Finset.Basic._auxLemma.4",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.32",
   "Iff",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Finset.cons",
   "Not",
   "congrArg",
   "Eq.trans",
   "Set.instInsertSet"],
  "name": "Finset.coe_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Finset α} {h : ¬a ∈ s}, ↑(Finset.cons a s h) = insert a ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.id",
   "Topology.WithLowerSet",
   "Topology.WithLowerSet.map",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "ContinuousMap.id",
   "Eq"],
  "name": "Topology.WithLowerSet.map_id",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.WithLowerSet.map OrderHom.id = ContinuousMap.id (Topology.WithLowerSet α)",
  "constCategory": "Theorem"},
 {"references": ["Set", "LE", "IsUpperSet", "UpperSet"],
  "name": "UpperSet.mk",
  "constType":
  "{α : Type u_6} → [inst : LE α] → (carrier : Set α) → IsUpperSet carrier → UpperSet α",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Name.mkStr1",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "ReaderT.instMonadReaderT",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.concat.match_1",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil"],
  "name": "List.concat",
  "constType": "{α : Type u} → List α → α → List α",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Bot",
   "HImp.himp",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "HeytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toGeneralizedHeytingAlgebra : GeneralizedHeytingAlgebra α] →\n    [toBot : Bot α] → [toHasCompl : HasCompl α] → (∀ (a : α), ⊥ ≤ a) → (∀ (a : α), a ⇨ ⊥ = aᶜ) → HeytingAlgebra α",
  "constCategory": "Other"},
 {"references": ["Pure"],
  "name": "Pure.mk",
  "constType": "{f : Type u → Type v} → ({α : Type u} → α → f α) → Pure f",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.num",
   "String",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.casesOn",
   "Lean.Name.str"],
  "name": "Lean.Name.appendCore.match_1",
  "constType":
  "(motive : Lean.Name → Lean.Name → Sort u_1) →\n  (x x_1 : Lean.Name) →\n    ((n : Lean.Name) → motive n Lean.Name.anonymous) →\n      ((n p : Lean.Name) → (s : String) → motive n (Lean.Name.str p s)) →\n        ((n p : Lean.Name) → (d : ℕ) → motive n (Lean.Name.num p d)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "Inf.inf",
   "DistribLattice.mk",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SDiff.mk",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "BooleanAlgebra.toSDiff",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "sdiff_eq"],
  "name": "Pi.booleanAlgebra.proof_6",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → BooleanAlgebra (α i)] (x x_1 : (i : ι) → α i), x \\ x_1 = x ⊓ x_1ᶜ",
  "constCategory": "Theorem"},
 {"references": ["Subtype.val", "Subtype.ext", "Subtype", "Eq"],
  "name": "Function.Embedding.subtype.proof_1",
  "constType":
  "∀ {α : Sort u_1} (p : α → Prop) (x x_1 : Subtype p), ↑x = ↑x_1 → x = x_1",
  "constCategory": "Theorem"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.32",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "OrderDual.instPreorder",
   "Set",
   "OrderDual",
   "Singleton.singleton",
   "isGreatest_singleton",
   "IsLeast",
   "Preorder"],
  "name": "isLeast_singleton",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, IsLeast {a} a",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "GetElem",
  "constType":
  "(cont : Type u) → (idx : Type v) → outParam (Type w) → outParam (cont → idx → Prop) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.preimage", "Set", "Inter.inter", "rfl", "Eq", "Set.instInterSet"],
  "name": "Set.preimage_inter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s t : Set β}, f ⁻¹' (s ∩ t) = f ⁻¹' s ∩ f ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["Set.preimage",
   "Set",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "IsOpen.preimage",
   "IsOpen",
   "Iff.mpr",
   "continuous_def"],
  "name": "Continuous.comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β}, Continuous g → Continuous f → Continuous (g ∘ f)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "isGreatest_univ_iff",
   "IsGreatest",
   "Preorder",
   "IsTop",
   "Set.univ",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.13",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a : α}, IsGreatest Set.univ a = IsTop a",
  "constCategory": "Theorem"},
 {"references":
  ["LE.le.antisymm",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "bot_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "bot_unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≤ ⊥ → a = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.mk",
  "constType": "{ks : Lean.SyntaxNodeKinds} → Lean.Syntax → Lean.TSyntax ks",
  "constCategory": "Other"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Lattice.toInf",
   "HImp.himp",
   "Eq.mpr",
   "Iff",
   "himp_bot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "le_himp_iff",
   "propext",
   "disjoint_iff_inf_le",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot"],
  "name": "Disjoint.le_compl_right",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, Disjoint a b → a ≤ bᶜ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAppend"],
  "name": "HAppend.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAppend α β γ",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "Top.top",
   "OrderTop.le_top",
   "OrderTop",
   "inferInstanceAs",
   "Prod.instLEProd",
   "LE",
   "Prod",
   "BoundedOrder.toOrderTop",
   "Prod.orderTop",
   "LE.le",
   "BoundedOrder"],
  "name": "Prod.boundedOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : LE α] [inst_1 : LE β] [inst_2 : BoundedOrder α] [inst_3 : BoundedOrder β]\n  (a : α × β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.upper", "Topology.IsUpper", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsUpper.topology_eq_upperTopology",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α] [inst : Preorder α] [self : Topology.IsUpper α], t = Topology.upper α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Or",
   "False",
   "Multiset.instZeroMultiset",
   "Mathlib.Data.Multiset.Basic._auxLemma.6",
   "Multiset.instSingletonMultiset",
   "Multiset.instMembershipMultiset",
   "True",
   "iff_self",
   "Eq",
   "Mathlib.Data.Multiset.Basic._auxLemma.7",
   "Zero.toOfNat0",
   "Mathlib.Data.Multiset.Basic._auxLemma.13",
   "Iff",
   "of_eq_true",
   "Multiset",
   "Multiset.cons",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Multiset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_3",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.rec", "List", "List.nil"],
  "name": "List.recOn",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    (t : List α) → motive [] → ((head : α) → (tail : List α) → motive tail → motive (head :: tail)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "or_iff_left_iff_imp",
   "or_comm",
   "Eq",
   "id"],
  "name": "or_iff_right_iff_imp",
  "constType": "∀ {a b : Prop}, (a ∨ b ↔ b) ↔ a → b",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.mk"],
  "name": "Trunc.mk",
  "constType": "{α : Sort u_1} → α → Trunc α",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "Function.Embedding.mk",
   "Function.Embedding.rec",
   "Function.Embedding"],
  "name": "Function.Embedding.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : (α ↪ β) → Sort u} →\n      (t : α ↪ β) →\n        ((toFun : α → β) → (inj' : Function.Injective toFun) → motive { toFun := toFun, inj' := inj' }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_sets",
   "Filter.sets",
   "Membership.mem",
   "propext",
   "Set",
   "Filter",
   "Eq",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.2",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (s ∈ f.sets) = (s ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "Function.Embedding.inj'",
   "EmbeddingLike.toFunLike",
   "Multiset.mem_map_of_injective",
   "Function.instEmbeddingLikeEmbedding",
   "Iff",
   "Function.Embedding.toFun",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Finset.mem_map'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α ↪ β) {a : α} {s : Finset α}, ↑f a ∈ Finset.map f s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Set.image2",
   "Iff",
   "Eq.rec",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.forall_image2_iff.match_1",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.forall_image2_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {p : γ → Prop},\n  (∀ z ∈ Set.image2 f s t, p z) ↔ ∀ x ∈ s, ∀ y ∈ t, p (f x y)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "List.filter",
   "DecidableEq",
   "List",
   "List.replicate",
   "instBEq",
   "List.count",
   "Eq",
   "List.filter_beq'"],
  "name": "List.filter_eq'",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α) (a : α),\n  List.filter (fun x ↦ decide (x = a)) l = List.replicate (List.count a l) a",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "And.left"],
  "name": "Fintype.ofBijective.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Bijective f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "List.instAppendList",
   "List.Perm",
   "HAppend.hAppend",
   "List",
   "List.Perm.append_right",
   "List.Perm.trans",
   "List.Perm.append_left"],
  "name": "List.Perm.append",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ t₁ t₂ : List α}, l₁ ~ l₂ → t₁ ~ t₂ → l₁ ++ t₁ ~ l₂ ++ t₂",
  "constCategory": "Theorem"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Iic",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Iff", "Exists.intro", "Exists.casesOn", "Iff.mpr"],
  "name": "exists_prop_congr.match_1",
  "constType":
  "∀ {p p' : Prop} {q' : p → Prop} (hp : p ↔ p') (motive : (∃ (h : p'), q' (_ : p)) → Prop) (x : ∃ (h : p'), q' (_ : p)),\n  (∀ (w : p') (h : q' (_ : p)), motive (_ : ∃ (h : p'), q' (_ : p))) → motive x",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.rec"],
  "name": "Prop.distribLattice.proof_1",
  "constType": "∀ (x x_1 x_2 : Prop), (x → x_2) → (x_1 → x_2) → x ∨ x_1 → x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "ZeroHom.rec",
   "ZeroHom",
   "Eq"],
  "name": "ZeroHom.casesOn",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : Zero M] →\n      [inst_1 : Zero N] →\n        {motive : ZeroHom M N → Sort u} →\n          (t : ZeroHom M N) →\n            ((toFun : M → N) → (map_zero' : toFun 0 = 0) → motive { toFun := toFun, map_zero' := map_zero' }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.instPreorderProd",
   "Preorder.le_refl",
   "inferInstanceAs",
   "Prod",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (a : α × β), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "List.filterMap.match_1",
  "constType":
  "{β : Type u_1} →\n  (motive : Option β → Sort u_2) → (x : Option β) → (Unit → motive none) → ((b : β) → motive (some b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "CompleteAtomicBooleanAlgebra",
   "Inf.inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.le_sup_inf",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "propext",
   "Filter.map",
   "Set",
   "Filter",
   "Eq",
   "Filter.mem_map'",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.61",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, (t ∈ Filter.map m f) = ({x | m x ∈ t} ∈ f)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsClosed_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "CompleteLattice.sInf_le",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "OrderDual.completeLattice.proof_4",
   "CompleteLattice.sSup_le",
   "OrderDual.completeLattice.proof_1",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "OrderDual.completeLattice.proof_2",
   "OrderDual.infSet",
   "InfSet",
   "OrderDual.completeLattice.proof_5",
   "SupSet.sSup",
   "OrderDual.instLEOrderDual",
   "OrderDual.supSet",
   "OrderDual.boundedOrder",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice.proof_3",
   "OrderBot.toBot",
   "OrderDual",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderDual.lattice"],
  "name": "OrderDual.completeLattice",
  "constType":
  "(α : Type u_1) → [inst : CompleteLattice α] → CompleteLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Multiset.mem_cons",
   "Iff",
   "Finset",
   "Finset.cons",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Finset.mem_cons",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : ¬a ∈ s}, b ∈ Finset.cons a s h ↔ b = a ∨ b ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "congr_arg",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Fintype.subtype.match_1",
   "rfl",
   "Multiset.instMembershipMultiset",
   "Iff.mpr",
   "Eq",
   "Finset.nodup",
   "Iff",
   "Iff.mp",
   "Finset",
   "Multiset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.mk",
   "Multiset.mem_pmap",
   "Subtype",
   "Subtype.mk"],
  "name": "Fintype.subtype.proof_3",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ p x) (x : { x // p x }),\n  x ∈\n    { val := Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x),\n      nodup := (_ : Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x))) }",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.cons",
   "False",
   "Eq.refl",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableEqNat",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_head2",
  "constType":
  "∀ {x y : ℕ} {ys : List ℕ}, x ≠ y → Lean.Data.AC.mergeIdem (x :: y :: ys) = x :: Lean.Data.AC.mergeIdem (y :: ys)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Or",
   "Bot.bot",
   "Mathlib.Order.Filter.Prod._auxLemma.31",
   "Mathlib.Order.Filter.Prod._auxLemma.30",
   "CompleteLattice.toBot",
   "Filter.instSProd",
   "Filter.NeBot",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Mathlib.Order.Filter.Prod._auxLemma.32",
   "Iff",
   "of_eq_true",
   "SProd.sprod",
   "congr",
   "Filter",
   "Prod",
   "Not",
   "congrArg",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.prod_neBot",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : Filter α} {g : Filter β}, Filter.NeBot (f ×ˢ g) ↔ Filter.NeBot f ∧ Filter.NeBot g",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "instMinNat",
   "Nat.min_eq_left",
   "Eq"],
  "name": "Nat.zero_min",
  "constType": "∀ (a : ℕ), min 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet", "Inhabited"],
  "name": "Topology.WithLowerSet.instInhabitedWithLowerSet._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Or",
   "Or.inl",
   "Or.inr",
   "Exists.intro",
   "Or.casesOn",
   "Exists.casesOn"],
  "name": "exists_or.match_1",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} (motive : (∃ x, p x ∨ q x) → Prop) (x : ∃ x, p x ∨ q x),\n  (∀ (x : α) (h : p x), motive (_ : ∃ x, p x ∨ q x)) → (∀ (x : α) (h : q x), motive (_ : ∃ x, p x ∨ q x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "SemilatticeSup.mk",
   "And.intro",
   "Prop.partialOrder",
   "Sup.mk",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Or.rec"],
  "name": "Prop.distribLattice.proof_2",
  "constType": "∀ (x x_1 x_2 : Prop), x ≤ x_1 → x ≤ x_2 → x → x_1 ∧ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "Prod.lattice",
   "InfSet.sInf",
   "le_sInf",
   "Prod.fst",
   "Lattice.mk",
   "Lattice.le_inf",
   "And.left",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "InfSet.mk",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "And",
   "And.right",
   "Prod.infSet",
   "CompleteLattice",
   "Set.ball_image_of_ball",
   "CompleteLattice.toInfSet",
   "Prod",
   "And.intro",
   "Set.image",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.completeLattice.proof_7",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (x : Set (α × β)) (x_1 : α × β),\n  (∀ b ∈ x, x_1 ≤ b) → x_1.1 ≤ (sInf x).1 ∧ x_1.2 ≤ (sInf x).2",
  "constCategory": "Theorem"},
 {"references":
  ["Inhabited", "Lean.Name.anonymous", "Lean.Name", "Inhabited.mk"],
  "name": "Lean.instInhabitedName",
  "constType": "Inhabited Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "Lean.Data.AC.removeNeutrals.loop.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (Unit → motive true) → (Unit → motive false) → motive x",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadLift",
  "constType":
  "semiOutParam (Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "And",
   "Set.iUnion",
   "Set",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iUnion.match_1",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_2} {x : α} {s : ι → Set α} (motive : x ∈ ⋃ i, s i → Prop) (x_1 : x ∈ ⋃ i, s i),\n  (∀ (w : Set α) (a : ι) (t_eq : s a = w) (h : x ∈ w), motive (_ : ∃ t ∈ Set.range fun i ↦ s i, x ∈ t)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "optParam",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "List",
   "List.range'.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.range'",
  "constType": "ℕ → ℕ → optParam ℕ 1 → List ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat", "String.Pos"],
  "name": "String.Pos.mk",
  "constType": "ℕ → String.Pos",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "List",
   "List.pmap.proof_1",
   "PUnit",
   "List.pmap.proof_2",
   "List.nil",
   "List.pmap.match_1"],
  "name": "List.pmap",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (l : List α) → (∀ a ∈ l, p a) → List β",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_5",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Bot.bot",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toBot",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_12",
  "constType": "∀ {α : Type u_1} (x : (Filter α)ᵒᵈᵒᵈ), ⊥ ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.246",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Subtype.mk", "Subtype"],
  "name": "Subtype.rec",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      ((val : α) → (property : p val) → motive { val := val, property := property }) → (t : Subtype p) → motive t",
  "constCategory": "Other"},
 {"references": ["SDiff.mk", "SDiff.sdiff", "SDiff"],
  "name": "Pi.sdiff",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → SDiff (α i)] → SDiff ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "Prod.lattice",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.mk",
   "SupSet.sSup",
   "Prod.fst",
   "Lattice.mk",
   "Lattice.le_inf",
   "And.left",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "And",
   "And.right",
   "CompleteLattice",
   "Set.ball_image_of_ball",
   "Prod.supSet",
   "CompleteSemilatticeSup.toPartialOrder",
   "Prod",
   "And.intro",
   "Set.image",
   "sSup_le",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.completeLattice.proof_5",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (x : Set (α × β)) (x_1 : α × β),\n  (∀ b ∈ x, b ≤ x_1) → (sSup x).1 ≤ x_1.1 ∧ (sSup x).2 ≤ x_1.2",
  "constCategory": "Theorem"},
 {"references": ["Option.none", "Option.some", "Option.casesOn", "Option"],
  "name":
  "_private.Std.Data.List.Lemmas.0.List.filterMap_cons.match_1.splitter",
  "constType":
  "{β : Type u_1} → (motive : Option β → Sort u_2) → (x : Option β) → motive none → ((b : β) → motive (some b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["False", "Iff.mp", "Iff", "Not"],
  "name": "instDecidableIff.proof_2",
  "constType": "∀ {p q : Prop}, p → ¬q → (p ↔ q) → False",
  "constCategory": "Theorem"},
 {"references":
  ["not_or_intro",
   "eq_self",
   "Min.min",
   "Or",
   "False",
   "Eq.refl",
   "Classical.em",
   "Or.casesOn",
   "LE.le",
   "Nat.le_total",
   "Eq",
   "ite",
   "Eq.mpr",
   "if_pos",
   "instLENat",
   "of_eq_true",
   "False.casesOn",
   "Not",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "congrArg",
   "if_neg",
   "Nat.decLe",
   "id",
   "congrFun"],
  "name": "Nat.min_comm",
  "constType": "∀ (a b : ℕ), min a b = min b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.principal",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Iff",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Mathlib.Order.Filter.Basic._auxLemma.36",
   "Eq.trans",
   "instMembershipSetFilter",
   "id"],
  "name": "Filter.principal_eq_iff_eq",
  "constType":
  "∀ {α : Type u} {s t : Set α}, Filter.principal s = Filter.principal t ↔ s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.Continuous_of._closed_5",
   "Topology.Continuous_of._closed_7"],
  "name": "Topology.Continuous_of._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq.symm", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.23",
  "constType": "∀ {b a : Prop}, (a ∧ b) = ∃ (_ : a), b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.filter",
   "List",
   "Unit",
   "Eq.refl",
   "List.erase.match_1",
   "Bool",
   "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.filter._eq_2",
  "constType":
  "∀ {α : Type u} (p : α → Bool) (head : α) (tail : List α),\n  List.filter p (head :: tail) =\n    match p head with\n    | true => head :: List.filter p tail\n    | false => List.filter p tail",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Filter.join.match_1",
   "Filter.inter_mem",
   "Set",
   "Filter.mem_of_superset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_3",
  "constType":
  "∀ {α : Type u_1} (f : Filter (Filter α)) {x y : Set α},\n  x ∈ {s | {t | s ∈ t} ∈ f} → y ∈ {s | {t | s ∈ t} ∈ f} → {t | x ∩ y ∈ t} ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["False", "Classical.propDecidable", "Not", "Decidable.by_contradiction"],
  "name": "by_contradiction",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pred",
   "PUnit",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.sub",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.noConfusion", "Nat", "Nat.succ", "Eq"],
  "name": "Nat.succ.inj",
  "constType": "∀ {n n_1 : ℕ}, Nat.succ n = Nat.succ n_1 → n = n_1",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.le_trans",
   "Nat",
   "LE.le",
   "instLTNat",
   "Nat.succ"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithUpperSet.ofUpperSet",
   "Topology.IsUpperSet",
   "Equiv.toHomeomorphOfInducing",
   "Topology.WithUpperSet",
   "Homeomorph",
   "TopologicalSpace",
   "Topology.IsUpperSet.WithUpperSetHomeomorph.proof_1",
   "Preorder",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsUpperSet α] → Topology.WithUpperSet α ≃ₜ α",
  "constCategory": "Definition"},
 {"references":
  ["List.pairwise_iff_forall_sublist.match_1",
   "List.singleton_sublist",
   "List.instMembershipList",
   "List.Sublist",
   "List.Sublist.cons",
   "Std.Data.List.Lemmas._auxLemma.3",
   "Eq.refl",
   "And.left",
   "implies_congr",
   "Iff.mpr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "List.Sublist.subset",
   "List.rec",
   "forall_congr",
   "eq_false'",
   "List.nil",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "Std.Data.List.Lemmas._auxLemma.37",
   "List.cons",
   "False",
   "List.cons_sublist_cons",
   "implies_true",
   "List.Pairwise",
   "Iff.intro",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "propext",
   "List.pairwise_cons",
   "congr",
   "And.intro",
   "List.noConfusion",
   "congrArg"],
  "name": "List.pairwise_iff_forall_sublist",
  "constType":
  "∀ {α : Type u_1} {l : List α} {R : α → α → Prop}, List.Pairwise R l ↔ ∀ {a b : α}, List.Sublist [a, b] l → R a b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.mem_prod",
   "Prod",
   "Prod.fst",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Constructions._auxLemma.26",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {p : α × β}, (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Inter.inter",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "top_inf_eq",
   "Set.instBooleanAlgebraSet",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instInterSet"],
  "name": "Set.univ_inter",
  "constType": "∀ {α : Type u} (a : Set α), Set.univ ∩ a = a",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{α : Type u_4} → (val : Multiset α) → Multiset.Nodup val → Finset α",
  "constCategory": "Other"},
 {"references":
  ["List.tfae_singleton",
   "List.cons",
   "eq_true",
   "List.nil",
   "True",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.1",
  "constType": "∀ (p : Prop), List.TFAE [p] = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "List.cons",
   "OfNat.ofNat",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "Nat.add",
   "instLENat",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get?_len_le.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → (x_1 : ℕ) → List.length x ≤ x_1 → Prop) (x : List α) (x_1 : ℕ)\n  (x_2 : List.length x ≤ x_1),\n  (∀ (x : ℕ) (x_3 : List.length [] ≤ x), motive [] x x_3) →\n    (∀ (head : α) (l : List α) (n : ℕ) (h : List.length (head :: l) ≤ n + 1), motive (head :: l) (Nat.succ n) h) →\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.inter_mem",
   "Set",
   "Inter.inter",
   "Filter",
   "nhdsAdjoint.match_1",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (f : Filter α) (_s _t : Set α),\n  (a ∈ _s → _s ∈ f) → (a ∈ _t → _t ∈ f) → a ∈ _s ∩ _t → _s ∩ _t ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Equiv.toFun",
   "OrderDual.toDual",
   "continuous_coinduced_rng",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α],\n  Continuous\n    { toFun := ↑OrderDual.toDual, invFun := ↑OrderDual.ofDual,\n        left_inv := (_ : ∀ (a : αᵒᵈ), ↑OrderDual.toDual (↑OrderDual.ofDual a) = a),\n        right_inv := (_ : ∀ (a : Topology.WithUpper αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a) }.toFun",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "List.insert",
   "List.instUnionList",
   "False",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Union.union",
   "True",
   "Eq",
   "iff_self",
   "List.nil_union",
   "List.cons_union",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Iff",
   "DecidableEq",
   "List.rec",
   "of_eq_true",
   "propext",
   "List",
   "Std.Data.List.Lemmas._auxLemma.53",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "false_or",
   "Std.Data.List.Lemmas._auxLemma.10",
   "congrFun"],
  "name": "List.mem_union_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {x : α} {l₁ l₂ : List α}, x ∈ l₁ ∪ l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr2",
  "constType": "String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Monad",
   "EStateM",
   "Function.comp",
   "Unit",
   "Function.const",
   "Functor.mk",
   "Monad.mk",
   "Applicative.mk",
   "EStateM.seqRight",
   "EStateM.bind",
   "EStateM.pure",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "SeqRight.mk",
   "EStateM.map",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "EStateM.instMonadEStateM",
  "constType": "{ε σ : Type u} → Monad (EStateM ε σ)",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty"],
  "name": "Nonempty.rec",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop}, (∀ (val : α), motive (_ : Nonempty α)) → ∀ (t : Nonempty α), motive t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "True",
   "ite",
   "Eq",
   "Bool.of_not_eq_true",
   "Bool.true",
   "instOfNatNat",
   "List.countP",
   "Nat",
   "not_false_eq_true",
   "List.countP_cons_of_pos",
   "Eq.trans",
   "instDecidableEqBool",
   "eq_self",
   "List.cons",
   "False",
   "instAddNat",
   "instHAdd",
   "List.countP_cons_of_neg",
   "eq_false_of_decide",
   "instDecidableTrue",
   "ite_congr",
   "instDecidableFalse",
   "of_eq_true",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.countP_cons",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (a : α) (l : List α),\n  List.countP p (a :: l) = List.countP p l + if p a = true then 1 else 0",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«termI^_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_4",
   "_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[<]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLowerSet.noConfusionType",
   "Eq.ndrec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.casesOn",
   "Eq"],
  "name": "Topology.IsLowerSet.noConfusion",
  "constType":
  "{α : Type u_4} →\n  {t : TopologicalSpace α} →\n    {inst : Preorder α} →\n      {P : Sort u} → {v1 v2 : Topology.IsLowerSet α} → v1 = v2 → Topology.IsLowerSet.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["propext", "forall_comm", "Eq"],
  "name": "Std.Logic._auxLemma.54",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {p : α → β → Prop}, (∀ (a : α) (b : β), p a b) = ∀ (b : β) (a : α), p a b",
  "constCategory": "Theorem"},
 {"references": ["IsRefl"],
  "name": "IsRefl.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a : α), r a a) → IsRefl α r",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.toLattice",
   "CompletelyDistribLattice.toCompleteLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "CompleteAtomicBooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq"],
  "name": "CompleteAtomicBooleanAlgebra.himp_eq",
  "constType":
  "∀ {α : Type u} [self : CompleteAtomicBooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.toLower_ofLower",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithLower α), ↑Topology.WithLower.toLower (↑Topology.WithLower.ofLower a) = a",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "interior_subset",
   "Set",
   "TopologicalSpace",
   "HasSubset.Subset.antisymm",
   "interior_maximal",
   "interior",
   "IsOpen",
   "Eq",
   "Set.Subset.refl"],
  "name": "IsOpen.interior_eq",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen s → interior s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.ofDual",
   "OrderDual.toDual",
   "Topology.WithUpper",
   "OrderDual",
   "OrderDual.ofDual_toDual",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithLower.toDualHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : Topology.WithUpper αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "IsClosed",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α} (x : Set α) (motive : x ∈ {t | IsClosed t ∧ s ⊆ t} → Prop)\n  (x_1 : x ∈ {t | IsClosed t ∧ s ⊆ t}), (∀ (h₁ : IsClosed x) (h₂ : s ⊆ x), motive (_ : IsClosed x ∧ s ⊆ x)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op", "Lean.Data.AC.Context", "Lean.IsAssociative"],
  "name": "Lean.Data.AC.Context.assoc",
  "constType":
  "{α : Sort u} → (self : Lean.Data.AC.Context α) → Lean.IsAssociative self.op",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Iff.intro",
   "List.cons",
   "Iff",
   "List",
   "List.Chain.pairwise",
   "List.Pairwise.chain",
   "IsTrans",
   "List.Chain"],
  "name": "List.chain_iff_pairwise",
  "constType":
  "∀ {α : Type u} {R : α → α → Prop} [inst : IsTrans α R] {a : α} {l : List α}, List.Chain R a l ↔ List.Pairwise R (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["CoheytingAlgebra", "GeneralizedCoheytingAlgebra"],
  "name": "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : CoheytingAlgebra α] → GeneralizedCoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["sInfHom",
   "sInfHomClass.toFunLike",
   "InfSet",
   "FunLike.ext",
   "FunLike.coe",
   "sInfHom.instSInfHomClassSInfHom",
   "Eq"],
  "name": "sInfHom.ext",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : InfSet α] [inst_1 : InfSet β] {f g : sInfHom α β},\n  (∀ (a : α), ↑f a = ↑g a) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLower.toDualHomeomorph._lambda_1",
   "_obj",
   "Equiv.mk",
   "_neutral"],
  "name": "Topology.WithLower.toDualHomeomorph._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references": ["IsTrans"],
  "name": "IsTrans.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b c : α), r a b → r b c → r a c) → IsTrans α r",
  "constCategory": "Other"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.ofUpperSet",
  "constType": "{α : Type u_1} → Topology.WithUpperSet α ≃ α",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.neg_resolve_left",
  "constType": "∀ {a b : Prop}, ¬a ∨ b → a → b",
  "constCategory": "Theorem"},
 {"references":
  ["PLift.up",
   "cast",
   "PLift.down",
   "ULift.up",
   "PLift",
   "ULift.down",
   "ULift",
   "unsafeCast.proof_1"],
  "name": "unsafeCast",
  "constType": "{α : Sort u} → {β : Sort v} → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«term𝓝[≥]_»._closed_2",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[≥]_»._closed_5"],
  "name": "Topology.«term𝓝[≥]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "propext", "Eq"],
  "name": "Eq.propIntro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.zero_lt_succ",
   "instLTNat"],
  "name": "Nat.zero_lt_one",
  "constType": "0 < 1",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["outParam",
   "Inf",
   "Inf.inf",
   "InfHomClass.toFunLike",
   "FunLike.coe",
   "Eq",
   "InfHomClass"],
  "name": "InfHomClass.map_inf",
  "constType":
  "∀ {F : Type u_7} {α : outParam (Type u_8)} {β : outParam (Type u_9)} [inst : Inf α] [inst_1 : Inf β]\n  [self : InfHomClass F α β] (f : F) (a b : α), ↑f (a ⊓ b) = ↑f a ⊓ ↑f b",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "OfNat.ofNat",
   "List.countP_pos",
   "List.instMembershipList",
   "propext",
   "List",
   "Bool.true",
   "LT.lt",
   "instOfNatNat",
   "Bool",
   "List.countP",
   "Nat",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {l : List α}, (0 < List.countP p l) = ∃ a ∈ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.Syntax.getHeadInfo?",
   "Unit",
   "Lean.SourceInfo",
   "Lean.Syntax.getHeadInfo?.loop.match_1",
   "Lean.Syntax",
   "Option"],
  "name": "Lean.Syntax.getHeadInfo",
  "constType": "Lean.Syntax → Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Union.union",
   "Classical.propDecidable",
   "Finite",
   "Eq.refl",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Eq.ndrec",
   "Set.Elem",
   "Eq.symm",
   "Finite.of_fintype",
   "Set.instUnionSet",
   "nonempty_fintype",
   "Set.fintypeUnion"],
  "name": "Finite.Set.finite_union.proof_1",
  "constType":
  "∀ {α : Type u_1} (s t : Set α) [inst : Finite ↑s] [inst : Finite ↑t], Finite ↑(s ∪ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.casesOn",
   "List.nil",
   "Eq"],
  "name": "List.eq_replicate_of_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} (motive : (x : List α) → (∀ b ∈ x, b = a) → Prop) (x : List α) (x_1 : ∀ b ∈ x, b = a),\n  (∀ (x : ∀ b ∈ [], b = a), motive [] x) →\n    (∀ (b : α) (l : List α) (H : ∀ b_1 ∈ b :: l, b_1 = a), motive (b :: l) H) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["isLUB_pair",
   "CompleteLattice.toLattice",
   "IsLUB.sSup_eq",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "CompleteLattice",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Sup.sup",
   "Singleton.singleton",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "Insert.insert",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instInsertSet"],
  "name": "sSup_pair",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {a b : α}, sSup {a, b} = a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.attach.proof_1",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "rfl",
   "List.attach",
   "Eq",
   "List.map_pmap",
   "Subtype.property",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.map",
   "List.pmap_congr",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "List.pmap_eq_map_attach",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} (f : (a : α) → p a → β) (l : List α) (H : ∀ a ∈ l, p a),\n  List.pmap f l H = List.map (fun x ↦ f ↑x (_ : p ↑x)) (List.attach l)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Filter.mkOfClosure.proof_1",
   "Filter.mk",
   "Filter.mkOfClosure.proof_3",
   "Set",
   "Filter.generate",
   "Filter",
   "Filter.mkOfClosure.proof_2",
   "Eq"],
  "name": "Filter.mkOfClosure",
  "constType":
  "{α : Type u} → (s : Set (Set α)) → (Filter.generate s).sets = s → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "False",
   "List.instMembershipList",
   "implies_true",
   "Eq.refl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "false_implies",
   "List.Pairwise",
   "Std.Data.List.Lemmas._auxLemma.1",
   "And",
   "Std.Data.List.Basic._auxLemma.3",
   "of_eq_true",
   "List",
   "forall_congr",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "and_self"],
  "name": "List.pairwise_singleton",
  "constType":
  "∀ {α : Type u_1} (R : α → α → Prop) (a : α), List.Pairwise R [a]",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Lean.MacroScope"],
  "name": "Lean.Macro.Context.currMacroScope",
  "constType": "Lean.Macro.Context → Lean.MacroScope",
  "constCategory": "Definition"},
 {"references": ["CompleteBooleanAlgebra", "BooleanAlgebra"],
  "name": "CompleteBooleanAlgebra.toBooleanAlgebra",
  "constType":
  "{α : Type u_1} → [self : CompleteBooleanAlgebra α] → BooleanAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Set", "TopologicalSpace"],
  "name": "TopologicalSpace.IsTopologicalBasis",
  "constType": "{α : Type u} → [t : TopologicalSpace α] → Set (Set α) → Prop",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "IsIdempotent",
   "Sup.sup",
   "instIsIdempotentSupToSup.proof_1"],
  "name": "instIsIdempotentSupToSup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α], IsIdempotent α fun x x_1 ↦ x ⊔ x_1",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "And.intro",
   "Exists.intro",
   "Nat",
   "And.casesOn",
   "Exists.casesOn",
   "instLTNat",
   "Eq"],
  "name": "List.mem_range'_1.match_1",
  "constType":
  "∀ {m s n : ℕ} (motive : (∃ i < n, m = s + i) → Prop) (x : ∃ i < n, m = s + i),\n  (∀ (i : ℕ) (h : i < n) (e : m = s + i), motive (_ : ∃ i < n, m = s + i)) → motive x",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → HEq a a_1 → Sort u_1} →\n      motive a (_ : HEq a a) → {β : Sort u} → {a_1 : β} → (t : HEq a a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["And",
   "OrderDual.instPreorder",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "inferInstanceAs",
   "OrderDual",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : PartialOrder α] (a b : αᵒᵈ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.sUnion",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.sUnion",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} (S : Set (Set α)),\n  (∀ s ∈ S, TopologicalSpace.GenerateOpen g s) → TopologicalSpace.GenerateOpen g (⋃₀ S)",
  "constCategory": "Other"},
 {"references":
  ["Set.preimage",
   "Set",
   "Monotone",
   "IsUpperSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "IsUpperSet.preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {s : Set α},\n  IsUpperSet s → ∀ {f : β → α}, Monotone f → IsUpperSet (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["beq_iff_eq",
   "BEq.beq",
   "BEq",
   "propext",
   "Bool.true",
   "LawfulBEq",
   "Bool",
   "Eq"],
  "name": "Init.Core._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a b : α), ((a == b) = true) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.refl",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsLowerSet.WithLowerSetHomeomorph._spec_1",
   "_obj",
   "_neutral"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._rarg._cstage2",
  "constType": "_obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 ↦ x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 ↦ x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "Nat.sub_ne_zero_of_lt.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x < x_1 → Prop) (x x_1 : ℕ) (x_2 : x < x_1),\n  (∀ (h : 0 < 0), motive 0 0 h) →\n    (∀ (b : ℕ) (x : 0 < Nat.succ b), motive 0 (Nat.succ b) x) →\n      (∀ (a : ℕ) (h : Nat.succ a < 0), motive (Nat.succ a) 0 h) →\n        (∀ (a b : ℕ) (h : Nat.succ a < Nat.succ b), motive (Nat.succ a) (Nat.succ b) h) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.filterMap.match_1",
   "of_eq_true",
   "List.filterMap",
   "Option.none",
   "List",
   "Unit",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq",
   "Option"],
  "name": "List.filterMap_cons_none",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → Option β} (a : α) (l : List α),\n  f a = none → List.filterMap f (a :: l) = List.filterMap f l",
  "constCategory": "Theorem"},
 {"references": ["HImp"],
  "name": "HImp.mk",
  "constType": "{α : Type u_4} → (α → α → α) → HImp α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.instHasSubsetList",
   "List.instMembershipList",
   "List",
   "HasSubset.Subset"],
  "name": "List.Subset.refl",
  "constType": "∀ {α : Type u_1} (l : List α), l ⊆ l",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "eq_of_heq",
   "Eq.refl",
   "List.Pairwise.cons",
   "Eq",
   "List.Pairwise",
   "List.Pairwise.casesOn",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.nil",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.pairwise_cons.match_1",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α} (motive : List.Pairwise R (a :: l) → Prop)\n  (x : List.Pairwise R (a :: l)),\n  (∀ (h₁ : ∀ a' ∈ l, R a a') (h₂ : List.Pairwise R l), motive (_ : List.Pairwise R (a :: l))) → motive x",
  "constCategory": "Definition"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{α : Type u} → (α → α → α) → Inf α",
  "constCategory": "Other"},
 {"references": ["Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.intro",
  "constType": "∀ {α : Type u} {s : Set α}, Fintype ↑s → Set.Finite s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.45",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.node6",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Array.mkEmpty",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop} (t : Nonempty α), (∀ (val : α), motive (_ : Nonempty α)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "Eq.ge",
   "Inf.inf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Lattice.toInf",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HImp.himp",
   "himp_bot",
   "Iff.mp",
   "le_himp_iff",
   "disjoint_iff_inf_le",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "BoundedOrder.toOrderBot"],
  "name": "disjoint_compl_left",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, Disjoint aᶜ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Backtrackable.save",
   "EStateM",
   "EStateM.tryCatch.match_1",
   "EStateM.Backtrackable.restore",
   "EStateM.Backtrackable",
   "EStateM.Result"],
  "name": "EStateM.tryCatch",
  "constType":
  "{ε σ δ : Type u} →\n  [inst : EStateM.Backtrackable δ σ] → {α : Type u} → EStateM ε σ α → (ε → EStateM ε σ α) → EStateM ε σ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.35",
  "constType":
  "∀ {α : Type u} {s : Set α} {f : Filter α}, (f ≤ Filter.principal s) = (s ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.toBiheytingAlgebra",
   "IsCompl.compl_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "BooleanAlgebra.toDistribLattice",
   "IsCompl.symm",
   "BiheytingAlgebra.toHeytingAlgebra",
   "BooleanAlgebra",
   "Eq"],
  "name": "compl_compl",
  "constType": "∀ {α : Type u} [inst : BooleanAlgebra α] (x : α), xᶜᶜ = x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.brecOn",
   "Nat.below",
   "Nat.sub_le_sub_right.match_1",
   "instSubNat",
   "Unit",
   "HSub.hSub",
   "Nat.sub",
   "LE.le",
   "Nat.pred_le_pred",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.sub_le_sub_right",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n - k ≤ m - k",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.nil",
   "List.noConfusion",
   "List.noConfusionType",
   "Eq"],
  "name": "List.hasDecEq.proof_2",
  "constType":
  "∀ {α : Type u_1} (head : α) (tail : List α), head :: tail = [] → List.noConfusionType False (head :: tail) []",
  "constCategory": "Theorem"},
 {"references":
  ["List.Sublist.subset",
   "List",
   "List.Sublist",
   "List.eq_nil_of_subset_nil",
   "List.nil",
   "Eq"],
  "name": "List.eq_nil_of_sublist_nil",
  "constType": "∀ {α : Type u} {l : List α}, List.Sublist l [] → l = []",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelSemigroup", "AddSemigroup"],
  "name": "AddRightCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddRightCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Setoid.mk", "True", "true_equivalence"],
  "name": "trueSetoid",
  "constType": "{α : Sort u_1} → Setoid α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Order.Lattice._auxLemma.12",
   "and_true",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_eq_right",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.«termΩ^»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Nat.le_trans", "Nat", "Nat.le_step", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_trans",
  "constType": "∀ {n m k : ℕ}, n < m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.closure_of._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references": ["List.findIdx.go", "Eq.refl", "List.nil", "Bool", "Nat", "Eq"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go._eq_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (x : ℕ), List.findIdx.go p [] x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Exists",
   "Classical.indefiniteDescription.match_1",
   "Subtype.mk",
   "Subtype",
   "Nonempty"],
  "name": "Classical.indefiniteDescription.proof_1",
  "constType":
  "∀ {α : Sort u_1} (p : α → Prop), (∃ x, p x) → Nonempty { x // p x }",
  "constCategory": "Theorem"},
 {"references":
  ["Char",
   "String.noConfusionType",
   "Eq.ndrec",
   "List",
   "String",
   "String.casesOn",
   "Eq.refl",
   "Eq"],
  "name": "String.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : String} → v1 = v2 → String.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Filter.tendsto_comap_iff",
   "nhds",
   "Iff.rfl",
   "Function.comp",
   "Eq.refl",
   "Inducing",
   "Inducing.nhds_eq_comap",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "id"],
  "name": "Inducing.tendsto_nhds_iff",
  "constType":
  "∀ {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ] {ι : Type u_5} {f : ι → β}\n  {g : β → γ} {a : Filter ι} {b : β}, Inducing g → (Filter.Tendsto f a (nhds b) ↔ Filter.Tendsto (g ∘ f) a (nhds (g b)))",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nat.succ_lt_succ",
   "Iff",
   "Nat.lt_of_succ_lt_succ",
   "LT.lt",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.succ_lt_succ_iff",
  "constType": "∀ {a b : ℕ}, Nat.succ a < Nat.succ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.rec",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.recOn",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLower α → Sort u} →\n        (t_1 : Topology.IsLower α) →\n          ((topology_eq_lowerTopology : t = Topology.lower α) → motive (_ : Topology.IsLower α)) → motive t_1",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.tail",
  "constType":
  "∀ {α : Type u} {a : α} (b : α) {as : List α}, List.Mem a as → List.Mem a (b :: as)",
  "constCategory": "Other"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Array.foldlM.loop.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (i : ℕ) → (Unit → motive 0) → ((i' : ℕ) → motive (Nat.succ i')) → motive i",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "PProd",
   "PProd.fst",
   "Prod.snd",
   "Prod.mk",
   "Equiv.pprodEquivProd.proof_2",
   "Equiv.pprodEquivProd.proof_1",
   "Equiv.mk",
   "Prod",
   "Prod.fst",
   "PProd.snd",
   "PProd.mk"],
  "name": "Equiv.pprodEquivProd",
  "constType": "{α : Type u_1} → {β : Type u_2} → PProd α β ≃ α × β",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.Perm",
   "List.rec",
   "List.Perm.nil",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Perm.refl.match_1",
   "List.nil",
   "List.Perm.cons"],
  "name": "List.Perm.refl",
  "constType": "∀ {α : Type uu} (l : List α), l ~ l",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Lean.Name.mkStr1"],
  "name": "Lean.identKind",
  "constType": "Lean.SyntaxNodeKind",
  "constCategory": "Definition"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.below",
   "List.brecOn",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "True",
   "Eq",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "PProd",
   "Iff",
   "List.rec",
   "PUnit",
   "List.nil",
   "Eq.trans",
   "Membership.mem",
   "List.mem_map.match_1",
   "funext",
   "List.cons",
   "Or",
   "False",
   "Unit",
   "eq_comm",
   "Std.Logic._auxLemma.32",
   "Std.Logic._auxLemma.48",
   "And",
   "PProd.fst",
   "of_eq_true",
   "List",
   "propext",
   "congr",
   "List.map",
   "congrArg",
   "congrFun"],
  "name": "List.mem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {b : β} {f : α → β} {l : List α}, b ∈ List.map f l ↔ ∃ a ∈ l, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "cond",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "Subtype.val",
   "instInhabitedPUnit",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "CompletelyDistribLattice",
   "le_iSup",
   "iSup",
   "True",
   "Preorder.toLE",
   "Iff.of_eq",
   "Eq",
   "Subtype.property",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Eq.mpr",
   "iSup_congr_Prop",
   "Set.Elem",
   "iSup_const",
   "Bool.true",
   "iSup_subtype",
   "PUnit",
   "le_trans",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "Subtype",
   "instNonempty",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompletelyDistribLattice.toCompleteDistribLattice.match_1",
   "SupSet.sSup",
   "iSup_le",
   "LE.le",
   "Set.instMembershipSet",
   "of_eq_true",
   "iInf",
   "iInf_bool_eq",
   "CompleteLattice.toInfSet",
   "Bool.false",
   "sSup_eq_iSup",
   "le_refl",
   "instTransEq",
   "iInf_iSup_eq",
   "Bool",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Subtype.mk",
   "congrFun"],
  "name": "CompletelyDistribLattice.toCompleteDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompletelyDistribLattice α] (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Membership.mk",
   "Membership",
   "Set.instMembershipSet"],
  "name": "instMembershipSetFilter",
  "constType": "{α : Type u_1} → Membership (Set α) (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Filter.le_principal_iff",
   "propext",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.50",
  "constType":
  "∀ {α : Type u} {s : Set α} {f : Filter α}, (f ≤ Filter.principal s) = (s ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (toZeroHom : ZeroHom M N) →\n          (∀ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n            M →+ N",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Function.Involutive",
  "constType": "{α : Sort u_1} → (α → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "exists_eq_left.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α} (motive : (∃ a, a = a' ∧ p a) → Prop) (x : ∃ a, a = a' ∧ p a),\n  (∀ (w : α) (e : w = a') (h : p w), motive (_ : ∃ a, a = a' ∧ p a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_right",
  "constType": "∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "cond",
   "OfNat.ofNat",
   "List.findIdx.go.match_1",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.findIdx.go",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go._eq_1",
   "Eq",
   "Eq.ndrec",
   "List",
   "instOfNatNat",
   "Bool",
   "List.nil",
   "Nat",
   "_private.Std.Data.List.Lemmas.0.List.findIdx.go.match_1.splitter",
   "Eq.symm",
   "id"],
  "name": "_private.Std.Data.List.Lemmas.0.List.findIdx.go._unfold",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (x : List α) (x_1 : ℕ),\n  List.findIdx.go p x x_1 =\n    match x, x_1 with\n    | [], n => n\n    | a :: l, n => bif p a then n else List.findIdx.go p l (n + 1)",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.concat.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → α → Sort u_2) →\n    (x : List α) →\n      (x_1 : α) → ((b : α) → motive [] b) → ((a : α) → (as : List α) → (b : α) → motive (a :: as) b) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "of_eq_true",
   "List.rec",
   "List",
   "List.nil",
   "List.map",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "id",
   "Eq"],
  "name": "List.map_id",
  "constType": "∀ {α : Type u_1} (l : List α), List.map id l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Iff", "Decidable.imp_iff_or_not", "Classical.propDecidable", "Not"],
  "name": "imp_iff_or_not",
  "constType": "∀ {b a : Prop}, b → a ↔ a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "isLowerSet_sUnion",
   "Set",
   "Set.sUnion",
   "Preorder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Topology.lowerSet.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Preorder α] (x : Set (Set α)), (∀ s ∈ x, IsLowerSet s) → IsLowerSet (⋃₀ x)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "forall_congr'"],
  "name": "ball_congr",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {P Q : (x : α) → p x → Prop},\n  (∀ (x : α) (h : p x), P x h ↔ Q x h) → ((∀ (x : α) (h : p x), P x h) ↔ ∀ (x : α) (h : p x), Q x h)",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Not", "by_contra"],
  "name": "of_not_not",
  "constType": "∀ {a : Prop}, ¬¬a → a",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.mk",
  "constType": "{α : Type u_9} → (Set α → α) → SupSet α",
  "constCategory": "Other"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Subtype.val",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype",
   "Subtype.casesOn",
   "Eq"],
  "name": "List.Nodup.pmap.match_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a}\n  (x : { x // x ∈ l }) (motive : (x_1 : { x // x ∈ l }) → f ↑x_1 (_ : p ↑x_1) = f ↑x (_ : p ↑x) → Prop)\n  (x_1 : { x // x ∈ l }) (h : f ↑x_1 (_ : p ↑x_1) = f ↑x (_ : p ↑x)),\n  (∀ (a : α) (ha : a ∈ l) (h : f ↑{ val := a, property := ha } (_ : p ↑{ val := a, property := ha }) = f ↑x (_ : p ↑x)),\n      motive { val := a, property := ha } h) →\n    motive x_1 h",
  "constCategory": "Definition"},
 {"references": ["Topology.WithLower", "Nonempty"],
  "name": "Topology.WithLower.instNonemptyWithLower",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α], Nonempty (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "funext",
   "Function.RightInverse",
   "Set.preimage_subset_image_of_inverse",
   "Set.preimage",
   "Set",
   "Set.image_subset_preimage_of_inverse",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq"],
  "name": "Set.image_eq_preimage_of_inverse",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {g : β → α},\n  Function.LeftInverse g f → Function.RightInverse g f → Set.image f = Set.preimage g",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "MonadWithReaderOf",
  "constType":
  "semiOutParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.le_sup_left",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_5",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.below.cons₂",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.below.slnil",
   "List.Sublist.rec",
   "List.Sublist.below"],
  "name": "List.Sublist.brecOn",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop} {a a_1 : List α} (x : List.Sublist a a_1),\n  (∀ (a a_2 : List α) (x : List.Sublist a a_2), List.Sublist.below x → motive a a_2 x) → motive a a_1 x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "bot_unique",
   "Preorder.toLE",
   "Eq",
   "Filter.principal",
   "Filter.instPartialOrderFilter",
   "OrderBot.toBot",
   "Set.empty_subset",
   "Filter",
   "BoundedOrder.toOrderBot",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.principal_empty",
  "constType": "∀ {α : Type u}, Filter.principal ∅ = ⊥",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedCoheytingAlgebra", "Lattice"],
  "name": "GeneralizedCoheytingAlgebra.toLattice",
  "constType":
  "{α : Type u_4} → [self : GeneralizedCoheytingAlgebra α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_11",
  "constType":
  "∀ {α : Type u_1} (x y z : α → Prop), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.noConfusionType", "Eq.ndrec", "Eq.refl", "Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : ℕ} → v1 = v2 → Nat.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "instAddNat",
   "Nat.le_add_right",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le.intro",
  "constType": "∀ {n m k : ℕ}, n + k = m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "setOf",
   "Set",
   "And.intro",
   "And.casesOn",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_1",
  "constType":
  "∀ {α : Type u_1} {g : Set (Set α)} {a : α} (s : Set α) (motive : s ∈ {s | a ∈ s ∧ s ∈ g} → Prop)\n  (x : s ∈ {s | a ∈ s ∧ s ∈ g}), (∀ (as : a ∈ s) (sg : s ∈ g), motive (_ : a ∈ s ∧ s ∈ g)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonadStateOf.modifyGet",
   "getThe",
   "MonadState.mk",
   "MonadStateOf.set",
   "MonadState",
   "Prod",
   "MonadStateOf"],
  "name": "instMonadState",
  "constType":
  "(σ : Type u) → (m : Type u → Type v) → [inst : MonadStateOf σ m] → MonadState σ m",
  "constCategory": "Definition"},
 {"references":
  ["BEq.beq",
   "instLENat",
   "List.Sublist.countP_le",
   "DecidableEq",
   "List",
   "List.Sublist",
   "instBEq",
   "Nat",
   "List.count",
   "LE.le"],
  "name": "List.Sublist.count_le",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {l₁ l₂ : List α},\n  List.Sublist l₁ l₂ → ∀ (a : α), List.count a l₁ ≤ List.count a l₂",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "sup_assoc",
   "SemilatticeInf",
   "Eq"],
  "name": "inf_assoc",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ⊓ b ⊓ c = a ⊓ (b ⊓ c)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons",
   "List.Sublist.below"],
  "name": "List.Sublist.below.cons",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop} {l₁ l₂ : List α} (a : α)\n  {a_1 : List.Sublist l₁ l₂},\n  List.Sublist.below a_1 → motive l₁ l₂ a_1 → List.Sublist.below (_ : List.Sublist l₁ (a :: l₂))",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Array",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.node6",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Array.mkEmpty",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.GenerateOpen.basic",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "Inter.inter",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.GenerateOpen.rec",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {motive : (a : Set α) → TopologicalSpace.GenerateOpen g a → Prop},\n  (∀ (s : Set α) (a : s ∈ g), motive s (_ : TopologicalSpace.GenerateOpen g s)) →\n    motive Set.univ (_ : TopologicalSpace.GenerateOpen g Set.univ) →\n      (∀ (s t : Set α) (a : TopologicalSpace.GenerateOpen g s) (a_1 : TopologicalSpace.GenerateOpen g t),\n          motive s a → motive t a_1 → motive (s ∩ t) (_ : TopologicalSpace.GenerateOpen g (s ∩ t))) →\n        (∀ (S : Set (Set α)) (a : ∀ s ∈ S, TopologicalSpace.GenerateOpen g s),\n            (∀ (s : Set α) (a_1 : s ∈ S), motive s (_ : TopologicalSpace.GenerateOpen g s)) →\n              motive (⋃₀ S) (_ : TopologicalSpace.GenerateOpen g (⋃₀ S))) →\n          ∀ {a : Set α} (t : TopologicalSpace.GenerateOpen g a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["sInfHom",
   "sInfHom.rec",
   "Set",
   "InfSet.sInf",
   "sInfHom.mk",
   "InfSet",
   "Set.image",
   "Eq"],
  "name": "sInfHom.casesOn",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : InfSet α] →\n      [inst_1 : InfSet β] →\n        {motive : sInfHom α β → Sort u} →\n          (t : sInfHom α β) →\n            ((toFun : α → β) →\n                (map_sInf' : ∀ (s : Set α), toFun (sInf s) = sInf (toFun '' s)) →\n                  motive { toFun := toFun, map_sInf' := map_sInf' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "Set.preimage",
   "TopologicalSpace.ext",
   "Set",
   "Exists.intro",
   "rfl",
   "Eq",
   "Iff.intro",
   "And",
   "propext",
   "induced_id.match_1",
   "Eq.rec",
   "TopologicalSpace",
   "And.intro",
   "TopologicalSpace.induced",
   "IsOpen",
   "id"],
  "name": "induced_id",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α], TopologicalSpace.induced id t = t",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{α : Type u} →\n  [toInf : Inf α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ⊓ b ≤ a) →\n        (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → SemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["Array.mkArray3",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node3",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.rec",
   "List.instMembershipList",
   "List",
   "List.mem_cons_of_mem",
   "List.mem_cons_self",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.imp_of_mem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {R S : α → α → Prop},\n  (∀ {a b : α}, a ∈ l → b ∈ l → R a b → S a b) → List.Pairwise R l → List.Pairwise S l",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.lt_of_succ_lt_succ",
  "constType": "∀ {n m : ℕ}, Nat.succ n < Nat.succ m → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "instHSub",
   "And",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "LT.lt",
   "HSub.hSub",
   "PSigma.mk",
   "Nat.div.inductionOn._unary",
   "Not",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div.inductionOn",
  "constType":
  "{motive : ℕ → ℕ → Sort u} →\n  (x y : ℕ) →\n    ((x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) →\n      ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y) → motive x y",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.lt.base", "Nat", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_succ_self",
  "constType": "∀ (n : ℕ), n < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["IsCommutative", "Eq"],
  "name": "IsCommutative.mk",
  "constType":
  "∀ {α : Type u} {op : α → α → α}, (∀ (a b : α), op a b = op b a) → IsCommutative α op",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Eq.mpr",
   "OfNat.ofNat",
   "Eq.ndrec",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.add_sub_add_left",
   "Eq.refl",
   "Nat.sub_zero",
   "instOfNatNat",
   "Nat",
   "id",
   "Eq"],
  "name": "Nat.add_sub_cancel_left",
  "constType": "∀ (n m : ℕ), n + m - n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Not.elim", "Or", "Iff", "or_iff_right_iff_imp", "Not", "Iff.mpr"],
  "name": "or_iff_right",
  "constType": "∀ {a b : Prop}, ¬a → (a ∨ b ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.finite_range",
   "Exists.casesOn",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Topology.IsLower",
   "Set.Elem",
   "Set.image_subset_iff",
   "Set.image",
   "And.casesOn",
   "Eq.trans",
   "Set.compl_iUnion",
   "Subtype",
   "TopologicalSpace.IsTopologicalBasis",
   "setOf",
   "Subtype.forall'",
   "eq_of_heq",
   "Set.sInter_eq_iInter",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "HEq.refl",
   "of_eq_true",
   "propext",
   "Eq.mp",
   "Set.iInter",
   "Set.Finite.to_subtype",
   "And.intro",
   "congrArg",
   "SetLike.coe",
   "congrFun",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "HEq",
   "coe_upperClosure",
   "Subtype.val",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.biInter_range",
   "Exists.intro",
   "Set.Ici",
   "UpperSet",
   "rfl",
   "True",
   "Topology.IsLower.topology_eq",
   "Set.ext",
   "Set.range",
   "Set.Finite.image",
   "upperClosure",
   "TopologicalSpace",
   "Eq.symm",
   "Topology.IsLower.lowerBasis",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.subset_def",
   "funext",
   "TopologicalSpace.isTopologicalBasis_of_subbasis",
   "Set.preimage",
   "Set.sInter_image",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Finite",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Eq.casesOn",
   "Set.sInter"],
  "name": "Topology.IsLower.isTopologicalBasis",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α],\n  TopologicalSpace.IsTopologicalBasis (Topology.IsLower.lowerBasis α)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "IsLowerSet",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.lowerSet._cstage1",
  "constType": "(α : Type u_4) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": ["Filter"],
  "name": "Filter.NeBot",
  "constType": "{α : Type u} → Filter α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace", "T0Space.mk", "T0Space", "Inseparable", "Eq"],
  "name": "T0Space.rec",
  "constType":
  "{α : Type u} →\n  [inst : TopologicalSpace α] →\n    {motive : T0Space α → Sort u_1} →\n      ((t0 : ∀ ⦃x y : α⦄, Inseparable x y → x = y) → motive (_ : T0Space α)) → (t : T0Space α) → motive t",
  "constCategory": "Other"},
 {"references": ["Setoid", "List.Perm", "List", "Setoid.mk", "List.Perm.eqv"],
  "name": "List.isSetoid",
  "constType": "(α : Type u_1) → Setoid (List α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsRefl",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "nhds",
   "propext",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Order._auxLemma.34",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, (s ∈ nhds a) = ∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "OfNat.ofNat",
   "Nat.le.step",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Nat.zero",
   "Eq.ndrec",
   "HEq.refl",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "Nat.pred_le_pred.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ≤ x_1 → Prop) (x x_1 : ℕ) (x_2 : x ≤ x_1),\n  (∀ (n : ℕ), motive n n (_ : Nat.le n n)) →\n    (∀ (n : ℕ) (h : Nat.le 0 n), motive 0 (Nat.succ n) (_ : Nat.le 0 (Nat.succ n))) →\n      (∀ (n n_1 : ℕ) (h : Nat.le (Nat.succ n) n_1),\n          motive (Nat.succ n) (Nat.succ n_1) (_ : Nat.le (Nat.succ n) (Nat.succ n_1))) →\n        motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Specializes",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet_specializes_toUpperSet",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Topology.WithUpperSet.toUpperSet",
   "Preorder.toLE",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSet_le_ofUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : Topology.WithUpperSet α},\n  ↑Topology.WithUpperSet.ofUpperSet a ≤ ↑Topology.WithUpperSet.ofUpperSet b ↔ b ⤳ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.WithLower.instPreorderWithLower._rarg", "_neutral"],
  "name": "Topology.WithLower.instPreorderWithLower._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Filter.univ_mem'", "setOf", "Filter", "Filter.Eventually"],
  "name": "Filter.eventually_of_forall",
  "constType":
  "∀ {α : Type u} {p : α → Prop} {f : Filter α}, (∀ (x : α), p x) → ∀ᶠ (x : α) in f, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_inter_iff",
   "Membership.mem",
   "And",
   "propext",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Basic._auxLemma.43",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∩ b) = (x ∈ a ∧ x ∈ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[_]_»._closed_9",
   "Topology.«term𝓝[_]_»._closed_8"],
  "name": "Topology.«term𝓝[_]_»._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Char",
   "List",
   "String.utf8ByteSize.go",
   "String",
   "Nat",
   "String.utf8ByteSize.match_1"],
  "name": "String.utf8ByteSize",
  "constType": "String → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf.inf",
   "Eq.refl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "inf_top_eq",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Eq.mpr",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "Disjoint.eq_bot",
   "BoundedOrder.toOrderBot",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder",
   "id",
   "inf_le_inf_right",
   "Bot.bot",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "le_sup_left",
   "Codisjoint",
   "DistribLattice.toLattice",
   "sup_inf_right",
   "Eq.ndrec",
   "bot_sup_eq",
   "OrderBot.toBot",
   "Sup.sup",
   "Codisjoint.eq_top"],
  "name": "Disjoint.le_of_codisjoint",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {a b c : α}, Disjoint a b → Codisjoint b c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "HasCompl.compl",
   "LE",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "IsLowerSet.compl",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s : Set α}, IsLowerSet s → IsUpperSet sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["List",
   "Unit",
   "Lean.Data.AC.insert.match_1",
   "List.nil",
   "Nat",
   "Lean.Data.AC.mergeIdem.loop"],
  "name": "Lean.Data.AC.mergeIdem",
  "constType": "List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_left",
  "constType": "∀ {a b c : Prop}, (a → b) → a ∨ c → b ∨ c",
  "constCategory": "Theorem"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLowerSet.rec",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Topology.IsLowerSet.mk",
   "Eq"],
  "name": "Topology.IsLowerSet.casesOn",
  "constType":
  "{α : Type u_4} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLowerSet α → Sort u} →\n        (t_1 : Topology.IsLowerSet α) →\n          ((topology_eq_lowerSetTopology : t = Topology.lowerSet α) → motive (_ : Topology.IsLowerSet α)) → motive t_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "closure",
   "Membership.mem",
   "Filter.principal",
   "Iff",
   "nhds",
   "clusterPt_principal_iff_frequently",
   "Set",
   "TopologicalSpace",
   "Iff.trans",
   "mem_closure_iff_frequently",
   "ClusterPt",
   "Filter.Frequently",
   "Set.instMembershipSet"],
  "name": "mem_closure_iff_clusterPt",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {a : α}, a ∈ closure s ↔ ClusterPt a (Filter.principal s)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_5",
   "List.cons",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[_]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_9} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet", "Filter.GenerateSets", "Set", "HasSubset.Subset"],
  "name": "Filter.GenerateSets.superset",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {s t : Set α}, Filter.GenerateSets g s → s ⊆ t → Filter.GenerateSets g t",
  "constCategory": "Other"},
 {"references":
  ["OrderDual.semilatticeInf",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "SemilatticeInf.inf_le_right",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderDual.lattice.proof_5",
  "constType": "∀ (α : Type u_1) [inst : Lattice α] (a b : αᵒᵈ), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpper",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Topology.IsUpper",
   "TopologicalSpace",
   "Topology.WithUpper.instPreorderWithUpper",
   "Topology.IsUpper.mk",
   "Preorder",
   "rfl"],
  "name":
  "Topology.instIsUpperWithUpperInstTopologicalSpaceWithUpperInstPreorderWithUpper.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpper (Topology.WithUpper α)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "propext",
   "List",
   "List.replicate",
   "List.eq_replicate",
   "List.length",
   "Nat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} {l : List α}, (l = List.replicate n a) = (List.length l = n ∧ ∀ b ∈ l, b = a)",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "List.instMembershipList", "List"],
  "name": "List.Subset",
  "constType": "{α : Type u_1} → List α → List α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Function.RightInverse",
   "Equiv.rec",
   "Equiv.mk"],
  "name": "Equiv.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : α ≃ β → Sort u} →\n      (t : α ≃ β) →\n        ((toFun : α → β) →\n            (invFun : β → α) →\n              (left_inv : Function.LeftInverse invFun toFun) →\n                (right_inv : Function.RightInverse invFun toFun) →\n                  motive { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "And",
   "instHAppend",
   "List.eraseP",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Bool.true",
   "Not",
   "Bool",
   "And.intro",
   "And.casesOn"],
  "name": "List.exists_of_eraseP.match_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} (l : List α)\n  (motive :\n    (∃ a, ∃ l₁, ∃ l₂, (∀ b ∈ l₁, ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ List.eraseP p l = l₁ ++ l₂) → Prop)\n  (x : ∃ a, ∃ l₁, ∃ l₂, (∀ b ∈ l₁, ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ List.eraseP p l = l₁ ++ l₂),\n  (∀ (c : α) (l₁ l₂ : List α) (h₁ : ∀ b ∈ l₁, ¬p b = true) (h₂ : p c = true) (h₃ : l = l₁ ++ c :: l₂)\n      (h₄ : List.eraseP p l = l₁ ++ l₂),\n      motive\n        (_ : ∃ a, ∃ l₁, ∃ l₂, (∀ b ∈ l₁, ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ List.eraseP p l = l₁ ++ l₂)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_5",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "rfl",
   "Eq",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.ofLower_toLower",
  "constType":
  "∀ {α : Type u_1} (a : α), ↑Topology.WithLower.ofLower (↑Topology.WithLower.toLower a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.sInter_subset_of_mem",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "And.intro",
   "IsClosed"],
  "name": "closure_minimal",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ⊆ t → IsClosed t → closure s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "cond",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.findIdx.go",
   "List.findIdx_cons.findIdx_go_succ",
   "List.findIdx",
   "True",
   "Eq",
   "Nat.zero_add",
   "Bool.casesOn",
   "Eq.ndrec",
   "of_eq_true",
   "List",
   "Bool.false",
   "Bool.true",
   "congr",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.findIdx_cons",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) (b : α) (l : List α), List.findIdx p (b :: l) = bif p b then 0 else List.findIdx p l + 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "Inf", "InfHomClass"],
  "name": "InfHomClass.toFunLike",
  "constType":
  "{F : Type u_7} →\n  {α : outParam (Type u_8)} →\n    {β : outParam (Type u_9)} → [inst : Inf α] → [inst_1 : Inf β] → [self : InfHomClass F α β] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pred_le.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive Nat.zero) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Subtype.val",
   "propext",
   "Subtype.exists'",
   "Subtype",
   "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.24",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop}, (∃ x, ∃ (h : p x), q x h) = ∃ x, q ↑x (_ : p ↑x)",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeInf.toInf",
   "Inf.inf",
   "IsAssociative",
   "instIsAssociativeInfToInf.proof_1",
   "SemilatticeInf"],
  "name": "instIsAssociativeInfToInf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α], IsAssociative α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references": ["MonadWithReaderOf", "semiOutParam"],
  "name": "MonadWithReaderOf.mk",
  "constType":
  "{ρ : semiOutParam (Type u)} → {m : Type u → Type v} → ({α : Type u} → (ρ → ρ) → m α → m α) → MonadWithReaderOf ρ m",
  "constCategory": "Other"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "constCategory": "Theorem"},
 {"references": ["List", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.range.loop.match_1",
  "constType":
  "(motive : ℕ → List ℕ → Sort u_1) →\n  (x : ℕ) →\n    (x_1 : List ℕ) → ((ns : List ℕ) → motive 0 ns) → ((n : ℕ) → (ns : List ℕ) → motive (Nat.succ n) ns) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Functor"],
  "name": "Applicative.toFunctor",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → Functor f",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.«term𝓝[>]_»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[>]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "Inf.inf",
   "Filter.instInfFilter",
   "Filter.comap",
   "Prod",
   "Filter",
   "Prod.fst"],
  "name": "Filter.prod",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → Filter α → Filter β → Filter (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.not_mem_nil.match_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (motive : a ∈ [] → Prop) (a : a ∈ []), motive a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "instLENat",
   "Nat.le_of_lt_succ",
   "LT.lt",
   "Nat.lt_succ_of_le",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.lt_succ",
  "constType": "∀ {m n : ℕ}, m < Nat.succ n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced",
   "IsOpen",
   "Eq"],
  "name": "isOpen_induced_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [t : TopologicalSpace β] {s : Set α} {f : α → β},\n  IsOpen s ↔ ∃ t_1, IsOpen t_1 ∧ f ⁻¹' t_1 = s",
  "constCategory": "Theorem"},
 {"references": ["Char", "List", "String", "String.casesOn", "Eq"],
  "name": "String.noConfusionType",
  "constType": "Sort u → String → String → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Nat.decLt",
   "LT.lt",
   "Array.get",
   "Not",
   "dite",
   "Nat",
   "Array.size",
   "instLTNat",
   "Fin.mk"],
  "name": "Array.getD",
  "constType": "{α : Type u_1} → Array α → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Iff",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpper.ofUpper",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpper.ofUpper_inj",
  "constType":
  "∀ {α : Type u_1} {a b : Topology.WithUpper α}, ↑Topology.WithUpper.ofUpper a = ↑Topology.WithUpper.ofUpper b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.upper._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "List.Pairwise.nil",
   "List.Pairwise.below",
   "List",
   "List.nil"],
  "name": "List.Pairwise.below.nil",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop},\n  List.Pairwise.below (_ : List.Pairwise R [])",
  "constCategory": "Other"},
 {"references": ["outParam", "TopologicalSpace"],
  "name": "ContinuousMapClass",
  "constType":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → Type (max (max u_1 u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "OfNat.ofNat",
   "Trans.trans",
   "instIsCommutativeSupToSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "Eq.refl",
   "Lean.IsNeutral",
   "instIsIdempotentInfToInf",
   "Eq",
   "Lattice.toInf",
   "sup_inf_self",
   "instIsAssociativeInfToInf",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Option.some",
   "List.nil",
   "Nat",
   "Lattice.toSemilatticeSup",
   "instIsIdempotent",
   "Eq.trans",
   "instIsIdempotentSupToSup",
   "id",
   "List.cons",
   "Lattice.toSemilatticeInf",
   "Lean.Data.AC.eval",
   "SDiff.sdiff",
   "instIsCommutative",
   "instIsCommutativeInfToInf",
   "Lean.IsIdempotent",
   "DistribLattice.toLattice",
   "sup_inf_sdiff",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "GeneralizedBooleanAlgebra",
   "instTransEq",
   "congr",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Bool",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "congrFun",
   "instIsAssociativeSupToSup"],
  "name": "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_sup_self'",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : GeneralizedBooleanAlgebra α], y \\ x ⊔ x = y ⊔ x",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Eq.rec", "HasSubset.Subset", "HasSubset", "subset_rfl", "Eq"],
  "name": "superset_of_eq",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1], a = b → b ⊆ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Lean.Data.AC.Expr.op",
   "PProd.fst",
   "List.append",
   "List.cons",
   "Lean.Data.AC.Expr",
   "List",
   "PUnit",
   "Lean.Data.AC.Expr.rec",
   "Lean.Data.AC.Expr.below",
   "Lean.Data.AC.Expr.brecOn",
   "List.nil",
   "PProd.snd",
   "Nat",
   "Lean.Data.AC.Expr.var",
   "_private.Init.Data.AC.0.Lean.Data.AC.reprExpr.match_1._@.Init.Data.AC._hyg.40"],
  "name": "Lean.Data.AC.Expr.toList",
  "constType": "Lean.Data.AC.Expr → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Nat.min_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "Eq.refl",
   "Nat",
   "instMinNat",
   "Nat.min_eq_left",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.min_eq_right",
  "constType": "∀ {a b : ℕ}, b ≤ a → min a b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "OrderDual.distribLattice",
   "IsCompl",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "OrderDual.boundedOrder",
   "DistribLattice.toLattice",
   "Iff.intro",
   "Lattice.toInf",
   "IsCompl.dual",
   "Iff",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "IsCompl.inf_left_le_of_le_sup_right",
   "OrderDual",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "IsCompl.symm",
   "BoundedOrder"],
  "name": "IsCompl.le_sup_right_iff_inf_left_le",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y a b : α},\n  IsCompl x y → (a ≤ b ⊔ y ↔ a ⊓ x ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.forall_image2_iff.match_1",
  "constType":
  "∀ {α : Type u_3} {β : Type u_2} {γ : Type u_1} {f : α → β → γ} {s : Set α} {t : Set β} (x : γ)\n  (motive : x ∈ Set.image2 f s t → Prop) (x_1 : x ∈ Set.image2 f s t),\n  (∀ (x_2 : α) (y : β) (hx : x_2 ∈ s) (hy : y ∈ t) (hz : f x_2 y = x),\n      motive (_ : ∃ a, ∃ b, a ∈ s ∧ b ∈ t ∧ f a b = x)) →\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Lean.Name.rec",
   "PProd.fst",
   "Lean.Name.below",
   "Lean.Name.brecOn",
   "Lean.Name.num",
   "Lean.Name.appendCore.match_1",
   "String",
   "PUnit",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.Name.str"],
  "name": "Lean.Name.appendCore",
  "constType": "Lean.Name → Lean.Name → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_wfRel.proof_1",
   "WellFoundedRelation",
   "Nat.lt",
   "Nat",
   "WellFoundedRelation.mk"],
  "name": "Nat.lt_wfRel",
  "constType": "WellFoundedRelation ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.closure_of._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.closure_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists.fst.match_1",
   "Exists",
   "Iff.mp",
   "Iff",
   "exists_prop_congr.match_1",
   "Exists.intro",
   "Iff.mpr"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteLattice",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "iSup_subtype",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "iSup_subtype''",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {ι : Type u_9} (s : Set ι) (f : ι → α), ⨆ i, f ↑i = ⨆ t ∈ s, f t",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "setOf",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "Filter.principal",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "congrArg",
   "interior_eq_nhds'",
   "Eq.trans",
   "interior",
   "Mathlib.Topology.Basic._auxLemma.50",
   "instMembershipSetFilter"],
  "name": "interior_eq_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, interior s = {a | nhds a ≤ Filter.principal s}",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.rec",
  "constType":
  "{α : Type u_1} →\n  {motive : Filter α → Sort u} →\n    ((sets : Set (Set α)) →\n        (univ_sets : Set.univ ∈ sets) →\n          (sets_of_superset : ∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets) →\n            (inter_sets : ∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) →\n              motive\n                { sets := sets, univ_sets := univ_sets, sets_of_superset := sets_of_superset,\n                  inter_sets := inter_sets }) →\n      (t : Filter α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Iff",
   "List.mem_map_of_injective.match_1",
   "Function.Injective",
   "List.mem_map_of_mem",
   "List.instMembershipList",
   "List",
   "Eq.rec",
   "List.map",
   "List.exists_of_mem_map",
   "Eq"],
  "name": "List.mem_map_of_injective",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β}, Function.Injective f → ∀ {a : α} {l : List α}, f a ∈ List.map f l ↔ a ∈ l",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn", "Eq"],
  "name": "Fintype.ofBijective.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (b : β) (motive : (∃ a, f a = b) → Prop) (x : ∃ a, f a = b),\n  (∀ (w : α) (e : f w = b), motive (_ : ∃ a, f a = b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "LE", "Pi.hasLe", "LE.le"],
  "name": "Pi.le_def",
  "constType":
  "∀ {ι : Type u} {α : ι → Type v} [inst : (i : ι) → LE (α i)] {x y : (i : ι) → α i}, x ≤ y ↔ ∀ (i : ι), x i ≤ y i",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toTop",
   "top_unique"],
  "name": "sup_compl_eq_top",
  "constType": "∀ {α : Type u} {x : α} [inst : BooleanAlgebra α], x ⊔ xᶜ = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "List.cons", "List.Nodup", "List.pairwise_singleton", "List.nil"],
  "name": "List.nodup_singleton",
  "constType": "∀ {α : Type u} (a : α), List.Nodup [a]",
  "constCategory": "Theorem"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.coe",
  "constType":
  "{E : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EquivLike E α β] → E → α → β",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "Not", "Or.elim"],
  "name": "not_or_intro",
  "constType": "∀ {a b : Prop}, ¬a → ¬b → ¬(a ∨ b)",
  "constCategory": "Theorem"},
 {"references": ["IsAssociative", "Eq"],
  "name": "IsAssociative.assoc",
  "constType":
  "∀ {α : Type u} {op : α → α → α} [self : IsAssociative α op] (a b c : α), op (op a b) c = op a (op b c)",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "inferInstanceAs",
   "OrderDual",
   "Preorder.le_trans",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : PartialOrder α] (a b c : αᵒᵈ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.List.Dedup._auxLemma.2",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "Iff",
   "decide_eq_true_eq",
   "of_eq_true",
   "Bool.true",
   "Decidable",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Eq"],
  "name": "decide_eq_true_iff",
  "constType": "∀ (p : Prop) [inst : Decidable p], decide p = true ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.cat", "_obj", "Topology.IsOpen_of._closed_9"],
  "name": "Topology.«term𝓝[_]_»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Prop.booleanAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.inf_compl_le_bot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_12",
  "constType": "∀ {α : Type u_1} (x : α → Prop), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instHAdd",
   "Nat.lt_of_lt_of_le",
   "HAdd.hAdd",
   "Nat.add_lt_add_left",
   "LE.le",
   "instLTNat",
   "Eq",
   "GT.gt",
   "instHMul",
   "instLENat",
   "Nat.mul_le_mul_left",
   "LT.lt",
   "Eq.rec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.mul_lt_mul_of_pos_left",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → k * n < k * m",
  "constCategory": "Theorem"},
 {"references":
  ["WellFounded.fixF", "Acc.inv", "Acc", "WellFounded.fixFEq.proof_1", "Eq"],
  "name": "WellFounded.fixFEq",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {C : α → Sort v} (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p ↦ WellFounded.fixF F y (_ : Acc (fun y x ↦ r y x) y)",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_of_le_right",
   "Sup.sup",
   "sup_le",
   "le_sup_of_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c d : α}, a ≤ b → c ≤ d → a ⊔ c ≤ b ⊔ d",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "iInf_inf_eq",
   "funext",
   "Prod.snd",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Prod.fst",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "sInf_image",
   "Prod.infSet",
   "Eq.mpr",
   "CompleteLattice",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Prod",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "infsInfHom.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] (s : Set (α × α)),\n  (fun x ↦ x.1 ⊓ x.2) (sInf s) = sInf ((fun x ↦ x.1 ⊓ x.2) '' s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Pure",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Eq.refl",
   "List.Mem",
   "Exists.intro",
   "List.cons_append",
   "rfl",
   "Eq",
   "PProd",
   "instHAppend",
   "List.append_of_mem.match_2",
   "Eq.mpr",
   "PProd.fst",
   "Eq.ndrec",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.nil",
   "List.append_of_mem.match_1",
   "id"],
  "name": "List.append_of_mem",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → ∃ s, ∃ t, l = s ++ a :: t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List",
   "List.Chain.nil",
   "List.nil",
   "List.Chain",
   "List.Chain.cons"],
  "name": "List.Chain.rec",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop},\n  (∀ {a : α}, motive a [] (_ : List.Chain R a [])) →\n    (∀ {a b : α} {l : List α} (a_1 : R a b) (a_2 : List.Chain R b l),\n        motive b l a_2 → motive a (b :: l) (_ : List.Chain R a (b :: l))) →\n      ∀ {a : α} {a_1 : List α} (t : List.Chain R a a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "And",
   "Iff.mp",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "Continuous",
   "continuous_prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "And.left"],
  "name": "continuous_fst",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], Continuous Prod.fst",
  "constCategory": "Theorem"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.mk",
  "constType": "{α : Type u_9} → (Set α → α) → InfSet α",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[>]_»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Continuous",
   "TopologicalSpace",
   "ContinuousMap",
   "autoParam",
   "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6"],
  "name": "ContinuousMap.mk",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : TopologicalSpace β] → (toFun : α → β) → autoParam (Continuous toFun) _auto✝ → C(α, β)",
  "constCategory": "Other"},
 {"references": ["And", "and_imp", "Iff", "False", "Not"],
  "name": "not_and",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ a → ¬b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["Quot.rec", "Eq.ndrec", "Quot", "Quot.sound", "Eq", "Quot.mk"],
  "name": "Quot.recOn'",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (q : Quot r) →\n        (f : (a : α) → motive (Quot.mk r a)) →\n          (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → motive q",
  "constCategory": "Definition"},
 {"references": ["Topology.WithUpper.rec._rarg", "_obj", "_neutral"],
  "name": "Topology.WithUpper.rec._cstage2",
  "constType": "_neutral → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["trivial", "eq_true", "True", "Eq"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (α → True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "False.casesOn",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet"],
  "name": "Set.empty_subset.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (a : α) → a ∈ ∅ → Prop) (a : α) (a_1 : a ∈ ∅), motive a a_1",
  "constCategory": "Definition"},
 {"references": ["Function.comp", "rfl", "Eq", "id"],
  "name": "Function.comp.right_id",
  "constType": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), f ∘ id = f",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsClosed_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.EvalInformation",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["SupSet", "CompleteBooleanAlgebra"],
  "name": "CompleteBooleanAlgebra.toSupSet",
  "constType": "{α : Type u_1} → [self : CompleteBooleanAlgebra α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "t0Space_iff_inseparable.match_1",
   "TopologicalSpace",
   "T0Space.mk",
   "T0Space",
   "Inseparable",
   "Eq"],
  "name": "t0Space_iff_inseparable",
  "constType":
  "∀ (α : Type u) [inst : TopologicalSpace α], T0Space α ↔ ∀ (x y : α), Inseparable x y → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "Eq.refl",
   "Symmetric",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "List.Perm.symm",
   "Eq.mpr",
   "List.Perm.cons_inv",
   "Iff",
   "List.Pairwise.rec",
   "List.perm_middle",
   "List.nil",
   "Eq.symm",
   "id",
   "Membership.mem",
   "List.cons",
   "List.mem_split",
   "List.pairwise_middle",
   "Iff.intro",
   "List.Pairwise",
   "List.Perm.subset",
   "instHAppend",
   "And",
   "Eq.ndrec",
   "List.Perm",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "List.pairwise_cons",
   "List.mem_cons_self",
   "List.Perm.trans",
   "And.intro",
   "List.Perm.nil_eq"],
  "name": "List.Perm.pairwise_iff",
  "constType":
  "∀ {α : Type uu} {R : α → α → Prop},\n  Symmetric R → ∀ {l₁ l₂ : List α}, l₁ ~ l₂ → (List.Pairwise R l₁ ↔ List.Pairwise R l₂)",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat"],
  "name": "UInt64.size",
  "constType": "ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.le_inf",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : DistribLattice α] (a b c : αᵒᵈ), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → γ) → Insert α γ",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.mem_range_self",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} (i : ι), f i ∈ Set.range f",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "LE", "LE.le"],
  "name": "Pi.hasLe",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → LE (α i)] → LE ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references":
  ["Char.val",
   "Decidable.casesOn",
   "UInt32",
   "Char",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Eq"],
  "name": "instDecidableEqChar.match_1",
  "constType":
  "(c d : Char) →\n  (motive : Decidable (c.val = d.val) → Sort u_1) →\n    (x : Decidable (c.val = d.val)) →\n      ((h : c.val = d.val) → motive (isTrue h)) → ((h : ¬c.val = d.val) → motive (isFalse h)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.SourceInfo", "Substring", "String.Pos"],
  "name": "Lean.SourceInfo.original",
  "constType":
  "Substring → String.Pos → Substring → String.Pos → Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "Eq.rec",
   "Continuous",
   "Eq.refl",
   "TopologicalSpace",
   "ContinuousMap",
   "Eq.symm",
   "autoParam",
   "_auto._@.Mathlib.Topology.ContinuousFunction.Basic._hyg.6",
   "ContinuousMap.casesOn",
   "ContinuousMap.toFun",
   "ContinuousMap.mk",
   "Eq"],
  "name": "ContinuousMap.toContinuousMapClass.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f g : C(α, β)),\n  f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsIdempotent",
  "constType": "(α : Type u) → (α → α → α) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "LE",
   "Set.univ",
   "LE.le",
   "Set.instMembershipSet",
   "id"],
  "name": "isLowerSet_univ",
  "constType": "∀ {α : Type u_1} [inst : LE α], IsLowerSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "TopologicalSpace.generateFrom",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "setOf",
   "Function.comp",
   "Set",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
   "OrderDual.ofDual",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "TopologicalSpace.mkOfClosure_sets",
   "TopologicalSpace.mkOfClosure",
   "TopologicalSpace",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.Subset.antisymm",
   "IsOpen"],
  "name": "TopologicalSpace.gciGenerateFrom.proof_3",
  "constType":
  "∀ (α : Type u_1) (x : (Set (Set α))ᵒᵈ) (x_1 : x ≤ ↑OrderDual.toDual {s | IsOpen s}),\n  TopologicalSpace.mkOfClosure x (_ : {u | TopologicalSpace.GenerateOpen x u} = x) = TopologicalSpace.generateFrom x",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "OrderDual.instPreorder",
   "Iff",
   "Topology.IsLower",
   "OrderDual.instIsUpper",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Preorder"],
  "name": "Topology.isUpper_orderDual",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α], Topology.IsUpper αᵒᵈ ↔ Topology.IsLower α",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), ZeroHom.toFun (↑f) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet", "Set", "HasSubset.Subset", "Set.Subset.refl"],
  "name": "Set.Subset.rfl",
  "constType": "∀ {α : Type u} {s : Set α}, s ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["And", "False", "Not", "and_not_self.match_1"],
  "name": "and_not_self",
  "constType": "∀ {a : Prop}, ¬(a ∧ ¬a)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Prod.casesOn", "Prod.mk", "LE", "Prod", "LE.le"],
  "name": "Prod.instPreorderProd.match_5",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) (src : LE (α × β)) (x : α × β) (motive : (x_1 : α × β) → x_1 ≤ x → Prop) (x_1 : α × β)\n  (x_2 : x_1 ≤ x), (∀ (a : α) (b : β) (x : (a, b) ≤ x), motive (a, b) x) → motive x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.IsUpper.WithUpperHomeomorph._rarg", "_neutral"],
  "name": "Topology.IsUpper.WithUpperHomeomorph._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "Quot",
   "PSigma.eta",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.indepCoherent",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a)),\n  (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) →\n    ∀ (a b : α), r a b → Quot.indep f a = Quot.indep f b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "And.left",
   "Iff.mpr",
   "List.Pairwise",
   "And",
   "Iff.mp",
   "List.chain_cons",
   "List",
   "List.pairwise_cons",
   "List.Pairwise.rec",
   "Eq.mp",
   "List.Chain.nil",
   "List.nil",
   "And.intro",
   "List.Chain",
   "Std.Data.List.Lemmas._auxLemma.101",
   "List.Pairwise.chain.match_1"],
  "name": "List.Pairwise.chain",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α}, List.Pairwise R (a :: l) → List.Chain R a l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Iff.symm",
   "And",
   "Iff",
   "Filter.eq_sInf_of_mem_iff_exists_mem",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter",
   "Iff.trans",
   "Set.exists_range_iff",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.eq_iInf_of_mem_iff_exists_mem",
  "constType":
  "∀ {α : Type u} {ι : Sort x} {f : ι → Filter α} {l : Filter α}, (∀ {s : Set α}, s ∈ l ↔ ∃ i, s ∈ f i) → l = iInf f",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le", "bot_le"],
  "name": "Pi.orderBot.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → LE (α' i)] [inst_1 : (i : ι) → OrderBot (α' i)]\n  (x : (i : ι) → α' i) (x_1 : ι), ⊥ ≤ x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "Eq.refl",
   "implies_congr",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Filter.principal",
   "Iff",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "TopologicalSpace",
   "Filter",
   "Eq.trans",
   "IsOpen",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "Std.Logic._auxLemma.23",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "And",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "Mathlib.Order.CompleteLattice._auxLemma.8",
   "congrFun"],
  "name": "le_nhds_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {f : Filter α} {a : α}, f ≤ nhds a ↔ ∀ (s : Set α), a ∈ s → IsOpen s → s ∈ f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "GeneralizedCoheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_13",
   "Topology.IsOpen_of._closed_11"],
  "name": "Topology.IsOpen_of._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List",
   "Multiset.attach",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "List.mem_attach"],
  "name": "Multiset.mem_attach",
  "constType":
  "∀ {α : Type u_1} (s : Multiset α) (x : { x // x ∈ s }), x ∈ Multiset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "Iff",
   "Inf.inf",
   "Set",
   "Set.Nonempty",
   "Filter.instInfFilter",
   "Filter.basis_sets",
   "Inter.inter",
   "Filter",
   "Filter.NeBot",
   "Filter.HasBasis.inf_principal_neBot_iff",
   "Set.instInterSet",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.inf_principal_neBot_iff",
  "constType":
  "∀ {α : Type u_1} {l : Filter α} {s : Set α}, Filter.NeBot (l ⊓ Filter.principal s) ↔ ∀ U ∈ l, Set.Nonempty (U ∩ s)",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedCoheytingAlgebra", "SDiff"],
  "name": "GeneralizedCoheytingAlgebra.toSDiff",
  "constType":
  "{α : Type u_4} → [self : GeneralizedCoheytingAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.right",
   "Iff",
   "forall_and.match_1",
   "And.intro",
   "And.left"],
  "name": "forall_and",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) ↔ (∀ (x : α), p x) ∧ ∀ (x : α), q x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.instInhabitedMacroScopesView",
   "cond.match_1",
   "List.cons",
   "Lean.Name.brecOn",
   "Lean.Name.below",
   "Lean.Name.num",
   "Lean.MacroScopesView",
   "String",
   "Unit",
   "instBEq",
   "Lean.MacroScope",
   "Eq",
   "_private.Init.Prelude.0.Lean.extractImported",
   "_private.Init.Prelude.0.Lean.assembleParts",
   "PProd",
   "namedPattern",
   "Lean.Name.rec",
   "PProd.fst",
   "BEq.beq",
   "List",
   "PUnit",
   "Lean.MacroScopesView.mk",
   "panic",
   "List.nil",
   "Bool",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "_private.Init.Prelude.0.Lean.extractImported.match_1",
   "instDecidableEqString",
   "Lean.Name.str"],
  "name": "_private.Init.Prelude.0.Lean.extractMainModule",
  "constType":
  "List Lean.MacroScope → Lean.Name → List Lean.Name → Lean.MacroScopesView",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.closure_of._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.«termI^_»._closed_11",
   "Topology.«termI^_»._closed_3"],
  "name": "Topology.«termI^_»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Directed",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "ball_congr",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "forall_congr",
   "Mathlib.Order.Directed._auxLemma.2",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Directed._auxLemma.1",
   "DirectedOn",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.40",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "DirectedOn.directed_val",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} {s : Set α}, DirectedOn r s → Directed r Subtype.val",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteSemilatticeSup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Filter.filter_eq.match_1",
   "Set.instHasSubsetSet",
   "Filter.mk",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.univ",
   "rfl",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.filter_eq",
  "constType": "∀ {α : Type u} {f g : Filter α}, f.sets = g.sets → f = g",
  "constCategory": "Theorem"},
 {"references": ["Min.min", "Eq.refl", "Nat", "instMinNat", "Eq"],
  "name": "Nat.linearOrder.proof_1",
  "constType": "∀ (a b : ℕ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references": ["Set", "Filter"],
  "name": "Filter.sets",
  "constType": "{α : Type u_1} → Filter α → Set (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "LE.mk",
   "And",
   "propext",
   "Iff.rfl",
   "LT.lt",
   "Function.comp",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder.proof_2",
  "constType": "∀ (x x_1 : Prop), x ≤ x_1 → x_1 ≤ x → x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "Topology.IsLower.isClosed_upperClosure",
   "OrderDual.instPreorder",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "IsClosed",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "lowerClosure",
   "Preorder.toLE",
   "Set.Finite",
   "SetLike.coe"],
  "name": "Topology.IsUpper.isClosed_lowerClosure",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] {s : Set α},\n  Set.Finite s → IsClosed ↑(lowerClosure s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "nhds",
   "propext",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.49",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, (s ∈ nhds a) = ∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.Nonempty",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Set.instInterSet"],
  "name": "mem_closure_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {s : Set α} (x : Set α) (motive : Set.Nonempty (xᶜ ∩ s) → Prop) (x_1 : Set.Nonempty (xᶜ ∩ s)),\n  (∀ (w : α) (hc : w ∈ xᶜ) (hs : w ∈ s), motive (_ : ∃ x_2, x_2 ∈ xᶜ ∩ s)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.toSup",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop"],
  "name": "Set.instBooleanAlgebraSet.proof_13",
  "constType": "∀ {α : Type u_1} (x : α → Prop), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.induced.proof_2",
   "TopologicalSpace.mk",
   "And",
   "Exists",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced.proof_3",
   "IsOpen",
   "TopologicalSpace.induced.proof_1",
   "Eq"],
  "name": "TopologicalSpace.induced",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → TopologicalSpace β → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "CompleteBooleanAlgebra",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "CompleteBooleanAlgebra.toInfSet",
   "Set.instMembershipSet"],
  "name": "CompleteBooleanAlgebra.le_sInf",
  "constType":
  "∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EmbeddingLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Eq.mpr",
   "Topology.IsUpperSet",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "TopologicalSpace",
   "Topology.IsUpperSet.topology_eq",
   "Topology.upperSet",
   "IsUpperSet",
   "Preorder",
   "IsOpen",
   "Preorder.toLE",
   "Eq",
   "id"],
  "name": "Topology.IsUpperSet.isOpen_iff_isUpperSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α] {s : Set α},\n  IsOpen s ↔ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Top.top",
   "LE.le.trans",
   "le_top",
   "Preorder",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "PartialOrder",
   "Eq",
   "OrderTop.toTop",
   "Eq.mpr",
   "GaloisInsertion.le_l_u",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "GaloisConnection.monotone_l",
   "OrderTop",
   "congrArg",
   "Top.mk",
   "id"],
  "name": "GaloisInsertion.liftOrderTop.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : Preorder α]\n  [inst_2 : OrderTop α] (gi : GaloisInsertion l u) (a : β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.brecOn",
   "List.below",
   "List.Perm.refl",
   "List.perm_middle.match_1",
   "List.Perm.swap",
   "List.Perm.cons",
   "instHAppend",
   "PProd",
   "PProd.fst",
   "List.Perm",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.Perm.trans",
   "List.nil"],
  "name": "List.perm_middle",
  "constType":
  "∀ {α : Type uu} {a : α} {l₁ l₂ : List α}, l₁ ++ a :: l₂ ~ a :: (l₁ ++ l₂)",
  "constCategory": "Theorem"},
 {"references": ["PLift.up", "PLift.down", "rfl", "Eq"],
  "name": "PLift.down_up",
  "constType": "∀ {α : Sort u} (a : α), { down := a }.down = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.Chain.rec",
   "List.cons",
   "List",
   "List.Chain.nil",
   "List.nil",
   "List.Chain",
   "List.Chain.cons"],
  "name": "List.Chain.casesOn",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop} {a : α}\n  {a_1 : List α} (t : List.Chain R a a_1),\n  (∀ {a : α}, motive a [] (_ : List.Chain R a [])) →\n    (∀ {a b : α} {l : List α} (a_2 : R a b) (a_3 : List.Chain R b l), motive a (b :: l) (_ : List.Chain R a (b :: l))) →\n      motive a a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_le.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive Nat.zero) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "Std.Logic._auxLemma.13",
   "of_eq_true",
   "Std.Logic._auxLemma.7",
   "congr",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun"],
  "name": "and_congr_left_iff",
  "constType": "∀ {a c b : Prop}, (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "Inf.inf",
   "disjoint_iff",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "BoundedOrder.toOrderTop",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "codisjoint_iff",
   "Codisjoint",
   "Lattice.toInf",
   "OrderTop.toTop",
   "SemilatticeSup.toSup",
   "OrderBot.toBot",
   "Sup.sup",
   "IsCompl.mk",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "IsCompl.of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Lattice α] [inst_1 : BoundedOrder α] {x y : α}, x ⊓ y = ⊥ → x ⊔ y = ⊤ → IsCompl x y",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "Or",
   "List.insert",
   "Or.inr",
   "Iff.rfl",
   "List.instMembershipList",
   "List.mem_cons",
   "Eq.refl",
   "dite",
   "Eq",
   "List.mem_insert_iff.match_1",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "List.insert_of_not_mem",
   "DecidableEq",
   "propext",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Not",
   "List.insert_of_mem",
   "id"],
  "name": "List.mem_insert_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ∈ List.insert b l ↔ a = b ∨ a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Inter.inter",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "inf_top_eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instBooleanAlgebraSet",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instInterSet"],
  "name": "Set.inter_univ",
  "constType": "∀ {α : Type u} (a : Set α), a ∩ Set.univ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsUpperSet",
   "Eq.ndrec",
   "Topology.IsUpperSet.noConfusionType",
   "TopologicalSpace",
   "Topology.upperSet",
   "Topology.IsUpperSet.casesOn",
   "Preorder",
   "Eq"],
  "name": "Topology.IsUpperSet.noConfusion",
  "constType":
  "{α : Type u_4} →\n  {t : TopologicalSpace α} →\n    {inst : Preorder α} →\n      {P : Sort u} → {v1 v2 : Topology.IsUpperSet α} → v1 = v2 → Topology.IsUpperSet.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Nat.decLt",
   "Eq.refl",
   "Classical.em",
   "eq_true_of_decide",
   "instLTNat",
   "True",
   "Eq",
   "ite",
   "Eq.mpr",
   "List.rec",
   "eq_false'",
   "instDecidableNot",
   "Bool.true",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "if_neg",
   "id",
   "Ne",
   "List.cons",
   "Or",
   "False",
   "Lean.Data.AC.insert",
   "Or.casesOn",
   "instDecidableFalse",
   "if_pos",
   "of_eq_true",
   "List",
   "LT.lt",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "Lean.Data.AC.insert_nonEmpty",
  "constType": "∀ {x : ℕ} {xs : List ℕ}, Lean.Data.AC.insert x xs ≠ []",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Iff.intro",
   "Exists",
   "Set.mem_iInter.match_1",
   "Iff",
   "setOf",
   "Eq.rec",
   "Set",
   "Set.iInter",
   "Exists.intro",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_iInter",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, x ∈ ⋂ i, s i ↔ ∀ (i : ι), x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α}, (a ∈ b :: l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "Prod.instLEProd",
   "OrderBot.bot_le",
   "Prod",
   "Prod.boundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE"],
  "name": "Prod.completeLattice.proof_9",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (a : α × β), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma", "Eq.ndrec", "Eq.rec", "Eq.refl", "PSigma.mk", "rfl", "Eq"],
  "name": "PSigma.eta",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {a₁ a₂ : α} {b₁ : β a₁} {b₂ : β a₂} (h₁ : a₁ = a₂),\n  h₁ ▸ b₁ = b₂ → { fst := a₁, snd := b₁ } = { fst := a₂, snd := b₂ }",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≠]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.mem_def",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.15",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s) = (a ∈ s.val)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "Membership.mem",
   "Filter.HasBasis",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter.exists_mem_subset_iff",
   "Filter",
   "Filter.HasBasis.mk",
   "id",
   "instMembershipSetFilter"],
  "name": "Filter.basis_sets",
  "constType":
  "∀ {α : Type u_1} (l : Filter α), Filter.HasBasis l (fun s ↦ s ∈ l) id",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Exists",
   "Iff.mp",
   "Finite",
   "Nat",
   "finite_iff_exists_equiv_fin",
   "Fin",
   "Nonempty"],
  "name": "Finite.exists_equiv_fin",
  "constType": "∀ (α : Sort u_3) [h : Finite α], ∃ n, Nonempty (α ≃ Fin n)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Topology.WithLowerSet",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Definition"},
 {"references":
  ["Set.fintypePure",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set",
   "Singleton.singleton",
   "Finite.of_fintype",
   "Set.Finite",
   "Set.toFinite"],
  "name": "Set.finite_singleton",
  "constType": "∀ {α : Type u} (a : α), Set.Finite {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "Set.sUnion",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.nhds_generateFrom.match_3",
  "constType":
  "∀ {α : Type u_1} {a : α} (S : Set (Set α)) (motive : a ∈ ⋃₀ S → Prop) (ha : a ∈ ⋃₀ S),\n  (∀ (t : Set α) (htS : t ∈ S) (hat : a ∈ t), motive (_ : ∃ t ∈ S, a ∈ t)) → motive ha",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.upperSet._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "IsGLB",
   "EmptyCollection.emptyCollection",
   "isGLB_empty_iff",
   "Top.top",
   "Set",
   "isTop_top",
   "OrderTop",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "IsTop",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "isGLB_empty",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α], IsGLB ∅ ⊤",
  "constCategory": "Theorem"},
 {"references": ["subset_trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "HasSubset.Subset.trans",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 ↦ x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.continuous",
   "Equiv",
   "Continuous",
   "TopologicalSpace",
   "Inducing",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toHomeomorphOfInducing.proof_1",
  "constType":
  "∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : X ≃ Y),\n  Inducing ↑f → Continuous ↑f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_ndunion",
   "Or",
   "Iff",
   "DecidableEq",
   "Union.union",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Finset.instUnionFinset"],
  "name": "Finset.mem_union",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["List.attach.proof_1",
   "Membership.mem",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Eq.refl",
   "List.attach",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
  "constType":
  "∀ {α : Type u_1} (l : List α), List.attach l = List.pmap Subtype.mk l (_ : ∀ x ∈ l, x ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Topology.Bases._auxLemma.1",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instLTOrderDual",
   "Preorder.toLT",
   "LE.le.trans",
   "le_refl",
   "OrderDual",
   "Preorder",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "OrderDual.instPreorder",
  "constType": "(α : Type u_3) → [inst : Preorder α] → Preorder αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SeqRight", "Unit"],
  "name": "SeqRight.seqRight",
  "constType":
  "{f : Type u → Type v} → [self : SeqRight f] → {α β : Type u} → f α → (Unit → f β) → f β",
  "constCategory": "Definition"},
 {"references": ["Bot", "GeneralizedBooleanAlgebra"],
  "name": "GeneralizedBooleanAlgebra.toBot",
  "constType": "{α : Type u} → [self : GeneralizedBooleanAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝ˢ»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower.WithLowerHomeomorph.proof_1",
   "Equiv.toHomeomorphOfInducing",
   "Topology.IsLower",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Homeomorph",
   "Topology.WithLower.ofLower",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.IsLower.WithLowerHomeomorph",
  "constType":
  "{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsLower α] → Topology.WithLower α ≃ₜ α",
  "constCategory": "Definition"},
 {"references": ["PLift"],
  "name": "PLift.up",
  "constType": "{α : Sort u} → α → PLift α",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[<]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKind", "Nat", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.node",
  "constType": "Lean.SyntaxNodeKind → ℕ → Lean.ParserDescr → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "String",
   "Lean.Macro",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Lean.Macro.State",
   "List",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Lean.Syntax.ident",
   "List.nil",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsOpen_of._closed_7"],
  "name": "Topology.IsOpen_of._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.mem_def",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.22",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s) = (a ∈ s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["List.below",
   "List.brecOn",
   "List.Sublist",
   "Eq.refl",
   "Nat.succ.inj",
   "instLTNat",
   "rfl",
   "Iff.mpr",
   "Eq",
   "PProd",
   "Eq.mpr",
   "instLENat",
   "List.Sublist.eq_of_length.match_2",
   "Nat.lt_succ_self",
   "List.rec",
   "Eq.rec",
   "PUnit",
   "List.nil",
   "List.Sublist.eq_of_length.match_1",
   "Nat",
   "Eq.symm",
   "id",
   "List.Sublist.length_le",
   "List.cons",
   "False",
   "Nat.not_lt",
   "List.length",
   "LE.le",
   "PProd.fst",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "Not"],
  "name": "List.Sublist.eq_of_length",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.length l₁ = List.length l₂ → l₁ = l₂",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references": [],
  "name": "String.Pos",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{α : Type u} → (α → α → α) → Sup α",
  "constCategory": "Other"},
 {"references":
  ["le_bot_iff",
   "Bot.bot",
   "Iff",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "disjoint_iff_inf_le",
   "Inf.inf",
   "OrderBot.toBot",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Iff.trans",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "disjoint_iff",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ a ⊓ b = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Equiv.invFun", "Function.RightInverse"],
  "name": "Equiv.right_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.RightInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.instIsReflSetSubsetInstHasSubsetSet",
   "Set",
   "Mathlib.Topology.Inseparable._auxLemma.9",
   "HasSubset.Subset",
   "Mathlib.Topology.Inseparable._auxLemma.19",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Set.instIsAntisymmSetSubsetInstHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Specializes",
   "Mathlib.Topology.Inseparable._auxLemma.18",
   "Mathlib.Topology.Inseparable._auxLemma.20",
   "congr",
   "TopologicalSpace",
   "Singleton.singleton",
   "Inseparable",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "inseparable_iff_closure_eq",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y ↔ closure {x} = closure {y}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "False.elim",
   "EmptyCollection.emptyCollection",
   "Set",
   "iff_true_intro",
   "Set.instEmptyCollectionSet",
   "True",
   "Set.instMembershipSet"],
  "name": "Set.ball_empty_iff",
  "constType": "∀ {α : Type u} {p : α → Prop}, (∀ x ∈ ∅, p x) ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Specializes",
   "nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Inseparable",
   "le_antisymm_iff"],
  "name": "inseparable_iff_specializes_and",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, Inseparable x y ↔ x ⤳ y ∧ y ⤳ x",
  "constCategory": "Theorem"},
 {"references": ["And", "eq_false", "False", "And.left", "Eq"],
  "name": "false_and",
  "constType": "∀ (p : Prop), (False ∧ p) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "Filter",
   "And.intro",
   "And.casesOn",
   "instMembershipSetFilter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.join.match_1",
  "constType":
  "∀ {α : Type u_1} {x y : Set α} (f : Filter α) (motive : f ∈ {t | x ∈ t} ∩ {t | y ∈ t} → Prop)\n  (x_1 : f ∈ {t | x ∈ t} ∩ {t | y ∈ t}),\n  (∀ (h₁ : f ∈ {t | x ∈ t}) (h₂ : f ∈ {t | y ∈ t}), motive (_ : f ∈ {t | x ∈ t} ∧ f ∈ {t | y ∈ t})) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat", "instHAdd", "HAdd.hAdd", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "Nat.add_succ",
  "constType": "∀ (n m : ℕ), n + Nat.succ m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["Array",
   "Array.foldlM",
   "OfNat.ofNat",
   "Id",
   "Id.run",
   "instOfNatNat",
   "Nat",
   "Array.size",
   "optParam",
   "Id.instMonadId"],
  "name": "Array.foldl",
  "constType":
  "{α : Type u} → {β : Type v} → (β → α → β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → β",
  "constCategory": "Definition"},
 {"references": ["SupSet", "sSupHom", "Set", "SupSet.sSup", "Set.image", "Eq"],
  "name": "sSupHom.mk",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : SupSet α] →\n      [inst_1 : SupSet β] → (toFun : α → β) → (∀ (s : Set α), toFun (sSup s) = sSup (toFun '' s)) → sSupHom α β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Iff",
   "Iff.rfl",
   "Filter.map",
   "Set",
   "Filter",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_map'",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, t ∈ Filter.map m f ↔ {x | m x ∈ t} ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Mathlib.Order.Filter.Basic._auxLemma.13",
   "funext",
   "setOf",
   "of_eq_true",
   "Mathlib.Order.Filter.Basic._auxLemma.12",
   "Set",
   "Filter",
   "congrArg",
   "Set.univ",
   "Eq.trans",
   "True",
   "congrFun",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.join.proof_1",
  "constType":
  "∀ {α : Type u_1} (f : Filter (Filter α)), Set.univ ∈ {x | {x_1 | x ∈ x_1} ∈ f}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.Continuous_of._closed_8",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.Continuous_of._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadWithReader"],
  "name": "MonadWithReader.withReader",
  "constType":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → [self : MonadWithReader ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Macro.State",
   "List",
   "String",
   "Prod",
   "Lean.Name",
   "Lean.MacroScope"],
  "name": "Lean.Macro.State.mk",
  "constType": "Lean.MacroScope → List (Lean.Name × String) → Lean.Macro.State",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "List.cons",
   "List.insert",
   "List.instMembershipList",
   "True",
   "Eq",
   "ite",
   "if_pos",
   "DecidableEq",
   "of_eq_true",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Decidable",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.insert_of_mem",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, a ∈ l → List.insert a l = l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.attach.proof_1",
   "Multiset",
   "Multiset.pmap",
   "Subtype.mk",
   "Multiset.instMembershipMultiset",
   "Subtype"],
  "name": "Multiset.attach",
  "constType": "{α : Type u_1} → (s : Multiset α) → Multiset { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references": ["Equiv.refl", "_obj", "_neutral"],
  "name": "Topology.WithLowerSet.toLowerSetOrderIso._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "List.count_eq_length",
   "List.length_replicate",
   "List.replicate",
   "List.eq_of_mem_replicate",
   "instBEq",
   "List.length",
   "Nat",
   "Eq.symm",
   "List.count",
   "Eq.trans",
   "Iff.mpr",
   "Eq"],
  "name": "List.count_replicate_self",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (n : ℕ), List.count a (List.replicate n a) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "GetElem.getElem",
   "OfNat.ofNat",
   "Nat.decLt",
   "HAdd.hAdd",
   "dite",
   "Pure.pure",
   "instLTNat",
   "Monad.toBind",
   "Array",
   "PProd",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Bind.bind",
   "Nat.succ",
   "Applicative.toPure",
   "Array.foldlM.loop.proof_1",
   "Nat.below",
   "Nat.brecOn",
   "Monad.toApplicative",
   "instAddNat",
   "Array.foldlM.loop.match_1",
   "instHAdd",
   "Unit",
   "Array.size",
   "LE.le",
   "PProd.fst",
   "Nat.rec",
   "LT.lt",
   "Not",
   "instGetElemArrayNatLtInstLTNatSize"],
  "name": "Array.foldlM.loop",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → (as : Array α) → (stop : ℕ) → stop ≤ Array.size as → ℕ → ℕ → β → m β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "Filter.HasBasis.mem_iff'",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {t : Set α},\n  Filter.HasBasis l p s → (t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKinds", "Lean.TSyntaxArray", "Lean.Syntax"],
  "name": "Lean.TSyntaxArray.raw",
  "constType":
  "{ks : Lean.SyntaxNodeKinds} → Lean.TSyntaxArray ks → Array Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "instHAppend",
   "List.instAppendList",
   "List.instMembershipList",
   "HAppend.hAppend",
   "propext",
   "List",
   "List.pairwise_append",
   "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {l₁ l₂ : List α},\n  List.Pairwise R (l₁ ++ l₂) = (List.Pairwise R l₁ ∧ List.Pairwise R l₂ ∧ ∀ a ∈ l₁, ∀ b ∈ l₂, R a b)",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.preimage",
   "Set",
   "HasSubset.Subset",
   "Eq.refl",
   "IsClosed.preimage",
   "closure_mono",
   "subset_closure",
   "Eq",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "isClosed_closure",
   "Eq.ndrec",
   "Continuous",
   "TopologicalSpace",
   "IsClosed.closure_eq",
   "Set.preimage_mono",
   "Eq.symm",
   "id"],
  "name": "Continuous.closure_preimage_subset",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ (t : Set β), closure (f ⁻¹' t) ⊆ f ⁻¹' closure t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Set.Elem",
   "propext",
   "Set.toFinset",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.mem_toFinset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.23",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ Set.toFinset s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_3",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "OrderDual"],
  "name": "OrderDual.toDual",
  "constType": "{α : Type u_1} → α ≃ αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.mk",
   "TopologicalSpace.GenerateOpen.univ",
   "TopologicalSpace.GenerateOpen.inter",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.GenerateOpen.sUnion",
   "TopologicalSpace.GenerateOpen"],
  "name": "TopologicalSpace.generateFrom",
  "constType": "{α : Type u} → Set (Set α) → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«termI^_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "LE.le.trans",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "implies_congr",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.le_l_u",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "GaloisConnection.monotone_l",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_4",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeInf α]\n  (gi : GaloisInsertion l u) (a b c : β), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Order.Directed._auxLemma.2",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelMonoid.add_right_cancel",
  "constType":
  "∀ {M : Type u} [self : AddCancelMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Eq.symm",
   "Eq.subset",
   "Set.Subset.antisymm",
   "Set.Subset.antisymm_iff.match_1",
   "Eq"],
  "name": "Set.Subset.antisymm_iff",
  "constType": "∀ {α : Type u} {a b : Set α}, a = b ↔ a ⊆ b ∧ b ⊆ a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Finite", "Nat", "Fin"],
  "name": "Finite.intro",
  "constType": "∀ {α : Sort u_1} {n : ℕ}, α ≃ Fin n → Finite α",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Function.Surjective",
   "Equiv.instEquivLikeEquiv",
   "EquivLike.surjective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.surjective",
  "constType":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Surjective ↑e",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instBooleanAlgebraSet",
   "Union.union",
   "compl_inf",
   "Set",
   "HasCompl.compl",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.compl_inter",
  "constType": "∀ {α : Type u} (s t : Set α), (s ∩ t)ᶜ = sᶜ ∪ tᶜ",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": ["SizeOf", "sizeOfWFRel", "WellFoundedRelation"],
  "name": "instWellFoundedRelation",
  "constType": "{α : Sort u_1} → [inst : SizeOf α] → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.termπ_._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadReaderOf", "semiOutParam"],
  "name": "MonadReaderOf.read",
  "constType":
  "{ρ : semiOutParam (Type u)} → {m : Type u → Type v} → [self : MonadReaderOf ρ m] → m ρ",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "And.intro",
   "IsLeast",
   "Preorder",
   "And.left",
   "Set.instMembershipSet"],
  "name": "IsLeast.isGLB",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsLeast s a → IsGLB s a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.mem_of_superset",
   "CompleteLattice.toBoundedOrder",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "bot_unique",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.rec",
   "Set.empty_subset",
   "OrderBot.toBot",
   "Filter.instPartialOrderFilter",
   "Filter.mem_bot",
   "Filter",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.empty_mem_iff_bot",
  "constType": "∀ {α : Type u} {f : Filter α}, ∅ ∈ f ↔ f = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.fintypeEmpty",
   "Set.Elem",
   "Set",
   "Set.instEmptyCollectionSet",
   "Finite.of_fintype",
   "Set.Finite",
   "Set.toFinite"],
  "name": "Set.finite_empty",
  "constType": "∀ {α : Type u}, Set.Finite ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingletonFinset",
  "constType": "{α : Type u_1} → Singleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "OfNat.ofNat",
   "List.instMembershipList",
   "List.exists_mem_of_length_pos.match_1",
   "List",
   "LT.lt",
   "List.Mem.head",
   "instOfNatNat",
   "Exists.intro",
   "List.length",
   "Nat",
   "instLTNat"],
  "name": "List.exists_mem_of_length_pos",
  "constType": "∀ {α : Type u_1} {l : List α}, 0 < List.length l → ∃ a, a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.«term𝓝[≠]_»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≠]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Membership.mem",
   "OfNat.ofNat",
   "List.cons",
   "PartialOrder.toPreorder",
   "nhds",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "Pure.pure",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "List.TFAE.out",
   "Filter.instPureFilter",
   "Iff",
   "Specializes",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "instOfNatNat",
   "Singleton.singleton",
   "Filter",
   "List.nil",
   "IsClosed",
   "List.get?",
   "Nat",
   "IsOpen",
   "specializes_TFAE",
   "Option"],
  "name": "specializes_iff_closure_subset",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ⤳ y ↔ closure {y} ⊆ closure {x}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_1"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "compl_le_compl",
   "compl_compl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Eq.mp",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "congrArg",
   "HeytingAlgebra.toHasCompl"],
  "name": "compl_le_of_compl_le",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], yᶜ ≤ x → xᶜ ≤ y",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo", "Lean.Syntax", "Option"],
  "name": "Lean.Syntax.getHeadInfo?",
  "constType": "Lean.Syntax → Option Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "Filter.comap",
   "HasSubset.Subset",
   "Filter",
   "And.intro",
   "Exists.intro",
   "Set.Subset.rfl",
   "instMembershipSetFilter"],
  "name": "Filter.preimage_mem_comap",
  "constType":
  "∀ {α : Type u} {β : Type v} {g : Filter β} {m : α → β} {t : Set β}, t ∈ g → m ⁻¹' t ∈ Filter.comap m g",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_1",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] (a b : (i : ι) → α i), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "List.nil",
   "Lean.SourceInfo.fromRef"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.MonadRef",
  "constType": "(Type → Type) → Type 1",
  "constCategory": "Other"},
 {"references":
  ["GaloisConnection",
   "Filter.map_le_iff_le_comap",
   "PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter.comap",
   "Filter"],
  "name": "Filter.gc_map_comap",
  "constType":
  "∀ {α : Type u} {β : Type v} (m : α → β), GaloisConnection (Filter.map m) (Filter.comap m)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.erase.match_1",
   "List.nil",
   "Bool",
   "List.isEmpty.match_1"],
  "name": "List.filter",
  "constType": "{α : Type u} → (α → Bool) → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "Set.instSingletonSet",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set",
   "Sup.sup",
   "isLUB_singleton",
   "Singleton.singleton",
   "Insert.insert",
   "IsLUB.insert",
   "IsLUB",
   "SemilatticeSup.toPartialOrder",
   "Set.instInsertSet"],
  "name": "isLUB_pair",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeSup γ] {a b : γ}, IsLUB {a, b} (a ⊔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Equiv.refl",
   "lcProof",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "RelIso.mk",
   "Preorder",
   "Topology.WithUpperSet.toUpperSet",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.toUpperSetOrderIso._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → α ≃o Topology.WithUpperSet α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Alternative",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Lean.Name.mkStr3",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HImp",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["And", "propext", "and_true_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.4",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.lattice",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_2",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] (a b : (i : ι) → α i), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["Max.mk", "LE", "Max", "LE.le", "ite", "DecidableRel"],
  "name": "maxOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Mathlib.Data.Set.Lattice._auxLemma.2",
   "Set.univ",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.sUnion",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.sUnion_eq_univ_iff",
  "constType":
  "∀ {α : Type u_1} {c : Set (Set α)}, ⋃₀ c = Set.univ ↔ ∀ (a : α), ∃ b ∈ c, a ∈ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.term𝓝._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "exists_congr",
   "And.left",
   "Filter.HasBasis.mem_iff",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_nhds_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, s ∈ nhds a ↔ ∃ t, t ⊆ s ∧ IsOpen t ∧ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "List.Pairwise.nil",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Data.List.Range._hyg.49",
   "instIsTransLtToLT",
   "optParam",
   "autoParam",
   "List.pairwise_lt_range'.match_1",
   "instLTNat",
   "List.Pairwise",
   "List.chain_iff_pairwise",
   "Nat.add",
   "Iff.mp",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "List.chain_lt_range'",
   "List.Chain",
   "Nat.strictOrderedSemiring"],
  "name": "List.pairwise_lt_range'",
  "constType":
  "∀ (s n : ℕ) (step : optParam ℕ 1),\n  autoParam (0 < step) _auto✝ → List.Pairwise (fun x x_1 ↦ x < x_1) (List.range' s n step)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "eq_true",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_right",
   "True",
   "Eq",
   "Set.instInterSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.27",
  "constType": "∀ {α : Type u} (s t : Set α), (s ∩ t ⊆ t) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "LE.le.trans",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iInf_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "iInf_le_of_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α} (i : ι), f i ≤ a → iInf f ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Function.LeftInverse",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Eq.rec",
   "Set",
   "HasSubset.Subset",
   "Set.image",
   "Eq.symm",
   "Set.image_subset_preimage_of_inverse.match_1",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_preimage_of_inverse",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {g : β → α}, Function.LeftInverse g f → ∀ (s : Set α), f '' s ⊆ g ⁻¹' s",
  "constCategory": "Theorem"},
 {"references": ["BEq.beq", "BEq", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "LawfulBEq.eq_of_beq",
  "constType":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "HImp.himp",
   "Eq.mpr",
   "Iff",
   "himp_bot",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq.symm",
   "BoundedOrder.toOrderBot",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "GeneralizedHeytingAlgebra.toHImp",
   "HeytingAlgebra.toBot",
   "Disjoint",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "le_himp_iff",
   "propext",
   "disjoint_iff_inf_le",
   "HeytingAlgebra.toBoundedOrder",
   "OrderBot.toBot"],
  "name": "le_compl_iff_disjoint_right",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, a ≤ bᶜ ↔ Disjoint a b",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro",
   "Function.sometimes",
   "Classical.propDecidable",
   "dif_pos",
   "Not",
   "Classical.choice",
   "Nonempty",
   "Eq"],
  "name": "Function.sometimes_eq",
  "constType":
  "∀ {p : Prop} {α : Sort u_1} [inst : Nonempty α] (f : p → α) (a : p), Function.sometimes f = f a",
  "constCategory": "Theorem"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "Std.Logic._auxLemma.31",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Bot", "Nonempty.intro", "Bot.bot", "Nonempty"],
  "name": "bot_nonempty.proof_1",
  "constType": "∀ (α : Type u_1) [inst : Bot α], Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "Set.finite_def.match_2",
  "constType":
  "∀ {α : Type u_1} {s : Set α} (motive : Nonempty (Fintype ↑s) → Prop) (x : Nonempty (Fintype ↑s)),\n  (∀ (h : Fintype ↑s), motive (_ : Nonempty (Fintype ↑s))) → motive x",
  "constCategory": "Definition"},
 {"references": ["Not", "Filter", "Filter.Eventually"],
  "name": "Filter.Frequently",
  "constType": "{α : Type u} → (α → Prop) → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "funext",
   "Iff",
   "of_eq_true",
   "propext",
   "eq_comm",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.38",
   "congrFun",
   "Eq"],
  "name": "exists_eq_left'",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a' = a ∧ p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["List.tfae_cons_cons",
   "And",
   "List.cons",
   "Iff",
   "propext",
   "List",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.2",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.TFAE (a :: b :: l) = ((a ↔ b) ∧ List.TFAE (b :: l))",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.Injective",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Function.LeftInverse.injective"],
  "name": "EquivLike.toEmbeddingLike.proof_2",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e : E), Function.Injective (EquivLike.coe e)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Fin.val",
   "eq_of_heq",
   "LT.lt",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Fin.casesOn",
   "Eq"],
  "name": "Fin.eq_of_val_eq.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (x x_1 : Fin n) → ↑x = ↑x_1 → Prop) (x x_1 : Fin n) (x_2 : ↑x = ↑x_1),\n  (∀ (val : ℕ) (isLt isLt_1 : val < n),\n      motive { val := val, isLt := isLt } { val := val, isLt := isLt_1 }\n        (_ : ↑{ val := val, isLt := (_ : val < n) } = ↑{ val := val, isLt := (_ : val < n) })) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image2",
  "constType":
  "{α : Type u_1} → {β : Type u_3} → {γ : Type u_5} → (α → β → γ) → Set α → Set β → Set γ",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "List.instMembershipList",
   "propext",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.length",
   "Nat",
   "List.length_pos_iff_exists_mem",
   "instLTNat",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {l : List α}, (0 < List.length l) = ∃ a, a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.mem_iInter",
   "propext",
   "Set",
   "Set.iInter",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, (x ∈ ⋂ i, s i) = ∀ (i : ι), x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "induced_id",
   "Topology.WithUpperSet.ofUpperSet",
   "Inducing.mk",
   "Topology.WithUpperSet",
   "Eq.refl",
   "Inducing",
   "Topology.upperSet",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Topology.IsUpperSet",
   "Eq.mpr",
   "Eq.ndrec",
   "TopologicalSpace",
   "Topology.IsUpperSet.topology_eq",
   "TopologicalSpace.induced",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
   "id"],
  "name": "Topology.IsUpperSet.WithUpperSetHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α],\n  Inducing ↑Topology.WithUpperSet.ofUpperSet",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result.ok", "EStateM", "PUnit.unit", "PUnit"],
  "name": "EStateM.set",
  "constType": "{ε σ : Type u} → σ → EStateM ε σ PUnit.{u + 1}",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le", "And", "Iff", "Iff.rfl", "LT.lt", "Multiset", "Not", "LT.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_3",
  "constType": "∀ {α : Type u_1} (a b : Multiset α), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "List.get?_mem",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.492",
   "List",
   "Option.some",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.531",
   "List.get?",
   "Nat",
   "autoParam",
   "List.TFAE",
   "Option",
   "Eq"],
  "name": "List.TFAE.out",
  "constType":
  "∀ {l : List Prop},\n  List.TFAE l →\n    ∀ (n₁ n₂ : ℕ) {a b : Prop},\n      autoParam (List.get? l n₁ = some a) _auto✝ → autoParam (List.get? l n₂ = some b) _auto✝¹ → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) →\n          [toNontrivial : Nontrivial α] →\n            0 ≤ 1 →\n              (∀ (a b c : α), a < b → 0 < c → c * a < c * b) →\n                (∀ (a b c : α), a < b → 0 < c → a * c < b * c) → StrictOrderedSemiring α",
  "constCategory": "Other"},
 {"references": ["IsIdempotent", "Eq"],
  "name": "IsIdempotent.idempotent",
  "constType":
  "∀ {α : Type u} {op : α → α → α} [self : IsIdempotent α op] (a : α), op a a = a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Array.mkArray4",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node4",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "compl_involutive",
   "HasCompl.compl",
   "Function.Involutive.injective",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra"],
  "name": "compl_injective",
  "constType":
  "∀ {α : Type u} [inst : BooleanAlgebra α], Function.Injective compl",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "PartialOrder.toPreorder",
   "Prod.snd",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "Inf.mk",
   "And",
   "Inf",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] (x x_1 : α × β),\n  (x ⊓ x_1).1 ≤ x_1.1 ∧ (x ⊓ x_1).2 ≤ x_1.2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "iSup_le.match_1",
   "CompleteLattice.toInfSet",
   "Eq.rec",
   "Set",
   "le_sInf",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "le_iInf",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (∀ (i : ι), a ≤ f i) → a ≤ iInf f",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.intro",
  "constType": "∀ {α : Sort u}, (∀ (a b : α), a = b) → Subsingleton α",
  "constCategory": "Other"},
 {"references":
  ["List.instHasSubsetList",
   "List.pwFilter_sublist",
   "List.Sublist.subset",
   "List",
   "HasSubset.Subset",
   "List.pwFilter",
   "DecidableRel"],
  "name": "List.pwFilter_subset",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} [inst : DecidableRel R] (l : List α), List.pwFilter R l ⊆ l",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.semilatticeSup",
   "inferInstanceAs",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.lattice.proof_1",
  "constType":
  "∀ {ι : Type u_1} {α' : ι → Type u_2} [inst : (i : ι) → Lattice (α' i)] (a b : (i : ι) → α' i), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.val", "Decidable", "instLEFin", "Nat", "LE.le", "Nat.decLe", "Fin"],
  "name": "Fin.decLe",
  "constType": "{n : ℕ} → (a b : Fin n) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["OrderHom", "Preorder"],
  "name": "OrderHom.toFun",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Or.casesOn",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod_lt.match_1",
  "constType":
  "∀ (x y : ℕ) (motive : ¬0 < y ∨ ¬y ≤ x → Prop) (h₁ : ¬0 < y ∨ ¬y ≤ x),\n  (∀ (h₁ : ¬0 < y), motive (_ : ¬0 < y ∨ ¬y ≤ x)) → (∀ (h₁ : ¬y ≤ x), motive (_ : ¬0 < y ∨ ¬y ≤ x)) → motive h₁",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List.rec",
   "List",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Lean.Data.AC.evalList.match_1",
   "absurd",
   "id",
   "Eq"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.evalList.match_1.eq_3",
  "constType":
  "∀ (motive : List ℕ → Sort u_1) (x : ℕ) (xs : List ℕ) (h_1 : Unit → motive []) (h_2 : (x : ℕ) → motive [x])\n  (h_3 : (x : ℕ) → (xs : List ℕ) → motive (x :: xs)),\n  (xs = [] → False) →\n    (match x :: xs with\n      | [] => h_1 ()\n      | [x] => h_2 x\n      | x :: xs => h_3 x xs) =\n      h_3 x xs",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_11",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.IsOpen_of._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Lean.Name", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.getMainModule",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → m Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Continuous", "TopologicalSpace", "ContinuousMap", "ContinuousMap.toFun"],
  "name": "ContinuousMap.continuous_toFun",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : C(α, β)),\n  Continuous self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet.monotone_to_upperTopology_continuous",
   "Topology.IsLower",
   "Continuous",
   "OrderDual.instIsUpper",
   "OrderDual",
   "Monotone",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Monotone.dual",
   "OrderDual.instIsUpperSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.IsLowerSet.monotone_to_lowerTopology_continuous",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : TopologicalSpace α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Topology.IsLowerSet α] [inst_5 : Topology.IsLower β] {f : α → β},\n  Monotone f → Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "false_and",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "Option.noConfusion",
   "Std.Logic._auxLemma.45",
   "List.find?_cons.match_1",
   "implies_congr",
   "True",
   "Eq",
   "false_implies",
   "iff_self",
   "Std.Data.List.Lemmas._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "eq_false'",
   "Option.none",
   "forall_congr",
   "Bool.true",
   "Option.some",
   "List.nil",
   "_private.Std.Data.List.Lemmas.0.List.find?_cons.match_1.splitter",
   "Eq.symm",
   "Eq.trans",
   "instDecidableEqBool",
   "id",
   "Option",
   "Membership.mem",
   "eq_self",
   "Bool.not_eq_true",
   "Or",
   "List.cons",
   "False",
   "Unit",
   "implies_true",
   "eq_false_of_decide",
   "And",
   "List.find?",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "List",
   "Bool.false",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "congrFun"],
  "name": "List.find?_eq_none",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {l : List α}, List.find? p l = none ↔ ∀ x ∈ l, ¬p x = true",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.modCore",
   "Nat.mod.match_1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.mod",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«term𝓝[≥]_»._closed_3", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[≥]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«term𝓝[≠]_»._closed_5",
   "Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[≠]_»._closed_2"],
  "name": "Topology.«term𝓝[≠]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "And.imp_right",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "and_or_left.match_1",
   "And.intro",
   "Or.imp",
   "Or.rec"],
  "name": "and_or_left",
  "constType": "∀ {a b c : Prop}, a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Multiset.instPartialOrderMultiset.proof_2",
   "Multiset.instPartialOrderMultiset.proof_4",
   "Multiset",
   "Multiset.instPartialOrderMultiset.proof_3",
   "Not",
   "Multiset.instPartialOrderMultiset.proof_1",
   "LT.mk",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Multiset.instPartialOrderMultiset",
  "constType": "{α : Type u_1} → PartialOrder (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.70",
  "constType": "∀ {a b c : Prop}, (a ∧ b ∧ c) = (b ∧ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "continuous_coinduced_rng",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "TopologicalSpace.coinduced",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Equiv.invFun",
   "Continuous",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α],\n  Continuous\n    { toFun := ↑OrderDual.toDual, invFun := ↑OrderDual.ofDual,\n        left_inv := (_ : ∀ (a : αᵒᵈ), ↑OrderDual.toDual (↑OrderDual.ofDual a) = a),\n        right_inv := (_ : ∀ (a : Topology.WithLowerSet αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a) }.invFun",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Multiset",
   "Finset.mk",
   "Multiset.toFinset.proof_1",
   "Multiset.dedup"],
  "name": "Multiset.toFinset",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Set.mem_inter_iff",
   "Membership.mem",
   "And",
   "propext",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.36",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∩ b) = (x ∈ a ∧ x ∈ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Monad",
   "Set",
   "Function.comp",
   "Unit",
   "Function.const",
   "Functor.mk",
   "Monad.mk",
   "Applicative.mk",
   "Set.seq",
   "Set.instMembershipSet",
   "Set.instSingletonSet",
   "Set.iUnion",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "Singleton.singleton",
   "Set.image",
   "SeqRight.mk",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "Set.monad",
  "constType": "Monad Set",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableAnd.match_1",
  "constType":
  "{q : Prop} →\n  (motive : Decidable q → Sort u_1) →\n    (dq : Decidable q) → ((hq : q) → motive (isTrue hq)) → ((hq : ¬q) → motive (isFalse hq)) → motive dq",
  "constCategory": "Definition"},
 {"references": ["And", "Function.Surjective", "Function.Injective"],
  "name": "Function.Bijective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Set.ext",
   "Fintype",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Set.mem_toFinset",
   "Eq"],
  "name": "Set.coe_toFinset",
  "constType":
  "∀ {α : Type u_1} (s : Set α) [inst : Fintype ↑s], ↑(Set.toFinset s) = s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeInf.sInf_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Not", "absurd"],
  "name": "instDecidableIff.proof_4",
  "constType": "∀ {p q : Prop}, ¬p → ¬q → (p ↔ q)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SeqLeft",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "Inf",
   "Inf.inf",
   "Continuous",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "ContinuousInf"],
  "name": "ContinuousInf.mk",
  "constType":
  "∀ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Inf L], (Continuous fun p ↦ p.1 ⊓ p.2) → ContinuousInf L",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "Nat.lt_of_lt_of_le",
   "Eq.refl",
   "instLTNat",
   "ite",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.decLe",
   "if_neg",
   "Nat.modCore_eq_mod.match_1",
   "id",
   "instHSub",
   "False",
   "Nat.modCore",
   "HSub.hSub",
   "instDecidableAnd",
   "LE.le",
   "And",
   "Nat.instModNat",
   "instHMod",
   "Eq.ndrec",
   "Nat.zero",
   "LT.lt",
   "HMod.hMod",
   "Nat.lt_irrefl",
   "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
   "Nat.casesOn"],
  "name": "Nat.modCore_eq_mod",
  "constType": "∀ (x y : ℕ), Nat.modCore x y = x % y",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Filter.frequently_iff_forall_eventually_exists_and",
   "propext",
   "Filter",
   "Filter.Eventually",
   "Filter.Frequently",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.87",
  "constType":
  "∀ {α : Type u} {p : α → Prop} {f : Filter α},\n  (∃ᶠ (x : α) in f, p x) = ∀ {q : α → Prop}, (∀ᶠ (x : α) in f, q x) → ∃ x, p x ∧ q x",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "RelHomClass",
  "constType":
  "Type u_5 →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} → outParam (α → α → Prop) → outParam (β → β → Prop) → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["sup_inf_right",
   "Set.instBooleanAlgebraSet",
   "Union.union",
   "Set",
   "Inter.inter",
   "BooleanAlgebra.toDistribLattice",
   "Set.instUnionSet",
   "Set.instInterSet",
   "Eq"],
  "name": "Set.inter_union_distrib_right",
  "constType": "∀ {α : Type u} {s t u : Set α}, s ∩ t ∪ u = (s ∪ u) ∩ (t ∪ u)",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "TopologicalSpace",
   "IsClosed",
   "Preorder",
   "LE.le",
   "ClosedIciTopology",
   "Preorder.toLE"],
  "name": "ClosedIciTopology.isClosed_ge'",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : ClosedIciTopology α] (a : α),\n  IsClosed {b | a ≤ b}",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.decidableBEx.match_5",
   "PProd.fst",
   "cond",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "Bool"],
  "name": "List.eraseP",
  "constType": "{α : Type u_1} → (α → Bool) → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "nhds",
   "propext",
   "Set",
   "Set.Nonempty",
   "clusterPt_principal_iff",
   "TopologicalSpace",
   "Inter.inter",
   "Filter",
   "ClusterPt",
   "Eq",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Basic._auxLemma.41",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {x : α} {s : Set α},\n  ClusterPt x (Filter.principal s) = ∀ U ∈ nhds x, Set.Nonempty (U ∩ s)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "lt_iff_le_not_le"],
  "name": "Preorder.lift.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder β] (f : α → β) (x x_1 : α), f x < f x_1 ↔ f x ≤ f x_1 ∧ ¬f x_1 ≤ f x",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.toUpperSet._cstage1",
  "constType": "{α : Type u_1} → α ≃ Topology.WithUpperSet α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "GE.ge",
   "Eq.refl",
   "Preorder.toLE",
   "True",
   "Eq",
   "iff_self",
   "Iff.of_eq",
   "Set.ext",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "Set.iUnion",
   "Iff",
   "Filter",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter",
   "Membership.mem",
   "Filter.sets",
   "funext",
   "DirectedOn",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "Order.Preimage",
   "And",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "propext",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter.mem_biInf_of_directed",
   "congrArg",
   "exists_prop_congr'"],
  "name": "Filter.biInf_sets_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : β → Filter α} {s : Set β},\n  DirectedOn (f ⁻¹'o fun x x_1 ↦ x ≥ x_1) s → Set.Nonempty s → (⨅ i ∈ s, f i).sets = ⋃ i ∈ s, (f i).sets",
  "constCategory": "Theorem"},
 {"references": ["CoheytingAlgebra", "Top"],
  "name": "CoheytingAlgebra.toTop",
  "constType": "{α : Type u_4} → [self : CoheytingAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toBot",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "CompleteLattice.bot_le",
  "constType": "∀ {α : Type u_9} [self : CompleteLattice α] (x : α), ⊥ ≤ x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[≤]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "IsClosed",
   "Set.sInter"],
  "name": "closure",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "Set",
   "isBot_bot",
   "OrderBot.toBot",
   "OrderBot",
   "Set.Ici",
   "Preorder",
   "Set.univ",
   "Preorder.toLE",
   "Eq",
   "IsBot.Ici_eq"],
  "name": "Set.Ici_bot",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : OrderBot α], Set.Ici ⊥ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.eraseP",
   "List.cons",
   "cond",
   "of_eq_true",
   "List",
   "Bool.true",
   "Bool",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.eraseP_cons_of_pos",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} (p : α → Bool), p a = true → List.eraseP p (a :: l) = l",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Nat"],
  "name": "Lean.Macro.Context.maxRecDepth",
  "constType": "Lean.Macro.Context → ℕ",
  "constCategory": "Definition"},
 {"references": ["UInt32.val", "UInt32", "Fin.val", "Nat", "UInt32.size"],
  "name": "UInt32.toNat",
  "constType": "UInt32 → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.cons",
   "Lean.Data.AC.insert",
   "List.rec",
   "List",
   "Lean.Data.AC.sort.loop",
   "Lean.Data.AC.insert_nonEmpty",
   "List.nil",
   "Nat",
   "id"],
  "name": "Lean.Data.AC.Context.sort_loop_nonEmpty",
  "constType":
  "∀ {ys : List ℕ} (xs : List ℕ), xs ≠ [] → Lean.Data.AC.sort.loop xs ys ≠ []",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "propext",
   "SProd.sprod",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Prod",
   "Filter.instSProd",
   "Filter.mem_prod_iff",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set (α × β)} {f : Filter α} {g : Filter β},\n  (s ∈ f ×ˢ g) = ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ×ˢ t₂ ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "SupSet.sSup",
   "iSup",
   "Set.image_eq_range",
   "Eq",
   "Set.instMembershipSet",
   "SupSet",
   "Set.range",
   "Eq.mpr",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.Elem",
   "Set.image",
   "id"],
  "name": "sSup_image'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SupSet α] {s : Set β} {f : β → α}, sSup (f '' s) = ⨆ a, f ↑a",
  "constCategory": "Theorem"},
 {"references": ["MonadLift", "semiOutParam"],
  "name": "MonadLift.monadLift",
  "constType":
  "{m : semiOutParam (Type u → Type v)} → {n : Type u → Type w} → [self : MonadLift m n] → {α : Type u} → m α → n α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_7",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "List.instMembershipList",
   "eq_of_heq",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "Bool.true",
   "List.Mem.head",
   "Not",
   "List.Mem.casesOn",
   "Bool",
   "List.noConfusion",
   "Eq.symm"],
  "name": "List.exists_of_eraseP.match_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} (l : List α) (a : α) (motive : (b : α) → a ∈ b :: l → ¬p b = true → Prop) (b : α)\n  (al : a ∈ b :: l) (pb : ¬p b = true),\n  (∀ (pb : ¬p a = true), motive a (_ : List.Mem a (a :: l)) pb) →\n    (∀ (b : α) (al : List.Mem a l) (pb : ¬p b = true), motive b (_ : List.Mem a (b :: l)) pb) → motive b al pb",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "propext",
   "GeneralizedCoheytingAlgebra",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "sdiff_le_comm",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Heyting.Basic._auxLemma.14",
  "constType":
  "∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b c : α}, (a \\ b ≤ c) = (a \\ c ≤ b)",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": ["WellFounded.apply", "WellFounded.fixF", "WellFounded"],
  "name": "WellFounded.fix",
  "constType":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf.le_sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "le_sInf",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "forall₂_imp",
   "LE",
   "IsUpperSet",
   "Set.sInter",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "isUpperSet_sInter",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {S : Set (Set α)}, (∀ s ∈ S, IsUpperSet s) → IsUpperSet (⋂₀ S)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower", "Topology.WithLower", "TopologicalSpace", "Preorder"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Exists",
   "OfNat.ofNat",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Lean.IsNeutral",
   "Exists.casesOn",
   "Eq",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "Filter.inter_mem",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Filter",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "List.cons",
   "setOf",
   "Set.inter_isComm",
   "Lean.Data.AC.eval",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "Set.instMembershipSet",
   "And",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "congr",
   "Bool",
   "And.intro",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "Set.inter_isAssoc",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_3",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α) {x y : Set α},\n  x ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} →\n    y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} → x ∩ y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b}",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "Set",
   "InfSet.sInf",
   "sInfHomClass.toFunLike",
   "InfSet",
   "FunLike.coe",
   "Set.image",
   "sInfHomClass",
   "Eq"],
  "name": "sInfHomClass.map_sInf",
  "constType":
  "∀ {F : Type u_8} {α : outParam (Type u_9)} {β : outParam (Type u_10)} [inst : InfSet α] [inst_1 : InfSet β]\n  [self : sInfHomClass F α β] (f : F) (s : Set α), ↑f (sInf s) = sInf (↑f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedCancelAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (x : α), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.casesOn",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.length_pos_of_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} (motive : (x : List α) → a ∈ x → Prop) (x : List α) (x_1 : a ∈ x),\n  (∀ (head : α) (tail : List α) (x : a ∈ head :: tail), motive (head :: tail) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Eq.mpr",
   "Set.iUnion",
   "isOpen_biUnion",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "Set.preimage_sUnion",
   "congrArg",
   "IsOpen",
   "Eq",
   "id",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.coinduced.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (t : TopologicalSpace α) (s : Set (Set β)),\n  (∀ t_1 ∈ s, (fun s ↦ IsOpen (f ⁻¹' s)) t_1) → (fun s ↦ IsOpen (f ⁻¹' s)) (⋃₀ s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["eq_true", "List.Chain.nil", "List.nil", "List.Chain", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a [] = True",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "EquivLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff.symm",
   "Topology.WithLowerSet.toLowerSet_specializes_toLowerSet",
   "Iff",
   "Topology.WithLowerSet",
   "Specializes",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "FunLike.coe",
   "Topology.WithLowerSet.toLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSet_le_ofLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a b : Topology.WithLowerSet α},\n  ↑Topology.WithLowerSet.ofLowerSet a ≤ ↑Topology.WithLowerSet.ofLowerSet b ↔ a ⤳ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "Eq.refl",
   "List.length",
   "List.forall_mem_cons",
   "List.eq_replicate_of_mem.match_1",
   "rfl",
   "Eq",
   "PProd",
   "And",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff.mp",
   "List.rec",
   "List",
   "PUnit",
   "List.replicate",
   "List.nil",
   "List.eq_replicate_of_mem.match_2",
   "Nat",
   "Eq.symm",
   "_private.Std.Data.List.Lemmas.0.List.replicate._eq_2",
   "Nat.succ",
   "List.length_cons",
   "id"],
  "name": "List.eq_replicate_of_mem",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α}, (∀ b ∈ l, b = a) → l = List.replicate (List.length l) a",
  "constCategory": "Theorem"},
 {"references": ["Lean.IsAssociative", "Eq"],
  "name": "Lean.IsAssociative.assoc",
  "constType":
  "∀ {α : Sort u} {op : α → α → α} [self : Lean.IsAssociative op] (a b c : α), op (op a b) c = op a (op b c)",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Lean.PrettyPrinter.UnexpandM", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.Unexpander",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "GaloisInsertion.le_l_u",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "GaloisConnection.monotone_l",
   "LE.le.trans",
   "le_sup_right",
   "Sup.sup",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeSup α],\n  GaloisInsertion l u → ∀ (x b : β), b ≤ l (u x ⊔ u b)",
  "constCategory": "Theorem"},
 {"references": ["Lean.MacroScopesView", "Lean.Name"],
  "name": "Lean.MacroScopesView.imported",
  "constType": "Lean.MacroScopesView → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Fintype.Basic._auxLemma.23",
   "Or",
   "Set",
   "Union.union",
   "Set.toFinset",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Fintype",
   "Iff",
   "DecidableEq",
   "Set.Elem",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "Mathlib.Data.Set.Basic._auxLemma.17",
   "Mathlib.Data.Finset.Basic._auxLemma.73",
   "congr",
   "congrArg",
   "Eq.trans",
   "Finset.instUnionFinset",
   "Set.instUnionSet"],
  "name": "Set.fintypeUnion.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s t : Set α) [inst_1 : Fintype ↑s] [inst_2 : Fintype ↑t] (a : α),\n  a ∈ Set.toFinset s ∪ Set.toFinset t ↔ a ∈ s ∪ t",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "OrderTop.le_top",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "Pi.hasLe",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "Pi.orderTop",
   "Preorder.toLE"],
  "name": "Pi.generalizedHeytingAlgebra.proof_4",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → GeneralizedHeytingAlgebra (α i)] (a : (i : ι) → α i), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["BEq.beq", "BEq", "Bool.true", "LawfulBEq", "Bool", "Eq"],
  "name": "LawfulBEq.rfl",
  "constType":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] {a : α}, (a == a) = true",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "GeneralizedHeytingAlgebra"],
  "name": "HeytingAlgebra.toGeneralizedHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : HeytingAlgebra α] → GeneralizedHeytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.«termI^_»._closed_4",
   "Lean.Name.str._override"],
  "name": "Topology.«termI^_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd.proof_1",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "IsLeftCancelAdd"],
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd",
  "constType":
  "∀ (G : Type u) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.map_add_range'.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x 0 x_3) → (∀ (s n step : ℕ), motive s (Nat.succ n) step) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["BEq", "BEq.mk", "Nat.beq", "Nat"],
  "name": "instBEqNat",
  "constType": "BEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toSup : Sup α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ a ⊔ b) →\n        (∀ (a b : α), b ≤ a ⊔ b) → (∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "List.cons",
   "List.filterMap",
   "Function.comp",
   "Unit",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "List.filterMap_cons.match_1",
   "congr",
   "Option.some",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Option"],
  "name": "List.filterMap_eq_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), List.filterMap (some ∘ f) = List.map f",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "Function.Injective", "FunLike.coe"],
  "name": "FunLike.coe_injective'",
  "constType":
  "∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\n  Function.Injective FunLike.coe",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iSup",
   "iSup_le",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "iSup₂_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {a : α} {f : (i : ι) → κ i → α},\n  (∀ (i : ι) (j : κ i), f i j ≤ a) → ⨆ i, ⨆ j, f i j ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Nat",
   "instLTNat",
   "Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero",
  "constType": "∀ (n : ℕ), ¬n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (y : β), y ∈ f '' s ↔ ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_4",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_3"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Fintype", "Finset"],
  "name": "Fintype.elems",
  "constType": "{α : Type u_4} → [self : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "TopologicalSpace.generateFrom",
   "setOf",
   "Set",
   "TopologicalSpace",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.Ici",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq"],
  "name": "Topology.lower",
  "constType": "(α : Type u_1) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_18._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List.Perm", "List", "List.nil", "List.perm_inv_core"],
  "name": "List.Perm.cons_inv",
  "constType":
  "∀ {α : Type uu} {a : α} {l₁ l₂ : List α}, a :: l₁ ~ a :: l₂ → l₁ ~ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "sInf_eq_iInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Eq.symm",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α}, ⨅ a ∈ s, a = sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "OrderDual.semilatticeInf.proof_1",
   "LE.le",
   "Preorder.toLE",
   "le_sup_left",
   "PartialOrder",
   "SemilatticeSup",
   "Inf.mk",
   "instInfOrderDual",
   "SemilatticeSup.toSup",
   "Inf",
   "OrderDual",
   "inferInstanceAs",
   "sup_le",
   "le_sup_right",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "OrderDual.semilatticeInf",
  "constType":
  "(α : Type u_1) → [inst : SemilatticeSup α] → SemilatticeInf αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_exists_eq_and.match_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (motive : (∃ a, p (f a)) → Prop) (x : ∃ a, p (f a)),\n  (∀ (a : α) (ha : p (f a)), motive (_ : ∃ a, p (f a))) → motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_right",
  "constType": "∀ {b c a : Prop}, (b → c) → a ∨ b → a ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.NeBot.ne'",
   "Iff.intro",
   "Ne",
   "Bot.bot",
   "Iff",
   "Filter.NeBot.mk",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.neBot_iff",
  "constType": "∀ {α : Type u} {f : Filter α}, Filter.NeBot f ↔ f ≠ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references": ["Bot", "Top", "Top.top", "OrderDual", "Bot.mk"],
  "name": "OrderDual.bot",
  "constType": "(α : Type u) → [inst : Top α] → Bot αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.perm_middle.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → List α → Prop) (x x_1 : List α),\n  (∀ (x : List α), motive [] x) → (∀ (b : α) (l₁ l₂ : List α), motive (b :: l₁) l₂) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["And",
   "BEq.beq",
   "List.instBEqList",
   "BEq",
   "List",
   "Bool.true",
   "And.intro",
   "Bool",
   "And.casesOn",
   "Eq"],
  "name": "List.instLawfulBEqListInstBEqList.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : BEq α] (a : α) (as : List α) (b : α) (bs : List α) (motive : a = b ∧ (as == bs) = true → Prop)\n  (h : a = b ∧ (as == bs) = true),\n  (∀ (h₁ : a = b) (h₂ : (as == bs) = true), motive (_ : a = b ∧ (as == bs) = true)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Prod.snd",
   "Set.preimage",
   "Inf.inf",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Prod.fst",
   "Filter.instSProd",
   "Mathlib.Order.Filter.Prod._auxLemma.19",
   "Filter.comap_principal",
   "Eq",
   "Filter.principal",
   "Eq.mpr",
   "Set.prod",
   "SProd.sprod",
   "Filter.instInfFilter",
   "congr",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.inf_principal",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Set.instInterSet",
   "id"],
  "name": "Filter.prod_principal_principal",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β},\n  Filter.principal s ×ˢ Filter.principal t = Filter.principal (s ×ˢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Or",
   "Nat.below",
   "Or.inr",
   "Unit",
   "GE.ge",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.lt_or_ge.match_2",
   "Nat.le_succ_of_le",
   "PProd.fst",
   "Nat.rec",
   "Or.inl",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "Eq.rec",
   "LT.lt",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.zero_le",
   "Nat.succ",
   "Nat.eq_or_lt_of_le",
   "Nat.lt_or_ge.match_1"],
  "name": "Nat.lt_or_ge",
  "constType": "∀ (n m : ℕ), n < m ∨ n ≥ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set",
   "Set.mem_preimage",
   "Eq.refl",
   "Set.Iic",
   "closure_mono",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Topology.IsUpperSet",
   "Set.instSingletonSet",
   "Iff",
   "forall_congr",
   "Continuous",
   "Set.mem_of_mem_of_subset",
   "TopologicalSpace",
   "IsUpperSet.preimage",
   "Eq.symm",
   "IsOpen",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
   "id",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "Set.preimage",
   "Continuous.closure_preimage_subset",
   "HasSubset.Subset",
   "IsUpperSet",
   "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.1",
   "Preorder",
   "LE.le",
   "Set.mem_Iic",
   "Set.instMembershipSet",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.mem_singleton_iff",
   "propext",
   "Eq.mp",
   "Monotone",
   "Singleton.singleton",
   "Topology.IsUpperSet.closure_singleton"],
  "name": "Topology.IsUpperSet.monotone_iff_continuous",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : TopologicalSpace α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Topology.IsUpperSet α] [inst_5 : Topology.IsUpperSet β] {f : α → β},\n  Monotone f ↔ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Set.univ",
   "Filter.univ_mem",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), (Filter.generate s).sets = s → Set.univ ∈ s",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Equivalence.mk", "Equivalence", "True"],
  "name": "true_equivalence",
  "constType": "∀ {α : Sort u_1}, Equivalence fun x x ↦ True",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "DistribLattice",
   "Pi.lattice",
   "DistribLattice.mk",
   "Pi.distribLattice.proof_1"],
  "name": "Pi.distribLattice",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → DistribLattice (α' i)] → DistribLattice ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.mem_of_elem_eq_true.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : List α → Prop) (as : List α),\n  (Unit → motive []) → (∀ (a' : α) (as : List α), motive (a' :: as)) → motive as",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "Or", "propext", "exists_eq_or_imp", "Eq"],
  "name": "Std.Logic._auxLemma.48",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop} {a' : α}, (∃ a, (a = a' ∨ q a) ∧ p a) = (p a' ∨ ∃ a, q a ∧ p a)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "instLENat", "Fin.val", "LE", "Nat", "LE.le", "Fin"],
  "name": "instLEFin",
  "constType": "{n : ℕ} → LE (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Nat.rec",
   "of_eq_true",
   "List.replicate",
   "instOfNatNat",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.length_replicate",
  "constType":
  "∀ {α : Type u} (n : ℕ) (a : α), List.length (List.replicate n a) = n",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_6",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (a : β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "LE",
   "inferInstanceAs",
   "le_trans",
   "Pi.hasLe",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Pi.preorder.proof_2",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → Preorder (α i)] (a b c : (i : ι) → α i),\n  a ≤ b → b ≤ c → ∀ (i : ι), a i ≤ c i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.nodup_cons",
   "List.insert",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "Eq",
   "And",
   "Eq.mpr",
   "List.Nodup",
   "Eq.ndrec",
   "DecidableEq",
   "List.insert_of_not_mem",
   "propext",
   "List",
   "List.instDecidableMemListInstMembershipList",
   "Not",
   "And.intro",
   "List.insert_of_mem",
   "id"],
  "name": "List.Nodup.insert",
  "constType":
  "∀ {α : Type u} {l : List α} {a : α} [inst : DecidableEq α], List.Nodup l → List.Nodup (List.insert a l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Nodup",
   "Function.Injective",
   "List.instMembershipList",
   "List",
   "List.Nodup.map_on",
   "List.map",
   "Eq"],
  "name": "List.Nodup.map",
  "constType":
  "∀ {α : Type u} {β : Type v} {l : List α} {f : α → β}, Function.Injective f → List.Nodup l → List.Nodup (List.map f l)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "TopologicalSpace.mk",
   "Topology.WithUpper",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Set",
   "Inducing",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Set.Iic",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsUpper.WithUpperHomeomorph._spec_1",
  "constType":
  "(α : Type u_1) →\n  (inst : Preorder α) →\n    (inst_1 : TopologicalSpace α) →\n      let _x_1 :=\n        { IsOpen := TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s},\n          isOpen_univ := (_ : TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} Set.univ),\n          isOpen_inter :=\n            (_ :\n              ∀ (s t : Set α),\n                TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} s →\n                  TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} t →\n                    TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} (Inter.inter✝ s t)),\n          isOpen_sUnion :=\n            (_ :\n              ∀ (S : Set (Set α)),\n                (∀ s ∈ S, TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} s) →\n                  TopologicalSpace.GenerateOpen {s | ∃ a, HasCompl.compl✝ (Set.Iic a) = s} (⋃₀ S)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithUpper α ≃ α) → Inducing ↑f → Topology.WithUpper α ≃ₜ α",
  "constCategory": "Axiom"},
 {"references":
  ["sSup_singleton",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "Eq.refl",
   "iSup",
   "SupSet.sSup",
   "Nonempty",
   "CompleteSemilatticeSup.toSupSet",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Set.instSingletonSet",
   "CompleteLattice",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.range_const",
   "Singleton.singleton",
   "CompleteLattice.toSupSet",
   "id"],
  "name": "iSup_const",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {a : α} [inst_1 : Nonempty ι], ⨆ x, a = a",
  "constCategory": "Theorem"},
 {"references":
  ["LowerSet",
   "Membership.mem",
   "mem_lowerClosure",
   "And",
   "Exists",
   "propext",
   "LowerSet.instSetLikeLowerSet",
   "Set",
   "Preorder",
   "lowerClosure",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.UpperLower.Basic._auxLemma.95",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} {x : α}, (x ∈ lowerClosure s) = ∃ a ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Inf.inf",
   "inferInstanceAs",
   "OrderDual",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderDual.distribLattice.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : DistribLattice α] (a b : αᵒᵈ), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Bot.bot",
   "GaloisInsertion.liftBoundedOrder.proof_1",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "GaloisConnection.liftOrderBot",
   "OrderBot.bot_le",
   "Preorder",
   "LE.le",
   "GaloisInsertion",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : Preorder α]\n  [inst_2 : BoundedOrder α] (gi : GaloisInsertion l u) (a : β), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.mk"],
  "name": "Quotient.mk",
  "constType": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "∀ (n : ℕ), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "Nat",
   "instDecidableEqNat",
   "Eq",
   "ite",
   "Lean.Data.AC.mergeIdem.loop.match_1"],
  "name": "Lean.Data.AC.mergeIdem.loop",
  "constType": "ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "sSupHom",
   "Set",
   "sSupHom.toFun",
   "SupSet.sSup",
   "Set.image",
   "Eq"],
  "name": "sSupHom.map_sSup'",
  "constType":
  "∀ {α : Type u_8} {β : Type u_9} [inst : SupSet α] [inst_1 : SupSet β] (self : sSupHom α β) (s : Set α),\n  sSupHom.toFun self (sSup s) = sSup (self.toFun '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "TopologicalSpace.GenerateOpen.basic",
   "Eq.mpr",
   "Eq.ndrec",
   "Set",
   "Eq.refl",
   "TopologicalSpace",
   "TopologicalSpace.IsTopologicalBasis.eq_generateFrom",
   "IsOpen",
   "Eq",
   "id",
   "Set.instMembershipSet",
   "TopologicalSpace.IsTopologicalBasis"],
  "name": "TopologicalSpace.IsTopologicalBasis.isOpen",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α} {b : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis b → s ∈ b → IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Equivalence"],
  "name": "Setoid.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → Equivalence r → Setoid α",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{α : Type u} → [self : Inf α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Inducing.casesOn",
   "Inducing.mk",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "inducing_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] (f : α → β),\n  Inducing f ↔ tα = TopologicalSpace.induced f tβ",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Prod.instPartialOrder.match_1",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Eq",
   "LE.le.antisymm",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "Prod.ext",
   "Preorder.lt_iff_le_not_le",
   "Prod.instPartialOrder.match_2"],
  "name": "Prod.instPartialOrder.proof_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (x x_1 : α × β),\n  x ≤ x_1 → x_1 ≤ x → x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "le_iInf_iff",
   "CompleteLattice.toInfSet",
   "propext",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.CompleteLattice._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (a ≤ iInf f) = ∀ (i : ι), a ≤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Not.elim",
   "Std.Data.List.Lemmas._auxLemma.2",
   "List.instMembershipList",
   "Eq.refl",
   "List.casesOn",
   "List.Perm.swap",
   "Exists.casesOn",
   "List.Perm.cons",
   "rfl",
   "True",
   "Eq",
   "List.Perm.symm",
   "Std.Data.List.Lemmas._auxLemma.11",
   "Eq.mpr",
   "true_or",
   "List.perm_middle",
   "List.nil",
   "Eq.symm",
   "List.perm_induction_on",
   "Eq.trans",
   "id",
   "Membership.mem",
   "eq_self",
   "List.Perm.swap'",
   "List.append",
   "List.cons",
   "Or",
   "List.mem_split",
   "List.not_mem_nil",
   "or_true",
   "List.Perm.subset",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "List.Perm",
   "of_eq_true",
   "HAppend.hAppend",
   "List",
   "List.Perm.trans",
   "List.noConfusion",
   "congrArg",
   "congrFun"],
  "name": "List.perm_inv_core",
  "constType":
  "∀ {α : Type uu} {a : α} {l₁ l₂ r₁ r₂ : List α}, l₁ ++ a :: r₁ ~ l₂ ++ a :: r₂ → l₁ ++ r₁ ~ l₂ ++ r₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "∀ {α : Type u_1} (a : α), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "LawfulBEq",
   "Nat.eq_of_beq_eq_true",
   "implies_true",
   "instBEqNat",
   "True",
   "Eq",
   "BEq.beq",
   "of_eq_true",
   "forall_congr",
   "LawfulBEq.mk",
   "Bool.true",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "Nat.beq_refl",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.instLawfulBEqNatInstBEqNat.proof_1",
  "constType": "LawfulBEq ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.below.rec",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.casesOn",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop}\n  {motive_1 : {a : List α} → (x : List.Pairwise R a) → List.Pairwise.below x → Prop} {a : List α}\n  {x : List.Pairwise R a} (t : List.Pairwise.below x),\n  motive_1 (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R [])) →\n    (∀ {a : α} {l : List α} (a_1 : ∀ a' ∈ l, R a a') {a_2 : List.Pairwise R l} (a_3 : List.Pairwise.below a_2)\n        (a_4 : motive l a_2),\n        motive_1 (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) →\n      motive_1 x t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.inter_mem_inf",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Filter.mem_inf_of_inter",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s t u : Set α}, s ∈ f → t ∈ g → s ∩ t ⊆ u → u ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references":
  ["inf_comm",
   "IsCommutative.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf",
   "IsCommutative"],
  "name": "instIsCommutativeInfToInf.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α], IsCommutative α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.ble",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.ble_succ_eq_true.match_1",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.ble_succ_eq_true",
  "constType":
  "∀ {n m : ℕ}, Nat.ble n m = true → Nat.ble n (Nat.succ m) = true",
  "constCategory": "Theorem"},
 {"references":
  ["PSigma",
   "Eq.ndrec",
   "PSigma.snd",
   "PSigma.fst",
   "Eq.ndrecOn",
   "Quot.liftIndepPr1",
   "Quot.indepCoherent",
   "Quot.lift",
   "Quot",
   "Quot.indep",
   "Quot.sound",
   "Eq",
   "Quot.mk"],
  "name": "Quot.rec",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (f : (a : α) → motive (Quot.mk r a)) →\n        (∀ (a b : α) (p : r a b), (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → (q : Quot r) → motive q",
  "constCategory": "Definition"},
 {"references": ["Ne", "List.Nodup", "List.Pairwise.nil", "List.nil"],
  "name": "List.nodup_nil",
  "constType": "∀ {α : Type u}, List.Nodup []",
  "constCategory": "Theorem"},
 {"references":
  ["Or.resolve_left",
   "Iff.intro",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "Decidable",
   "dite",
   "Not"],
  "name": "Decidable.or_iff_not_imp_left",
  "constType": "∀ {a b : Prop} [inst : Decidable a], a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil"],
  "name": "List.Sublist.rec",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop},\n  motive [] [] (_ : List.Sublist [] []) →\n    (∀ {l₁ l₂ : List α} (a : α) (a_1 : List.Sublist l₁ l₂),\n        motive l₁ l₂ a_1 → motive l₁ (a :: l₂) (_ : List.Sublist l₁ (a :: l₂))) →\n      (∀ {l₁ l₂ : List α} (a : α) (a_1 : List.Sublist l₁ l₂),\n          motive l₁ l₂ a_1 → motive (a :: l₁) (a :: l₂) (_ : List.Sublist (a :: l₁) (a :: l₂))) →\n        ∀ {a a_1 : List α} (t : List.Sublist a a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references": ["Fin.val", "LT.lt", "LT", "LT.mk", "Nat", "instLTNat", "Fin"],
  "name": "instLTFin",
  "constType": "{n : ℕ} → LT (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "HImp.himp",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "HasCompl.compl",
   "HeytingAlgebra.toHasCompl",
   "Eq"],
  "name": "HeytingAlgebra.himp_bot",
  "constType": "∀ {α : Type u_4} [self : HeytingAlgebra α] (a : α), a ⇨ ⊥ = aᶜ",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "TopologicalSpace.GenerateOpen",
  "constType": "{α : Type u} → Set (Set α) → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "And",
   "Pi.preorder.proof_2",
   "Pi.preorder.proof_1",
   "inferInstanceAs",
   "LE",
   "Not",
   "Pi.preorder.proof_3",
   "LT.mk",
   "Pi.hasLe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Pi.preorder",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → Preorder (α i)] → Preorder ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Lean.ParserDescr.symbol", "Topology.«termI^_»._closed_6"],
  "name": "Topology.«termI^_»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc", "WellFounded.apply.proof_1"],
  "name": "WellFounded.apply",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, WellFounded r → ∀ (a : α), Acc r a",
  "constCategory": "Definition"},
 {"references":
  ["Directed.mono",
   "Function.comp",
   "directed_comp",
   "Directed",
   "Iff.mpr",
   "Order.Preimage"],
  "name": "Directed.mono_comp",
  "constType":
  "∀ {α : Type u} {β : Type v} (r : α → α → Prop) {ι : Sort u_1} {rb : β → β → Prop} {g : α → β} {f : ι → α},\n  (∀ ⦃x y : α⦄, r x y → rb (g x) (g y)) → Directed r f → Directed rb (g ∘ f)",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftSemilatticeInf.proof_1",
   "Inf.mk",
   "GaloisInsertion.liftSemilatticeInf.proof_3",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "PartialOrder.le_antisymm",
   "SemilatticeInf.toPartialOrder",
   "GaloisInsertion.liftSemilatticeInf.proof_4",
   "GaloisInsertion.choice",
   "GaloisInsertion",
   "GaloisInsertion.liftSemilatticeInf.proof_2",
   "SemilatticeInf.mk",
   "SemilatticeInf",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeInf",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : SemilatticeInf α] → GaloisInsertion l u → SemilatticeInf β",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "nhds",
   "Inf.inf",
   "Set",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter"],
  "name": "nhdsWithin",
  "constType":
  "{α : Type u} → [inst : TopologicalSpace α] → α → Set α → Filter α",
  "constCategory": "Definition"},
 {"references": ["PLift.up", "PLift.down", "PLift", "rfl", "Eq"],
  "name": "PLift.up_down",
  "constType": "∀ {α : Sort u} (b : PLift α), { down := b.down } = b",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisCoinsertion.choice",
   "GaloisCoinsertion",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisCoinsertion.choice_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α}\n  (self : GaloisCoinsertion l u) (a : β) (h : a ≤ l (u a)), GaloisCoinsertion.choice self a h = u a",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Homotopy.termΩ._closed_2",
   "_obj",
   "Lean.Name.mkStr3",
   "Topology.«termI^_»._closed_1",
   "Topology.Homotopy.termΩ._closed_1"],
  "name": "Topology.Homotopy.termΩ._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "instHAppend",
   "List.Sublist.append_right.match_1._@.Std.Data.List.Lemmas._hyg.7596",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.append_right",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → ∀ (l : List α), List.Sublist (l₁ ++ l) (l₂ ++ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Trans.trans",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "sup_inf_sdiff",
   "SemilatticeSup.toSup",
   "GeneralizedBooleanAlgebra",
   "le_sup_right",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup"],
  "name": "_private.Mathlib.Order.BooleanAlgebra.0.sdiff_le'",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : GeneralizedBooleanAlgebra α], x \\ y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.mk",
   "Eq"],
  "name": "Topology.IsLower.rec",
  "constType":
  "{α : Type u_1} →\n  [t : TopologicalSpace α] →\n    [inst : Preorder α] →\n      {motive : Topology.IsLower α → Sort u} →\n        ((topology_eq_lowerTopology : t = Topology.lower α) → motive (_ : Topology.IsLower α)) →\n          (t : Topology.IsLower α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithLower.of_WithLower_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithLower.ofLower.symm = Topology.WithLower.toLower",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "HEq",
   "HEq.refl",
   "List.instMembershipList",
   "List",
   "List.Mem.tail",
   "Eq.refl",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.casesOn",
   "List.nil",
   "List.noConfusion",
   "Eq"],
  "name": "List.decidableBAll.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (a : α) → a ∈ [] → Prop) (a : α) (a_1 : a ∈ []), motive a a_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower",
   "TopologicalSpace",
   "Topology.IsLower.instClosedIciTopology.proof_1",
   "Preorder",
   "ClosedIciTopology"],
  "name": "Topology.IsLower.instClosedIciTopology",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α], ClosedIciTopology α",
  "constCategory": "Definition"},
 {"references": ["or_congr", "Or", "Iff", "Iff.rfl"],
  "name": "or_congr_left",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (a ∨ c ↔ b ∨ c)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "GetElem"],
  "name": "GetElem.getElem",
  "constType":
  "{cont : Type u} →\n  {idx : Type v} →\n    {elem : outParam (Type w)} →\n      {dom : outParam (cont → idx → Prop)} →\n        [self : GetElem cont idx elem dom] → (xs : cont) → (i : idx) → dom xs i → elem",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "EmbeddingLike"],
  "name": "EmbeddingLike.toFunLike",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EmbeddingLike F α β] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.casesOn",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "List.Sublist",
   "Eq.refl",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.slnil",
   "List.noConfusion",
   "Eq.symm",
   "Eq"],
  "name": "List.pairwise_iff_forall_sublist.match_1",
  "constType":
  "∀ {α : Type u_1} (hd : α) (tl : List α) (motive : (x x_1 : α) → List.Sublist [x, x_1] (hd :: tl) → Prop) (x x_1 : α)\n  (x_2 : List.Sublist [x, x_1] (hd :: tl)),\n  (∀ (a b : α) (hab : List.Sublist [a, b] tl), motive a b (_ : List.Sublist [a, b] (hd :: tl))) →\n    (∀ (b : α) (hab : List.Sublist [b] tl), motive hd b (_ : List.Sublist [hd, b] (hd :: tl))) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List.rec",
   "List",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "List.casesOn",
   "List.nil",
   "Lean.Data.AC.removeNeutrals.match_1",
   "Nat",
   "absurd",
   "id",
   "Eq"],
  "name": "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.eq_2",
  "constType":
  "∀ (motive : List ℕ → Sort u_1) (ys : List ℕ) (h_1 : Unit → motive []) (h_2 : (ys : List ℕ) → motive ys),\n  (ys = [] → False) →\n    (match ys with\n      | [] => h_1 ()\n      | ys => h_2 ys) =\n      h_2 ys",
  "constCategory": "Theorem"},
 {"references":
  ["instHAppend",
   "Exists",
   "List.cons",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "Exists.intro",
   "Exists.casesOn",
   "Eq"],
  "name": "List.append_of_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} (as : List α) (motive : (∃ s, ∃ t, as = s ++ a :: t) → Prop) (x : ∃ s, ∃ t, as = s ++ a :: t),\n  (∀ (s t : List α) (h' : as = s ++ a :: t), motive (_ : ∃ s, ∃ t, as = s ++ a :: t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["and_imp",
   "Bot.bot",
   "Prop.distribLattice",
   "GeneralizedHeytingAlgebra.toHImp",
   "OrderTop.le_top",
   "BoundedOrder.toOrderTop",
   "rfl",
   "Eq",
   "DistribLattice.toLattice",
   "OrderTop.toTop",
   "Iff.symm",
   "And",
   "HImp.himp",
   "HImp.mk",
   "OrderBot.toBot",
   "Prop.le",
   "BoundedOrder.toOrderBot",
   "Prop.boundedOrder",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "Prop.heytingAlgebra.proof_4",
  "constType": "∀ (x : Prop), x ⇨ ⊥ = x ⇨ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "instMinNat",
   "Nat.min_eq_right",
   "Eq"],
  "name": "Nat.min_zero",
  "constType": "∀ (a : ℕ), min a 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "Function.comp",
   "monotone_dual_iff",
   "Eq.refl",
   "instTopologicalSpaceOrderDual",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "OrderDual.ofDual",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Topology.IsUpperSet.monotone_iff_continuous",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "Monotone",
   "OrderDual",
   "OrderDual.instIsUpperSet",
   "Eq.symm",
   "id"],
  "name": "Topology.IsLowerSet.monotone_iff_continuous",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : TopologicalSpace α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Topology.IsLowerSet α] [inst_5 : Topology.IsLowerSet β] {f : α → β},\n  Monotone f ↔ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddSemigroup.toAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "IsLeftCancelAdd",
   "IsLeftCancelAdd.mk"],
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd.proof_1",
  "constType":
  "∀ (G : Type u_1) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.refl",
   "_obj",
   "Equiv.toHomeomorphOfInducing._at.Topology.IsLower.WithLowerHomeomorph._spec_1",
   "_neutral"],
  "name": "Topology.IsLower.WithLowerHomeomorph._rarg._cstage2",
  "constType": "_obj → _obj → _neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instModNat",
  "constType": "Mod ℕ",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "Lean.Data.AC.mergeIdem.loop.match_1",
  "constType":
  "(motive : ℕ → List ℕ → Sort u_1) →\n  (x : ℕ) →\n    (x_1 : List ℕ) →\n      ((curr next : ℕ) → (rest : List ℕ) → motive curr (next :: rest)) → ((curr : ℕ) → motive curr []) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsClosed_of_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Pow.mk", "Nat.pow", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "Pow ℕ ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Topology.lower",
   "Set.preimage",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Iff.rfl",
   "Topology.WithLower",
   "Set",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Preorder",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.isOpen_preimage_ofLower",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, IsOpen (↑Topology.WithLower.ofLower ⁻¹' s) ↔ TopologicalSpace.IsOpen s",
  "constCategory": "Theorem"},
 {"references": ["Functor"],
  "name": "Functor.mk",
  "constType":
  "{f : Type u → Type v} → ({α β : Type u} → (α → β) → f α → f β) → ({α β : Type u} → α → f β → f α) → Functor f",
  "constCategory": "Other"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (h : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m h",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "exists_prop.match_2",
   "And",
   "Exists",
   "Iff",
   "Exists.intro",
   "And.intro",
   "exists_prop.match_1"],
  "name": "exists_prop",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) ↔ a ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le.dest.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : (∃ k, n + k = m) → Prop) (this : ∃ k, n + k = m),\n  (∀ (k : ℕ) (h : n + k = m), motive (_ : ∃ k, n + k = m)) → motive this",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_left",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b : α × β), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Applicative", "Monad"],
  "name": "Monad.toApplicative",
  "constType": "{m : Type u → Type v} → [self : Monad m] → Applicative m",
  "constCategory": "Definition"},
 {"references":
  ["not_exists",
   "Exists",
   "Iff.mp",
   "Filter.eventually_of_forall",
   "Classical.propDecidable",
   "Not",
   "Filter",
   "Decidable.byContradiction",
   "Filter.Frequently"],
  "name": "Filter.Frequently.exists",
  "constType":
  "∀ {α : Type u} {p : α → Prop} {f : Filter α}, (∃ᶠ (x : α) in f, p x) → ∃ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "SemilatticeSup.le_sup_left",
  "constType": "∀ {α : Type u} [self : SemilatticeSup α] (a b : α), a ≤ a ⊔ b",
  "constCategory": "Definition"},
 {"references":
  ["Lean.IsIdempotent.mk",
   "IsIdempotent",
   "Lean.IsIdempotent",
   "instIsIdempotent.proof_1"],
  "name": "instIsIdempotent",
  "constType":
  "{α : Type u_1} → {op : α → α → α} → [inst : IsIdempotent α op] → Lean.IsIdempotent op",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Filter.instTopFilter",
   "Top.top",
   "propext",
   "Set",
   "Filter",
   "Set.univ",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.18",
  "constType": "∀ {α : Type u} {s : Set α}, (s ∈ ⊤) = (s = Set.univ)",
  "constCategory": "Theorem"},
 {"references":
  ["List.nodup_attach",
   "Membership.mem",
   "Setoid.r",
   "Iff",
   "List",
   "Multiset.attach",
   "List.isSetoid",
   "Multiset",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset",
   "Subtype"],
  "name": "Multiset.nodup_attach",
  "constType":
  "∀ {α : Type u_1} {s : Multiset α}, Multiset.Nodup (Multiset.attach s) ↔ Multiset.Nodup s",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Set",
   "Set.mem_preimage",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set β} {a : α}, (a ∈ f ⁻¹' s) = (f a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Nat.mul_lt_mul_of_pos_left",
   "instLTNat",
   "Eq",
   "GT.gt"],
  "name": "Nat.mul_lt_mul_of_pos_right",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → n * k < m * k",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.mkStr3",
   "Topology.Homotopy.«termΩ^»._closed_1",
   "Topology.«termI^_»._closed_1",
   "Topology.Homotopy.termΩ._closed_1"],
  "name": "Topology.Homotopy.«termΩ^»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.mk",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (toFun : α → β) → Function.Injective toFun → α ↪ β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "True",
   "Std.Data.List.Basic._auxLemma.2",
   "iff_self",
   "List.Pairwise",
   "And",
   "Std.Data.List.Lemmas._auxLemma.69",
   "Iff",
   "List.rec",
   "of_eq_true",
   "propext",
   "Std.Data.List.Lemmas._auxLemma.68",
   "List",
   "congr",
   "List.map",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.pairwise_map",
  "constType":
  "∀ {α : Type u_1} {α_1 : Type u_2} {f : α → α_1} {R : α_1 → α_1 → Prop} {l : List α},\n  List.Pairwise R (List.map f l) ↔ List.Pairwise (fun a b ↦ R (f a) (f b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Function.comp",
   "Set",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.image_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : β → γ) (g : α → β) (a : Set α), f ∘ g '' a = f '' (g '' a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "propext",
   "Union.union",
   "Inf.inf",
   "Set",
   "Filter.mem_inf_principal'",
   "Filter.instInfFilter",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instUnionSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.63",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, (s ∈ f ⊓ Filter.principal t) = (tᶜ ∪ s ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Inter.inter",
   "And.intro",
   "And.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "nhdsAdjoint.match_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (_s _t : Set α) (motive : a ∈ _s ∩ _t → Prop) (x : a ∈ _s ∩ _t),\n  (∀ (has : a ∈ _s) (hat : a ∈ _t), motive (_ : a ∈ _s ∧ a ∈ _t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Pi.semilatticeInf.proof_1",
   "Pi.semilatticeInf.proof_3",
   "SemilatticeInf.toInf",
   "Pi.partialOrder",
   "Pi.instInfForAll",
   "SemilatticeInf.toPartialOrder",
   "Pi.semilatticeInf.proof_2",
   "SemilatticeInf.mk",
   "SemilatticeInf"],
  "name": "Pi.semilatticeInf",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → SemilatticeInf (α' i)] → SemilatticeInf ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "List.Mem.tail", "List.Mem.head", "List.Mem"],
  "name": "List.Mem.rec",
  "constType":
  "∀ {α : Type u} {a : α} {motive : (a_1 : List α) → List.Mem a a_1 → Prop},\n  (∀ (as : List α), motive (a :: as) (_ : List.Mem a (a :: as))) →\n    (∀ (b : α) {as : List α} (a_1 : List.Mem a as), motive as a_1 → motive (b :: as) (_ : List.Mem a (b :: as))) →\n      ∀ {a_1 : List α} (t : List.Mem a a_1), motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Array", "instLENat", "Nat.le_refl", "Nat", "Array.size", "LE.le"],
  "name": "Array.foldlM.proof_1",
  "constType": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "GaloisInsertion.liftOrderTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop.le_top",
   "Preorder",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "BoundedOrder",
   "PartialOrder"],
  "name": "GaloisInsertion.liftBoundedOrder.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : Preorder α]\n  [inst_2 : BoundedOrder α] (gi : GaloisInsertion l u) (a : β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.foldl_eq_foldr.match_1",
   "eq_self",
   "List.cons",
   "Or",
   "Or.inr",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "List.mem_cons",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.3",
   "True",
   "Eq",
   "PProd",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "List.ilast'",
   "of_eq_true",
   "propext",
   "List",
   "PUnit",
   "List.nil",
   "Eq.trans",
   "id"],
  "name": "List.ilast'_mem",
  "constType": "∀ {α : Type u} (a : α) (l : List α), List.ilast' a l ∈ a :: l",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil", "Nat"],
  "name": "List.findIdx.go.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → ℕ → Sort u_2) →\n    (x : List α) →\n      (x_1 : ℕ) → ((n : ℕ) → motive [] n) → ((a : α) → (l : List α) → (n : ℕ) → motive (a :: l) n) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.mem_replicate.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Syntax.isNodeOf", "Bool", "Lean.nullKind", "Nat", "Lean.Syntax"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Lean.Syntax → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Finset.nodup",
   "Function.Embedding.inj'",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Multiset.Nodup.map",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Finset.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α ↪ β) (s : Finset α), Multiset.Nodup (Multiset.map (↑f) s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.mk",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toTop",
   "Preorder.toLE",
   "BooleanAlgebra",
   "BoundedOrder"],
  "name": "BooleanAlgebra.toBoundedOrder",
  "constType": "{α : Type u} → [h : BooleanAlgebra α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Prod.instPartialOrder.proof_3",
   "Prod.instPartialOrder.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.instPreorderProd",
   "inferInstanceAs",
   "Prod",
   "Preorder",
   "Prod.instPartialOrder.proof_2",
   "Prod.instPartialOrder.proof_4",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Prod.instPartialOrder",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : PartialOrder α] → [inst : PartialOrder β] → PartialOrder (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.mem_attach",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) (x : { x // x ∈ s }), x ∈ Finset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.Syntax.node4",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["IsTrans",
   "Preorder",
   "instIsTransLeToLE.proof_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "instIsTransLeToLE",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsTrans α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.refl", "OrderDual"],
  "name": "OrderDual.ofDual",
  "constType": "{α : Type u_1} → αᵒᵈ ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_right",
   "inf_le_left",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "GaloisInsertion.gc",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "LE.le",
   "GaloisInsertion.choice",
   "Preorder.toLE",
   "Eq",
   "GaloisConnection.l_le",
   "PartialOrder",
   "Inf.mk",
   "Eq.mpr",
   "GaloisInsertion.choice_eq",
   "forall_congr",
   "le_inf",
   "PartialOrder.le_antisymm",
   "congrArg",
   "SemilatticeInf",
   "congrFun",
   "id"],
  "name": "GaloisInsertion.liftSemilatticeInf.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeInf α]\n  (gi : GaloisInsertion l u) (a b : β), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Directed",
   "implies_congr",
   "True",
   "Eq",
   "Iff.of_eq",
   "ball_congr",
   "iff_self",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Eq.mpr",
   "Iff",
   "forall_congr",
   "Mathlib.Order.Directed._auxLemma.2",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Subtype",
   "id",
   "Membership.mem",
   "funext",
   "Mathlib.Order.Directed._auxLemma.1",
   "DirectedOn",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.40",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "directedOn_iff_directed",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} {s : Set α}, DirectedOn r s ↔ Directed r Subtype.val",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Eq"],
  "name": "Function.Surjective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "rfl",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.subset_def",
  "constType": "∀ {α : Type u} {s t : Set α}, (s ⊆ t) = ∀ x ∈ s, x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMod",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "isOpen_biUnion",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "implies_congr",
   "Set.instMembershipSet",
   "Eq",
   "Eq.mpr",
   "Set.iUnion",
   "Set.compl_sInter",
   "forall_congr",
   "Set.sUnion_image",
   "TopologicalSpace",
   "Set.sUnion",
   "IsClosed",
   "Set.image",
   "Mathlib.Topology.Basic._auxLemma.8",
   "congrArg",
   "Set.sInter",
   "Eq.trans",
   "IsOpen",
   "id"],
  "name": "isClosed_sInter",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set (Set α)}, (∀ t ∈ s, IsClosed t) → IsClosed (⋂₀ s)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.instPartialOrderTopologicalSpace",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "Mathlib.Topology.Order._auxLemma.27",
   "ConditionallyCompleteLattice.toLattice",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "iff_self",
   "TopologicalSpace.coinduced",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "And",
   "Iff",
   "of_eq_true",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Continuous",
   "congr",
   "TopologicalSpace",
   "Mathlib.Topology.Order._auxLemma.31",
   "congrArg",
   "Eq.trans"],
  "name": "continuous_inf_rng",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\n  Continuous f ↔ Continuous f ∧ Continuous f",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "IsCompl.le_left_iff",
   "Iff",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "IsCompl",
   "LE.le",
   "IsCompl.symm",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "IsCompl.le_right_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DistribLattice α] [inst_1 : BoundedOrder α] {x y z : α}, IsCompl x y → (z ≤ y ↔ Disjoint z x)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "of_eq_true",
   "Bool.false",
   "not",
   "Bool.true",
   "Eq.refl",
   "eq_true_of_decide",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_true'",
  "constType": "∀ (b : Bool), ((!b) = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "lcProof",
   "Set",
   "TopologicalSpace",
   "Set.sUnion",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instMembershipSet"],
  "name": "Topology.upperSet._cstage1",
  "constType": "(α : Type u_4) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lower",
   "Topology.IsLower",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.casesOn",
   "Eq"],
  "name": "Topology.IsLower.noConfusionType",
  "constType":
  "{α : Type u_1} →\n  {t : TopologicalSpace α} → {inst : Preorder α} → Sort u → Topology.IsLower α → Topology.IsLower α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.pwFilter_map.match_1",
  "constType":
  "∀ {β : Type u_1} (motive : List β → Prop) (x : List β),\n  (Unit → motive []) → (∀ (x : β) (xs : List β), motive (x :: xs)) → motive x",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Finset.eq_of_veq.match_1",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Multiset",
   "Finset",
   "Eq.refl",
   "Finset.val",
   "Multiset.Nodup",
   "Eq.casesOn",
   "Finset.mk",
   "Eq.symm",
   "Eq"],
  "name": "Finset.eq_of_veq",
  "constType": "∀ {α : Type u_1} {s t : Finset α}, s.val = t.val → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.mem_iUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.47",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["CoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "Top.top",
   "CoheytingAlgebra.top_sdiff",
   "CoheytingAlgebra.toTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "CoheytingAlgebra.toHNot",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq"],
  "name": "top_sdiff'",
  "constType":
  "∀ {α : Type u_2} [inst : CoheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.«term𝓝[>]_»._closed_2",
   "Topology.«term𝓝[>]_»._closed_5"],
  "name": "Topology.«term𝓝[>]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Option.none", "Option.some", "Option"],
  "name": "Option.rec",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} → motive none → ((val : α) → motive (some val)) → (t : Option α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Eq.refl",
   "instLTNat",
   "Eq",
   "Nat.linearOrder",
   "Iff",
   "Preorder.toLT",
   "Iff.trans",
   "Nat",
   "Eq.symm",
   "Fin.mk",
   "Fin.casesOn",
   "Ne",
   "Or",
   "Fin.val",
   "List.pairwise_iff_get",
   "Nat.ne_of_lt",
   "List.length",
   "Or.casesOn",
   "instLTFin",
   "Iff.intro",
   "List.Pairwise",
   "Fin.veq_of_eq",
   "Eq.ndrec",
   "False.elim",
   "List.Nodup",
   "Function.Injective",
   "List",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "List.get",
   "Fin",
   "lt_trichotomy"],
  "name": "List.nodup_iff_injective_get",
  "constType":
  "∀ {α : Type u} {l : List α}, List.Nodup l ↔ Function.Injective (List.get l)",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (n : ℕ) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "Set",
   "Set.inter_self",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "True",
   "Eq",
   "And",
   "of_eq_true",
   "Filter",
   "And.intro",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_1",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α), ∃ a ∈ f, ∃ b ∈ g, Set.univ = a ∩ b",
  "constCategory": "Theorem"},
 {"references":
  ["False", "Fin.val", "Fin.val_eq_of_eq", "Not", "Nat", "absurd", "Fin", "Eq"],
  "name": "Fin.ne_of_val_ne",
  "constType": "∀ {n : ℕ} {i j : Fin n}, ¬↑i = ↑j → ¬i = j",
  "constCategory": "Theorem"},
 {"references": ["Bind"],
  "name": "Bind.mk",
  "constType":
  "{m : Type u → Type v} → ({α β : Type u} → m α → (α → m β) → m β) → Bind m",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "IsAssociative",
   "Inter.inter",
   "Set.instInterSet",
   "Set.inter_isAssoc.proof_1"],
  "name": "Set.inter_isAssoc",
  "constType": "∀ {α : Type u}, IsAssociative (Set α) fun x x_1 ↦ x ∩ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "Inf.inf",
   "Filter.instInfFilter",
   "Filter.comap",
   "Eq.refl",
   "Filter.prod",
   "Prod",
   "Filter",
   "Prod.fst",
   "Eq"],
  "name": "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : Filter α) (g : Filter β),\n  Filter.prod f g = Filter.comap Prod.fst f ⊓ Filter.comap Prod.snd g",
  "constCategory": "Theorem"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.mk",
   "Nat.decLt",
   "Nat",
   "compareOfLessAndEq",
   "instLTNat",
   "instDecidableEqNat",
   "Ord"],
  "name": "instOrdNat",
  "constType": "Ord ℕ",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.Finite.image",
   "Set.ball_image_iff",
   "Set.sInter_image",
   "Set.Finite.isOpen_sInter",
   "Eq.rec",
   "Set",
   "Set.iInter",
   "TopologicalSpace",
   "Set.image",
   "Set.sInter",
   "IsOpen",
   "Iff.mpr",
   "Set.Finite",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.Finite.isOpen_biInter",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] {s : Set β} {f : β → Set α},\n  Set.Finite s → (∀ i ∈ s, IsOpen (f i)) → IsOpen (⋂ i ∈ s, f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Std.Logic._auxLemma.39",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_id'",
  "constType": "∀ {α : Type u_1} (s : Set α), (fun x ↦ x) '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.withRef",
   "EStateM",
   "OfNat.ofNat",
   "Lean.Syntax.getArgs",
   "cond",
   "Array.mkArray0",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Array.append",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.TSyntaxArray",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.MonadQuotation.toMonadRef",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.TSyntaxArray.raw",
   "Lean.Syntax.getArg",
   "Lean.TSyntaxArray.mk",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "or",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Bool.false",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.PrettyPrinter.UnexpandM",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name": "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Codisjoint",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : OrderTop α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.Perm",
   "instLENat",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "LE.le"],
  "name": "List.Subperm.perm_of_length_le.match_1",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (motive : l₁ <+~ l₂ → List.length l₂ ≤ List.length l₁ → Prop) (x : l₁ <+~ l₂)\n  (x_1 : List.length l₂ ≤ List.length l₁),\n  (∀ (_l : List α) (p : _l ~ l₁) (s : List.Sublist _l l₂) (h : List.length l₂ ≤ List.length l₁),\n      motive (_ : ∃ l, ∃ (_ : l ~ l₁), List.Sublist l l₂) h) →\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.«termI^_»._closed_8",
   "Lean.Name.str._override"],
  "name": "Topology.«termI^_»._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "ne_false_of_eq_true.match_1",
   "Bool.true",
   "Not",
   "Bool",
   "Eq"],
  "name": "ne_false_of_eq_true",
  "constType": "∀ {b : Bool}, b = true → ¬b = false",
  "constCategory": "Theorem"},
 {"references": ["Array", "Nat", "List.length", "Array.data"],
  "name": "Array.size",
  "constType": "{α : Type u} → Array α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_7",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_5",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_true",
   "OfNat.ofNat",
   "List.Nodup",
   "List.range'",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "optParam",
   "instLTNat",
   "True",
   "Eq",
   "List.nodup_range'"],
  "name": "Mathlib.Data.List.Range._auxLemma.2",
  "constType":
  "∀ (s n : ℕ) (step : optParam ℕ 1), autoParam (0 < step) _auto✝ → List.Nodup (List.range' s n step) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteSemilatticeSup.sSup_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_succ_of_le",
   "OfNat.ofNat",
   "List.Sublist.reverse.match_1._@.Std.Data.List.Lemmas._hyg.8887",
   "instLENat",
   "List",
   "Unit",
   "Nat.le_refl",
   "List.Sublist",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "List.length",
   "Nat",
   "LE.le",
   "List.Sublist.below",
   "List.Sublist.brecOn"],
  "name": "List.Sublist.length_le",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → List.length l₁ ≤ List.length l₂",
  "constCategory": "Theorem"},
 {"references": ["Subtype.mk", "Subtype", "Subtype.casesOn"],
  "name": "Subtype.forall.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : { a // p a } → Prop) (x : { a // p a }),\n  (∀ (a : α) (b : p a), motive { val := a, property := b }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "Setoid.r",
   "List.mem_map",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Multiset.mem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, b ∈ Multiset.map f s ↔ ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Sublist"],
  "name": "List.Sublist.cons₂",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist (a :: l₁) (a :: l₂)",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.lower._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {b : Set (Set α)} (s t : Set α) (motive : (∃ t₃ ∈ b, a ∈ t₃ ∧ t₃ ⊆ s ∩ t) → Prop)\n  (x : ∃ t₃ ∈ b, a ∈ t₃ ∧ t₃ ⊆ s ∩ t),\n  (∀ (u : Set α) (hu₁ : u ∈ b) (hu₂ : a ∈ u) (hu₃ : u ⊆ s ∩ t), motive (_ : ∃ t₃ ∈ b, a ∈ t₃ ∧ t₃ ⊆ s ∩ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Prod.fst",
   "And.left",
   "Prod.instInfProd",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "And",
   "Inf.mk",
   "And.right",
   "Inf",
   "le_inf",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "PartialOrder.le_antisymm",
   "Prod",
   "And.intro",
   "SemilatticeInf"],
  "name": "Prod.semilatticeInf.proof_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] (x x_1 x_2 : α × β),\n  x ≤ x_1 → x ≤ x_2 → x.1 ≤ (x_1 ⊓ x_2).1 ∧ x.2 ≤ (x_1 ⊓ x_2).2",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "SemilatticeSup",
   "And",
   "Iff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "sup_le",
   "le_sup_right",
   "le_trans",
   "Sup.sup",
   "sup_le_iff.match_1",
   "And.intro",
   "LE.le",
   "le_sup_left",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "Iff.mp", "False", "Iff", "propext", "Not", "Eq"],
  "name": "iff_false",
  "constType": "∀ (p : Prop), (p ↔ False) = ¬p",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Mathlib.Topology.Order._auxLemma.15",
   "Mathlib.Topology.Order._auxLemma.34",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Set.Subset.rfl",
   "Eq",
   "Eq.mpr",
   "Iff",
   "TopologicalSpace",
   "Filter",
   "TopologicalSpace.induced",
   "And.casesOn",
   "IsOpen",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "Set.preimage",
   "nhds",
   "HasSubset.Subset.trans",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "congr",
   "And.intro",
   "Set.preimage_mono",
   "congrArg",
   "congrFun"],
  "name": "mem_nhds_induced",
  "constType":
  "∀ {α : Type u} {β : Type v} [T : TopologicalSpace α] (f : β → α) (a : β) (s : Set β),\n  s ∈ nhds a ↔ ∃ u ∈ nhds (f a), f ⁻¹' u ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["UInt32",
   "Decidable",
   "inferInstanceAs",
   "instLEFin",
   "instLEUInt32",
   "UInt32.size",
   "UInt32.decEq.match_1",
   "LE.le",
   "Fin",
   "Fin.decLe"],
  "name": "UInt32.decLe",
  "constType": "(a b : UInt32) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_true",
   "Bool.true",
   "of_decide_eq_true",
   "Decidable",
   "Bool",
   "True",
   "Eq"],
  "name": "eq_true_of_decide",
  "constType": "∀ {p : Prop} {x : Decidable p}, decide p = true → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "Monad.toApplicative",
   "Lean.Macro.Context.currMacroScope",
   "Lean.MacroM",
   "Lean.MonadQuotation.mk",
   "Pure.pure",
   "Lean.Macro.withFreshMacroScope",
   "Lean.Macro.instMonadRefMacroM",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.Macro.Exception",
   "Lean.Name",
   "Lean.MonadQuotation",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadQuotationMacroM",
  "constType": "Lean.MonadQuotation Lean.MacroM",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, (∀ (a : α), Acc r a) → WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_4"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Ne",
   "List.cons",
   "False",
   "Lean.Data.AC.Expr",
   "Eq.refl",
   "List.casesOn",
   "True",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "HAppend.hAppend",
   "List",
   "eq_false'",
   "Lean.Data.AC.Expr.rec",
   "Not",
   "List.nil",
   "Nat",
   "List.noConfusion",
   "Eq.symm",
   "not_false_eq_true",
   "congrArg",
   "absurd",
   "Lean.Data.AC.Expr.toList",
   "Eq.trans",
   "id"],
  "name": "Lean.Data.AC.Context.toList_nonEmpty",
  "constType": "∀ (e : Lean.Data.AC.Expr), Lean.Data.AC.Expr.toList e ≠ []",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.MonadQuotation",
  "constType": "(Type → Type) → Type 1",
  "constCategory": "Other"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "GaloisConnection",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set.preimage",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "Eq.refl",
   "Preorder",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Eq",
   "Set.instMembershipSet",
   "Set.ext",
   "And",
   "upperBounds",
   "Iff",
   "of_eq_true",
   "propext",
   "forall_congr",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "GaloisConnection.upperBounds_l_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ (s : Set α), upperBounds (l '' s) = u ⁻¹' upperBounds s",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝ˢ»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "IsGreatest",
   "And.intro",
   "Preorder",
   "And.left",
   "IsLUB",
   "Set.instMembershipSet"],
  "name": "IsGreatest.isLUB",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsGreatest s a → IsLUB s a",
  "constCategory": "Theorem"},
 {"references":
  ["ContravariantClass.elim",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : ContravariantClass α α (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1] {a b c : α}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["WellFounded.fixF", "Acc.rec", "Acc.inv", "Acc.intro", "Acc", "rfl", "Eq"],
  "name": "WellFounded.fixFEq.proof_1",
  "constType":
  "∀ {α : Sort u_1} {r : α → α → Prop} {C : α → Sort u_2} (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p ↦ WellFounded.fixF F y (_ : Acc (fun y x ↦ r y x) y)",
  "constCategory": "Theorem"},
 {"references": ["OrderHom.mk", "Monotone", "OrderHom", "Preorder"],
  "name": "OrderHom.rec",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {motive : (α →o β) → Sort u} →\n          ((toFun : α → β) → (monotone' : Monotone toFun) → motive { toFun := toFun, monotone' := monotone' }) →\n            (t : α →o β) → motive t",
  "constCategory": "Other"},
 {"references": ["Multiset", "Add", "Multiset.add", "Add.mk"],
  "name": "Multiset.instAddMultiset",
  "constType": "{α : Type u_1} → Add (Multiset α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.IsIdempotent",
  "constType": "{α : Sort u} → (α → α → α) → Type",
  "constCategory": "Other"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.size", "Fin", "UInt32.rec"],
  "name": "UInt32.casesOn",
  "constType":
  "{motive : UInt32 → Sort u} → (t : UInt32) → ((val : Fin UInt32.size) → motive { val := val }) → motive t",
  "constCategory": "Definition"},
 {"references": ["List.Sublist", "List.nil"],
  "name": "List.Sublist.slnil",
  "constType": "∀ {α : Type u_1}, List.Sublist [] []",
  "constCategory": "Other"},
 {"references":
  ["Topology.instIsUpperProd.proof_1",
   "instTopologicalSpaceProd",
   "Prod.instPreorderProd",
   "Topology.IsUpper",
   "OrderTop",
   "TopologicalSpace",
   "Prod",
   "Preorder",
   "Preorder.toLE"],
  "name": "Topology.instIsUpperProd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α]\n  [inst_3 : OrderTop α] [inst_4 : Preorder β] [inst_5 : TopologicalSpace β] [inst_6 : Topology.IsUpper β]\n  [inst_7 : OrderTop β], Topology.IsUpper (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "Eq"],
  "name": "Topology.IsLowerSet.topology_eq_lowerSetTopology",
  "constType":
  "∀ {α : Type u_4} [t : TopologicalSpace α] [inst : Preorder α] [self : Topology.IsLowerSet α], t = Topology.lowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.Range._hyg.236",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.9",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "And",
   "Filter.mem_sup",
   "SemilatticeSup.toSup",
   "propext",
   "Set",
   "Sup.sup",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.25",
  "constType":
  "∀ {α : Type u} {f g : Filter α} {s : Set α}, (s ∈ f ⊔ g) = (s ∈ f ∧ s ∈ g)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsLowerSet",
   "Set",
   "HasCompl.compl",
   "LE",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsUpperSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "IsUpperSet.compl",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s : Set α}, IsUpperSet s → IsLowerSet sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Lean.SourceInfo",
   "Option.casesOn",
   "Option"],
  "name": "Lean.Syntax.getHeadInfo?.loop.match_1",
  "constType":
  "(motive : Option Lean.SourceInfo → Sort u_1) →\n  (x : Option Lean.SourceInfo) → ((info : Lean.SourceInfo) → motive (some info)) → (Unit → motive none) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.instMembershipSet"],
  "name": "Finset.mem_coe",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ ↑s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Filter.inter_mem",
   "Eq.rec",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Filter.mkOfClosure.proof_3",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), (Filter.generate s).sets = s → ∀ {x y : Set α}, x ∈ s → y ∈ s → x ∩ y ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] → [inst_1 : Zero N] → [self : ZeroHomClass F M N] → FunLike F M fun x ↦ N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Data.AC.Context",
  "constType": "Sort u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.Continuous_of._closed_1",
   "Topology.IsOpen_of._closed_1"],
  "name": "Topology.Continuous_of._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references": ["Trunc.eq", "Subsingleton.intro", "Subsingleton", "Trunc"],
  "name": "Trunc.instSubsingletonTrunc.proof_1",
  "constType": "∀ {α : Sort u_1}, Subsingleton (Trunc α)",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare", "Ordering", "Eq.refl", "instOrdNat", "Nat", "Eq"],
  "name": "Nat.linearOrder.proof_3",
  "constType": "∀ (a b : ℕ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.erase.match_2",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → α → Sort u_2) →\n    (x : List α) →\n      (x_1 : α) → ((x : α) → motive [] x) → ((a : α) → (as : List α) → (b : α) → motive (a :: as) b) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.inv",
  "constType":
  "{E : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EquivLike E α β] → E → β → α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Syntax.getArgs",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Syntax.node",
   "EStateM.Result.error",
   "Lean.Name.mkStr2",
   "Array",
   "Array.mkEmpty",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Array.append",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Symmetric",
  "constType": "{β : Sort v} → (β → β → Prop) → Prop",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Ici",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List.Subperm.refl",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le"],
  "name": "Multiset.instPartialOrderMultiset.proof_1",
  "constType": "∀ {α : Type u_1} (a : Multiset α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n < Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_6"],
  "name":
  "Topology._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termπ__1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.28",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Topology.lower",
   "Topology.IsLower",
   "Topology.IsLower.noConfusionType",
   "TopologicalSpace",
   "Preorder",
   "Topology.IsLower.casesOn",
   "Eq"],
  "name": "Topology.IsLower.noConfusion",
  "constType":
  "{α : Type u_1} →\n  {t : TopologicalSpace α} →\n    {inst : Preorder α} →\n      {P : Sort u} → {v1 v2 : Topology.IsLower α} → v1 = v2 → Topology.IsLower.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["BEq"],
  "name": "LawfulBEq",
  "constType": "(α : Type u) → [inst : BEq α] → Prop",
  "constCategory": "Other"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.492",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.mem_iUnion.match_2",
  "constType":
  "∀ {α : Type u_2} {ι : Sort u_1} {x : α} {s : ι → Set α} (motive : (∃ i, x ∈ s i) → Prop) (x_1 : ∃ i, x ∈ s i),\n  (∀ (a : ι) (h : x ∈ s a), motive (_ : ∃ i, x ∈ s i)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Topology.Continuous_of._closed_6", "_obj", "Lean.ParserDescr.symbol"],
  "name": "Topology.Continuous_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Bool.true",
   "Eq.refl",
   "Eq.casesOn",
   "Bool",
   "Eq.symm",
   "Eq"],
  "name": "List.mem_filter.match_1",
  "constType":
  "∀ {α : Type u_1} {x : α} {p : α → Bool} (motive : (a : α) → x = a → p a = true → Prop) (a : α) (x_1 : x = a)\n  (h : p a = true), (∀ (h : p x = true), motive x (_ : x = x) h) → motive a x_1 h",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "HasSubset.Subset",
   "BoundedOrder.toOrderTop",
   "Set.univ",
   "Preorder.toLE",
   "Eq",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "top_le_iff",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "BiheytingAlgebra.toCoheytingAlgebra"],
  "name": "Set.univ_subset_iff",
  "constType": "∀ {α : Type u} {s : Set α}, Set.univ ⊆ s ↔ s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "HNot.hnot",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra.sdiff_eq",
   "isCompl_compl",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "HNot.mk",
   "Lattice.toInf",
   "top_inf_eq",
   "Eq.mpr",
   "HImp.himp",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "id",
   "BooleanAlgebra.le_top",
   "Bot.bot",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "himp_eq",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "LE.le",
   "GeneralizedHeytingAlgebra.toTop",
   "DistribLattice.toLattice",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "bot_sup_eq",
   "propext",
   "HeytingAlgebra.mk",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.bot_le",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Set.range_subset_iff",
   "rfl",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.range_const_subset",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {c : α}, (Set.range fun x ↦ c) ⊆ {c}",
  "constCategory": "Theorem"},
 {"references":
  ["iInf_subtype",
   "Classical.choose_spec",
   "iInf_range",
   "CompleteSemilatticeInf.toPartialOrder",
   "Classical.choose",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "le_iInf",
   "Subtype.val",
   "Set",
   "CompletelyDistribLattice",
   "Eq.refl",
   "le_iSup",
   "Exists.intro",
   "iSup",
   "rfl",
   "True",
   "Preorder.toLE",
   "Eq",
   "Iff.of_eq",
   "Subtype.property",
   "Set.range",
   "Eq.mpr",
   "iSup_congr_Prop",
   "Set.Elem",
   "iSup_subtype",
   "le_trans",
   "Eq.symm",
   "iInf_le",
   "Eq.trans",
   "CompletelyDistribLattice.iInf_iSup_eq",
   "CompleteLattice.toSupSet",
   "Subtype",
   "id",
   "iInf_congr_Prop",
   "eq_self",
   "Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "funext",
   "iSup_range",
   "iSup_le",
   "LE.le",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "le_refl",
   "instTransEq",
   "le_iInf_iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "congrArg",
   "Subtype.mk"],
  "name": "iInf_iSup_eq",
  "constType":
  "∀ {α : Type u} {ι : Sort w} {κ : ι → Sort w'} [inst : CompletelyDistribLattice α] {f : (a : ι) → κ a → α},\n  ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.term𝓝._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype.complete",
   "Fintype",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Finset.mem_univ",
  "constType": "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT", "Unit", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "LE.le",
   "Preorder.toLE",
   "le_isGLB_iff",
   "Set.instMembershipSet",
   "Set.range",
   "Iff",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "lowerBounds",
   "Iff.trans",
   "Set.forall_range_iff",
   "CompleteLattice.toCompleteSemilatticeInf",
   "isGLB_iInf"],
  "name": "le_iInf_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, a ≤ iInf f ↔ ∀ (i : ι), a ≤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet", "Eq"],
  "name": "Set.insert",
  "constType": "{α : Type u_1} → α → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "∀ {α : Type u_1} (x y : Set α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references": ["And", "and_congr_left_iff", "Iff", "propext", "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.9",
  "constType": "∀ {a c b : Prop}, (a ∧ c ↔ b ∧ c) = (c → (a ↔ b))",
  "constCategory": "Theorem"},
 {"references":
  ["sup_compl_eq_top",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Eq.refl",
   "inf_sup_left",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra.sdiff_eq",
   "Preorder.toLE",
   "BooleanAlgebra",
   "inf_top_eq",
   "Eq",
   "OrderTop.toTop",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "BooleanAlgebra.toSDiff",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toTop",
   "id"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a b : α), a ⊓ b ⊔ a \\ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder",
   "GaloisInsertion.choice",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisInsertion.choice_eq",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α}\n  (self : GaloisInsertion l u) (a : α) (h : u (l a) ≤ a), GaloisInsertion.choice self a h = l a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "And",
   "setOf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Set",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "definition._@.Mathlib.Topology.Basic._hyg.10536",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Macro.Context", "_private.Init.Prelude.0.Lean.Macro.MethodsRef"],
  "name": "Lean.Macro.Context.methods",
  "constType": "Lean.Macro.Context → Lean.Macro.MethodsRef",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "eq_true",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.57",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), List.Sublist l₁ l₂ → List.Sublist (a :: l₁) (a :: l₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["InfTopHomClass",
   "Top",
   "outParam",
   "Top.top",
   "Inf",
   "InfHomClass.toFunLike",
   "FunLike.coe",
   "Eq",
   "InfHomClass"],
  "name": "InfTopHomClass.mk",
  "constType":
  "{F : Type u_7} →\n  {α : outParam (Type u_8)} →\n    {β : outParam (Type u_9)} →\n      [inst : Inf α] →\n        [inst_1 : Inf β] →\n          [inst_2 : Top α] →\n            [inst_3 : Top β] → [toInfHomClass : InfHomClass F α β] → (∀ (f : F), ↑f ⊤ = ⊤) → InfTopHomClass F α β",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "compl_compl",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Set.compl_sUnion",
   "Set.sUnion",
   "Set.image",
   "Set.sInter",
   "Eq.symm",
   "id"],
  "name": "Set.sUnion_eq_compl_sInter_compl",
  "constType": "∀ {α : Type u_1} (S : Set (Set α)), ⋃₀ S = (⋂₀ (compl '' S))ᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.ext",
   "upperBounds_mono_mem",
   "And.right",
   "upperBounds",
   "Set",
   "lowerBounds",
   "Set.Ici",
   "Preorder",
   "And.left",
   "IsLUB",
   "Eq",
   "Set.instMembershipSet"],
  "name": "IsLUB.upperBounds_eq",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, IsLUB s a → upperBounds s = Set.Ici a",
  "constCategory": "Theorem"},
 {"references": ["and_or_left", "And", "Or", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.25",
  "constType": "∀ {a b c : Prop}, (a ∧ (b ∨ c)) = (a ∧ b ∨ a ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Lean.Name",
  "constCategory": "Other"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Mathlib.Topology.Bases._auxLemma.2",
  "constType": "∀ {a b c : Prop}, (a ∧ b ∧ c) = (b ∧ a ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "Continuous",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "inf_inf_distrib_left",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "Eq.refl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "inf_bot_eq",
   "BooleanAlgebra.sdiff_eq",
   "Preorder.toLE",
   "BooleanAlgebra",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "OrderBot.toBot",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.toSDiff",
   "Eq.symm",
   "BooleanAlgebra.toDistribLattice",
   "inf_compl_eq_bot'",
   "BoundedOrder.toOrderBot",
   "id"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\ b = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "GeneralizedHeytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.le_himp_iff",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedHeytingAlgebra α] (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Definition"},
 {"references": ["Preorder"],
  "name": "GaloisCoinsertion",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["UInt32.mk", "UInt32", "UInt32.size", "Fin"],
  "name": "UInt32.rec",
  "constType":
  "{motive : UInt32 → Sort u} → ((val : Fin UInt32.size) → motive { val := val }) → (t : UInt32) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.mk",
  "constType": "{α : Type u_3} → (α → α) → HasCompl α",
  "constCategory": "Other"},
 {"references":
  ["And.rec",
   "Iff.intro",
   "And",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "And.imp",
   "And.intro",
   "Or.imp_right",
   "Or.rec"],
  "name": "or_and_left",
  "constType": "∀ {a b c : Prop}, a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "or_self.match_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ p → Prop) (x : p ∨ p),\n  (∀ (h : p), motive (_ : p ∨ p)) → (∀ (h : p), motive (_ : p ∨ p)) → motive x",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAppend",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LE.mk", "And", "Prod.snd", "LE", "Prod", "Prod.fst", "LE.le"],
  "name": "Prod.instLEProd",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : LE α] → [inst : LE β] → LE (α × β)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Min",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Decidable.casesOn",
   "Decidable.isFalse",
   "List.instMembershipList",
   "List",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "List.decidableBAll.match_3",
  "constType":
  "{α : Type u_1} →\n  (p : α → Prop) →\n    (xs : List α) →\n      (motive : Decidable (∀ x ∈ xs, p x) → Sort u_2) →\n        (x : Decidable (∀ x ∈ xs, p x)) →\n          ((h₂ : ∀ x ∈ xs, p x) → motive (isTrue h₂)) → ((h₂ : ¬∀ x ∈ xs, p x) → motive (isFalse h₂)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["outParam", "FunLike", "ContinuousMapClass", "TopologicalSpace"],
  "name": "ContinuousMapClass.toFunLike",
  "constType":
  "{F : Type u_1} →\n  {α : outParam (Type u_2)} →\n    {β : outParam (Type u_3)} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] → [self : ContinuousMapClass F α β] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references": ["Iff", "False", "iff_true_intro", "Not", "not_false", "True"],
  "name": "not_false_iff",
  "constType": "¬False ↔ True",
  "constCategory": "Theorem"},
 {"references": ["le_rfl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.lift.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder β] (f : α → β) (x : α), f x ≤ f x",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "Char",
   "List",
   "Unit",
   "Unit.unit",
   "List.casesOn",
   "List.nil"],
  "name": "String.utf8ByteSize.go.match_1",
  "constType":
  "(motive : List Char → Sort u_1) →\n  (x : List Char) → (Unit → motive []) → ((c : Char) → (cs : List Char) → motive (c :: cs)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "OrderDual.lattice.proof_6",
   "OrderDual.lattice.proof_5",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "OrderDual.lattice.proof_1",
   "SemilatticeSup",
   "OrderDual.lattice.proof_2",
   "OrderDual.semilatticeInf",
   "OrderDual.lattice.proof_4",
   "SemilatticeSup.toSup",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "OrderDual.lattice.proof_3",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "OrderDual.lattice",
  "constType": "(α : Type u_1) → [inst : Lattice α] → Lattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["Lean.Macro.Context", "Nat"],
  "name": "Lean.Macro.Context.currRecDepth",
  "constType": "Lean.Macro.Context → ℕ",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.gt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left.match_1",
  "constType":
  "∀ {a b c : ℕ} (motive : (∃ k, a + b + k = a + c) → Prop) (x : ∃ k, a + b + k = a + c),\n  (∀ (d : ℕ) (hd : a + b + d = a + c), motive (_ : ∃ k, a + b + k = a + c)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_10",
   "Topology.IsOpen_of._closed_5",
   "Topology.IsClosed_of._closed_4"],
  "name": "Topology.IsClosed_of._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.preimage",
   "Set",
   "HasSubset.Subset.trans",
   "HasSubset.Subset",
   "Exists.intro",
   "Set.Subset.rfl",
   "Eq",
   "Iff.intro",
   "Filter.comap_principal.match_1",
   "Filter.principal",
   "And",
   "Set.instHasSubsetSet",
   "Filter.comap",
   "Filter",
   "And.intro",
   "Filter.ext",
   "Set.preimage_mono",
   "instMembershipSetFilter"],
  "name": "Filter.comap_principal",
  "constType":
  "∀ {α : Type u} {β : Type v} {m : α → β} {t : Set β}, Filter.comap m (Filter.principal t) = Filter.principal (m ⁻¹' t)",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "GaloisInsertion", "Preorder.toLE"],
  "name": "GaloisInsertion.choice",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisInsertion l u → (x : α) → u (l x) ≤ x → β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instLENat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "LE.le",
   "True",
   "Eq"],
  "name": "Init.Data.Nat.Basic._auxLemma.1",
  "constType": "∀ (n : ℕ), (0 ≤ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "EStateM",
   "EStateM.modifyGet.match_1",
   "Prod",
   "EStateM.Result"],
  "name": "EStateM.modifyGet",
  "constType": "{ε σ α : Type u} → (σ → α × σ) → EStateM ε σ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.mem_filter",
   "List.filter",
   "List.instMembershipList",
   "propext",
   "List",
   "Bool.true",
   "Bool",
   "Eq"],
  "name": "Std.Data.List.Count._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {x : α} {p : α → Bool} {as : List α}, (x ∈ List.filter p as) = (x ∈ as ∧ p x = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat"],
  "name": "Nat.ge_of_not_lt",
  "constType": "∀ {n m : ℕ}, ¬n < m → n ≥ m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.removeNeutrals",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.loop.match_1.splitter",
   "Lean.IsNeutral.right_neutral",
   "instDecidableEqList",
   "List.casesOn",
   "Eq.refl",
   "Lean.Data.AC.Context.unwrap_isNeutral",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "Lean.Data.AC.List.two_step_induction",
   "Lean.IsNeutral.left_neutral",
   "Bool.true",
   "Lean.Data.AC.instContextInformationContext",
   "List.nil",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Lean.Data.AC.ContextInformation.isNeutral",
   "Lean.Data.AC.EvalInformation.evalOp",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.splitter",
   "id",
   "eq_self",
   "funext",
   "List.cons",
   "False",
   "Unit",
   "Lean.Data.AC.removeNeutrals.loop.match_1",
   "Lean.Data.AC.removeNeutrals.match_1",
   "eq_false_of_decide",
   "_private.Init.Data.AC.0.Lean.Data.AC.evalList._eq_3",
   "instDecidableFalse",
   "Bool.casesOn",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "False.elim",
   "Lean.Data.AC.removeNeutrals.loop",
   "of_eq_true",
   "Bool.false",
   "List",
   "instDecidableForAll",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Eq.mp",
   "congr",
   "Bool",
   "List.noConfusion",
   "congrArg",
   "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.eq_2",
   "congrFun"],
  "name": "Lean.Data.AC.Context.evalList_removeNeutrals",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α) (e : List ℕ),\n  Lean.Data.AC.evalList α ctx (Lean.Data.AC.removeNeutrals ctx e) = Lean.Data.AC.evalList α ctx e",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop", "Top.top", "le_top", "OrderTop", "LE", "IsTop"],
  "name": "isTop_top",
  "constType": "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α], IsTop ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«termI^_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α}, (a ∈ b :: l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["List", "List.range.loop", "List.nil", "Nat"],
  "name": "List.range",
  "constType": "ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "Inter.inter",
   "Exists.intro",
   "rfl",
   "Preorder.toLE",
   "Set.Subset.rfl",
   "True",
   "Mathlib.Data.Set.Basic._auxLemma.26",
   "Eq",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Eq.mpr",
   "Filter",
   "Eq.trans",
   "instMembershipSetFilter",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "HasSubset.Subset",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "And",
   "Set.instHasSubsetSet",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "congr",
   "And.intro",
   "Mathlib.Data.Set.Basic._auxLemma.27",
   "congrArg",
   "le_antisymm",
   "and_self",
   "Mathlib.Order.Filter.Basic._auxLemma.42",
   "Set.instInterSet"],
  "name": "Filter.inf_principal",
  "constType":
  "∀ {α : Type u} {s t : Set α}, Filter.principal s ⊓ Filter.principal t = Filter.principal (s ∩ t)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "UInt32.size",
   "Nat",
   "instLTNat"],
  "name": "Char.utf8Size.proof_5",
  "constType": "65535 < UInt32.size",
  "constCategory": "Theorem"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Top.top",
   "Inf.inf",
   "inf_of_le_right",
   "le_top",
   "SemilatticeInf.toPartialOrder",
   "OrderTop",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "top_inf_eq",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] {a : α}, ⊤ ⊓ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set.ball_empty_iff",
   "Set",
   "Set.instEmptyCollectionSet",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.18",
  "constType": "∀ {α : Type u} {p : α → Prop}, (∀ x ∈ ∅, p x) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.decidableBEx.match_5",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((x : α) → (xs : List α) → motive (x :: xs)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Acc.rec", "Acc.intro", "Acc"],
  "name": "Acc.recOn",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : (a : α) → Acc r a → Sort u_1} →\n      {a : α} →\n        (t : Acc r a) →\n          ((x : α) →\n              (h : ∀ (y : α), r y x → Acc r y) →\n                ((y : α) → (a : r y x) → motive y (_ : Acc r y)) → motive x (_ : Acc r x)) →\n            motive a t",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "UpperSet.coe_iInf",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.Ici",
   "Mathlib.Order.UpperLower.Basic._auxLemma.94",
   "UpperSet",
   "SetLike.instMembership",
   "Preorder.toLE",
   "True",
   "Eq",
   "iff_self",
   "Iff.of_eq",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "upperClosure",
   "Set.iUnion_congr_Prop",
   "Std.Logic._auxLemma.52",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "UpperSet.Ici",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Preorder",
   "LE.le",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Set.instMembershipSet",
   "And",
   "of_eq_true",
   "iInf",
   "UpperSet.ext",
   "congr",
   "congrArg",
   "SetLike.coe",
   "exists_prop_congr'"],
  "name": "UpperSet.iInf_Ici",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (s : Set α), ⨅ a ∈ s, UpperSet.Ici a = upperClosure s",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.mp_mem.match_1",
   "Membership.mem",
   "setOf",
   "Filter.inter_mem",
   "Set",
   "Filter.mem_of_superset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mp_mem",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → {x | x ∈ s → x ∈ t} ∈ f → t ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["add_right_cancel",
   "Function.Injective",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add"],
  "name": "add_left_injective",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G), Function.Injective fun x ↦ x + a",
  "constCategory": "Theorem"},
 {"references":
  ["Char.val",
   "UInt32",
   "Char",
   "Char.val_eq_of_eq",
   "False",
   "Not",
   "absurd",
   "Eq"],
  "name": "Char.ne_of_val_ne",
  "constType": "∀ {c d : Char}, ¬c.val = d.val → ¬c = d",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instSubNat",
   "Nat.succ_sub",
   "Nat.sub_le_sub_right",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "instLTNat",
   "Eq",
   "Nat.add_sub_cancel_left",
   "instLENat",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "Nat",
   "Nat.succ"],
  "name": "Nat.sub_lt_left_of_lt_add",
  "constType": "∀ {n k m : ℕ}, n ≤ k → k < n + m → k - n < m",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "Set.univ", "rfl", "Eq"],
  "name": "Set.preimage_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f ⁻¹' Set.univ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "HasSubset.Subset", "HasSubset", "Eq", "subset_of_eq"],
  "name": "Eq.subset'",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsRefl α fun x x_1 ↦ x ⊆ x_1], a = b → a ⊆ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "induced_id",
   "Inducing.mk",
   "Topology.lowerSet",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLowerSet",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Topology.WithLowerSet",
   "Eq.ndrec",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "TopologicalSpace",
   "Topology.WithLowerSet.ofLowerSet",
   "TopologicalSpace.induced",
   "Topology.IsLowerSet.topology_eq",
   "id"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α],\n  Inducing ↑Topology.WithLowerSet.ofLowerSet",
  "constCategory": "Theorem"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Contravariant M N μ r → ContravariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "_auto._@.Mathlib.Topology.Homeomorph._hyg.17",
   "Equiv.invFun",
   "Continuous",
   "Homeomorph",
   "_auto._@.Mathlib.Topology.Homeomorph._hyg.46",
   "TopologicalSpace",
   "autoParam"],
  "name": "Homeomorph.mk",
  "constType":
  "{X : Type u_4} →\n  {Y : Type u_5} →\n    [inst : TopologicalSpace X] →\n      [inst_1 : TopologicalSpace Y] →\n        (toEquiv : X ≃ Y) →\n          autoParam (Continuous toEquiv.toFun) _auto✝ → autoParam (Continuous toEquiv.invFun) _auto✝¹ → X ≃ₜ Y",
  "constCategory": "Other"},
 {"references":
  ["Std.Logic._auxLemma.29",
   "Membership.mem",
   "Exists",
   "List.instMembershipList",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.12",
   "Std.Logic._auxLemma.23",
   "implies_congr",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.57",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "List",
   "forall_congr",
   "List.map",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.forall_mem_map_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {P : β → Prop}, (∀ i ∈ List.map f l, P i) ↔ ∀ j ∈ l, P (f j)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_3",
   "Lean.Name.str._override"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.Variable"],
  "name": "Lean.Data.AC.Variable.value",
  "constType": "{α : Sort u} → {op : α → α → α} → Lean.Data.AC.Variable op → α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "Iff",
   "Iff.rfl",
   "FunLike.coe",
   "Topology.WithUpper.toUpper",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Topology.WithUpper.toUpper_inj",
  "constType":
  "∀ {α : Type u_1} {a b : α}, ↑Topology.WithUpper.toUpper a = ↑Topology.WithUpper.toUpper b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.booleanAlgebra.proof_3",
   "HeytingAlgebra",
   "Pi.booleanAlgebra.proof_1",
   "Pi.booleanAlgebra.proof_7",
   "HeytingAlgebra.toBot",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "SDiff.sdiff",
   "Pi.booleanAlgebra.proof_2",
   "BooleanAlgebra",
   "Pi.heytingAlgebra",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.distribLattice",
   "BooleanAlgebra.mk",
   "GeneralizedHeytingAlgebra.toTop",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Pi.booleanAlgebra.proof_6",
   "DistribLattice",
   "Pi.booleanAlgebra.proof_5",
   "SDiff.mk",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "BooleanAlgebra.toSDiff",
   "SDiff",
   "BooleanAlgebra.toDistribLattice",
   "HeytingAlgebra.toHasCompl",
   "Pi.booleanAlgebra.proof_4"],
  "name": "Pi.booleanAlgebra",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → BooleanAlgebra (α i)] → BooleanAlgebra ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.MacroScopesView", "List", "Lean.Name", "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.mk",
  "constType":
  "Lean.Name → Lean.Name → Lean.Name → List Lean.MacroScope → Lean.MacroScopesView",
  "constCategory": "Other"},
 {"references":
  ["_obj", "_neutral", "Topology.IsLowerSet.WithLowerSetHomeomorph._rarg"],
  "name": "Topology.IsLowerSet.WithLowerSetHomeomorph._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["Set.range", "SupSet", "Eq.refl", "SupSet.sSup", "iSup", "Eq"],
  "name": "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
  "constType":
  "∀ {α : Type u_1} [inst : SupSet α] {ι : Sort u_9} (s : ι → α), iSup s = sSup (Set.range s)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Exists.intro", "Exists.casesOn", "Subtype.mk", "Subtype"],
  "name": "Subtype.exists.match_2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}\n  (motive : (∃ a, ∃ (b : p a), q { val := a, property := b }) → Prop)\n  (x : ∃ a, ∃ (b : p a), q { val := a, property := b }),\n  (∀ (a : α) (b : p a) (h : q { val := a, property := b }),\n      motive (_ : ∃ a, ∃ (b : p a), q { val := a, property := b })) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "And",
   "Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.map",
   "List.get",
   "List.length",
   "Exists.casesOn",
   "instLTFin",
   "Fin",
   "Eq"],
  "name": "List.sublist_eq_map_get.match_1",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}\n  (motive : (∃ is, l₁ = List.map (List.get l₂) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is) → Prop)\n  (IH : ∃ is, l₁ = List.map (List.get l₂) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is),\n  (∀ (is : List (Fin (List.length l₂))) (IH : l₁ = List.map (List.get l₂) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is),\n      motive (_ : ∃ is, l₁ = List.map (List.get l₂) is ∧ List.Pairwise (fun x x_1 ↦ x < x_1) is)) →\n    motive IH",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "And.intro",
   "And.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mp_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {s t : Set α} (x : α) (motive : x ∈ s ∩ {x | x ∈ s → x ∈ t} → Prop)\n  (x_1 : x ∈ s ∩ {x | x ∈ s → x ∈ t}),\n  (∀ (h₁ : x ∈ s) (h₂ : x ∈ {x | x ∈ s → x ∈ t}), motive (_ : x ∈ s ∧ x ∈ {x | x ∈ s → x ∈ t})) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "Topology.IsClosed_of._closed_6",
   "Topology.IsClosed_of._closed_2"],
  "name": "Topology.IsClosed_of._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Iff",
   "Topology.WithUpperSet.instPreorderWithUpperSet",
   "Equiv.refl",
   "lcProof",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.ofUpperSetOrderIso._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithUpperSet α ≃o α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Eq.rec",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "Eq.symm",
   "absurd",
   "instLTNat",
   "Eq"],
  "name": "Nat.ne_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.IsAssociative.assoc",
   "instDecidableEqList",
   "Eq.refl",
   "List.casesOn",
   "implies_congr",
   "True",
   "instDecidableEqNat",
   "Eq",
   "Lean.Data.AC.Context.assoc",
   "Eq.mpr",
   "Lean.Data.AC.evalList",
   "Lean.Data.AC.Context",
   "eq_false'",
   "instDecidableNot",
   "Lean.Data.AC.List.two_step_induction",
   "List.nil",
   "Nat",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "id",
   "true_implies",
   "eq_self",
   "Ne",
   "List.append",
   "List.cons",
   "False",
   "eq_false_of_decide",
   "Lean.Data.AC.Context.op",
   "instHAppend",
   "False.elim",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "List",
   "Bool.false",
   "HAppend.hAppend",
   "Eq.mp",
   "Lean.Data.AC.EvalInformation.evalVar",
   "Not",
   "Bool",
   "List.noConfusion",
   "congrArg"],
  "name": "Lean.Data.AC.Context.evalList_append",
  "constType":
  "∀ {α : Sort u_1} (ctx : Lean.Data.AC.Context α) (l r : List ℕ),\n  l ≠ [] →\n    r ≠ [] →\n      Lean.Data.AC.evalList α ctx (List.append l r) =\n        Lean.Data.AC.Context.op ctx (Lean.Data.AC.evalList α ctx l) (Lean.Data.AC.evalList α ctx r)",
  "constCategory": "Theorem"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "Ne",
   "And",
   "Iff.mp",
   "False",
   "List.Pairwise.map",
   "List.Nodup",
   "List.Pairwise.and_mem",
   "List.instMembershipList",
   "List",
   "List.map",
   "List.Nodup.map_on.match_1",
   "Eq"],
  "name": "List.Nodup.map_on",
  "constType":
  "∀ {α : Type u} {β : Type v} {l : List α} {f : α → β},\n  (∀ x ∈ l, ∀ y ∈ l, f x = f y → x = y) → List.Nodup l → List.Nodup (List.map f l)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Sup",
   "Prod.instSupProd",
   "SemilatticeSup.mk",
   "Sup.mk",
   "PartialOrder",
   "Prod.semilatticeSup.proof_3",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "Prod.instPartialOrder",
   "inferInstanceAs",
   "Prod.semilatticeSup.proof_4",
   "Prod",
   "Sup.sup",
   "Prod.semilatticeSup.proof_2",
   "Prod.semilatticeSup.proof_1",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prod.semilatticeSup",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : SemilatticeSup α] → [inst : SemilatticeSup β] → SemilatticeSup (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["List.eraseP_cons_of_pos",
   "Exists",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "Eq.refl",
   "dite",
   "Exists.intro",
   "Iff.mpr",
   "True",
   "List.eraseP_cons_of_neg",
   "Eq",
   "PProd",
   "Bool.of_not_eq_true",
   "Eq.mpr",
   "List.eraseP",
   "List.rec",
   "Bool.true",
   "PUnit",
   "List.nil",
   "List.Sublist.eq_of_length.match_1",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "instDecidableEqBool",
   "Membership.mem",
   "eq_self",
   "List.exists_of_eraseP.match_1",
   "List.cons",
   "False",
   "List.Mem",
   "eq_false_of_decide",
   "List.forall_mem_cons",
   "List.cons_append",
   "List.exists_of_eraseP.match_2",
   "instHAppend",
   "And",
   "PProd.fst",
   "Eq.ndrec",
   "List.instAppendList",
   "of_eq_true",
   "Bool.false",
   "HAppend.hAppend",
   "List",
   "List.forall_mem_nil",
   "congr",
   "Not",
   "Bool",
   "And.intro",
   "List.exists_of_eraseP.match_3",
   "congrArg",
   "and_self",
   "congrFun"],
  "name": "List.exists_of_eraseP",
  "constType":
  "∀ {α : Type u_1} {p : α → Bool} {l : List α} {a : α},\n  a ∈ l →\n    p a = true → ∃ a, ∃ l₁, ∃ l₂, (∀ b ∈ l₁, ¬p b = true) ∧ p a = true ∧ l = l₁ ++ a :: l₂ ∧ List.eraseP p l = l₁ ++ l₂",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instCanLiftSetFinsetToSetFinite.proof_1",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite",
  "constType":
  "∀ {α : Type u}, CanLift (Set α) (Finset α) Finset.toSet Set.Finite",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "implies_congr",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "True",
   "iff_self",
   "Mathlib.Topology.Basic._auxLemma.5",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "Function.Surjective.forall",
   "compl_surjective",
   "Iff.trans",
   "IsClosed",
   "congrArg",
   "Eq.trans",
   "IsOpen",
   "congrFun",
   "continuous_def"],
  "name": "continuous_iff_isClosed",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f ↔ ∀ (s : Set β), IsClosed s → IsClosed (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_11"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "autoParam",
   "LE.le",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2928",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2967",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2889",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 ↦ x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 ↦ x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["_obj", "Topology.Homotopy.«termΩ^»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.Homotopy.«termΩ^»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "False",
   "List",
   "List.casesOn",
   "List.nil",
   "List.noConfusion",
   "Nat",
   "Eq"],
  "name":
  "_private.Init.Data.AC.0.Lean.Data.AC.removeNeutrals.match_1.splitter",
  "constType":
  "(motive : List ℕ → Sort u_1) → (x : List ℕ) → motive [] → ((ys : List ℕ) → (ys = [] → False) → motive ys) → motive x",
  "constCategory": "Definition"},
 {"references": ["Char.mk", "UInt32", "Char", "UInt32.isValidChar"],
  "name": "Char.rec",
  "constType":
  "{motive : Char → Sort u} →\n  ((val : UInt32) → (valid : UInt32.isValidChar val) → motive { val := val, valid := valid }) → (t : Char) → motive t",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._lambda_1"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhdsWithin_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadState", "Prod"],
  "name": "MonadState.modifyGet",
  "constType":
  "{σ : outParam (Type u)} → {m : Type u → Type v} → [self : MonadState σ m] → {α : Type u} → (σ → α × σ) → m α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.instPreorderProd.match_5",
   "Prod.snd",
   "Prod.instPreorderProd.match_4",
   "Prod.instLEProd",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Prod.mk",
   "Prod.instPreorderProd.match_2",
   "Prod.instPreorderProd.match_3",
   "inferInstanceAs",
   "LE",
   "Prod",
   "le_trans",
   "And.intro"],
  "name": "Prod.instPreorderProd.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Preorder α] [inst_1 : Preorder β] (x x_1 x_2 : α × β),\n  x ≤ x_1 → x_1 ≤ x_2 → x ≤ x_2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Char",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["BiheytingAlgebra",
   "BooleanAlgebra.le_top",
   "BooleanAlgebra.toBiheytingAlgebra.proof_2",
   "HasCompl.compl",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.toBiheytingAlgebra.proof_1",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff",
   "BooleanAlgebra",
   "HNot.mk",
   "DistribLattice.toLattice",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "BooleanAlgebra.toHImp",
   "GeneralizedCoheytingAlgebra",
   "BiheytingAlgebra.mk",
   "HeytingAlgebra.mk",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toBiheytingAlgebra.proof_3",
   "BooleanAlgebra.toTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra",
  "constType": "{α : Type u} → [inst : BooleanAlgebra α] → BiheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.univ_sets",
   "Set",
   "Filter",
   "Set.univ",
   "instMembershipSetFilter"],
  "name": "Filter.univ_mem",
  "constType": "∀ {α : Type u} {f : Filter α}, Set.univ ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.term𝓝",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "_obj",
   "Topology.IsOpen_of._closed_5",
   "Topology.«term𝓝[>]_»._closed_4",
   "Topology.«term𝓝[_]_»._closed_9"],
  "name": "Topology.«term𝓝[>]_»._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Fin.val",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Nat",
   "Fin",
   "Eq"],
  "name": "instDecidableEqFin.match_1",
  "constType":
  "(n : ℕ) →\n  (i j : Fin n) →\n    (motive : Decidable (↑i = ↑j) → Sort u_1) →\n      (x : Decidable (↑i = ↑j)) → ((h : ↑i = ↑j) → motive (isTrue h)) → ((h : ¬↑i = ↑j) → motive (isFalse h)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Prod.snd",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.mk",
   "Prod.fst",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "And",
   "CompleteLattice",
   "Prod.supSet",
   "le_sSup",
   "Prod",
   "And.intro",
   "Set.image",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet",
   "Set.mem_image_of_mem"],
  "name": "Prod.completeLattice.proof_4",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (x : Set (α × β)),\n  ∀ x_1 ∈ x, x_1.1 ≤ (sSup x).1 ∧ x_1.2 ≤ (sSup x).2",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Ne",
   "List.erase_cons",
   "List.cons",
   "instBEq",
   "List.erase",
   "True",
   "Eq",
   "ite",
   "DecidableEq",
   "of_eq_true",
   "List",
   "Decidable",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "congrFun"],
  "name": "List.erase_cons_tail",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} (l : List α), b ≠ a → List.erase (b :: l) a = b :: List.erase l a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddRightCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Array",
   "GetElem.mk",
   "LT.lt",
   "Array.get",
   "Nat",
   "Array.size",
   "instLTNat",
   "Fin.mk",
   "GetElem"],
  "name": "instGetElemArrayNatLtInstLTNatSize",
  "constType":
  "{α : Type u_1} → GetElem (Array α) ℕ α fun xs i ↦ i < Array.size xs",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Prod.instPreorderProd.match_1",
   "Prod.snd",
   "Prod.mk",
   "le_refl",
   "Prod.instLEProd",
   "LE",
   "inferInstanceAs",
   "Prod",
   "Prod.fst",
   "And.intro",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Prod.instPreorderProd.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Preorder α] [inst_1 : Preorder β] (x : α × β), x ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_inf_iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.13",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, (a ≤ b ⊓ c) = (a ≤ b ∧ a ≤ c)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Context", "Lean.Name"],
  "name": "Lean.Macro.Context.mainModule",
  "constType": "Lean.Macro.Context → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.forall_mem_nil.match_1",
   "List.instMembershipList",
   "List",
   "List.nil"],
  "name": "List.forall_mem_nil",
  "constType": "∀ {α : Type u_1} (p : α → Prop), ∀ x ∈ [], p x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Quot.liftOn",
   "Setoid.r",
   "List.instMembershipList",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Mem.proof_1"],
  "name": "Multiset.Mem",
  "constType": "{α : Type u_1} → α → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((a : ℕ) → motive a Nat.zero) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "LE.le",
   "Multiset.instAddMultiset",
   "ContravariantClass",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1",
  "constType":
  "∀ {α : Type u_1}, ContravariantClass (Multiset α) (Multiset α) (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsOpen_of._closed_8",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name": "Topology.IsOpen_of._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Bool.casesOn",
   "Lean.SourceInfo.casesOn",
   "Bool.false",
   "Bool.true",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "optParam",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.getPos?.match_1",
  "constType":
  "(motive : Lean.SourceInfo → optParam Bool false → Sort u_1) →\n  (info : Lean.SourceInfo) →\n    (canonicalOnly : optParam Bool false) →\n      ((leading : Substring) →\n          (pos : String.Pos) →\n            (trailing : Substring) →\n              (endPos : String.Pos) →\n                (x : optParam Bool false) → motive (Lean.SourceInfo.original leading pos trailing endPos) x) →\n        ((pos endPos : String.Pos) → (x : optParam Bool false) → motive (Lean.SourceInfo.synthetic pos endPos true) x) →\n          ((pos endPos : String.Pos) → (canonical : Bool) → motive (Lean.SourceInfo.synthetic pos endPos canonical)) →\n            ((x : Lean.SourceInfo) → (x_1 : optParam Bool false) → motive x x_1) → motive info canonicalOnly",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.forall_mem_cons.match_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α} (motive : (p a ∧ ∀ x ∈ l, p x) → Prop) (x : p a ∧ ∀ x ∈ l, p x),\n  (∀ (H₁ : p a) (H₂ : ∀ x ∈ l, p x), motive (_ : p a ∧ ∀ x ∈ l, p x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp",
   "nhds",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "Inducing",
   "inducing_iff_nhds",
   "Eq"],
  "name": "Inducing.nhds_eq_comap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Inducing f → ∀ (a : α), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Prod.snd",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Prod.fst",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Preorder.mk",
   "Prod.instPreorderProd",
   "Preorder.toLT",
   "inferInstanceAs",
   "Prod",
   "And.intro",
   "And.casesOn",
   "Preorder.lt_iff_le_not_le"],
  "name": "Prod.instPartialOrder.match_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (x x_1 : α × β),\n  let src := inferInstanceAs (Preorder (α × β));\n  ∀ (motive : x_1 ≤ x → Prop) (x_2 : x_1 ≤ x),\n    (∀ (hca : x_1.1 ≤ x.1) (hdb : x_1.2 ≤ x.2), motive (_ : x_1.1 ≤ x.1 ∧ x_1.2 ≤ x.2)) → motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.filter_length_eq_length",
   "List.filter",
   "Iff.rfl",
   "List.instMembershipList",
   "Eq.refl",
   "List.length",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "List",
   "propext",
   "Bool.true",
   "Bool",
   "Nat",
   "List.countP",
   "id",
   "List.countP_eq_length_filter"],
  "name": "List.countP_eq_length",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {l : List α}, List.countP p l = List.length l ↔ ∀ a ∈ l, p a = true",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List.Pairwise.brecOn",
   "List",
   "Function.comp",
   "Unit",
   "List.Pairwise.imp.match_1._@.Std.Data.List.Lemmas._hyg.29208",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.imp",
  "constType":
  "∀ {α : Type u_1} {R S : α → α → Prop},\n  (∀ {a b : α}, R a b → S a b) → ∀ {l : List α}, List.Pairwise R l → List.Pairwise S l",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.reverseAux.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → List α → Sort u_2) →\n    (x x_1 : List α) → ((r : List α) → motive [] r) → ((a : α) → (l r : List α) → motive (a :: l) r) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "Inf.inf",
   "GeneralizedBooleanAlgebra.toSDiff",
   "GeneralizedBooleanAlgebra",
   "SDiff.sdiff",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "Eq"],
  "name": "GeneralizedBooleanAlgebra.sup_inf_sdiff",
  "constType":
  "∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊔ a \\ b = a",
  "constCategory": "Definition"},
 {"references": ["CoheytingAlgebra", "HNot"],
  "name": "CoheytingAlgebra.toHNot",
  "constType": "{α : Type u_4} → [self : CoheytingAlgebra α] → HNot α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup", "Finset.univ", "Fintype", "Finset.val", "Multiset.Nodup"],
  "name": "Fintype.truncEquivFin.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Fintype α], Multiset.Nodup Finset.univ.val",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "List.instMembershipList",
   "implies_true",
   "Eq.refl",
   "implies_congr_ctx",
   "True",
   "iff_self",
   "List.Pairwise",
   "And",
   "eq_true",
   "Iff",
   "of_eq_true",
   "List",
   "List.Pairwise.iff_of_mem",
   "forall_congr",
   "congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.Pairwise.and_mem",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {l : List α}, List.Pairwise R l ↔ List.Pairwise (fun x y ↦ x ∈ l ∧ y ∈ l ∧ R x y) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "Iff",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Set",
   "Function.comp",
   "Set.Ici",
   "Set.ext_iff",
   "eq_of_forall_ge_iff",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "PartialOrder"],
  "name": "Set.Ici_injective",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α], Function.Injective Set.Ici",
  "constCategory": "Theorem"},
 {"references": ["MonadExceptOf.throw", "MonadExceptOf"],
  "name": "throwThe",
  "constType":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.casesOn",
   "HEq",
   "eq_of_heq",
   "List.Sublist",
   "List.Sublist.cons",
   "Eq.refl",
   "List.length",
   "List.Sublist.slnil",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "List",
   "List.Sublist.cons₂",
   "List.nil",
   "Nat",
   "Eq.symm"],
  "name": "List.Sublist.eq_of_length.match_2",
  "constType":
  "∀ {α : Type u_1} (motive : (l₂ l₁ : List α) → List.Sublist l₁ l₂ → List.length l₁ = List.length l₂ → Prop)\n  (l₂ l₁ : List α) (x : List.Sublist l₁ l₂) (x_1 : List.length l₁ = List.length l₂),\n  (∀ (x : List.length [] = List.length []), motive [] [] (_ : List.Sublist [] []) x) →\n    (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (h : List.length l₁ = List.length (a :: l₂)),\n        motive (a :: l₂) l₁ (_ : List.Sublist l₁ (a :: l₂)) h) →\n      (∀ (l₁ l₂ : List α) (a : α) (s : List.Sublist l₁ l₂) (h : List.length (a :: l₁) = List.length (a :: l₂)),\n          motive (a :: l₂) (a :: l₁) (_ : List.Sublist (a :: l₁) (a :: l₂)) h) →\n        motive l₂ l₁ x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "OrderDual",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "Preorder.toLE",
   "OrderDual.boundedOrder"],
  "name": "OrderDual.completeLattice.proof_4",
  "constType": "∀ (α : Type u_1) [inst : CompleteLattice α] (a : αᵒᵈ), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["And", "Iff", "Prod.mk.injEq", "Prod.mk", "Prod", "Eq", "Iff.of_eq"],
  "name": "Prod.mk.inj_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a₁ a₂ : α} {b₁ b₂ : β}, (a₁, b₁) = (a₂, b₂) ↔ a₁ = a₂ ∧ b₁ = b₂",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Set.instHasSubsetSet",
   "propext",
   "Union.union",
   "Set",
   "HasSubset.Subset",
   "Set.union_subset_iff",
   "Set.instUnionSet",
   "Eq"],
  "name": "Mathlib.Order.Filter.Basic._auxLemma.57",
  "constType": "∀ {α : Type u} {s t u : Set α}, (s ∪ t ⊆ u) = (s ⊆ u ∧ t ⊆ u)",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.lowerSet",
   "TopologicalSpace",
   "Topology.IsLowerSet",
   "Preorder",
   "rfl",
   "Topology.IsLowerSet.mk"],
  "name": "Topology.instIsLowerSetLowerSet.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLowerSet α",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder", "Preorder.toLE", "BoundedOrder", "PartialOrder"],
  "name": "IsCompl",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : BoundedOrder α] → α → α → Prop",
  "constCategory": "Other"},
 {"references": ["OrderDual", "TopologicalSpace"],
  "name": "instTopologicalSpaceOrderDual",
  "constType":
  "{α : Type u} → [inst : TopologicalSpace α] → TopologicalSpace αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.instUnionList",
   "List.insert",
   "Mathlib.Data.List.Perm._auxLemma.31",
   "Union.union",
   "True",
   "List.nil_union",
   "List.cons_union",
   "eq_true",
   "List.Perm",
   "DecidableEq",
   "List.rec",
   "of_eq_true",
   "List",
   "congr",
   "List.nil",
   "congrArg",
   "Eq.trans"],
  "name": "List.Perm.union_left",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] (l : List α) {t₁ t₂ : List α}, t₁ ~ t₂ → l ∪ t₁ ~ l ∪ t₂",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.append",
   "List.brecOn",
   "List.below",
   "Iff.rfl",
   "List.Subperm",
   "Unit",
   "List.subperm_cons",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "Iff",
   "List.instAppendList",
   "List.rec",
   "List",
   "HAppend.hAppend",
   "PUnit",
   "List.Perm.refl.match_1",
   "Iff.trans",
   "List.nil"],
  "name": "List.subperm_append_left",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α} (l : List α), l ++ l₁ <+~ l ++ l₂ ↔ l₁ <+~ l₂",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.IsOpen_of._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse"],
  "name": "Function.RightInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "List.cons",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "List",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "And.intro",
   "List.noConfusion",
   "Eq.symm",
   "And.casesOn",
   "Eq.propIntro",
   "Eq"],
  "name": "List.cons.injEq",
  "constType":
  "∀ {α : Type u} (head : α) (tail : List α) (head_1 : α) (tail_1 : List α),\n  (head :: tail = head_1 :: tail_1) = (head = head_1 ∧ tail = tail_1)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "Preorder.toLE",
   "ContravariantClass",
   "Multiset.instPartialOrderMultiset",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset.proof_1"],
  "name":
  "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "∀ {α : Type u_1}, ContravariantClass (Multiset α) (Multiset α) (fun x x_1 ↦ x + x_1) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Unit",
   "Nat.ble_self_eq_true",
   "Nat.ble_eq_true_of_le.match_1",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.ble_succ_eq_true",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.ble n m = true",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Injective",
   "EmbeddingLike.injective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe"],
  "name": "EquivLike.injective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Injective ↑e",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → p → Prop) (x : Decidable p) (x_1 : p),\n  (∀ (h x : p), motive (isTrue h) x) → (∀ (h₁ : ¬p) (h₂ : p), motive (isFalse h₁) h₂) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "Set",
   "True",
   "Set.instMembershipSet",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set.iInter",
   "congr",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "congrArg",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "Eq.trans"],
  "name": "Set.preimage_iInter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {f : α → β} {s : ι → Set β}, f ⁻¹' ⋂ i, s i = ⋂ i, f ⁻¹' s i",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLowerSet", "Preorder"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inferInstanceAs",
   "SemilatticeInf.inf_le_right",
   "Prod",
   "Lattice",
   "Prod.semilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "Prod.lattice.proof_5",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : Lattice α] [inst_1 : Lattice β] (a b : α × β), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Membership.mem",
   "Equiv",
   "AddHomClass.toFunLike",
   "List.isSetoid",
   "Multiset.Nodup",
   "AddCommMonoid.toAddMonoid",
   "Trunc.instSubsingletonTrunc",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "instSubsingletonForAll",
   "Multiset.instMembershipMultiset",
   "OrderedCancelAddCommMonoid.toAddCommMonoid",
   "Setoid.r",
   "Nat.addMonoid",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "List",
   "Subsingleton",
   "Multiset",
   "Trunc",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "Fin",
   "AddMonoidHom",
   "Quot.mk"],
  "name": "Fintype.truncEquivFin.proof_1",
  "constType":
  "∀ (α : Type u_1) (a : List α),\n  Subsingleton\n    ((∀ (x : α), x ∈ Quot.mk Setoid.r a) →\n      Multiset.Nodup (Quot.mk Setoid.r a) → Trunc (α ≃ Fin (↑Multiset.card (Quot.mk Setoid.r a))))",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.lattice.proof_3",
   "Pi.lattice.proof_1",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Pi.lattice.proof_2",
   "Pi.semilatticeInf",
   "SemilatticeSup",
   "Pi.lattice.proof_6",
   "SemilatticeSup.toSup",
   "Pi.lattice.proof_5",
   "Pi.semilatticeSup",
   "inferInstanceAs",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "Pi.lattice.proof_4"],
  "name": "Pi.lattice",
  "constType":
  "{ι : Type u_1} → {α' : ι → Type u_2} → [inst : (i : ι) → Lattice (α' i)] → Lattice ((i : ι) → α' i)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["Lean.Data.AC.EvalInformation", "Nat"],
  "name": "Lean.Data.AC.EvalInformation.evalVar",
  "constType":
  "{α : Sort u} → {β : Sort v} → [self : Lean.Data.AC.EvalInformation α β] → α → ℕ → β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "instOfNatNat", "Nat", "optParam", "Nat.succ", "Nat.casesOn"],
  "name": "List.range'.match_1",
  "constType":
  "(motive : ℕ → ℕ → optParam ℕ 1 → Sort u_1) →\n  (x x_1 : ℕ) →\n    (x_2 : optParam ℕ 1) →\n      ((x : ℕ) → (x_3 : optParam ℕ 1) → motive x 0 x_3) →\n        ((s n : ℕ) → (step : optParam ℕ 1) → motive s (Nat.succ n) step) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_13",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_2",
   "Lean.Name.mkStr4",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_1",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Iff",
   "Iff.rfl",
   "Set",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.mem_inter_iff",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), x ∈ a ∩ b ↔ x ∈ a ∧ x ∈ b",
  "constCategory": "Theorem"},
 {"references": ["And", "propext", "forall_and", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.19",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) = ((∀ (x : α), p x) ∧ ∀ (x : α), q x)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.rec._rarg._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{α : Type u_1} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["List.eraseP_cons_of_pos",
   "List.erase_cons_tail",
   "List.below",
   "List.brecOn",
   "Eq.refl",
   "dite",
   "rfl",
   "List.erase",
   "True",
   "List.eraseP_cons_of_neg",
   "Eq",
   "Subsingleton.elim",
   "Decidable.decide",
   "PProd",
   "List.eraseP",
   "List.rec",
   "List.erase_cons_head",
   "Eq.rec",
   "Bool.true",
   "PUnit",
   "Decidable",
   "List.nil",
   "not_false_eq_true",
   "Eq.trans",
   "instDecidableEqBool",
   "eq_self",
   "List.mem_map.match_1",
   "List.cons",
   "funext",
   "False",
   "Unit",
   "instBEq",
   "Ne.symm",
   "eq_false_of_decide",
   "instDecidableTrue",
   "instDecidableFalse",
   "PProd.fst",
   "eq_false",
   "Eq.ndrec",
   "of_eq_true",
   "DecidableEq",
   "Bool.false",
   "List",
   "congr",
   "Not",
   "Bool",
   "congrArg",
   "instSubsingletonDecidable",
   "congrFun"],
  "name": "List.erase_eq_eraseP",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.erase l a = List.eraseP (fun b ↦ decide (a = b)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Order.Basic._auxLemma.1",
   "of_eq_true",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.7",
   "Set",
   "Set.Ici",
   "Preorder",
   "LE.le",
   "Eq.trans",
   "True",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.left_mem_Ici",
  "constType": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ∈ Set.Ici a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Pure.pure",
   "Applicative.toPure"],
  "name": "ReaderT.pure",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → {α : Type u} → α → ReaderT ρ m α",
  "constCategory": "Definition"},
 {"references": ["Multiset", "Finset", "Multiset.Nodup", "Finset.mk"],
  "name": "Finset.rec",
  "constType":
  "{α : Type u_4} →\n  {motive : Finset α → Sort u} →\n    ((val : Multiset α) → (nodup : Multiset.Nodup val) → motive { val := val, nodup := nodup }) →\n      (t : Finset α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«term𝓝[≠]_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_top",
   "Equiv",
   "OrderDual.toDual",
   "CompleteSemilatticeInf.toPartialOrder",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "Top.top",
   "Function.comp",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "GaloisCoinsertion.dual",
   "PartialOrder",
   "Equiv.instFunLikeEquiv",
   "CompleteLattice.toLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "GaloisCoinsertion",
   "OrderDual.completeLattice",
   "CompleteLattice.toTop",
   "OrderDual",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "GaloisCoinsertion.liftCompleteLattice.proof_6",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder α] [inst_1 : CompleteLattice β]\n  (gi : GaloisCoinsertion l u) (x : αᵒᵈᵒᵈ), x ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toSupSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "propext",
   "Set",
   "Preorder",
   "LE.le",
   "mem_upperBounds",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Order.Bounds.Basic._auxLemma.12",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α}, (a ∈ upperBounds s) = ∀ x ∈ s, x ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "eq_true", "List.Perm", "List", "List.Perm.cons", "True", "Eq"],
  "name": "Mathlib.Data.List.Perm._auxLemma.13",
  "constType":
  "∀ {α : Type uu} (x : α) {l₁ l₂ : List α}, l₁ ~ l₂ → (x :: l₁ ~ x :: l₂) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "Multiset.ndunion",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.ndunion"],
  "name": "Finset.instUnionFinset.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s t : Finset α), Multiset.Nodup (Multiset.ndunion s.val t.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.toFun",
   "Equiv.invFun",
   "Function.comp",
   "Function.LeftInverse.comp",
   "Equiv.left_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.LeftInverse (↑e₁.symm ∘ e₂.invFun) (e₂.toFun ∘ ↑e₁)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithUpperSet"],
  "name": "Topology.WithUpperSet.toUpperSet",
  "constType": "{α : Type u_1} → α ≃ Topology.WithUpperSet α",
  "constCategory": "Definition"},
 {"references": ["IsTrans"],
  "name": "IsTrans.trans",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [self : IsTrans α r] (a b c : α), r a b → r b c → r a c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "and_assoc",
   "Iff.rfl",
   "Eq.refl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "SemilatticeSup",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "Iff",
   "propext",
   "congr",
   "Sup.sup",
   "Mathlib.Order.Lattice._auxLemma.3",
   "eq_of_forall_ge_iff",
   "congrArg",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congrFun",
   "id"],
  "name": "sup_assoc",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ⊔ c = a ⊔ (b ⊔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["RelHomClass.map_rel",
   "Monotone",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "OrderHomClass",
   "RelHomClass.toFunLike"],
  "name": "OrderHomClass.monotone",
  "constType":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : OrderHomClass F α β]\n  (f : F), Monotone ↑f",
  "constCategory": "Theorem"},
 {"references": ["WellFounded.intro", "WellFounded", "Acc"],
  "name": "WellFounded.rec",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : WellFounded r → Sort u_1} →\n      ((h : ∀ (a : α), Acc r a) → motive (_ : WellFounded r)) → (t : WellFounded r) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "Set", "LE", "LE.le", "Set.instMembershipSet"],
  "name": "IsLowerSet",
  "constType": "{α : Type u_1} → [inst : LE α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.mem_cons",
   "Or",
   "propext",
   "Finset",
   "Finset.cons",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.39",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : ¬a ∈ s}, (b ∈ Finset.cons a s h) = (b = a ∨ b ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "Filter.HasBasis.to_hasBasis'.match_1",
  "constType":
  "∀ {α : Type u_2} {ι' : Sort u_1} {p' : ι' → Prop} {s' : ι' → Set α} (t : Set α) (motive : (∃ i, p' i ∧ s' i ⊆ t) → Prop)\n  (x : ∃ i, p' i ∧ s' i ⊆ t), (∀ (i' : ι') (hi' : p' i') (ht : s' i' ⊆ t), motive (_ : ∃ i, p' i ∧ s' i ⊆ t)) → motive x",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[_]_»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "outParam",
   "OfNat.ofNat",
   "FunLike",
   "ZeroHomClass",
   "FunLike.coe",
   "Eq"],
  "name": "ZeroHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] →\n        [inst_1 : Zero N] → [toFunLike : FunLike F M fun x ↦ N] → (∀ (f : F), ↑f 0 = 0) → ZeroHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "Inducing.continuous_iff",
   "Iff.mp",
   "Function.comp",
   "Continuous",
   "TopologicalSpace",
   "Inducing"],
  "name": "Inducing.continuous",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Inducing f → Continuous f",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.termπ_._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.eq_of_mem_singleton.match_1",
   "Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "Unit",
   "List.nil",
   "rfl",
   "Eq"],
  "name": "List.eq_of_mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, a ∈ [b] → a = b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.WithLowerSet.instPreorderWithLowerSet._rarg._cstage2",
  "constType": "_obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsLower", "Topology.lower", "TopologicalSpace", "Preorder", "Eq"],
  "name": "Topology.IsLower.mk",
  "constType":
  "∀ {α : Type u_1} [t : TopologicalSpace α] [inst : Preorder α], t = Topology.lower α → Topology.IsLower α",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Continuous_of._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["inf_le_left",
   "inf_le_right",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Disjoint",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Iff.intro",
   "Iff",
   "le_inf",
   "OrderBot.toBot",
   "SemilatticeInf"],
  "name": "disjoint_iff_inf_le",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ a ⊓ b ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["WellFoundedRelation.rel",
   "invImage.proof_1",
   "WellFoundedRelation",
   "InvImage",
   "WellFoundedRelation.mk"],
  "name": "invImage",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (α → β) → WellFoundedRelation β → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "PSigma",
   "PSigma.casesOn",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instSizeOfNat",
   "dite",
   "instDecidableAnd",
   "Nat.modCore._unary.proof_1",
   "WellFounded.fix",
   "instLTNat",
   "LE.le",
   "instWellFoundedRelation",
   "And",
   "instLENat",
   "invImage",
   "Nat.div_rec_lemma",
   "LT.lt",
   "SizeOf.sizeOf",
   "PSigma.mk",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decLe"],
  "name": "Nat.modCore._unary",
  "constType": "(_ : ℕ) ×' ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{α : Type u_1} → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.«termI^_»._closed_7",
   "_obj",
   "Topology.«termI^_»._closed_10",
   "Topology.«termI^_»._closed_5"],
  "name": "Topology.«termI^_»._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Filter.univ_sets",
  "constType": "∀ {α : Type u_1} (self : Filter α), Set.univ ∈ self.sets",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "LE.le",
   "BddAbove",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "upperBounds",
   "BddBelow",
   "lowerBounds",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "ConditionallyCompleteLattice.mk",
  "constType":
  "{α : Type u_5} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      [toInfSet : InfSet α] →\n        (∀ (s : Set α) (a : α), BddAbove s → a ∈ s → a ≤ sSup s) →\n          (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a) →\n            (∀ (s : Set α) (a : α), BddBelow s → a ∈ s → sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s) → ConditionallyCompleteLattice α",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Filter.GenerateSets", "Set", "Set.univ"],
  "name": "Filter.GenerateSets.univ",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)}, Filter.GenerateSets g Set.univ",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "And",
   "Exists",
   "Filter.HasBasis.to_hasBasis'.match_1",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Iff.mp",
   "Set",
   "Filter.HasBasis.mem_of_mem",
   "HasSubset.Subset",
   "Filter",
   "Filter.HasBasis.mem_iff",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.forall_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s →\n    ∀ {P : Set α → Prop}, (∀ ⦃s t : Set α⦄, s ⊆ t → P s → P t) → ((∀ s ∈ l, P s) ↔ ∀ (i : ι), p i → P (s i))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap.proof_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or.casesOn",
   "Eq"],
  "name": "le_of_not_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α} (motive : a < b ∨ a = b ∨ b < a → Prop) (x : a < b ∨ a = b ∨ b < a),\n  (∀ (hlt : a < b), motive (_ : a < b ∨ a = b ∨ b < a)) →\n    (∀ (HEq : a = b), motive (_ : a < b ∨ a = b ∨ b < a)) →\n      (∀ (hgt : b < a), motive (_ : a < b ∨ a = b ∨ b < a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "propext",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Eq",
   "continuous_def"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : TopologicalSpace α} {x_1 : TopologicalSpace β} {f : α → β},\n  Continuous f = ∀ (s : Set β), IsOpen s → IsOpen (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.Pairwise",
   "List.pairwise_map",
   "Iff.mp",
   "List.Pairwise.imp",
   "List",
   "List.map"],
  "name": "List.Pairwise.of_map",
  "constType":
  "∀ {β : Type u_1} {α : Type u_2} {R : α → α → Prop} {l : List α} {S : β → β → Prop} (f : α → β),\n  (∀ (a b : α), S (f a) (f b) → R a b) → List.Pairwise S (List.map f l) → List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references":
  ["IsRefl", "Preorder", "LE.le", "Preorder.toLE", "instIsReflLeToLE.proof_1"],
  "name": "instIsReflLeToLE",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsRefl α fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_NhdsSet___unexpand_nhdsSet_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.IsUpperSet",
   "Topology.IsUpperSet.mk",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder",
   "rfl"],
  "name": "Topology.instIsUpperSetUpperSet.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Preorder α], Topology.IsUpperSet α",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike.bijective",
   "Function.Bijective",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.bijective",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Bijective ↑e",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_sup_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Pi.semilatticeSup.proof_2",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → SemilatticeSup (α' i)] (x x_1 : (i : ι) → α' i) (x_2 : ι),\n  x_1 x_2 ≤ x x_2 ⊔ x_1 x_2",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[<]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "instDecidableNot",
   "Bool.false",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_false",
  "constType": "∀ (b : Bool), (¬b = false) = (b = true)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "List.filter",
   "OfNat.ofNat",
   "List.instMembershipList",
   "Std.Data.List.Count._auxLemma.2",
   "List.length",
   "instLTNat",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "List",
   "LT.lt",
   "Bool.true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "List.countP",
   "congrArg",
   "Eq.trans",
   "Std.Data.List.Count._auxLemma.1",
   "List.countP_eq_length_filter",
   "congrFun"],
  "name": "List.countP_pos",
  "constType":
  "∀ {α : Type u_1} (p : α → Bool) {l : List α}, 0 < List.countP p l ↔ ∃ a ∈ l, p a = true",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "exists_comm.match_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} (motive : (∃ a, ∃ b, p a b) → Prop) (x : ∃ a, ∃ b, p a b),\n  (∀ (a : α) (b : β) (h : p a b), motive (_ : ∃ a, ∃ b, p a b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Sublist.refl",
   "List.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons"],
  "name": "List.sublist_cons",
  "constType": "∀ {α : Type u_1} (a : α) (l : List α), List.Sublist l (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["Preorder"],
  "name": "GaloisInsertion",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Type (max u_2 u_3)",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references":
  ["List.Sublist.refl",
   "PProd",
   "instHAppend",
   "PProd.fst",
   "List.cons",
   "List.sublist_append_left.match_1",
   "List.instAppendList",
   "List.rec",
   "List.below",
   "List.brecOn",
   "HAppend.hAppend",
   "List",
   "PUnit",
   "List.Sublist",
   "List.Sublist.cons",
   "List.nil"],
  "name": "List.sublist_append_right",
  "constType": "∀ {α : Type u_1} (l₁ l₂ : List α), List.Sublist l₂ (l₁ ++ l₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.pairwise_cons",
   "List.instMembershipList",
   "List"],
  "name": "List.Pairwise.of_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} {R : α → α → Prop}, List.Pairwise R (a :: l) → List.Pairwise R l",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_termI^__1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["MonadStateOf.get", "MonadStateOf"],
  "name": "getThe",
  "constType":
  "(σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → m σ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Bot.bot",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.NeBot.ne'",
  "constType": "∀ {α : Type u} {f : Filter α} [self : Filter.NeBot f], f ≠ ⊥",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Bot.bot",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_15",
  "constType": "∀ {α : Type u_1} (a : α → Prop), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "_obj",
   "Topology.«term𝓝ˢ»._closed_2",
   "Topology.«term𝓝ˢ»._closed_1"],
  "name": "Topology.«term𝓝ˢ»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOn₃",
  "constType":
  "∀ {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid φ}\n  {motive : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃),\n  (∀ (a : α) (b : β) (c : φ), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b) (Quotient.mk s₃ c)) → motive q₁ q₂ q₃",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.instEquivLikeEquiv.proof_1",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "EquivLike.mk"],
  "name": "Equiv.instEquivLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → EquivLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false_iff_not",
   "Bool.false",
   "propext",
   "Decidable",
   "Not",
   "Bool",
   "Eq"],
  "name": "Std.Logic._auxLemma.58",
  "constType": "∀ (p : Prop) [inst : Decidable p], (decide p = false) = ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "le_sup_left"],
  "name": "Pi.semilatticeSup.proof_1",
  "constType":
  "∀ {ι : Type u_2} {α' : ι → Type u_1} [inst : (i : ι) → SemilatticeSup (α' i)] (x x_1 : (i : ι) → α' i) (x_2 : ι),\n  x x_2 ≤ x x_2 ⊔ x_1 x_2",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Inhabited", "Nat", "Inhabited.mk"],
  "name": "instInhabitedNat",
  "constType": "Inhabited ℕ",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Function.Surjective.exists.match_1",
  "constType":
  "∀ {β : Sort u_1} {p : β → Prop} (motive : (∃ y, p y) → Prop) (x : ∃ y, p y),\n  (∀ (y : β) (hy : p y), motive (_ : ∃ y, p y)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Specializes",
  "constType": "{X : Type u_1} → [inst : TopologicalSpace X] → X → X → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image2_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {a : α} {b : β},\n  a ∈ s → b ∈ t → f a b ∈ Set.image2 f s t",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.termπ_._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finset.casesOn",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Finset.mk",
   "Eq"],
  "name": "Finset.eq_of_veq.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x x_1 : Finset α) → x.val = x_1.val → Prop) (x x_1 : Finset α) (x_2 : x.val = x_1.val),\n  (∀ (s : Multiset α) (nodup : Multiset.Nodup s) (t : Multiset α) (nodup_1 : Multiset.Nodup t)\n      (h : { val := s, nodup := nodup }.val = { val := t, nodup := nodup_1 }.val),\n      motive { val := s, nodup := nodup } { val := t, nodup := nodup_1 } h) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ord",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Order.Filter.Basic._auxLemma.13",
   "PartialOrder.toPreorder",
   "Set",
   "GE.ge",
   "Mathlib.Order.Filter.Basic._auxLemma.47",
   "Directed",
   "True",
   "Preorder.toLE",
   "Nonempty",
   "iff_self",
   "Set.instMembershipSet",
   "Set.iUnion",
   "Iff",
   "Filter.iInf_sets_eq",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.mem_iInf_of_directed",
  "constType":
  "∀ {α : Type u} {ι : Sort x} {f : ι → Filter α},\n  Directed (fun x x_1 ↦ x ≥ x_1) f → ∀ [inst : Nonempty ι] (s : Set α), s ∈ iInf f ↔ ∃ i, s ∈ f i",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithUpper", "Inhabited"],
  "name": "Topology.WithUpper.instInhabitedWithUpper._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Inhabited α] → Inhabited (Topology.WithUpper α)",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Lean.Syntax.missing",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "Lean.SourceInfo",
   "Nat",
   "Lean.Syntax",
   "Array.getD"],
  "name": "Lean.Syntax.getArg",
  "constType": "Lean.Syntax → ℕ → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "List.Perm.subperm_left.match_1",
   "List.Sublist.length_le",
   "List.Perm",
   "instLENat",
   "List",
   "Eq.rec",
   "List.Subperm",
   "List.Sublist",
   "List.length",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "List.Subperm.length_le",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ : List α}, l₁ <+~ l₂ → List.length l₁ ≤ List.length l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Fin.veq_of_eq", "False", "Fin.val", "Nat", "absurd", "Fin", "Eq"],
  "name": "Fin.ne_of_vne",
  "constType": "∀ {n : ℕ} {i j : Fin n}, ↑i ≠ ↑j → i ≠ j",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.IsLower.WithLowerHomeomorph._rarg", "_obj", "_neutral"],
  "name": "Topology.IsLower.WithLowerHomeomorph._cstage2",
  "constType": "_neutral → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_14"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_IsOpen_of_1._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "eq_true",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "le_sup_right",
   "Sup.sup",
   "LE.le",
   "True",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.2",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, (b ≤ a ⊔ b) = True",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Lean.Name → ℕ → Lean.Name",
  "constCategory": "Other"},
 {"references": ["Topology.WithUpperSet", "Preorder"],
  "name": "Topology.WithUpperSet.instPreorderWithUpperSet",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "IsGreatest", "Preorder"],
  "name": "IsGLB",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["MonadExceptOf.tryCatch", "MonadExceptOf"],
  "name": "tryCatchThe",
  "constType":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "induced_id",
   "Inducing.mk",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Topology.WithLower",
   "Eq.refl",
   "Inducing",
   "FunLike.coe",
   "Preorder",
   "Topology.IsLower.topology_eq",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Topology.IsLower",
   "Topology.lower",
   "TopologicalSpace",
   "Topology.WithLower.ofLower",
   "TopologicalSpace.induced",
   "id"],
  "name": "Topology.IsLower.WithLowerHomeomorph.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α],\n  Inducing ↑Topology.WithLower.ofLower",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.Syntax.getArg",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≥]__1»._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Array",
   "Array.mkEmpty",
   "Array.extract.loop",
   "Nat.sub",
   "Nat",
   "Array.size",
   "instMinNat"],
  "name": "Array.extract",
  "constType": "{α : Type u_1} → Array α → ℕ → ℕ → Array α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.Sublist.below.cons₂",
   "List.Sublist.below.cons",
   "List",
   "List.Sublist",
   "List.Sublist.cons₂",
   "List.Sublist.cons",
   "List.nil",
   "List.Sublist.below.rec",
   "List.Sublist.slnil",
   "List.Sublist.below.slnil",
   "List.Sublist.below"],
  "name": "List.Sublist.below.casesOn",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop}\n  {motive_1 : {a a_1 : List α} → (x : List.Sublist a a_1) → List.Sublist.below x → Prop} {a a_1 : List α}\n  {x : List.Sublist a a_1} (t : List.Sublist.below x),\n  motive_1 (_ : List.Sublist [] []) (_ : List.Sublist.below (_ : List.Sublist [] [])) →\n    (∀ {l₁ l₂ : List α} (a : α) {a_2 : List.Sublist l₁ l₂} (a_3 : List.Sublist.below a_2) (a_4 : motive l₁ l₂ a_2),\n        motive_1 (_ : List.Sublist l₁ (a :: l₂)) (_ : List.Sublist.below (_ : List.Sublist l₁ (a :: l₂)))) →\n      (∀ {l₁ l₂ : List α} (a : α) {a_2 : List.Sublist l₁ l₂} (a_3 : List.Sublist.below a_2) (a_4 : motive l₁ l₂ a_2),\n          motive_1 (_ : List.Sublist (a :: l₁) (a :: l₂))\n            (_ : List.Sublist.below (_ : List.Sublist (a :: l₁) (a :: l₂)))) →\n        motive_1 x t",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "Filter.HasBasis",
   "Iff",
   "Filter.HasBasis.inf_principal",
   "Filter.HasBasis.neBot_iff",
   "Inf.inf",
   "Set",
   "Set.Nonempty",
   "Filter.instInfFilter",
   "Inter.inter",
   "Filter",
   "Filter.NeBot",
   "Set.instInterSet"],
  "name": "Filter.HasBasis.inf_principal_neBot_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ {t : Set α}, Filter.NeBot (l ⊓ Filter.principal t) ↔ ∀ ⦃i : ι⦄, p i → Set.Nonempty (s i ∩ t)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "UInt64.size",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Eq.refl",
   "instOfNatNat",
   "Bool",
   "Nat",
   "instLTNat"],
  "name": "Lean.Name.hash.proof_1",
  "constType": "1723 < UInt64.size",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "Set.ball_image_iff",
   "Set",
   "HasSubset.Subset",
   "Set.image",
   "Set.instMembershipSet"],
  "name": "Set.image_subset_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β}, f '' s ⊆ t ↔ s ⊆ f ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["IsAntisymm", "HasSubset.Subset", "HasSubset", "subset_antisymm", "Eq"],
  "name": "HasSubset.Subset.antisymm",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsAntisymm α fun x x_1 ↦ x ⊆ x_1], a ⊆ b → b ⊆ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.cons",
  "constType": "{α : Type u_1} → α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.insert",
   "DecidableEq",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_insert_iff",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.53",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, (a ∈ List.insert b l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_trans.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_trans.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["OrderHom.comp",
   "ContinuousMap.comp",
   "Topology.WithUpperSet",
   "OrderHom",
   "Topology.WithUpperSet.map",
   "ContinuousMap",
   "Preorder",
   "rfl",
   "Eq",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.map_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ]\n  (g : β →o γ) (f : α →o β),\n  Topology.WithUpperSet.map (OrderHom.comp g f) =\n    ContinuousMap.comp (Topology.WithUpperSet.map g) (Topology.WithUpperSet.map f)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.mk",
  "constType": "{α : Type u_4} → (α → α) → HNot α",
  "constCategory": "Other"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ULift",
  "constType": "Type s → Type (max s r)",
  "constCategory": "Other"},
 {"references": ["BEq.beq", "BEq", "List", "List.findIdx", "Nat"],
  "name": "List.indexOf",
  "constType": "{α : Type u_1} → [inst : BEq α] → α → List α → ℕ",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1"],
  "name": "List.foldr",
  "constType": "{α : Type u} → {β : Type v} → (α → β → β) → β → List α → β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "String",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Filter.GenerateSets.inter",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.GenerateSets.basic",
   "Filter.GenerateSets",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.GenerateSets.rec",
  "constType":
  "∀ {α : Type u} {g : Set (Set α)} {motive : (a : Set α) → Filter.GenerateSets g a → Prop},\n  (∀ {s : Set α} (a : s ∈ g), motive s (_ : Filter.GenerateSets g s)) →\n    motive Set.univ (_ : Filter.GenerateSets g Set.univ) →\n      (∀ {s t : Set α} (a : Filter.GenerateSets g s) (a_1 : s ⊆ t),\n          motive s a → motive t (_ : Filter.GenerateSets g t)) →\n        (∀ {s t : Set α} (a : Filter.GenerateSets g s) (a_1 : Filter.GenerateSets g t),\n            motive s a → motive t a_1 → motive (s ∩ t) (_ : Filter.GenerateSets g (s ∩ t))) →\n          ∀ {a : Set α} (t : Filter.GenerateSets g a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Exists",
   "propext",
   "Set",
   "Set.mem_range",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.20",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {x : α}, (x ∈ Set.range f) = ∃ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "BooleanAlgebra.himp_eq",
  "constType":
  "∀ {α : Type u} [self : BooleanAlgebra α] (x y : α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CoheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["_obj", "Topology.«term𝓝[_]_»._closed_6", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[_]_»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "Iff.rfl", "LT.lt", "Not", "LT.mk"],
  "name": "Prop.partialOrder.proof_1",
  "constType": "∀ (a b : Prop), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup.sSup_le",
   "CompleteSemilatticeSup",
   "Set",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "LE.le",
   "CompleteSemilatticeSup.toSupSet",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "sSup_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "Std.Logic._auxLemma.24",
   "Eq.refl",
   "Mathlib.Data.Set.Lattice._auxLemma.2",
   "BooleanAlgebra.toHasCompl",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "Set.ext",
   "Iff",
   "forall_congr",
   "Set.image",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "Eq.trans",
   "Membership.mem",
   "Set.sInter_image",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Mathlib.Data.Set.Basic._auxLemma.78",
   "And",
   "Set.instBooleanAlgebraSet",
   "Std.Logic._auxLemma.31",
   "of_eq_true",
   "congr",
   "Set.iInter",
   "Not",
   "Set.sUnion",
   "Set.sInter",
   "congrArg"],
  "name": "Set.compl_sUnion",
  "constType": "∀ {α : Type u_1} (S : Set (Set α)), (⋃₀ S)ᶜ = ⋂₀ (compl '' S)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.5",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen sᶜ = IsClosed s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "funext",
   "Set.iUnion",
   "Set.preimage",
   "of_eq_true",
   "Set",
   "congrArg",
   "Set.preimage_iUnion",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "Set.preimage_iUnion₂",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {κ : ι → Sort u_7} {f : α → β} {s : (i : ι) → κ i → Set β},\n  f ⁻¹' ⋃ i, ⋃ j, s i j = ⋃ i, ⋃ j, f ⁻¹' s i j",
  "constCategory": "Theorem"},
 {"references":
  ["upperBounds",
   "PartialOrder.toPreorder",
   "IsLeast.unique",
   "Set",
   "IsLUB",
   "Eq",
   "PartialOrder"],
  "name": "IsLUB.unique",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {s : Set α} {a b : α}, IsLUB s a → IsLUB s b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj", "Topology.IsOpen_of._closed_12", "Lean.ParserDescr.symbol"],
  "name": "Topology.IsOpen_of._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.eq_empty_iff_forall_not_mem",
   "Membership.mem",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.11",
  "constType": "∀ {α : Type u} {s : Set α}, (s = ∅) = ∀ (x : α), ¬x ∈ s",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff"],
  "name": "iff_of_true",
  "constType": "∀ {a b : Prop}, a → b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Functor.map",
   "Monad",
   "Monad.toApplicative",
   "ReaderT",
   "Applicative.toFunctor",
   "Functor",
   "Functor.mapConst",
   "Functor.mk"],
  "name": "ReaderT.instFunctorReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → Functor (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.const",
  "constType": "{α : Sort u} → (β : Sort v) → α → β → α",
  "constCategory": "Definition"},
 {"references":
  ["IsGLB.insert",
   "IsGLB",
   "Set.instSingletonSet",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "Singleton.singleton",
   "Insert.insert",
   "SemilatticeInf",
   "Set.instInsertSet",
   "isGLB_singleton"],
  "name": "isGLB_pair",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] {a b : γ}, IsGLB {a, b} (a ⊓ b)",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["PSigma", "PSigma.rec", "PSigma.mk"],
  "name": "PSigma.casesOn",
  "constType":
  "{α : Sort u} →\n  {β : α → Sort v} →\n    {motive : PSigma β → Sort u_1} →\n      (t : PSigma β) → ((fst : α) → (snd : β fst) → motive { fst := fst, snd := snd }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "CompleteLattice.toTop",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "CompleteLattice.le_top",
  "constType": "∀ {α : Type u_9} [self : CompleteLattice α] (x : α), x ≤ ⊤",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "List.cons",
   "List.instMembershipList",
   "propext",
   "List",
   "List.mem_cons",
   "Eq"],
  "name": "Mathlib.Data.List.Chain._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} {a b : α} {l : List α}, (a ∈ b :: l) = (a = b ∨ a ∈ l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Mathlib.Data.List.Pairwise._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) = ((∀ a' ∈ l, R a a') ∧ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references":
  ["List.filter",
   "List.Sublist",
   "instBEq",
   "List.Sublist.count_le",
   "LE.le",
   "List.filter_eq",
   "Iff.mpr",
   "List.count_replicate_self",
   "Eq",
   "Iff.intro",
   "Decidable.decide",
   "List.replicate_sublist_replicate",
   "Iff",
   "instLENat",
   "DecidableEq",
   "List",
   "List.Sublist.trans",
   "List.filter_sublist",
   "Eq.rec",
   "Eq.mp",
   "List.replicate",
   "Nat",
   "congrArg",
   "List.count",
   "congrFun"],
  "name": "List.le_count_iff_replicate_sublist",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {n : ℕ} {a : α} {l : List α},\n  n ≤ List.count a l ↔ List.Sublist (List.replicate n a) l",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp",
   "PartialOrder.toPreorder",
   "Disjoint",
   "disjoint_comm",
   "OrderBot",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Disjoint.symm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] ⦃a b : α⦄, Disjoint a b → Disjoint b a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.sets",
   "Set",
   "True",
   "Mathlib.Order.Filter.Basic._auxLemma.3",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Mathlib.Order.Filter.Basic._auxLemma.2",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "congr",
   "Filter",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "congrFun",
   "Mathlib.Order.Filter.Basic._auxLemma.4"],
  "name": "Filter.ext_iff",
  "constType":
  "∀ {α : Type u} {f g : Filter α}, f = g ↔ ∀ (s : Set α), s ∈ f ↔ s ∈ g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.not_nonempty_empty.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : Set.Nonempty ∅ → Prop) (x : Set.Nonempty ∅),\n  (∀ (w : α) (hx : w ∈ ∅), motive (_ : ∃ x, x ∈ ∅)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.get._sunfold.proof_1",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "rfl",
   "instLTNat",
   "Eq",
   "List.get?_eq_get.match_1",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "Option.some",
   "instOfNatNat",
   "Nat",
   "List.get?",
   "List.get",
   "Fin.mk",
   "Option"],
  "name": "List.get?_eq_get",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} (h : n < List.length l), List.get? l n = some (List.get l { val := n, isLt := h })",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.lift.proof_2",
   "LE.mk",
   "Preorder.toLT",
   "LT.lt",
   "LT.mk",
   "Preorder",
   "Preorder.lift.proof_3",
   "LE.le",
   "Preorder.lift.proof_1",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Preorder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : Preorder β] → (α → β) → Preorder α",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "MonadStateOf",
  "constType":
  "semiOutParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references": ["semiOutParam"],
  "name": "MonadExceptOf",
  "constType":
  "semiOutParam (Type u) → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "Iff",
   "Topology.isUpperSet_orderDual",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.isLowerSet_orderDual",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α], Topology.IsLowerSet αᵒᵈ ↔ Topology.IsUpperSet α",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "CompleteLattice.sInf_le",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_9",
  "constType": "∀ {α : Type u_1} (s : Set (Filter α)ᵒᵈᵒᵈ), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Eq.to_iff", "Iff", "Eq"],
  "name": "iff_of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HAppend"],
  "name": "HAppend.hAppend",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAppend α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "IsCancelAdd",
   "AddMonoid.toAddZeroClass",
   "AddCancelMonoid.toIsCancelAdd.proof_1"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "And", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.inter",
  "constType": "{α : Type u_1} → Set α → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_left_comm", "Eq"],
  "name": "Std.Data.List.Pairwise._auxLemma.5",
  "constType": "∀ {a b c : Prop}, (a ∧ b ∧ c) = (b ∧ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set",
   "GE.ge",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "isOpen_univ",
   "Eq",
   "Filter.principal",
   "Filter.HasBasis",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Set.inter_subset_right",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "nhds_basis_opens.match_1",
   "Set.univ",
   "Set.instLESet",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "Order.Preimage",
   "And",
   "Eq.ndrec",
   "iInf",
   "Filter.hasBasis_biInf_principal",
   "And.intro",
   "Set.inter_subset_left",
   "Set.mem_univ",
   "Set.instInterSet"],
  "name": "nhds_basis_opens",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] (a : α), Filter.HasBasis (nhds a) (fun s ↦ a ∈ s ∧ IsOpen s) fun s ↦ s",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "instMonadExcept",
   "Lean.TSyntax",
   "Lean.MonadQuotation.getCurrMacroScope",
   "ReaderT.instMonadExceptOfReaderT",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Nat",
   "Bind.bind",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "ReaderT.instMonadReaderT",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "ReaderT.instApplicativeReaderT",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "EStateM.instMonadEStateM",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "EStateM.instMonadExceptOfEStateM",
   "Lean.Name"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Pi.orderBot",
   "OrderBot.toBot",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.bot_le",
   "Pi.hasLe",
   "LE.le",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE"],
  "name": "Pi.heytingAlgebra.proof_3",
  "constType":
  "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → HeytingAlgebra (α i)] (a : (i : ι) → α i), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Decidable", "Eq"],
  "name": "decEq",
  "constType":
  "{α : Sort u} → [inst : DecidableEq α] → (a b : α) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "PUnit"],
  "name": "EStateM.dummySave",
  "constType": "{σ : Type u} → σ → PUnit.{u_1}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "upperBounds",
   "Set",
   "Preorder",
   "Set.instMembershipSet"],
  "name": "IsGreatest",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Mathlib.Logic.Basic._auxLemma.41",
   "Set",
   "Eq.refl",
   "IsGreatest",
   "Preorder",
   "Set.univ",
   "implies_congr",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "And",
   "upperBounds",
   "Iff",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Mathlib.Order.Bounds.Basic._auxLemma.12",
   "of_eq_true",
   "forall_congr",
   "congr",
   "IsTop",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "isGreatest_univ_iff",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a : α}, IsGreatest Set.univ a ↔ IsTop a",
  "constCategory": "Theorem"},
 {"references": ["BEq", "BEq.mk", "Lean.Name.beq", "Lean.Name"],
  "name": "Lean.Name.instBEqName",
  "constType": "BEq Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "Set",
   "LowerSet.instSetLikeLowerSet",
   "SetLike.ext'",
   "LE",
   "SetLike.coe",
   "Eq"],
  "name": "LowerSet.ext",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] {s t : LowerSet α}, ↑s = ↑t → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CompleteBooleanAlgebra",
   "funext",
   "CompleteBooleanAlgebra.toBooleanAlgebra",
   "CompleteBooleanAlgebra.toSupSet",
   "compl_compl",
   "HasCompl.compl",
   "compl_injective",
   "BooleanAlgebra.toHasCompl",
   "iSup",
   "True",
   "CompleteBooleanAlgebra.toInfSet",
   "Eq",
   "iInf",
   "of_eq_true",
   "compl_iInf",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "compl_iSup",
  "constType":
  "∀ {α : Type u} {ι : Sort w} [inst : CompleteBooleanAlgebra α] {f : ι → α}, (iSup f)ᶜ = ⨅ i, (f i)ᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "Function.LeftInverse",
   "EquivLike",
   "outParam",
   "EquivLike.inv"],
  "name": "EquivLike.left_inv",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e : E),\n  Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "List.range_loop_range'.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (n : ℕ), motive 0 n) → (∀ (s n : ℕ), motive (Nat.succ s) n) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "le_iSup₂",
   "iSup_subtype.match_1",
   "iSup",
   "le_iSup",
   "iSup_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "iSup₂_le",
   "Subtype",
   "CompleteLattice.toSupSet",
   "Subtype.mk"],
  "name": "iSup_subtype",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {p : ι → Prop} {f : Subtype p → α},\n  iSup f = ⨆ i, ⨆ (h : p i), f { val := i, property := h }",
  "constCategory": "Theorem"},
 {"references": ["Ordering"],
  "name": "Ordering.lt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.12",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["LowerSet", "IsLowerSet", "Set", "LowerSet.mk", "LE"],
  "name": "LowerSet.rec",
  "constType":
  "{α : Type u_6} →\n  [inst : LE α] →\n    {motive : LowerSet α → Sort u} →\n      ((carrier : Set α) → (lower' : IsLowerSet carrier) → motive { carrier := carrier, lower' := lower' }) →\n        (t : LowerSet α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EmbeddingLike.injective'",
   "Function.Injective",
   "EmbeddingLike",
   "FunLike.coe"],
  "name": "EmbeddingLike.injective",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [i : EmbeddingLike F α β] (f : F), Function.Injective ↑f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Set", "LE", "UpperSet.mk", "IsUpperSet", "UpperSet.rec", "UpperSet"],
  "name": "UpperSet.casesOn",
  "constType":
  "{α : Type u_6} →\n  [inst : LE α] →\n    {motive : UpperSet α → Sort u} →\n      (t : UpperSet α) →\n        ((carrier : Set α) → (upper' : IsUpperSet carrier) → motive { carrier := carrier, upper' := upper' }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.le",
   "instLENat",
   "Nat.pred",
   "Nat.pred_le_pred.match_1",
   "Nat.le_succ",
   "Nat.le_trans",
   "instOfNatNat",
   "Nat.le.refl",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.pred_le_pred",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.pred n ≤ Nat.pred m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Ne",
   "And",
   "List.instMembershipList",
   "List",
   "And.intro",
   "And.casesOn"],
  "name": "List.Nodup.map_on.match_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} (a b : α) (motive : a ∈ l ∧ b ∈ l ∧ a ≠ b → Prop) (x : a ∈ l ∧ b ∈ l ∧ a ≠ b),\n  (∀ (ma : a ∈ l) (mb : b ∈ l) (n : a ≠ b), motive (_ : a ∈ l ∧ b ∈ l ∧ a ≠ b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "List.nodup_cons",
   "List.Nodup",
   "List.instMembershipList",
   "List",
   "Not",
   "And.intro",
   "Iff.mpr"],
  "name": "List.Nodup.cons",
  "constType":
  "∀ {α : Type u} {l : List α} {a : α}, ¬a ∈ l → List.Nodup l → List.Nodup (a :: l)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.«term𝓝[_]_»._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Finite",
   "Set.Finite",
   "Set.toFinite",
   "Finite.Set.finite_range"],
  "name": "Set.finite_range",
  "constType":
  "∀ {α : Type u} {ι : Sort w} (f : ι → α) [inst : Finite ι], Set.Finite (Set.range f)",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.refl", "Topology.WithLower"],
  "name": "Topology.WithLower.toLower._cstage1",
  "constType": "{α : Type u_1} → α ≃ Topology.WithLower α",
  "constCategory": "Definition"},
 {"references": ["GeneralizedBooleanAlgebra", "SDiff"],
  "name": "GeneralizedBooleanAlgebra.toSDiff",
  "constType": "{α : Type u} → [self : GeneralizedBooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "instDiscreteTopologyProdInstTopologicalSpaceProd.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : α × β → Prop) (x : α × β), (∀ (a : α) (b : β), motive (a, b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero",
   "instLENat",
   "Nat.pred",
   "Unit",
   "Nat.pred_le.match_1",
   "Nat.le_succ",
   "Nat.le.refl",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.pred_le",
  "constType": "∀ (n : ℕ), Nat.pred n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.le.step",
  "constType": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "constCategory": "Other"},
 {"references":
  ["IsGLB",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Set.insert_eq",
   "Set",
   "Inf.inf",
   "Union.union",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Insert.insert",
   "isGLB_singleton",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "IsGLB.union",
   "Singleton.singleton",
   "SemilatticeInf",
   "Set.instUnionSet",
   "Set.instInsertSet",
   "id"],
  "name": "IsGLB.insert",
  "constType":
  "∀ {γ : Type w} [inst : SemilatticeInf γ] (a : γ) {b : γ} {s : Set γ}, IsGLB s b → IsGLB (insert a s) (a ⊓ b)",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "Eq.symm",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen",
   "Eq"],
  "name": "Mathlib.Topology.Basic._auxLemma.8",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsClosed s = IsOpen sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_closure_of_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Equivalence"],
  "name": "Equivalence.refl",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_2",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.head",
  "constType": "∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)",
  "constCategory": "Other"},
 {"references": ["BEq", "Bool"],
  "name": "BEq.mk",
  "constType": "{α : Type u} → (α → α → Bool) → BEq α",
  "constCategory": "Other"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "String.csize",
   "PProd",
   "Char",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "String.utf8ByteSize.go.match_1"],
  "name": "String.utf8ByteSize.go",
  "constType": "List Char → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.SourceInfo.rec",
   "Lean.SourceInfo.original",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "Substring",
   "String.Pos"],
  "name": "Lean.SourceInfo.casesOn",
  "constType":
  "{motive : Lean.SourceInfo → Sort u} →\n  (t : Lean.SourceInfo) →\n    ((leading : Substring) →\n        (pos : String.Pos) →\n          (trailing : Substring) →\n            (endPos : String.Pos) → motive (Lean.SourceInfo.original leading pos trailing endPos)) →\n      ((pos endPos : String.Pos) → (canonical : Bool) → motive (Lean.SourceInfo.synthetic pos endPos canonical)) →\n        motive Lean.SourceInfo.none → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Finset.instMembershipFinset",
   "Mathlib.Data.Finset.Basic._auxLemma.17",
   "True",
   "Multiset.instMembershipMultiset",
   "of_eq_true",
   "Finset",
   "Multiset",
   "Finset.val",
   "Not",
   "Mathlib.Data.Finset.Basic._auxLemma.15",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.16"],
  "name": "Finset.not_mem_empty",
  "constType": "∀ {α : Type u_1} (a : α), ¬a ∈ ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "Iff.intro",
   "Iff",
   "of_decide_eq_false",
   "Bool.false",
   "decide_eq_false",
   "Decidable",
   "Not",
   "Bool",
   "Eq"],
  "name": "decide_eq_false_iff_not",
  "constType": "∀ (p : Prop) [inst : Decidable p], decide p = false ↔ ¬p",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "congr_arg", "Function.Injective", "Eq"],
  "name": "Function.Injective.eq_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α}, f a = f b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instMonadState",
   "MonadStateOf.set",
   "MonadStateOf.get",
   "liftM",
   "MonadLift",
   "MonadState.modifyGet",
   "PUnit",
   "instMonadLiftT",
   "Prod",
   "MonadLiftT.monadLift",
   "MonadStateOf.mk",
   "MonadStateOf",
   "instMonadLiftT_1"],
  "name": "instMonadStateOf",
  "constType":
  "{σ : Type u} →\n  {m : Type u → Type v} → {n : Type u → Type w} → [inst : MonadLift m n] → [inst : MonadStateOf σ m] → MonadStateOf σ n",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithUpper",
   "TopologicalSpace.IsOpen",
   "Iff",
   "Set.preimage",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "Iff.rfl",
   "Set",
   "Topology.upper",
   "FunLike.coe",
   "Preorder",
   "Topology.WithUpper.toUpper",
   "IsOpen",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpper.isOpen_def",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {s : Set (Topology.WithUpper α)},\n  IsOpen s ↔ TopologicalSpace.IsOpen (↑Topology.WithUpper.toUpper ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name": "Topology.term𝓝._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Eq", "congrFun"],
  "name": "congr_fun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "False",
   "instLENat",
   "Nat.not_le_of_gt",
   "flip",
   "LT.lt",
   "Not",
   "Nat.ge_of_not_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.not_lt",
  "constType": "∀ {a b : ℕ}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Iff",
   "forall_eq",
   "Set",
   "HasSubset.Subset",
   "Singleton.singleton",
   "Set.instMembershipSet"],
  "name": "Set.singleton_subset_iff",
  "constType": "∀ {α : Type u} {a : α} {s : Set α}, {a} ⊆ s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "List.mem_range",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "List.range"],
  "name": "List.finRange.proof_1",
  "constType": "∀ (n x : ℕ), x ∈ List.range n → x < n",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Nonempty", "instNonempty.proof_1"],
  "name": "instNonempty",
  "constType": "∀ {α : Sort u} [inst : Inhabited α], Nonempty α",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Std.Logic._auxLemma.52",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat", "List", "instOfNatNat", "Bool", "Nat", "List.countP.go"],
  "name": "List.countP",
  "constType": "{α : Type u_1} → (α → Bool) → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["propext",
   "Continuous",
   "ContinuousAt",
   "TopologicalSpace",
   "continuous_iff_continuousAt",
   "Eq"],
  "name": "Mathlib.Topology.Maps._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f = ∀ (x : α), ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "EmbeddingLike.toFunLike",
   "Exists",
   "Iff.rfl",
   "Finset.instMembershipFinset",
   "FunLike.coe",
   "Multiset.instMembershipMultiset",
   "Eq",
   "Finset.map",
   "Multiset.map",
   "And",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Multiset",
   "Finset.val",
   "Multiset.mem_map",
   "Function.Embedding",
   "Iff.trans",
   "id"],
  "name": "Finset.mem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} {b : β}, b ∈ Finset.map f s ↔ ∃ a ∈ s, ↑f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Pi.preorder",
   "LT.lt",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "Pi.partialOrder.proof_3",
  "constType":
  "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → PartialOrder (π i)] (a b : (i : ι) → π i), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Iff.intro",
   "Nonempty.intro",
   "Exists",
   "Iff",
   "Finite.intro",
   "Finite",
   "Exists.intro",
   "finite_iff_exists_equiv_fin.match_1",
   "Nat",
   "finite_iff_exists_equiv_fin.match_2",
   "Fin",
   "Nonempty"],
  "name": "finite_iff_exists_equiv_fin",
  "constType": "∀ {α : Sort u_3}, Finite α ↔ ∃ n, Nonempty (α ≃ Fin n)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "iInf_mono",
   "iInf_const_mono",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE"],
  "name": "biInf_mono",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {p q : ι → Prop},\n  (∀ (i : ι), p i → q i) → ⨅ i, ⨅ (_ : q i), f i ≤ ⨅ i, ⨅ (_ : p i), f i",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_5"],
  "name":
  "Topology.Homotopy._aux_Mathlib_Topology_Homotopy_HomotopyGroup___unexpand_LoopSpace_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Topology.lowerSet.proof_3",
   "TopologicalSpace.mk",
   "Topology.lowerSet.proof_1",
   "IsLowerSet",
   "TopologicalSpace",
   "Preorder",
   "Topology.lowerSet.proof_2",
   "Preorder.toLE"],
  "name": "Topology.lowerSet",
  "constType": "(α : Type u_4) → [inst : Preorder α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "IsRefl",
   "Set",
   "Set.instIsReflSetSubsetInstHasSubsetSet.proof_1",
   "HasSubset.Subset"],
  "name": "Set.instIsReflSetSubsetInstHasSubsetSet",
  "constType": "∀ {α : Type u}, IsRefl (Set α) fun x x_1 ↦ x ⊆ x_1",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "List",
   "LT.lt",
   "List.length",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "List.get._sunfold.proof_1",
  "constType":
  "∀ {α : Type u_1} (head : α) (as : List α) (i : ℕ), Nat.succ i < List.length (head :: as) → Nat.succ i ≤ List.length as",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Name._impl",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "Set.instHasSubsetSet",
   "Specializes",
   "propext",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Singleton.singleton",
   "specializes_iff_closure_subset",
   "Eq"],
  "name": "Mathlib.Topology.Order.UpperLowerSetTopology._auxLemma.3",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X}, x ⤳ y = (closure {y} ⊆ closure {x})",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Eq.rec",
   "Set",
   "TopologicalSpace.GenerateOpen.sUnion",
   "Set.sUnion",
   "TopologicalSpace.GenerateOpen",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure.proof_3",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)),\n  {u | TopologicalSpace.GenerateOpen s u} = s →\n    ∀ (s_1 : Set (Set α)), (∀ t ∈ s_1, (fun u ↦ u ∈ s) t) → (fun u ↦ u ∈ s) (⋃₀ s_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "imp_congr_right",
   "nhds",
   "Set",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Filter.principal",
   "Iff",
   "Filter.le_principal_iff",
   "isOpen_iff_nhds",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "IsOpen",
   "instMembershipSetFilter",
   "forall_congr'"],
  "name": "isOpen_iff_mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen s ↔ ∀ a ∈ s, s ∈ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.rec._cstage1",
  "constType":
  "{α : Type u_2} →\n  {β : Topology.WithLower α → Sort u_1} →\n    ((a : α) → β (↑Topology.WithLower.toLower a)) → (a : Topology.WithLower α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3995",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3875",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.lowerSet",
   "TopologicalSpace",
   "Preorder"],
  "name": "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Iff",
   "Decidable",
   "Not",
   "Iff.trans",
   "or_comm",
   "Decidable.imp_iff_not_or"],
  "name": "Decidable.imp_iff_or_not",
  "constType": "∀ {b a : Prop} [inst : Decidable b], b → a ↔ a ∨ ¬b",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "HeytingAlgebra",
   "Bot.bot",
   "inf_compl_self",
   "HeytingAlgebra.toBot",
   "Inf.inf",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "HeytingAlgebra.toHasCompl",
   "Eq"],
  "name": "inf_compl_eq_bot",
  "constType": "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, a ⊓ aᶜ = ⊥",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Prod.instPreorderProd.match_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) (motive : α × β → Prop) (x : α × β), (∀ (a : α) (b : β), motive (a, b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace.mk", "_obj", "_neutral"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower._cstage2",
  "constType": "_neutral → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_and_left", "Eq"],
  "name": "Std.Logic._auxLemma.40",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) = (b ∧ ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["upperBounds", "Set", "IsLeast", "Preorder"],
  "name": "IsLUB",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Order.Filter.Basic._auxLemma.25",
   "Set",
   "Union.union",
   "HasSubset.Subset",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "CompleteLattice.toLattice",
   "Mathlib.Order.Filter.Basic._auxLemma.57",
   "Filter.principal",
   "And",
   "Set.instHasSubsetSet",
   "SemilatticeSup.toSup",
   "Iff",
   "of_eq_true",
   "congr",
   "Sup.sup",
   "Filter",
   "Filter.ext",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "Set.instUnionSet",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.sup_principal",
  "constType":
  "∀ {α : Type u} {s t : Set α}, Filter.principal s ⊔ Filter.principal t = Filter.principal (s ∪ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Inducing.mk",
   "Inducing.rec",
   "TopologicalSpace",
   "Inducing",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "Inducing.casesOn",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [tα : TopologicalSpace α] →\n      [tβ : TopologicalSpace β] →\n        {f : α → β} →\n          {motive : Inducing f → Sort u} →\n            (t : Inducing f) → ((induced : tα = TopologicalSpace.induced f tβ) → motive (_ : Inducing f)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Or.resolve_left",
   "Ne",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.pos_of_ne_zero",
  "constType": "∀ {n : ℕ}, n ≠ 0 → 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_6",
   "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_4",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_NhdsSet___macroRules_Topology_term𝓝ˢ_1»._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Setoid.r",
   "List.nodup_cons",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons",
   "Not",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.nodup_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Multiset α}, Multiset.Nodup (a ::ₘ s) ↔ ¬a ∈ s ∧ Multiset.Nodup s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Data.AC.Expr.op", "Lean.Data.AC.Expr", "Nat", "Lean.Data.AC.Expr.var"],
  "name": "Lean.Data.AC.Expr.rec",
  "constType":
  "{motive : Lean.Data.AC.Expr → Sort u} →\n  ((x : ℕ) → motive (Lean.Data.AC.Expr.var x)) →\n    ((lhs rhs : Lean.Data.AC.Expr) → motive lhs → motive rhs → motive (Lean.Data.AC.Expr.op lhs rhs)) →\n      (t : Lean.Data.AC.Expr) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "DistribLattice",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "DistribLattice.le_sup_inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_sup_inf",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context.mk",
   "Lean.Macro.Context",
   "instMonadReaderOfReaderT",
   "Lean.Macro.Context.currMacroScope",
   "ReaderT.instMonadReaderT",
   "Lean.MacroM",
   "Lean.MonadRef",
   "Lean.Macro.Context.ref",
   "Pure.pure",
   "ReaderT.instApplicativeReaderT",
   "Monad.toBind",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.Macro.Context.methods",
   "EStateM.instMonadEStateM",
   "instMonadWithReaderOfReaderT",
   "instMonadWithReader",
   "instMonadReader",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.MonadRef.mk",
   "Lean.Macro.Exception",
   "Lean.Macro.Context.maxRecDepth",
   "Lean.Macro.Context.currRecDepth",
   "Bind.bind",
   "MonadWithReader.withReader",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadRefMacroM",
  "constType": "Lean.MonadRef Lean.MacroM",
  "constCategory": "Definition"},
 {"references": ["GaloisCoinsertion", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "GaloisCoinsertion.u_l_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},\n  GaloisCoinsertion l u → ∀ (x : α), u (l x) ≤ x",
  "constCategory": "Definition"},
 {"references":
  ["_obj", "Topology.«term𝓝[_]_»._closed_3", "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[_]_»._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Context.op",
   "Lean.Data.AC.Context",
   "Option.none",
   "Unit",
   "Unit.unit",
   "Lean.Data.AC.Variable.value",
   "Option.some",
   "Option.casesOn",
   "Lean.IsNeutral",
   "Nat",
   "Lean.Data.AC.Context.var",
   "Option"],
  "name": "Lean.Data.AC.Context.unwrap_isNeutral.match_1",
  "constType":
  "{α : Sort u_1} →\n  {ctx : Lean.Data.AC.Context α} →\n    {x : ℕ} →\n      (motive : Option (Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value) → Sort u_2) →\n        (x_1 : Option (Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value)) →\n          ((hn : Lean.IsNeutral ctx.op (Lean.Data.AC.Context.var ctx x).value) → motive (some hn)) →\n            (Unit → motive none) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.Pairwise.below.cons",
   "List.cons",
   "List.Pairwise.nil",
   "List.instMembershipList",
   "List.Pairwise.below",
   "List",
   "List.Pairwise.below.nil",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.rec",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop}\n  {motive_1 : {a : List α} → (x : List.Pairwise R a) → List.Pairwise.below x → Prop},\n  motive_1 (_ : List.Pairwise R []) (_ : List.Pairwise.below (_ : List.Pairwise R [])) →\n    (∀ {a : α} {l : List α} (a_1 : ∀ a' ∈ l, R a a') {a_2 : List.Pairwise R l} (a_3 : List.Pairwise.below a_2)\n        (a_4 : motive l a_2),\n        motive_1 a_2 a_3 →\n          motive_1 (_ : List.Pairwise R (a :: l)) (_ : List.Pairwise.below (_ : List.Pairwise R (a :: l)))) →\n      ∀ {a : List α} {x : List.Pairwise R a} (t : List.Pairwise.below x), motive_1 x t",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Iff",
   "not_lt_of_ge",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_of_not_gt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Order.Frame",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Inf.inf",
   "Set",
   "iSup",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Order.Frame.mk",
  "constType":
  "{α : Type u_1} →\n  [toCompleteLattice : CompleteLattice α] → (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) → Order.Frame α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "EmptyCollection.emptyCollection",
   "propext",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.instEmptyCollectionSet",
   "Filter",
   "CompleteLattice.toBot",
   "Eq.symm",
   "Filter.instCompleteLatticeFilter",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.20",
  "constType": "∀ {α : Type u} {f : Filter α}, (f = ⊥) = (∅ ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Filter.Eventually.mp",
   "Not",
   "Filter",
   "And.intro",
   "Filter.Eventually",
   "mt",
   "Filter.Eventually.mono",
   "Filter.Frequently"],
  "name": "Filter.Frequently.and_eventually",
  "constType":
  "∀ {α : Type u} {p q : α → Prop} {f : Filter α},\n  (∃ᶠ (x : α) in f, p x) → (∀ᶠ (x : α) in f, q x) → ∃ᶠ (x : α) in f, p x ∧ q x",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "or_assoc", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.10",
  "constType": "∀ {a b c : Prop}, ((a ∨ b) ∨ c) = (a ∨ b ∨ c)",
  "constCategory": "Theorem"},
 {"references": ["List", "List.Sublist"],
  "name": "List.Sublist.below",
  "constType":
  "{α : Type u_1} → {motive : (a a_1 : List α) → List.Sublist a a_1 → Prop} → {a a_1 : List α} → List.Sublist a a_1 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "Or", "Iff.mp", "Iff", "Or.inr", "or_iff_left_of_imp"],
  "name": "or_iff_left_iff_imp",
  "constType": "∀ {a b : Prop}, (a ∨ b ↔ a) ↔ b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.531",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "true_and",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "PLift",
   "True",
   "Eq",
   "iff_self",
   "Set.range",
   "Fintype",
   "Iff",
   "PLift.up",
   "forall_congr",
   "Finset.image",
   "Finset",
   "Mathlib.Data.ULift._auxLemma.3",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "Function.comp",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.univ",
   "And",
   "of_eq_true",
   "DecidableEq",
   "PLift.down",
   "congr",
   "congrArg",
   "congrFun"],
  "name": "Set.fintypeRange.proof_1",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_2} [inst : DecidableEq α] (f : ι → α) [inst_1 : Fintype (PLift ι)] (a : α),\n  a ∈ Finset.image (f ∘ PLift.down) Finset.univ ↔ a ∈ Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "Eq.refl",
   "Lean.Data.AC.mergeIdem.loop",
   "instDecidableTrue",
   "instDecidableEqNat",
   "True",
   "ite_congr",
   "Eq",
   "ite",
   "of_eq_true",
   "List",
   "Lean.Data.AC.mergeIdem",
   "Not",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Lean.Data.AC.Context.mergeIdem_head",
  "constType":
  "∀ {x : ℕ} {xs : List ℕ}, Lean.Data.AC.mergeIdem (x :: x :: xs) = Lean.Data.AC.mergeIdem (x :: xs)",
  "constCategory": "Theorem"},
 {"references": ["true_and", "And", "Iff", "iff_of_eq", "True"],
  "name": "true_and_iff",
  "constType": "∀ (p : Prop), True ∧ p ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.union",
   "HasEquiv.Equiv",
   "List.union",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.ndunion.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (x x_1 x_2 x_3 : List α),\n  x ≈ x_2 → x_1 ≈ x_3 → Quot.mk Setoid.r (List.union x x_1) = Quot.mk Setoid.r (List.union x_2 x_3)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_iff",
   "Set",
   "Set.image",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Set.ball_image_of_ball",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set α} {p : β → Prop}, (∀ x ∈ s, p (f x)) → ∀ y ∈ f '' s, p y",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Add M] → [inst : Add N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), ∀ t ∈ s, ∀ a ∈ t, ∃ t ∈ s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Filter.eq_sInf_of_mem_iff_exists_mem.match_1",
   "InfSet.sInf",
   "le_sInf",
   "Exists.intro",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet",
   "sInf_le",
   "And",
   "Iff.mp",
   "Iff",
   "CompleteLattice.toInfSet",
   "Filter.instPartialOrderFilter",
   "Filter",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.eq_sInf_of_mem_iff_exists_mem",
  "constType":
  "∀ {α : Type u} {S : Set (Filter α)} {l : Filter α}, (∀ {s : Set α}, s ∈ l ↔ ∃ f ∈ S, s ∈ f) → l = sInf S",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.cons",
   "List.Pairwise.below",
   "List.instMembershipList",
   "List",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.below.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop} {a : α} {l : List α}\n  (a_1 : ∀ a' ∈ l, R a a') {a_2 : List.Pairwise R l},\n  List.Pairwise.below a_2 → motive l a_2 → List.Pairwise.below (_ : List.Pairwise R (a :: l))",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompleteSemilatticeInf.sInf_le",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeInf.toInfSet",
   "Set",
   "InfSet.sInf",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "sInf_le",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ∈ s → sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Equiv",
   "Topology.WithUpperSet",
   "Set",
   "Inducing",
   "FunLike.coe",
   "IsUpperSet",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "lcProof",
   "Homeomorph",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name":
  "Equiv.toHomeomorphOfInducing._at.Topology.IsUpperSet.WithUpperSetHomeomorph._spec_1",
  "constType":
  "(α : Type u_1) →\n  (inst : Preorder α) →\n    (inst_1 : TopologicalSpace α) →\n      let _x_1 :=\n        { IsOpen := IsUpperSet, isOpen_univ := (_ : ∀ ⦃a b : α⦄, a ≤ b → a ∈ Set.univ → b ∈ Set.univ),\n          isOpen_inter := (_ : ∀ (x x_1 : Set α), IsUpperSet x → IsUpperSet x_1 → IsUpperSet (Inter.inter✝ x x_1)),\n          isOpen_sUnion := (_ : ∀ (x : Set (Set α)), (∀ s ∈ x, IsUpperSet s) → IsUpperSet (⋃₀ x)) };\n      let _y_3 := _x_1;\n      let _y_4 := inst_1;\n      (f : Topology.WithUpperSet α ≃ α) → Inducing ↑f → Topology.WithUpperSet α ≃ₜ α",
  "constCategory": "Axiom"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "PartialOrder.le_antisymm",
   "sup_le",
   "Sup.sup",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "GaloisConnection.l_le",
   "PartialOrder"],
  "name": "GaloisInsertion.liftSemilatticeSup.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : SemilatticeSup α],\n  GaloisInsertion l u → ∀ (a b c : β), a ≤ c → b ≤ c → l (u a ⊔ u b) ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "Iff.intro",
   "And",
   "Set.Elem",
   "And.intro",
   "Set.image",
   "And.casesOn",
   "Subtype.mk",
   "Subtype.casesOn"],
  "name": "Set.image_eq_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), f '' s = Set.range fun x ↦ f ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Unit",
   "Nat.not_succ_le_self.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_self_eq_true",
  "constType": "∀ (n : ℕ), Nat.ble n n = true",
  "constCategory": "Theorem"},
 {"references":
  ["List.Chain.rec", "List", "List.Chain.nil", "List.Chain", "List.Chain.cons"],
  "name": "List.Chain.imp'",
  "constType":
  "∀ {α : Type u_1} {R S : α → α → Prop},\n  (∀ ⦃a b : α⦄, R a b → S a b) →\n    ∀ {a b : α}, (∀ ⦃c : α⦄, R a c → S b c) → ∀ {l : List α}, List.Chain R a l → List.Chain S b l",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Topology.WithUpperSet.toUpperSet",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithUpperSet.rec",
  "constType":
  "{α : Type u_1} →\n  {β : Topology.WithUpperSet α → Sort u_4} →\n    ((a : α) → β (↑Topology.WithUpperSet.toUpperSet a)) → (a : Topology.WithUpperSet α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "Nat.succ_le_succ",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.succ_le_succ_iff",
  "constType": "∀ {a b : ℕ}, Nat.succ a ≤ Nat.succ b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.instMembershipList",
   "dite",
   "Iff.mpr",
   "True",
   "Eq",
   "Mathlib.Data.List.Perm._auxLemma.30",
   "instOfNatNat",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "List.count_eq_one_of_mem",
   "List.count_eq_zero_of_not_mem",
   "Membership.mem",
   "eq_self",
   "List.perm_iff_count",
   "False",
   "List.dedup",
   "instBEq",
   "mt",
   "List.Perm.subset",
   "eq_true",
   "eq_false",
   "List.Perm",
   "List.Nodup",
   "of_eq_true",
   "DecidableEq",
   "List",
   "List.Perm.mem_iff",
   "List.instDecidableMemListInstMembershipList",
   "congr",
   "Mathlib.Data.List.Dedup._auxLemma.3",
   "Not",
   "List.count",
   "congrArg"],
  "name": "List.Perm.dedup",
  "constType":
  "∀ {α : Type uu} [inst : DecidableEq α] {l₁ l₂ : List α}, l₁ ~ l₂ → List.dedup l₁ ~ List.dedup l₂",
  "constCategory": "Theorem"},
 {"references": ["Topology.WithLower", "Preorder"],
  "name": "Topology.WithLower.instPreorderWithLower",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Preorder (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.elems",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Fintype.complete",
  "constType": "∀ {α : Type u_4} [self : Fintype α] (x : α), x ∈ Fintype.elems",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.rfl",
   "Top.top",
   "Set",
   "Eq.refl",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Filter.instTopFilter",
   "propext",
   "Filter",
   "Filter.mem_top_iff_forall",
   "instMembershipSetFilter",
   "id"],
  "name": "Filter.mem_top",
  "constType": "∀ {α : Type u} {s : Set α}, s ∈ ⊤ ↔ s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithLowerSet",
   "Topology.WithLowerSet.instTopologicalSpaceWithLowerSet",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet.proof_1",
   "Topology.IsLowerSet",
   "Preorder"],
  "name":
  "Topology.instIsLowerSetWithLowerSetInstTopologicalSpaceWithLowerSetInstPreorderWithLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLowerSet (Topology.WithLowerSet α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bind",
  "constType": "(Type u → Type v) → Type (max (u + 1) v)",
  "constCategory": "Other"},
 {"references":
  ["IsCompl.disjoint",
   "PartialOrder.toPreorder",
   "Disjoint.symm",
   "IsCompl.mk",
   "IsCompl",
   "IsCompl.codisjoint",
   "BoundedOrder.toOrderTop",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "Codisjoint.symm",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.symm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → IsCompl y x",
  "constCategory": "Theorem"},
 {"references":
  ["Option.none",
   "Unit",
   "Unit.unit",
   "Option.some",
   "Option.casesOn",
   "Option"],
  "name": "Option.toBool.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : Option α → Sort u_2) → (x : Option α) → ((val : α) → motive (some val)) → (Unit → motive none) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn"],
  "name": "Directed.mono.match_1",
  "constType":
  "∀ {α : Type u_2} {r : α → α → Prop} {ι : Sort u_1} {f : ι → α} (a b : ι)\n  (motive : (∃ z, r (f a) (f z) ∧ r (f b) (f z)) → Prop) (x : ∃ z, r (f a) (f z) ∧ r (f b) (f z)),\n  (∀ (c : ι) (h₁ : r (f a) (f c)) (h₂ : r (f b) (f c)), motive (_ : ∃ z, r (f a) (f z) ∧ r (f b) (f z))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Order.Filter.Prod._auxLemma.27",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Init.WF.0.InvImage.accAux.proof_1", "InvImage", "Acc", "Eq"],
  "name": "_private.Init.WF.0.InvImage.accAux",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} (f : α → β) {b : β}, Acc r b → ∀ (x : α), f x = b → Acc (InvImage r f) x",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "TopologicalSpace.induced",
   "And.casesOn",
   "Exists.casesOn",
   "IsOpen",
   "Eq"],
  "name": "induced_compose.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [tγ : TopologicalSpace γ] {f : α → β} {g : β → γ} (x : Set α)\n  (motive : IsOpen x → Prop) (x_1 : IsOpen x),\n  (∀ (w : Set β) (s : Set γ) (hs : IsOpen s) (h₂ : g ⁻¹' s = w) (h₁ : f ⁻¹' w = x),\n      motive (_ : ∃ s', IsOpen s' ∧ f ⁻¹' s' = x)) →\n    motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["LowerSet",
   "LowerSet.casesOn",
   "Eq.ndrec",
   "IsLowerSet",
   "Eq.rec",
   "Set",
   "Eq.refl",
   "LowerSet.mk",
   "LE",
   "Eq.symm",
   "LowerSet.carrier",
   "Eq"],
  "name": "LowerSet.instSetLikeLowerSet.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LE α] (s t : LowerSet α), s.carrier = t.carrier → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_1",
   "_obj",
   "String.toSubstring'"],
  "name":
  "Topology.Homotopy.«_aux_Mathlib_Topology_Homotopy_HomotopyGroup___macroRules_Topology_Homotopy_termΩ^_1»._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["LawfulBEq", "Nat.instLawfulBEqNatInstBEqNat.proof_1", "instBEqNat", "Nat"],
  "name": "Nat.instLawfulBEqNatInstBEqNat",
  "constType": "LawfulBEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "And",
   "Nat.sub_lt",
   "Nat.div_rec_lemma.match_1",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "Nat.lt_of_lt_of_le",
   "LT.lt",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div_rec_lemma",
  "constType": "∀ {x y : ℕ}, 0 < y ∧ y ≤ x → x - y < x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.mk",
   "setOf",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.mkOfClosure.proof_2",
   "TopologicalSpace.GenerateOpen",
   "TopologicalSpace.mkOfClosure.proof_1",
   "TopologicalSpace.mkOfClosure.proof_3",
   "Set.instMembershipSet",
   "Eq"],
  "name": "TopologicalSpace.mkOfClosure",
  "constType":
  "{α : Type u} → (s : Set (Set α)) → {u | TopologicalSpace.GenerateOpen s u} = s → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsClosed",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "IsOpen"],
  "name": "IsClosed.isOpen_compl",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Iff",
   "setOf",
   "Set",
   "Filter",
   "Filter.Eventually",
   "Filter.HasBasis.mem_iff",
   "Set.instMembershipSet"],
  "name": "Filter.HasBasis.eventually_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α},\n  Filter.HasBasis l p s → ∀ {q : α → Prop}, (∀ᶠ (x : α) in l, q x) ↔ ∃ i, p i ∧ ∀ ⦃x : α⦄, x ∈ s i → q x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "Topology.«termI^_»._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Inf.inf",
   "Set",
   "CompleteLattice.toBoundedOrder",
   "Eq.refl",
   "Inter.inter",
   "IsCompl",
   "CompleteLattice.toBot",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Eq.mpr",
   "IsCompl.of_eq",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.inf_principal",
   "BoundedOrder.toOrderBot",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "Filter.sup_principal",
   "Top.top",
   "Set.union_compl_self",
   "Union.union",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instEmptyCollectionSet",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Filter.principal_univ",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Set.inter_compl_self",
   "Filter.instPartialOrderFilter",
   "OrderBot.toBot",
   "Filter.instInfFilter",
   "Sup.sup",
   "Filter.principal_empty",
   "Set.instUnionSet",
   "Set.instInterSet"],
  "name": "Filter.isCompl_principal",
  "constType":
  "∀ {α : Type u} (s : Set α), IsCompl (Filter.principal s) (Filter.principal sᶜ)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "Lean.Syntax.node4",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.MacroScope",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_Continuous_of_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "by_contradiction"],
  "name": "by_contra",
  "constType": "∀ {p : Prop}, (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Bot.bot",
   "SemilatticeSup.toSup",
   "Iff",
   "PartialOrder.toPreorder",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toLattice : Lattice α] →\n    [toBot : Bot α] →\n      [toSDiff : SDiff α] → (∀ (a : α), ⊥ ≤ a) → (∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) → GeneralizedCoheytingAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Membership.mem",
   "Exists",
   "setOf",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Preorder",
   "TopologicalSpace.GenerateOpen",
   "Set.Ici",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet",
   "lcProof",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8",
   "Set.instInterSet"],
  "name": "Topology.WithLower.instTopologicalSpaceWithLower._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithLower α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Topology.WithLower.toLower",
   "Topology.WithLower",
   "Topology.WithLower.ofLower",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLower.rec",
  "constType":
  "{α : Type u_2} →\n  {β : Topology.WithLower α → Sort u_1} →\n    ((a : α) → β (↑Topology.WithLower.toLower a)) → (a : Topology.WithLower α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["PProd", "Lean.Name.rec", "String", "PUnit", "Nat", "Lean.Name"],
  "name": "Lean.Name.below",
  "constType": "{motive : Lean.Name → Sort u} → Lean.Name → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["isLowerSet_compl",
   "IsLowerSet",
   "Iff.mp",
   "IsClosed.isOpen_compl",
   "Topology.IsLower",
   "Set",
   "HasCompl.compl",
   "TopologicalSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Topology.IsLower.isLowerSet_of_isOpen",
   "IsUpperSet",
   "IsClosed",
   "Preorder",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE"],
  "name": "Topology.IsLower.isUpperSet_of_isClosed",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLower α] {s : Set α},\n  IsClosed s → IsUpperSet s",
  "constCategory": "Theorem"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "constCategory": "Other"},
 {"references": ["BEq", "List", "BEq.mk", "List.beq"],
  "name": "List.instBEqList",
  "constType": "{α : Type u} → [inst : BEq α] → BEq (List α)",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Eq", "Option"],
  "name": "Option.noConfusionType",
  "constType": "{α : Type u} → Sort u_1 → Option α → Option α → Sort u_1",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "Setoid.r",
   "instHasEquiv",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "List.isSetoid",
   "Quot",
   "HasEquiv.Equiv",
   "List.Perm.append",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.add.proof_1",
  "constType":
  "∀ {α : Type u_1} (x x_1 x_2 x_3 : List α),\n  x ≈ x_2 → x_1 ≈ x_3 → Quot.mk Setoid.r (x ++ x_1) = Quot.mk Setoid.r (x_2 ++ x_3)",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Equivalence"],
  "name": "Setoid.iseqv",
  "constType": "∀ {α : Sort u} [self : Setoid α], Equivalence Setoid.r",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot", "OrderBot.toBot", "OrderBot.bot_le", "LE", "OrderBot", "LE.le"],
  "name": "bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Applicative",
   "Applicative.toSeqRight",
   "Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Unit",
   "SeqLeft.seqLeft",
   "ReaderT.instFunctorReaderT",
   "Applicative.toSeqLeft",
   "Applicative.mk",
   "Seq.seq",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "Applicative.toSeq",
   "SeqRight.mk",
   "ReaderT.pure",
   "SeqLeft.mk",
   "SeqRight.seqRight"],
  "name": "ReaderT.instApplicativeReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → Applicative (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Mathlib.Order.Filter.Basic._auxLemma.35",
   "HasSubset.Subset",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Mathlib.Order.Filter.Basic._auxLemma.11",
   "Filter.principal",
   "Set.instHasSubsetSet",
   "Iff",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "Filter",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "instMembershipSetFilter"],
  "name": "Filter.principal_mono",
  "constType":
  "∀ {α : Type u} {s t : Set α}, Filter.principal s ≤ Filter.principal t ↔ s ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.not_succ_le_self.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_1",
   "Lean.Name.str._override"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "StrictOrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termΩ._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Prod.instPreorderProd",
   "LT.lt",
   "inferInstanceAs",
   "Not",
   "Prod",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le",
   "PartialOrder"],
  "name": "Prod.instPartialOrder.proof_3",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : PartialOrder α] [inst_1 : PartialOrder β] (a b : α × β), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Std.Logic._auxLemma.29",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "Eq.refl",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Std.Logic._auxLemma.55",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.forall_range_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {p : α → Prop}, (∀ a ∈ Set.range f, p a) ↔ ∀ (i : ι), p (f i)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Filter",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["IsLowerSet",
   "isUpperSet_compl",
   "Iff.rfl",
   "compl_compl",
   "Set",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "IsUpperSet",
   "Preorder",
   "Topology.IsLowerSet",
   "isOpen_compl_iff",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Eq",
   "Iff.symm",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Topology.IsLowerSet.isOpen_iff_isLowerSet",
   "TopologicalSpace",
   "IsClosed",
   "Eq.symm",
   "IsOpen",
   "id"],
  "name": "Topology.IsLowerSet.isClosed_iff_isUpper",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsLowerSet α] {s : Set α},\n  IsClosed s ↔ IsUpperSet s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Mem.tail",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.rec"],
  "name": "List.Mem.casesOn",
  "constType":
  "∀ {α : Type u} {a : α} {motive : (a_1 : List α) → List.Mem a a_1 → Prop} {a_1 : List α} (t : List.Mem a a_1),\n  (∀ (as : List α), motive (a :: as) (_ : List.Mem a (a :: as))) →\n    (∀ (b : α) {as : List α} (a_2 : List.Mem a as), motive (b :: as) (_ : List.Mem a (b :: as))) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "PartialOrder.toPreorder",
   "CompleteSemilatticeSup",
   "Set",
   "lowerBounds",
   "le_sSup",
   "CompleteSemilatticeSup.toPartialOrder",
   "SupSet.sSup",
   "And.intro",
   "sSup_le",
   "IsLUB",
   "CompleteSemilatticeSup.toSupSet",
   "Set.instMembershipSet"],
  "name": "isLUB_sSup",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] (s : Set α), IsLUB s (sSup s)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "OfNat.ofNat",
   "List.cons",
   "instSubNat",
   "HSub.hSub",
   "Eq.refl",
   "Nat.zero_sub",
   "List.drop",
   "List.length",
   "True",
   "Eq",
   "instHAppend",
   "Eq.ndrec",
   "Nat.zero",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "congr",
   "instOfNatNat",
   "List.drop_nil",
   "List.nil",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Nat.succ_sub_succ_eq_sub",
   "Nat.succ",
   "Eq.trans",
   "Nat.casesOn",
   "congrFun"],
  "name": "List.drop_append_eq_append_drop",
  "constType":
  "∀ {α : Type u_1} {n : ℕ} {l₁ l₂ : List α}, List.drop n (l₁ ++ l₂) = List.drop n l₁ ++ List.drop (n - List.length l₁) l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "TopologicalSpace.generateFrom",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Set.sUnion",
   "Inter.inter",
   "Set.univ",
   "TopologicalSpace.IsTopologicalBasis",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "TopologicalSpace.IsTopologicalBasis.mk",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ t₁ ∈ s, ∀ t₂ ∈ s, ∀ x ∈ t₁ ∩ t₂, ∃ t₃ ∈ s, x ∈ t₃ ∧ t₃ ⊆ t₁ ∩ t₂) →\n    ⋃₀ s = Set.univ → t = TopologicalSpace.generateFrom s → TopologicalSpace.IsTopologicalBasis s",
  "constCategory": "Other"},
 {"references":
  ["closure",
   "Membership.mem",
   "propext",
   "Set",
   "mem_closure_iff_nhdsWithin_neBot",
   "TopologicalSpace",
   "nhdsWithin",
   "Filter.NeBot",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Topology.Constructions._auxLemma.27",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {x : α}, (x ∈ closure s) = Filter.NeBot (nhdsWithin x s)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Unit",
   "Nat.zero_add.match_1",
   "instOfNatNat",
   "Nat",
   "rfl",
   "instLTNat",
   "Nat.succ_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.eq_zero_or_pos",
  "constType": "∀ (n : ℕ), n = 0 ∨ n > 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "finite_iff_exists_equiv_fin.match_2",
  "constType":
  "∀ {α : Sort u_1} (motive : (∃ n, Nonempty (α ≃ Fin n)) → Prop) (x : ∃ n, Nonempty (α ≃ Fin n)),\n  (∀ (w : ℕ) (e : α ≃ Fin w), motive (_ : ∃ n, Nonempty (α ≃ Fin n))) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddLeftCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "optParam",
  "constType": "(α : Sort u) → α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap._sunfold.proof_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → p a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Trans.trans",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "Eq.refl",
   "sup_comm",
   "inf_assoc",
   "True",
   "Eq",
   "Lattice.toInf",
   "DistribLattice.toLattice",
   "sup_inf_self",
   "sup_inf_right",
   "Eq.mpr",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "Eq.ndrec",
   "inf_sup_self",
   "of_eq_true",
   "congr",
   "instTransEq",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "congrArg",
   "Eq.trans",
   "sup_inf_left",
   "id"],
  "name": "inf_sup_left",
  "constType":
  "∀ {α : Type u} [inst : DistribLattice α] {x y z : α}, x ⊓ (y ⊔ z) = x ⊓ y ⊔ x ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr",
   "Lean.MacroScopesView",
   "List",
   "Unit",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.review.match_1",
   "Nat",
   "Lean.MacroScopesView.mainModule",
   "Lean.MacroScopesView.imported",
   "Lean.Name.appendCore",
   "Lean.Name",
   "Lean.MacroScopesView.name",
   "List.foldl",
   "Lean.MacroScope",
   "Lean.MacroScopesView.scopes"],
  "name": "Lean.MacroScopesView.review",
  "constType": "Lean.MacroScopesView → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "Lean.Data.AC.insert",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil",
   "Nat",
   "Lean.Data.AC.sort.loop.match_1"],
  "name": "Lean.Data.AC.sort.loop",
  "constType": "List ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Classical.propDecidable", "Not", "dite", "Classical.choice", "Nonempty"],
  "name": "Function.sometimes",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → [inst : Nonempty β] → (α → β) → β",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "UpperSet.instInfSetUpperSet",
   "Set",
   "UpperSet.instSetLikeUpperSet",
   "Eq.refl",
   "Set.iUnion_exists",
   "UpperSet",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "Set.iUnion",
   "iInf",
   "of_eq_true",
   "Set.iUnion_iUnion_eq'",
   "LE",
   "Set.iUnion_congr_Prop",
   "congrArg",
   "Eq.trans",
   "SetLike.coe",
   "congrFun"],
  "name": "UpperSet.coe_iInf",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} [inst : LE α] (f : ι → UpperSet α), ↑(⨅ i, f i) = ⋃ i, ↑(f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "OrderDual.toDual",
   "continuous_coinduced_rng",
   "Topology.WithUpperSet",
   "FunLike.coe",
   "Preorder",
   "Equiv.instFunLikeEquiv",
   "TopologicalSpace.coinduced",
   "OrderDual.ofDual",
   "Topology.WithLowerSet",
   "Continuous",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "OrderDual.toDual_ofDual",
   "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet"],
  "name": "Topology.WithUpperSet.toDualHomeomorph.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α],\n  Continuous\n    { toFun := ↑OrderDual.toDual, invFun := ↑OrderDual.ofDual,\n        left_inv := (_ : ∀ (a : αᵒᵈ), ↑OrderDual.toDual (↑OrderDual.ofDual a) = a),\n        right_inv := (_ : ∀ (a : Topology.WithLowerSet αᵒᵈ), ↑OrderDual.ofDual (↑OrderDual.toDual a) = a) }.toFun",
  "constCategory": "Theorem"},
 {"references": ["Sup", "TopologicalSpace"],
  "name": "ContinuousSup",
  "constType":
  "(L : Type u_1) → [inst : TopologicalSpace L] → [inst : Sup L] → Prop",
  "constCategory": "Other"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{α : Type u_1} → Union (Set α)",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "forall_and", "Eq"],
  "name": "Std.Logic._auxLemma.44",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) = ((∀ (x : α), p x) ∧ ∀ (x : α), q x)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_3",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_4",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[>]__1»._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "inferInstance",
   "instIsTransLeToLE",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "IsTrans",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet.proof_1",
  "constType": "∀ {α : Type u_1}, IsTrans (Set α) fun x x_1 ↦ x ≤ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Topology.WithUpperSet.ofUpperSet",
   "Topology.WithUpperSet",
   "Topology.WithUpperSet.toUpperSet",
   "rfl",
   "Eq",
   "Equiv.symm"],
  "name": "Topology.WithUpperSet.of_WithUpperSet_symm_eq",
  "constType":
  "∀ {α : Type u_1}, Topology.WithUpperSet.ofUpperSet.symm = Topology.WithUpperSet.toUpperSet",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Filter.giGenerate.proof_1",
   "Filter.giGenerate.proof_3",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter.mkOfClosure",
   "Filter.le_generate_iff",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "GaloisInsertion.mk",
   "Filter",
   "Filter.giGenerate.proof_2",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "Filter.giGenerate",
  "constType": "(α : Type u_2) → GaloisInsertion Filter.generate Filter.sets",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.dummyRestore",
   "PUnit",
   "EStateM.Backtrackable",
   "EStateM.dummySave",
   "EStateM.Backtrackable.mk"],
  "name": "EStateM.nonBacktrackable",
  "constType": "{σ : Type u} → EStateM.Backtrackable PUnit.{u + 1} σ",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pow.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Iff", "forall_const"],
  "name": "forall_prop_of_true",
  "constType": "∀ {p : Prop} {q : p → Prop} (h : p), (∀ (h' : p), q h') ↔ q h",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "List.cons",
   "Nat.le",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.casesOn",
   "Nat.le.refl",
   "List.length",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "List",
   "LT.lt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get?_eq_get.match_1",
  "constType":
  "∀ {α : Type u_1} (motive : (x : List α) → (x_1 : ℕ) → x_1 < List.length x → Prop) (x : List α) (x_1 : ℕ)\n  (x_2 : x_1 < List.length x),\n  (∀ (head : α) (tail : List α) (x : 0 < List.length (head :: tail)), motive (head :: tail) 0 x) →\n    (∀ (head : α) (l : List α) (n : ℕ) (x : n + 1 < List.length (head :: l)), motive (head :: l) (Nat.succ n) x) →\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Equiv",
   "Iff",
   "Equiv.refl",
   "Topology.WithLowerSet",
   "lcProof",
   "FunLike.coe",
   "Topology.WithLowerSet.instPreorderWithLowerSet",
   "Topology.WithLowerSet.ofLowerSet",
   "RelIso.mk",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv"],
  "name": "Topology.WithLowerSet.ofLowerSetOrderIso._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithLowerSet α ≃o α",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "Topology.IsUpperSet",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "Topology.IsLowerSet",
   "Preorder",
   "OrderDual.instIsLowerSet.proof_1"],
  "name": "OrderDual.instIsLowerSet",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpperSet α],\n  Topology.IsLowerSet αᵒᵈ",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : FunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references": ["Bool.false", "Bool.true", "Bool"],
  "name": "Bool.rec",
  "constType":
  "{motive : Bool → Sort u} → motive false → motive true → (t : Bool) → motive t",
  "constCategory": "Other"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "UInt32",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.mk",
   "Equiv",
   "Exists",
   "Set",
   "Topology.WithLower",
   "Set.Iic",
   "Set.Ici",
   "Eq",
   "lcProof",
   "Continuous",
   "Homeomorph",
   "TopologicalSpace",
   "Membership.mem",
   "Equiv.toFun",
   "Topology.WithUpper",
   "OrderDual.toDual",
   "OrderDual.instPreorder",
   "setOf",
   "Topology.WithUpper.instTopologicalSpaceWithUpper",
   "HasCompl.compl._@.Mathlib.Data.Set.Basic._hyg.14",
   "Topology.WithLower.instTopologicalSpaceWithLower",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "TopologicalSpace.GenerateOpen",
   "Preorder",
   "Set.univ",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "TopologicalSpace.coinduced",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "OrderDual.ofDual",
   "Equiv.invFun",
   "OrderDual",
   "Equiv.mk",
   "OrderDual.ofDual_toDual",
   "Set.sUnion",
   "Homeomorph.mk",
   "OrderDual.toDual_ofDual",
   "Set.instInterSet",
   "Inter.inter._@.Mathlib.Data.Set.Basic._hyg.8"],
  "name": "Topology.WithLower.toDualHomeomorph._cstage1",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → Topology.WithLower α ≃ₜ Topology.WithUpper αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "Continuous.tendsto.match_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace β] {f : α → β} (x : α) (t : Set β)\n  (motive : f x ∈ t ∧ IsOpen t → Prop) (x_1 : f x ∈ t ∧ IsOpen t),\n  (∀ (hxt : f x ∈ t) (ht : IsOpen t), motive (_ : f x ∈ t ∧ IsOpen t)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Iff", "List.instMembershipList", "List"],
  "name": "List.TFAE",
  "constType": "List Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Topology.instIsLowerSetLowerSet.proof_1",
   "Topology.lowerSet",
   "Topology.IsLowerSet",
   "Preorder"],
  "name": "Topology.instIsLowerSetLowerSet",
  "constType": "∀ {α : Type u_1} [inst : Preorder α], Topology.IsLowerSet α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.ParserDescr.cat",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[_]_»._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Nat.zero",
   "List",
   "Eq.refl",
   "List.nil",
   "List.drop",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "List.drop_nil",
  "constType": "∀ {α : Type u} {i : ℕ}, List.drop i [] = []",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Function.comp",
   "Set",
   "Eq.refl",
   "Set.image_eq_range",
   "iSup",
   "SupSet.sSup",
   "Eq",
   "Set.instMembershipSet",
   "SupSet",
   "Set.range",
   "Eq.mpr",
   "Eq.ndrec",
   "_private.Mathlib.Order.CompleteLattice.0.iSup._eq_1",
   "Set.Elem",
   "Set.image",
   "Eq.symm",
   "Set.range_comp",
   "id"],
  "name": "iSup_range'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_5} [inst : SupSet α] (g : β → α) (f : ι → β), ⨆ b, g ↑b = ⨆ i, g (f i)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≠]__1»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name": "Topology.Homotopy.termΩ._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Eq.ndrec",
   "ZeroHom.casesOn",
   "ZeroHom.toFun",
   "ZeroHom.mk",
   "Eq.rec",
   "Eq.refl",
   "ZeroHom",
   "Eq.symm",
   "Eq"],
  "name": "ZeroHom.zeroHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : Zero M] [inst_1 : Zero N] (f g : ZeroHom M N), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "UpperSet",
  "constType": "(α : Type u_6) → [inst : LE α] → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "List.attach.proof_1",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "List.attach",
   "Eq",
   "List.map_pmap",
   "List.pmap_eq_map",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.map",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "List.attach_map_coe'",
  "constType":
  "∀ {α : Type u} {β : Type v} (l : List α) (f : α → β), List.map (fun i ↦ f ↑i) (List.attach l) = List.map f l",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Exists", "Iff", "Exists.intro", "forall_exists_index.match_1"],
  "name": "forall_exists_index",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) ↔ ∀ (x : α) (h : p x), q (_ : ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references":
  ["IsAssociative.mk",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "IsAssociative",
   "inf_assoc",
   "SemilatticeInf"],
  "name": "instIsAssociativeInfToInf.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SemilatticeInf α], IsAssociative α fun x x_1 ↦ x ⊓ x_1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Acc",
  "constType": "{α : Sort u} → (α → α → Prop) → α → Prop",
  "constCategory": "Other"},
 {"references": ["Eq", "IsCommutative"],
  "name": "IsCommutative.comm",
  "constType":
  "∀ {α : Type u} {op : α → α → α} [self : IsCommutative α op] (a b : α), op a b = op b a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_top",
   "OrderTop.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "CompleteLattice",
   "CompleteLattice.bot_le",
   "CompleteLattice.toTop",
   "CompleteLattice.toBot",
   "OrderBot.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{α : Type u_1} → [h : CompleteLattice α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "subset_trans",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 ↦ x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["closure",
   "Set.instSingletonSet",
   "OrderDual.instPreorder",
   "Set",
   "Topology.IsUpper",
   "OrderDual.instIsLower",
   "OrderDual",
   "TopologicalSpace",
   "Singleton.singleton",
   "Set.Iic",
   "instTopologicalSpaceOrderDual",
   "Preorder",
   "Topology.IsLower.closure_singleton",
   "Eq"],
  "name": "Topology.IsUpper.closure_singleton",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] (a : α),\n  closure {a} = Set.Iic a",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "exists_prop.match_2",
  "constType":
  "∀ {b a : Prop} (motive : a ∧ b → Prop) (x : a ∧ b), (∀ (hp : a) (hq : b), motive (_ : a ∧ b)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "_obj",
   "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_6",
   "List.nil",
   "_neutral"],
  "name":
  "Topology.«_aux_Mathlib_Topology_Basic___macroRules_Topology_term𝓝[≤]__1»._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["induced_iff_nhds_eq",
   "inducing_iff",
   "Iff",
   "nhds",
   "Filter.comap",
   "TopologicalSpace",
   "Filter",
   "Inducing",
   "Iff.trans",
   "TopologicalSpace.induced",
   "Eq"],
  "name": "inducing_iff_nhds",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Inducing f ↔ ∀ (a : α), nhds a = Filter.comap f (nhds (f a))",
  "constCategory": "Theorem"},
 {"references": ["sInfHom", "Set", "InfSet.sInf", "InfSet", "Set.image", "Eq"],
  "name": "sInfHom.mk",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : InfSet α] →\n      [inst_1 : InfSet β] → (toFun : α → β) → (∀ (s : Set α), toFun (sInf s) = sInf (toFun '' s)) → sInfHom α β",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Lean.Name.mkStr2",
   "OfNat.ofNat",
   "Lean.ParserDescr.cat",
   "Lean.ParserDescr.node",
   "instOfNatNat",
   "Lean.Name.mkStr1",
   "Nat",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "Topology.«term𝓝[>]_»",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.binary",
   "Topology.«term𝓝[_]_»._closed_5",
   "_obj",
   "Topology.«term𝓝[_]_»._closed_7",
   "Topology.IsOpen_of._closed_5"],
  "name": "Topology.«term𝓝[_]_»._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "IsCompl.disjoint",
   "OrderDual.instPartialOrder",
   "PartialOrder.toPreorder",
   "OrderDual",
   "FunLike.coe",
   "IsCompl.mk",
   "IsCompl",
   "IsCompl.codisjoint",
   "Preorder.toLE",
   "Equiv.instFunLikeEquiv",
   "OrderDual.boundedOrder",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.dual",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α},\n  IsCompl x y → IsCompl (↑OrderDual.toDual x) (↑OrderDual.toDual y)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderDual.instPreorder",
   "OrderDual",
   "TopologicalSpace",
   "instTopologicalSpaceOrderDual",
   "OrderDual.instIsUpperSet",
   "Topology.IsUpperSet.toAlexandrovDiscrete",
   "Topology.IsLowerSet",
   "Preorder",
   "AlexandrovDiscrete"],
  "name": "Topology.IsLowerSet.toAlexandrovDiscrete.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst : Topology.IsLowerSet α],\n  AlexandrovDiscrete αᵒᵈ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} → {s : outParam (β → β → Prop)} → [self : RelHomClass F r s] → FunLike F α fun x ↦ β",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "instAddNat",
   "Fin.val",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "Eq",
   "Eq.ndrec",
   "of_eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Fin.succ",
   "Nat.succ",
   "Fin",
   "Fin.mk",
   "Fin.casesOn"],
  "name": "Fin.val_succ",
  "constType": "∀ {n : ℕ} (j : Fin n), ↑(Fin.succ j) = ↑j + 1",
  "constCategory": "Theorem"},
 {"references": ["Array.mkEmpty", "_obj", "_neutral"],
  "name":
  "Topology._aux_Mathlib_Topology_Basic___unexpand_nhds_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadRef", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.toMonadRef",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → Lean.MonadRef m",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Alternative"],
  "name": "Alternative.toApplicative",
  "constType": "{f : Type u → Type v} → [self : Alternative f] → Applicative f",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "propext",
   "Set",
   "Filter.comap",
   "Filter",
   "Filter.mem_comap'",
   "Set.instMembershipSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Order.Filter.Bases._auxLemma.59",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {l : Filter β} {s : Set α},\n  (s ∈ Filter.comap f l) = ({y | ∀ ⦃x : α⦄, f x = y → x ∈ s} ∈ l)",
  "constCategory": "Theorem"},
 {"references": ["UInt32", "UInt32.size", "UInt32.casesOn", "Fin", "Eq"],
  "name": "UInt32.noConfusionType",
  "constType": "Sort u → UInt32 → UInt32 → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "LE.le",
   "PProd",
   "Nat.le_succ_of_le",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["Continuous", "TopologicalSpace", "ContinuousMap", "ContinuousMap.mk"],
  "name": "ContinuousMap.rec",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : TopologicalSpace α] →\n      [inst_1 : TopologicalSpace β] →\n        {motive : C(α, β) → Sort u} →\n          ((toFun : α → β) → (continuous_toFun : Continuous toFun) → motive (ContinuousMap.mk toFun)) →\n            (t : C(α, β)) → motive t",
  "constCategory": "Other"},
 {"references":
  ["propext", "List", "List.Sublist", "List.nil", "List.sublist_nil", "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.37",
  "constType": "∀ {α : Type u_1} {l : List α}, List.Sublist l [] = (l = [])",
  "constCategory": "Theorem"},
 {"references":
  ["Topology.WithUpperSet",
   "TopologicalSpace",
   "Topology.upperSet",
   "Preorder"],
  "name": "Topology.WithUpperSet.instTopologicalSpaceWithUpperSet",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → TopologicalSpace (Topology.WithUpperSet α)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_antisymm.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → m ≤ n → Prop) (m : ℕ) (h₁ : n ≤ m) (h₂ : m ≤ n),\n  (∀ (h₂ : n ≤ n), motive n (_ : Nat.le n n) h₂) →\n    (∀ (m : ℕ) (h : Nat.le n m) (h₂ : Nat.succ m ≤ n), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m)) h₂) →\n      motive m h₁ h₂",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "ClosedIciTopology",
  "constType":
  "(α : Type u_1) → [inst : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.trans",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "constCategory": "Theorem"},
 {"references": ["ReaderT", "MonadLift", "MonadLift.mk"],
  "name": "ReaderT.instMonadLiftReaderT",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → MonadLift m (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "trivial",
   "Bot.bot",
   "Set",
   "Filter",
   "CompleteLattice.toBot",
   "Filter.instCompleteLatticeFilter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_bot",
  "constType": "∀ {α : Type u} {s : Set α}, s ∈ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "Unit",
   "Unit.unit",
   "List.casesOn",
   "List.nil",
   "Lean.MacroScope"],
  "name": "Lean.MacroScopesView.review.match_1",
  "constType":
  "(motive : List Lean.MacroScope → Sort u_1) →\n  (x : List Lean.MacroScope) →\n    (Unit → motive []) → ((head : Lean.MacroScope) → (tail : List Lean.MacroScope) → motive (head :: tail)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (n : ℕ) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.monotone",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.mono",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β), Monotone ↑f",
  "constCategory": "Theorem"},
 {"references": ["PSigma"],
  "name": "PSigma.fst",
  "constType": "{α : Sort u} → {β : α → Sort v} → PSigma β → α",
  "constCategory": "Definition"},
 {"references": ["SDiff"],
  "name": "SDiff.mk",
  "constType": "{α : Type u} → (α → α → α) → SDiff α",
  "constCategory": "Other"},
 {"references": ["Inhabited", "String", "Inhabited.default"],
  "name": "panicCore",
  "constType": "{α : Type u} → [inst : Inhabited α] → String → α",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "IsCompl",
   "disjoint_compl_left",
   "IsCompl.codisjoint",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "IsCompl.disjoint",
   "LE.le.antisymm'",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "Disjoint.le_compl_left",
   "Disjoint.le_of_codisjoint",
   "HeytingAlgebra.toHasCompl"],
  "name": "IsCompl.compl_eq",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, IsCompl a b → aᶜ = b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "LT.lt",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Fin.casesOn",
   "Eq"],
  "name": "Fin.veq_of_eq.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (x x_1 : Fin n) → x = x_1 → Prop) (x x_1 : Fin n) (x_2 : x = x_1),\n  (∀ (val : ℕ) (isLt : val < n),\n      motive { val := val, isLt := isLt } { val := val, isLt := isLt }\n        (_ : { val := val, isLt := (_ : val < n) } = { val := val, isLt := (_ : val < n) })) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references": ["outParam", "MonadReader"],
  "name": "MonadReader.mk",
  "constType":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → m ρ → MonadReader ρ m",
  "constCategory": "Other"},
 {"references":
  ["Set.eq_univ_of_forall",
   "Set",
   "Set.Ici",
   "Preorder",
   "Set.univ",
   "Preorder.toLE",
   "IsBot",
   "Eq"],
  "name": "IsBot.Ici_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {a : α}, IsBot a → Set.Ici a = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "inf_le_inf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_inf_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] (a : α) {b c : α}, b ≤ c → a ⊓ b ≤ a ⊓ c",
  "constCategory": "Theorem"},
 {"references": ["List", "List.casesOn", "Eq"],
  "name": "List.noConfusionType",
  "constType": "{α : Type u} → Sort u_1 → List α → List α → Sort u_1",
  "constCategory": "Definition"},
 {"references":
  ["and_comm",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "and_assoc",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "Eq.symm",
   "Eq",
   "id"],
  "name": "and_left_comm",
  "constType": "∀ {a b c : Prop}, a ∧ b ∧ c ↔ b ∧ a ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.cons",
   "List.instMembershipList",
   "instBEq",
   "Exists.intro",
   "Exists.casesOn",
   "Eq",
   "And",
   "instHAppend",
   "BEq.beq",
   "List.eraseP",
   "List.instAppendList",
   "DecidableEq",
   "List",
   "HAppend.hAppend",
   "Bool.true",
   "Not",
   "And.intro",
   "Bool",
   "And.casesOn"],
  "name": "List.exists_erase_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}\n  (motive :\n    (∃ a_1,\n        ∃ l₁,\n          ∃ l₂,\n            (∀ b ∈ l₁, ¬(a == b) = true) ∧\n              (a == a_1) = true ∧ l = l₁ ++ a_1 :: l₂ ∧ List.eraseP (BEq.beq a) l = l₁ ++ l₂) →\n      Prop)\n  (x :\n    ∃ a_1,\n      ∃ l₁,\n        ∃ l₂,\n          (∀ b ∈ l₁, ¬(a == b) = true) ∧\n            (a == a_1) = true ∧ l = l₁ ++ a_1 :: l₂ ∧ List.eraseP (BEq.beq a) l = l₁ ++ l₂),\n  (∀ (w : α) (l₁ l₂ : List α) (h₁ : ∀ b ∈ l₁, ¬(a == b) = true) (e : (a == w) = true) (h₂ : l = l₁ ++ w :: l₂)\n      (h₃ : List.eraseP (BEq.beq a) l = l₁ ++ l₂),\n      motive\n        (_ :\n          ∃ a_1,\n            ∃ l₁,\n              ∃ l₂,\n                (∀ b ∈ l₁, ¬(a == b) = true) ∧\n                  (a == a_1) = true ∧ l = l₁ ++ a_1 :: l₂ ∧ List.eraseP (BEq.beq a) l = l₁ ++ l₂)) →\n    motive x",
  "constCategory": "Definition"},
 {"references": ["ULift"],
  "name": "ULift.down",
  "constType": "{α : Type s} → ULift.{r, s} α → α",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr3",
  "constType": "String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.mk",
   "Eq.ndrec",
   "Eq.rec",
   "Eq.refl",
   "Monotone",
   "OrderHom",
   "OrderHom.casesOn",
   "OrderHom.toFun",
   "Preorder",
   "Eq.symm",
   "Eq"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] (f g : α →o β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.tendsto_right_iff",
   "Filter.Eventually",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis.eventually_iff",
   "Filter.HasBasis",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter",
   "Filter.Tendsto",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {ι' : Sort u_5} {la : Filter α} {pa : ι → Prop} {sa : ι → Set α}\n  {lb : Filter β} {pb : ι' → Prop} {sb : ι' → Set β} {f : α → β},\n  Filter.HasBasis la pa sa →\n    Filter.HasBasis lb pb sb → (Filter.Tendsto f la lb ↔ ∀ (ib : ι'), pb ib → ∃ ia, pa ia ∧ ∀ x ∈ sa ia, f x ∈ sb ib)",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.subperm_left.match_1",
   "Exists",
   "List.Perm",
   "List.Sublist.trans",
   "List",
   "List.Subperm",
   "List.Sublist",
   "Exists.intro",
   "List.Subperm.trans.match_1",
   "Iff.mpr",
   "List.Perm.subperm_left"],
  "name": "List.Subperm.trans",
  "constType":
  "∀ {α : Type uu} {l₁ l₂ l₃ : List α}, l₁ <+~ l₂ → l₂ <+~ l₃ → l₁ <+~ l₃",
  "constCategory": "Theorem"}]