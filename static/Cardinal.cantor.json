[{"references": ["Quot", "Quot.mk", "Eq"],
  "name": "Quot.sound",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "constCategory": "Axiom"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.nil",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Add.mk",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3",
  "constType": "∀ {α : Type u_1} (s : Multiset α), s + 0 = s",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "List.mem_map",
   "List.instMembershipList",
   "propext",
   "List",
   "List.map",
   "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.70",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {b : β} {f : α → β} {l : List α}, (b ∈ List.map f l) = ∃ a ∈ l, f a = b",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Function.LeftInverse", "Function.RightInverse"],
  "name": "Equiv.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (toFun : α → β) → (invFun : β → α) → Function.LeftInverse invFun toFun → Function.RightInverse invFun toFun → α ≃ β",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.Injective",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "EquivLike.injective",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.injective",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Injective ⇑e",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "∀ {α : Type u_1} (a : Set α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "HasSSubset.SSubset",
   "Iff.rfl",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "Iff.intro",
   "Finset.ext",
   "LT.lt",
   "Finset",
   "Finset.instHasSubsetFinset",
   "Finset.instHasSSubsetFinset",
   "id"],
  "name": "Finset.partialOrder.proof_4",
  "constType": "∀ {α : Type u_1} (s t : Finset α), s ≤ t → t ≤ s → s = t",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "IsEmpty.mk",
   "Fin.val",
   "instOfNatNat",
   "Nat",
   "IsEmpty",
   "Nat.not_lt_zero",
   "Fin.isLt",
   "Fin"],
  "name": "Fin.isEmpty",
  "constType": "IsEmpty (Fin 0)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff.intro",
   "Set.ext",
   "Function.RightInverse.surjective",
   "setOf",
   "Function.Injective",
   "Eq.rec",
   "Set",
   "Not",
   "rfl",
   "Function.cantor_surjective",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Function.cantor_injective",
  "constType": "∀ {α : Type u_1} (f : Set α → α), ¬Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.sumCongr", "Cardinal", "Sum", "Add", "Cardinal.map₂", "Add.mk"],
  "name": "Cardinal.instAddCardinal",
  "constType": "Add Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.sumCongr",
   "Trans.trans",
   "Equiv.sumProdDistrib",
   "Equiv.instTransSortSortSortEquivEquivEquiv",
   "Sum",
   "Prod",
   "Equiv.prodComm"],
  "name": "Equiv.prodSumDistrib",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → α × (β ⊕ γ) ≃ α × β ⊕ α × γ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "One",
   "Cardinal",
   "One.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instOneCardinal",
  "constType": "One Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Finset.map.proof_1",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "FunLike.coe",
   "Finset.mk"],
  "name": "Finset.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["Set.piecewise",
   "Membership.mem",
   "Set",
   "Decidable",
   "Set.EqOn",
   "Set.piecewise_eq_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.piecewise_eqOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Set α) [inst : (j : α) → Decidable (j ∈ s)] (f g : α → β),\n  Set.EqOn (Set.piecewise s f g) f s",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "FunLike",
   "EquivLike.toEmbeddingLike",
   "Equiv.instEquivLikeEquiv"],
  "name": "Equiv.instFunLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Quotient.liftOn₂",
   "Cardinal",
   "LE",
   "Function.Embedding",
   "Cardinal.instLECardinal.proof_1",
   "Cardinal.isEquivalent",
   "Nonempty"],
  "name": "Cardinal.instLECardinal",
  "constType": "LE Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsTotal",
   "SemilatticeInf.toPartialOrder",
   "total_of",
   "Lattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "Lattice.toLinearOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [inst : Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "em",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Set.eq_univ_iff_forall",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "Set.instUnionSet",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.union_compl_self",
  "constType": "∀ {α : Type u} (s : Set α), s ∪ sᶜ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "LE.le",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "add_le_add_left",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ : Multiset α), s₁ ≤ s₂ → ∀ (a : Multiset α), a + s₁ ≤ a + s₂",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.piUnique.proof_1",
   "Equiv.piUnique.proof_2",
   "Equiv.mk",
   "Unique.instInhabited",
   "uniqueElim",
   "Inhabited.default",
   "Unique"],
  "name": "Equiv.piUnique",
  "constType":
  "{α : Sort u} → [inst : Unique α] → (β : α → Sort u_1) → ((i : α) → β i) ≃ β default",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Function.RightInverse",
   "Equiv.rec",
   "Equiv.mk"],
  "name": "Equiv.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : α ≃ β → Sort u} →\n      (t : α ≃ β) →\n        ((toFun : α → β) →\n            (invFun : β → α) →\n              (left_inv : Function.LeftInverse invFun toFun) →\n                (right_inv : Function.RightInverse invFun toFun) →\n                  motive { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) →\n          motive t",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not"],
  "name": "decide_eq_false.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → ¬p → Prop) (x : Decidable p) (x_1 : ¬p),\n  (∀ (h₁ : p) (h₂ : ¬p), motive (isTrue h₁) h₂) → (∀ (h x : ¬p), motive (isFalse h) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Cardinal.mk_congr",
   "Cardinal.instPowCardinal",
   "One.toOfNat1",
   "ULift",
   "Eq",
   "Cardinal.instOneCardinal",
   "instHPow",
   "Cardinal",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Fin.uniqueFinOne",
   "Nat",
   "Equiv.funUnique",
   "Fin",
   "ULift.instUniqueULift"],
  "name": "Cardinal.power_one",
  "constType": "∀ {a : Cardinal.{u}}, a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Quotient"],
  "name": "Trunc",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["IsEmpty.false", "IsEmpty.mk", "IsEmpty"],
  "name": "Function.isEmpty",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} [inst : IsEmpty β], (α → β) → IsEmpty α",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "propext", "or_false_iff", "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.13",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{α : Type u} →\n  [toCompleteLattice : CompleteLattice α] →\n    (∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)) →\n      CompletelyDistribLattice α",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references":
  ["Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8800",
   "Top.top",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "autoParam",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Top",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "HImp",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8834",
   "SemilatticeSup.toPartialOrder"],
  "name": "BooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toDistribLattice : DistribLattice α] →\n    [toHasCompl : HasCompl α] →\n      [toSDiff : SDiff α] →\n        [toHImp : HImp α] →\n          [toTop : Top α] →\n            [toBot : Bot α] →\n              (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n                (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                  (∀ (a : α), a ≤ ⊤) →\n                    (∀ (a : α), ⊥ ≤ a) →\n                      autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                        autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ → BooleanAlgebra α",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["Sum.elim",
   "PUnit.casesOn",
   "PUnit.unit",
   "Sum.casesOn",
   "Option.none",
   "Option.elim",
   "PUnit",
   "Eq.refl",
   "Option.some",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "Option",
   "Eq"],
  "name": "Equiv.optionEquivSumPUnit.proof_2",
  "constType":
  "∀ (α : Type u_1) (s : α ⊕ PUnit.{u_2 + 1}),\n  (fun o => Option.elim o (Sum.inr PUnit.unit) Sum.inl) ((fun s => Sum.elim some (fun x => none) s) s) = s",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "HasEquiv", "HasEquiv.mk"],
  "name": "instHasEquiv",
  "constType": "{α : Sort u} → [inst : Setoid α] → HasEquiv α",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["PUnit.unit",
   "Prod.mk",
   "Equiv.prodPUnit.match_1",
   "PUnit",
   "Prod",
   "Prod.fst",
   "rfl",
   "Eq"],
  "name": "Equiv.prodPUnit.proof_1",
  "constType":
  "∀ (α : Type u_1) (x : α × PUnit.{u_2 + 1}), (fun a => (a, PUnit.unit)) ((fun p => p.1) x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "List.Nodup.getEquivOfForallMemList.proof_2",
   "Membership.mem",
   "List.Nodup",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "Equiv.mk",
   "instBEq",
   "List.indexOf",
   "List.get",
   "List.length",
   "List.Nodup.getEquivOfForallMemList.proof_3",
   "List.Nodup.getEquivOfForallMemList.proof_1",
   "Fin.mk",
   "Fin"],
  "name": "List.Nodup.getEquivOfForallMemList",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → List.Nodup l → (∀ (x : α), x ∈ l) → Fin (List.length l) ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "List.pairwise_pmap",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "List.Pairwise.imp_of_mem",
   "Iff.mpr"],
  "name": "List.Pairwise.pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → α → Prop} {l : List α},\n  List.Pairwise R l →\n    ∀ {p : α → Prop} {f : (a : α) → p a → β} (h : ∀ x ∈ l, p x) {S : β → β → Prop},\n      (∀ ⦃x : α⦄ (hx : p x) ⦃y : α⦄ (hy : p y), R x y → S (f x hx) (f y hy)) → List.Pairwise S (List.pmap f l h)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "And",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Not",
   "And.intro",
   "Multiset.instMembershipMultiset",
   "Iff.mpr"],
  "name": "Finset.cons.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (s : Finset α), a ∉ s → Multiset.Nodup (a ::ₘ s.val)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Equivalence",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "Fintype.card",
   "FunLike.coe",
   "Multiset.card_map",
   "Fintype.ofBijective.proof_1",
   "Fintype.ofEquiv",
   "Equiv.instFunLikeEquiv",
   "Eq",
   "Finset.univ",
   "Fintype",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Embedding.mk",
   "Equiv.bijective",
   "Finset.val",
   "Function.Embedding",
   "Nat"],
  "name": "Fintype.ofEquiv_card",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] (f : α ≃ β), Fintype.card β = Fintype.card α",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Equiv.prodAssoc.match_1",
  "constType":
  "∀ (α : Type u_2) (β : Type u_1) (γ : Type u_3) (motive : (α × β) × γ → Prop) (x : (α × β) × γ),\n  (∀ (fst : α) (snd : β) (snd_1 : γ), motive ((fst, snd), snd_1)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "constCategory": "Theorem"},
 {"references": ["ULift.up", "ULift.down", "rfl", "ULift", "Eq"],
  "name": "ULift.up_down",
  "constType": "∀ {α : Type u} (b : ULift.{v, u} α), { down := b.down } = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "SemilatticeSup.toSup",
   "sup_eq_maxDefault",
   "IsTotal",
   "Max.max",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "List.cons",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "List",
   "PUnit",
   "List.range.loop.match_1",
   "Nat",
   "Nat.succ"],
  "name": "List.range.loop",
  "constType": "ℕ → List ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Prod.snd",
   "Prod.mk",
   "Equiv.mk",
   "Prod",
   "Prod.fst",
   "Equiv.prodAssoc.proof_1",
   "Equiv.prodAssoc.proof_2"],
  "name": "Equiv.prodAssoc",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α × β) × γ ≃ α × β × γ",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["eq_true",
   "Multiset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Nodup._auxLemma.4",
  "constType": "∀ {α : Type u_1} (a : α), Multiset.Nodup {a} = True",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "Disjoint.symm",
   "Disjoint",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "SemilatticeInf.toPartialOrder",
   "disjoint_compl_left",
   "HeytingAlgebra.toHasCompl",
   "HeytingAlgebra.toOrderBot"],
  "name": "disjoint_compl_right",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, Disjoint a aᶜ",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.symm",
   "Equivalence.mk",
   "List.Perm",
   "List.Perm.refl",
   "Equivalence",
   "List",
   "List.Perm.trans"],
  "name": "List.Perm.eqv",
  "constType": "∀ (α : Type u_1), Equivalence List.Perm",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Fintype.equivOfCardEq",
   "Cardinal.mk_congr",
   "Fintype.card_ulift",
   "Fintype.card",
   "Fin.fintype",
   "ULift",
   "True",
   "Eq",
   "Fintype.card_fin",
   "Fintype",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "of_eq_true",
   "Cardinal",
   "ULift.fintype",
   "Cardinal.mk",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin"],
  "name": "Cardinal.mk_fintype",
  "constType":
  "∀ (α : Type u) [h : Fintype α], Cardinal.mk α = ↑(Fintype.card α)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "List.cons", "List.Nodup", "List.pairwise_singleton", "List.nil"],
  "name": "List.nodup_singleton",
  "constType": "∀ {α : Type u} (a : α), List.Nodup [a]",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Cardinal",
   "instOfNatNat",
   "Cardinal.mk",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Fin",
   "Eq",
   "Cardinal.lift",
   "NatCast.natCast"],
  "name": "Cardinal.commSemiring.proof_14",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.coe",
  "constType":
  "{E : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EquivLike E α β] → E → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Function.RightInverse",
   "Function.Bijective.surjective",
   "Function.Bijective",
   "Function.surjInv",
   "Function.rightInverse_surjInv"],
  "name": "Equiv.ofBijective.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (hf : Function.Bijective f),\n  Function.RightInverse (Function.surjInv (_ : Function.Surjective f)) f",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOn₂", "Cardinal", "Cardinal.mk", "Cardinal.isEquivalent"],
  "name": "Cardinal.inductionOn₂",
  "constType":
  "∀ {p : Cardinal.{u_1} → Cardinal.{u_2} → Prop} (c₁ : Cardinal.{u_1}) (c₂ : Cardinal.{u_2}),\n  (∀ (α : Type u_1) (β : Type u_2), p (Cardinal.mk α) (Cardinal.mk β)) → p c₁ c₂",
  "constCategory": "Theorem"},
 {"references":
  ["List.length_range",
   "List.finRange.proof_1",
   "List.pmap",
   "Eq.refl",
   "List.length",
   "List.length_pmap",
   "instLTNat",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "_private.Mathlib.Data.List.Range.0.List.finRange._eq_1",
   "Nat",
   "Fin",
   "Fin.mk",
   "List.range",
   "id"],
  "name": "List.length_finRange",
  "constType": "∀ (n : ℕ), List.length (List.finRange n) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.inf_compl_le_bot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_12",
  "constType": "∀ {α : Type u_1} (x : α → Prop), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references": ["False", "Classical.cases_true_false", "True"],
  "name": "Classical.cases_on",
  "constType": "∀ (a : Prop) {p : Prop → Prop}, p True → p False → p a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.left_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Equiv.symm_apply_apply",
  "constType":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : α), e.symm (e x) = x",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod", "instDecidableEqProd.match_2"],
  "name": "Prod.map",
  "constType":
  "{α₁ : Type u₁} → {α₂ : Type u₂} → {β₁ : Type v₁} → {β₂ : Type v₂} → (α₁ → α₂) → (β₁ → β₂) → α₁ × β₁ → α₂ × β₂",
  "constCategory": "Definition"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Setoid.r",
   "List.Nodup",
   "propext",
   "List",
   "List.Perm.nodup_iff",
   "List.isSetoid",
   "Eq"],
  "name": "Multiset.Nodup.proof_1",
  "constType":
  "∀ {α : Type u_1} (x x_1 : List α), Setoid.r x x_1 → List.Nodup x = List.Nodup x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd", "instHAdd", "HAdd.hAdd", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.add_assoc",
  "constType":
  "∀ {G : Type u} [self : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Sum.casesOn",
   "Eq.refl",
   "Sum.swap",
   "Sum",
   "Sum.inr",
   "Eq.symm",
   "Sum.inl",
   "Eq"],
  "name": "Sum.swap_swap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (x : α ⊕ β), Sum.swap (Sum.swap x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M →+ N),\n  (fun f => f.toFun) f = (fun f => f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "rfl",
   "Equiv.prodAssoc.match_2",
   "Eq"],
  "name": "Equiv.prodAssoc.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_3) (γ : Type u_2) (x : α × β × γ),\n  (fun p => (p.1.1, p.1.2, p.2)) ((fun p => ((p.1, p.2.1), p.2.2)) x) = x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["Inhabited", "Unique.toInhabited", "Unique"],
  "name": "Unique.instInhabited",
  "constType": "{α : Sort u_1} → [inst : Unique α] → Inhabited α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.Nodup",
   "Multiset.Nodup.proof_1",
   "List",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Nodup",
  "constType": "{α : Type u_1} → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references": ["trivial", "eq_true", "True", "Eq"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (α → True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Setoid.r",
   "Cardinal",
   "Cardinal.mk",
   "Cardinal.isEquivalent",
   "Eq",
   "Quot.sound"],
  "name": "Cardinal.mk_congr",
  "constType": "∀ {α β : Type u}, α ≃ β → Cardinal.mk α = Cardinal.mk β",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → γ) → Insert α γ",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Quot",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "DecidableEq",
   "propext",
   "Finset",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.62",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Finset.cons.proof_1",
   "Finset.instMembershipFinset",
   "Not",
   "Finset.mk"],
  "name": "Finset.cons",
  "constType": "{α : Type u_1} → (a : α) → (s : Finset α) → a ∉ s → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), ZeroHom.toFun (↑f) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u_1} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references": ["False", "IsEmpty"],
  "name": "IsEmpty.mk",
  "constType": "∀ {α : Sort u_4}, (α → False) → IsEmpty α",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Cardinal.map",
   "Cardinal",
   "Equiv.ulift",
   "Equiv.trans",
   "ULift",
   "Equiv.symm"],
  "name": "Cardinal.lift",
  "constType": "Cardinal.{v} → Cardinal.{max v u}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.instMembershipFinset",
   "HasSubset",
   "HasSubset.mk"],
  "name": "Finset.instHasSubsetFinset",
  "constType": "{α : Type u_1} → HasSubset (Finset α)",
  "constCategory": "Definition"},
 {"references": ["List.Perm", "List"],
  "name": "List.Perm.trans",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ l₃ : List α}, List.Perm l₁ l₂ → List.Perm l₂ l₃ → List.Perm l₁ l₃",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommMonoid", "OrderedCancelAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedCancelAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Set.piecewise",
   "Set",
   "dite",
   "BooleanAlgebra.toHasCompl",
   "Exists.intro",
   "Exists.casesOn",
   "True",
   "Eq",
   "Set.range",
   "Set.ext",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "Decidable",
   "Set.image",
   "And.casesOn",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "Membership.mem",
   "eq_self",
   "False",
   "Or.inr",
   "Union.union",
   "HasCompl.compl",
   "Or.casesOn",
   "Set.piecewise_eq_of_mem",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "eq_false",
   "eq_true",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Or.inl",
   "of_eq_true",
   "Eq.mp",
   "Set.piecewise_eq_of_not_mem",
   "congr",
   "Not",
   "congrArg",
   "Set.instUnionSet",
   "and_self",
   "congrFun"],
  "name": "Set.range_piecewise",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Set α) [inst : (j : α) → Decidable (j ∈ s)] (f g : α → β),\n  Set.range (Set.piecewise s f g) = f '' s ∪ g '' sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.refl.proof_1", "Equiv.refl.proof_2", "Equiv.mk", "id"],
  "name": "Equiv.refl",
  "constType": "(α : Sort u_1) → α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.add_zero",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length.match_1",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)) (t : Set α), (∀ b ∈ s, b ≤ t) → ∀ a ∈ sSup s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "LE.mk",
   "Finset",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Finset.instHasSubsetFinset",
   "LE.le"],
  "name": "Finset.partialOrder.proof_2",
  "constType":
  "∀ {α : Type u_1} (s t u : Finset α), s ≤ t → t ≤ u → ∀ a ∈ s, a ∈ u",
  "constCategory": "Theorem"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{α : Type u_3} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.toSup",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop"],
  "name": "Set.instBooleanAlgebraSet.proof_13",
  "constType": "∀ {α : Type u_1} (x : α → Prop), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "EmbeddingLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["instHasEquiv", "Setoid", "Setoid.refl", "HasEquiv.Equiv", "Eq"],
  "name": "Quotient.lift₂.proof_1",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_1} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ),\n  (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n    ∀ (a₁ : α) (a b : β), a ≈ b → f a₁ a = f a₁ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "Fin.rightInverse_cast",
   "Fin.leftInverse_cast",
   "Equiv.mk",
   "instLEFin",
   "Fin.cast",
   "RelIso.mk",
   "Nat",
   "Fin.cast_le_cast",
   "Eq.symm",
   "LE.le",
   "Fin",
   "Eq"],
  "name": "Fin.castIso",
  "constType": "{n m : ℕ} → n = m → Fin n ≃o Fin m",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "funext",
   "Function.comp",
   "Equiv.symm_apply_apply",
   "FunLike.coe",
   "Eq",
   "id",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.symm_comp_self",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), ⇑e.symm ∘ ⇑e = id",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Not"],
  "name": "Decidable.isFalse",
  "constType": "{p : Prop} → ¬p → Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_le.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive Nat.zero) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.Embedding.antisymm.match_2",
   "Nonempty.intro",
   "Exists",
   "Function.Bijective",
   "Function.Injective",
   "Function.Embedding.antisymm.match_1",
   "Function.Embedding",
   "Equiv.ofBijective",
   "Function.Embedding.schroeder_bernstein",
   "Nonempty"],
  "name": "Function.Embedding.antisymm",
  "constType":
  "∀ {α : Type u} {β : Type v}, (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro", "Function.Embedding", "Nonempty", "Nonempty.casesOn"],
  "name": "Cardinal.instLECardinal.match_1",
  "constType":
  "∀ (x x_1 : Type u_1) (motive : Nonempty (x ↪ x_1) → Prop) (x_2 : Nonempty (x ↪ x_1)),\n  (∀ (e : x ↪ x_1), motive (_ : Nonempty (x ↪ x_1))) → motive x_2",
  "constCategory": "Definition"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "Inhabited.mk",
   "IsEmpty",
   "isEmptyElim",
   "Inhabited.default",
   "Eq"],
  "name": "Pi.uniqueOfIsEmpty.proof_1",
  "constType":
  "∀ {α : Sort u_1} [inst : IsEmpty α] (β : α → Sort u_2) (x : (a : α) → β a), x = default",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.mk",
   "Eq",
   "Quot.sound"],
  "name": "Quotient.sound",
  "constType": "∀ {α : Sort u} {s : Setoid α} {a b : α}, a ≈ b → ⟦a⟧ = ⟦b⟧",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Equiv",
   "Iff",
   "Function.isEmpty",
   "FunLike.coe",
   "IsEmpty",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.isEmpty_congr",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2}, α ≃ β → (IsEmpty α ↔ IsEmpty β)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "OfNat.ofNat", "OfNat", "Zero.mk"],
  "name": "Zero.ofOfNat0",
  "constType": "{α : Type u_1} → [inst : OfNat α 0] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.casesOn",
   "Equiv.toFun",
   "Eq.ndrec",
   "Function.RightInverse",
   "Equiv.invFun",
   "Eq.rec",
   "Eq.refl",
   "Equiv.mk",
   "Eq.symm",
   "Eq"],
  "name": "Equiv.instEquivLikeEquiv.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (e₁ e₂ : α ≃ β), e₁.toFun = e₂.toFun → e₁.invFun = e₂.invFun → e₁ = e₂",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Classical.choose", "Quot", "Quot.exists_rep", "Quot.mk", "Eq"],
  "name": "Quot.out",
  "constType": "{α : Sort u_1} → {r : α → α → Prop} → Quot r → α",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.monotone'",
   "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
   "FunLike.mk",
   "OrderHom",
   "OrderHom.toFun",
   "RelHomClass.mk",
   "Preorder",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → OrderHomClass (α →o β) α β",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "constCategory": "Other"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Equiv.prodCongr.match_1",
  "constType":
  "∀ {α₁ : Type u_1} {β₁ : Type u_2} (motive : α₁ × β₁ → Prop) (x : α₁ × β₁),\n  (∀ (a : α₁) (b : β₁), motive (a, b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike.coe", "EquivLike", "outParam", "EquivLike.inv", "Eq"],
  "name": "EquivLike.coe_injective'",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g",
  "constCategory": "Definition"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.map.proof_1", "Quot", "Quot.lift", "Relator.LiftFun", "Quot.mk"],
  "name": "Quot.map",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} → {ra : α → α → Prop} → {rb : β → β → Prop} → (f : α → β) → (ra ⇒ rb) f f → Quot ra → Quot rb",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.Mem",
  "constType": "{α : Type u} → α → List α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "EmbeddingLike.toFunLike",
   "Exists",
   "funext",
   "False",
   "Mathlib.Data.Finset.Image._auxLemma.1",
   "Option.noConfusion",
   "Finset.instMembershipFinset",
   "FunLike.coe",
   "True",
   "Function.Embedding.some",
   "Eq",
   "Finset.map",
   "And",
   "Std.Logic._auxLemma.31",
   "Function.instEmbeddingLikeEmbedding",
   "of_eq_true",
   "and_false",
   "eq_false'",
   "Option.none",
   "Finset",
   "Option.some",
   "Function.Embedding",
   "Not",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans",
   "Option"],
  "name": "Finset.insertNone.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Finset α), none ∉ Finset.map Function.Embedding.some s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "∀ {α ι : Type u_1} {κ : ι → Type u_1} (f : (a : ι) → κ a → Set α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "instHasEquiv",
   "Cardinal.map.match_1",
   "HasEquiv.Equiv",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.map.proof_1",
  "constType":
  "∀ (f : Type u_1 → Type u_2),\n  ((α β : Type u_1) → α ≃ β → f α ≃ f β) → ∀ (α β : Type u_1), α ≈ β → (fun x x_1 => x ≈ x_1) (f α) (f β)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references": ["Equiv.unique", "Equiv.ulift", "ULift", "Unique"],
  "name": "ULift.instUniqueULift",
  "constType": "{α : Type u} → [inst : Unique α] → Unique (ULift.{u_1, u} α)",
  "constCategory": "Definition"},
 {"references": ["Fin.val", "LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.isLt",
  "constType": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "constCategory": "Definition"},
 {"references":
  ["Unique.mk",
   "Inhabited.mk",
   "IsEmpty",
   "isEmptyElim",
   "Unique",
   "Pi.uniqueOfIsEmpty.proof_1"],
  "name": "Pi.uniqueOfIsEmpty",
  "constType":
  "{α : Sort u_1} → [inst : IsEmpty α] → (β : α → Sort v) → Unique ((a : α) → β a)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NeZero",
   "Nat.linearOrderedCommMonoidWithZero",
   "Inhabited",
   "Fin.instOfNatFin",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Inhabited.mk",
   "Fin"],
  "name": "Fin.inhabited",
  "constType": "(n : ℕ) → [inst : NeZero n] → Inhabited (Fin n)",
  "constCategory": "Definition"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.mk",
  "constType": "{α : Sort u} → (α → α → Sort v) → HasEquiv α",
  "constCategory": "Other"},
 {"references": ["HeytingAlgebra", "HasCompl"],
  "name": "HeytingAlgebra.toHasCompl",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal", "Cardinal.mk", "Cardinal.isEquivalent", "Quotient.inductionOn"],
  "name": "Cardinal.inductionOn",
  "constType":
  "∀ {p : Cardinal.{u_1} → Prop} (c : Cardinal.{u_1}), (∀ (α : Type u_1), p (Cardinal.mk α)) → p c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Function.LeftInverse", "Equiv.invFun"],
  "name": "Equiv.left_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.LeftInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references": ["False", "Iff", "Not", "Iff.mpr"],
  "name": "instDecidableIff.proof_3",
  "constType": "∀ {p q : Prop}, ¬p → q → (p ↔ q) → False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.image_congr",
   "of_eq_true",
   "Set.image_id'",
   "Set",
   "Eq.refl",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "True",
   "Set.instMembershipSet",
   "congrFun",
   "id",
   "Eq"],
  "name": "Set.image_id",
  "constType": "∀ {α : Type u_1} (s : Set α), id '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "RelEmbedding",
   "FunLike.mk",
   "Eq.refl",
   "RelEmbedding.toEmbedding",
   "FunLike.coe",
   "RelEmbedding.mk",
   "RelEmbedding.casesOn",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Embedding.toFun",
   "Function.Embedding.casesOn",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "RelEmbedding.map_rel_iff'",
   "Function.Embedding"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {r : α → α → Prop} {s : β → β → Prop} (f : r ↪r s) (a b : α), r a b → s (f a) (f b)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Cardinal.map.proof_1",
   "Cardinal",
   "Cardinal.isEquivalent",
   "Quotient.map"],
  "name": "Cardinal.map",
  "constType":
  "(f : Type u → Type v) → ((α β : Type u) → α ≃ β → f α ≃ f β) → Cardinal.{u} → Cardinal.{v}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.mem_cons",
   "Or",
   "propext",
   "Finset",
   "Finset.cons",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.42",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : a ∉ s}, (b ∈ Finset.cons a s h) = (b = a ∨ b ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.univ",
   "Fintype.mk",
   "Fintype",
   "PartialOrder.toPreorder",
   "Finset",
   "Finset.partialOrder",
   "Finset.insertNone",
   "FunLike.coe",
   "OrderEmbedding",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "LE.le",
   "Preorder.toLE",
   "instFintypeOption.proof_1",
   "RelHomClass.toFunLike",
   "Option"],
  "name": "instFintypeOption",
  "constType": "{α : Type u_4} → [inst : Fintype α] → Fintype (Option α)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Eq", "Set.instMembershipSet"],
  "name": "Set.InjOn",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{α : Type u} → (α → α → α) → Sup α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "List.pmap",
   "List.instMembershipList",
   "Subtype.val",
   "Mathlib.Data.List.Basic._auxLemma.9",
   "Mathlib.Data.List.Basic._auxLemma.69",
   "Eq.refl",
   "List.pmap_eq_map_attach",
   "List.attach",
   "Mathlib.Data.List.Basic._auxLemma.72",
   "Iff.mpr",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "Subtype.property",
   "And",
   "Mathlib.Data.List.Basic._auxLemma.71",
   "Iff",
   "of_eq_true",
   "List",
   "congr",
   "Mathlib.Data.List.Basic._auxLemma.70",
   "List.map",
   "congrArg",
   "Eq.trans",
   "Subtype",
   "Subtype.mk",
   "exists_prop_congr'"],
  "name": "List.mem_pmap",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a} {b : β},\n  b ∈ List.pmap f l H ↔ ∃ a, ∃ (h : a ∈ l), f a (_ : p a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.mk_congr",
   "Cardinal",
   "Equiv.ulift",
   "Cardinal.inductionOn",
   "ULift",
   "Cardinal.lift",
   "Eq"],
  "name": "Cardinal.lift_id'",
  "constType": "∀ (a : Cardinal.{max u v}), Cardinal.lift.{u, max u v} a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.toFun", "Equiv.invFun", "Function.RightInverse"],
  "name": "Equiv.right_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.RightInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat", "instHAdd", "HAdd.hAdd", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "Nat.add_succ",
  "constType": "∀ (n m : ℕ), n + Nat.succ m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Trunc.out",
   "Classical.decEq",
   "Fintype",
   "Fintype.truncEquivOfCardEq",
   "Fintype.card",
   "Nat",
   "Eq"],
  "name": "Fintype.equivOfCardEq",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Fintype α] → [inst_1 : Fintype β] → Fintype.card α = Fintype.card β → α ≃ β",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "And", "Iff.mp", "Iff", "And.imp", "Iff.mpr"],
  "name": "and_congr",
  "constType": "∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)",
  "constCategory": "Theorem"},
 {"references": ["Sum"],
  "name": "Sum.inr",
  "constType": "{α : Type u} → {β : Type v} → β → α ⊕ β",
  "constCategory": "Other"},
 {"references":
  ["NeZero",
   "Fin.ofNat'",
   "Nat.linearOrderedCommMonoidWithZero",
   "OfNat",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Fin.instOfNatFin.proof_1",
   "OfNat.mk",
   "Nat",
   "Fin"],
  "name": "Fin.instOfNatFin",
  "constType": "{n a : ℕ} → [inst : NeZero n] → OfNat (Fin n) a",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u} → α → Bot α",
  "constCategory": "Other"},
 {"references":
  ["sInf_le",
   "CompleteSemilatticeInf.toPartialOrder",
   "setOf",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderHom.instPreorderOrderHom",
   "OrderHom.lfp",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.lfp_le",
  "constType":
  "∀ {α : Type u} [inst : CompleteLattice α] (f : α →o α) {a : α}, f a ≤ a → OrderHom.lfp f ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Quotient.liftOn₂",
   "Iff.rfl",
   "LT.lt",
   "Cardinal",
   "Not",
   "Function.Embedding",
   "Cardinal.instLECardinal.proof_1",
   "LT.mk",
   "Cardinal.isEquivalent",
   "Nonempty"],
  "name": "Cardinal.partialOrder.proof_3",
  "constType": "∀ (a b : Cardinal.{u_1}), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "AddCommMonoid.toAddMonoid",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Equiv.sumProdDistrib",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Equiv.sumEmpty",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Cardinal.instAddCardinal",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Equiv.sumAssoc",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_8",
  "constType": "∀ (a b c : Cardinal.{u_1}), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.prodCongr",
   "Equiv.refl",
   "Equiv.equivPUnit",
   "PUnit",
   "Prod",
   "Equiv.prodPUnit",
   "Equiv.trans",
   "Unique"],
  "name": "Equiv.prodUnique",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : Unique β] → α × β ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.symm",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "one_add_one_eq_two",
  "constType": "∀ {α : Type u_1} [inst : AddMonoidWithOne α], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references":
  ["PUnit.subsingleton",
   "PUnit.unit",
   "PUnit",
   "Inhabited.mk",
   "Inhabited.default",
   "Eq"],
  "name": "PUnit.unique.proof_1",
  "constType": "∀ (x : PUnit.{u_1}), x = default",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{α : Type u_1} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["HeytingAlgebra", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : BiheytingAlgebra α] → HeytingAlgebra α",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Unique.instSubsingleton",
   "Unique.instInhabited",
   "Inhabited.default",
   "Eq",
   "instInhabitedForAll_1",
   "Subsingleton.elim",
   "Unique"],
  "name": "Equiv.equivOfUnique.proof_2",
  "constType":
  "∀ (α : Sort u_2) (β : Sort u_1) [inst : Unique α] [inst_1 : Unique β] (x : β), default (default x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Iff",
   "Set.instBooleanAlgebraSet",
   "Set",
   "compl_le_compl_iff_le",
   "HasCompl.compl",
   "HasSubset.Subset",
   "BooleanAlgebra.toHasCompl"],
  "name": "Set.compl_subset_compl",
  "constType": "∀ {α : Type u} {s t : Set α}, sᶜ ⊆ tᶜ ↔ t ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Function.Surjective",
   "Equiv.instEquivLikeEquiv",
   "EquivLike.surjective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.surjective",
  "constType":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Surjective ⇑e",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Prod.mk.eta.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : α × β → Prop) (x : α × β),\n  (∀ (fst : α) (snd : β), motive (fst, snd)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.prop_complete",
   "False",
   "Eq.rec",
   "Eq.symm",
   "Or.elim",
   "True",
   "Eq"],
  "name": "Classical.cases_true_false",
  "constType": "∀ (p : Prop → Prop), p True → p False → ∀ (a : Prop), p a",
  "constCategory": "Theorem"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Setoid", "Quot.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.ind",
  "constType":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop}, (∀ (a : α), motive ⟦a⟧) → ∀ (q : Quotient s), motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "Mathlib.Data.Finset.Basic._auxLemma.42",
   "True",
   "iff_self",
   "Eq",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.ext",
   "Finset",
   "Finset.cons",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "Not",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.cons_eq_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α) (h : a ∉ s), Finset.cons a s h = insert a s",
  "constCategory": "Theorem"},
 {"references": ["Option.some", "Membership.mk", "Membership", "Eq", "Option"],
  "name": "Option.instMembershipOption",
  "constType": "{α : Type u_1} → Membership α (Option α)",
  "constCategory": "Definition"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{α : Type u_1} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Unique.instSubsingleton",
   "Function.Surjective",
   "Subsingleton",
   "Function.Surjective.subsingleton",
   "Unique"],
  "name": "Function.Surjective.unique.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → β), Function.Surjective f → ∀ [inst : Unique α], Subsingleton β",
  "constCategory": "Theorem"},
 {"references": ["Trunc.lift", "Trunc", "Eq"],
  "name": "Trunc.liftOn",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → Trunc α → (f : α → β) → (∀ (a b : α), f a = f b) → β",
  "constCategory": "Definition"},
 {"references": ["Sum.elim", "Sum", "Sum.inr", "Sum.inl"],
  "name": "Sum.swap",
  "constType": "{α : Type u_1} → {β : Type u_2} → α ⊕ β → β ⊕ α",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "AddCommMonoid.toAddMonoid",
   "Cardinal.mk_eq_zero",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "Prod.isEmpty_left",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Cardinal.instAddCardinal",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Equiv.sumAssoc",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_9",
  "constType": "∀ (a : Cardinal.{u_1}), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "Cardinal",
   "Cardinal.mk",
   "Nat",
   "NatCast.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instNatCastCardinal",
  "constType": "NatCast Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_true_left", "propext", "True", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.43",
  "constType": "∀ (p : True → Prop), (∀ (x : True), p x) = p True.intro",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["Zero", "Multiset.zero", "Multiset", "Zero.mk"],
  "name": "Multiset.instZeroMultiset",
  "constType": "{α : Type u_1} → Zero (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Iff.intro",
   "Iff",
   "Function.Injective",
   "Set",
   "Set.univ",
   "Set.InjOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.injective_iff_injOn_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f ↔ Set.InjOn f Set.univ",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references": ["Empty", "False", "IsEmpty.mk", "Empty.elim", "IsEmpty"],
  "name": "instIsEmptyEmpty",
  "constType": "IsEmpty Empty",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references": ["HasSubset"],
  "name": "HasSubset.mk",
  "constType": "{α : Type u} → (α → α → Prop) → HasSubset α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "instNatPowNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.out"],
  "name": "Trunc.out",
  "constType": "{α : Sort u_1} → Trunc α → α",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "Setoid",
   "Quot",
   "HasEquiv.Equiv",
   "Relator.LiftFun",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Quotient.map₂.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} [sa : Setoid α] [sb : Setoid β] {γ : Sort u_3} [sc : Setoid γ] (f : α → β → γ),\n  ((fun x x_1 => x ≈ x_1) ⇒ (fun x x_1 => x ≈ x_1) ⇒ fun x x_1 => x ≈ x_1) f f →\n    ∀ (x : α) (x_1 : β) (x_2 : α) (x_3 : β),\n      x ≈ x_2 → x_1 ≈ x_3 → Quot.mk Setoid.r (f x x_1) = Quot.mk Setoid.r (f x_2 x_3)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{α : Sort u} → Nonempty α → α",
  "constCategory": "Axiom"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.Sublist",
  "constType": "{α : Type u_1} → List α → List α → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["List", "List.Mem", "Membership.mk", "Membership"],
  "name": "List.instMembershipList",
  "constType": "{α : Type u} → Membership α (List α)",
  "constCategory": "Definition"},
 {"references":
  ["subsingleton_of_forall_eq",
   "Subsingleton",
   "Unique.instInhabited",
   "Unique.eq_default",
   "Inhabited.default",
   "Unique"],
  "name": "Unique.instSubsingleton",
  "constType": "∀ {α : Sort u_1} [inst : Unique α], Subsingleton α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Eq.ndrec", "Bool", "Bool.noConfusionType", "Eq"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references":
  ["Pi.preorder", "OrderHom", "OrderHom.toFun", "Preorder.lift", "Preorder"],
  "name": "OrderHom.instPreorderOrderHom",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → Preorder (α →o β)",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse", "Function.RightInverse", "Function.Injective", "Eq"],
  "name": "Function.rightInverse_of_injective_of_leftInverse",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α},\n  Function.Injective f → Function.LeftInverse f g → Function.RightInverse f g",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "OrderHom",
   "FunLike.coe",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "RelHomClass.toFunLike",
   "LE.le.antisymm",
   "OrderHom.map_le_lfp",
   "CompleteLattice",
   "OrderHom.mono",
   "OrderHom.lfp_le",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderHom.instPreorderOrderHom",
   "OrderHom.lfp"],
  "name": "OrderHom.map_lfp",
  "constType":
  "∀ {α : Type u} [inst : CompleteLattice α] (f : α →o α), f (OrderHom.lfp f) = OrderHom.lfp f",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Quotient.inductionOn₂",
   "PartialOrder.toPreorder",
   "List.Sublist",
   "List.isSetoid",
   "Multiset.leInductionOn.match_1",
   "Quotient",
   "LE.le",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset",
   "Quotient.mk",
   "Eq",
   "Setoid.r",
   "List.Perm",
   "List",
   "Eq.rec",
   "Multiset",
   "Multiset.ofList",
   "Quot.sound"],
  "name": "Multiset.leInductionOn",
  "constType":
  "∀ {α : Type u_1} {C : Multiset α → Multiset α → Prop} {s t : Multiset α},\n  s ≤ t → (∀ {l₁ l₂ : List α}, List.Sublist l₁ l₂ → C ↑l₁ ↑l₂) → C s t",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff"],
  "name": "instDecidableIff.proof_1",
  "constType": "∀ {p q : Prop}, p → q → (p ↔ q)",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set",
   "And.intro",
   "Exists.intro",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image_subset.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a : Set α} (f : α → β) (x : β) (motive : (∃ x_1 ∈ a, f x_1 = x) → Prop)\n  (x_1 : ∃ x_1 ∈ a, f x_1 = x), (∀ (w : α) (h1 : w ∈ a) (h2 : f w = x), motive (_ : ∃ x_2 ∈ a, f x_2 = x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Std.Logic._auxLemma.31",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "∀ {α : Type u_1} (x y z : Set α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Option.instMembershipOption",
   "Finset.mem_insertNone",
   "PartialOrder.toPreorder",
   "Finset.instMembershipFinset",
   "Finset.partialOrder",
   "FunLike.coe",
   "OrderEmbedding",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Eq",
   "propext",
   "Finset",
   "Finset.insertNone",
   "Option"],
  "name": "Mathlib.Data.Finset.Option._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {o : Option α}, (o ∈ Finset.insertNone s) = ∀ a ∈ o, a ∈ s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.Injective",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Function.LeftInverse.injective"],
  "name": "EquivLike.toEmbeddingLike.proof_2",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e : E), Function.Injective (EquivLike.coe e)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "ULift",
   "AddMonoid.mk",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "Cardinal.inductionOn₃",
   "ULift.instIsEmptyULift",
   "Equiv.emptySum",
   "Cardinal.instAddCardinal",
   "AddMonoid.toAddSemigroup",
   "Fin.isEmpty'",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Cardinal.inductionOn",
   "Sum",
   "Equiv.sumAssoc",
   "Nat",
   "Fin",
   "Cardinal.inductionOn₂",
   "Add.mk"],
  "name": "Cardinal.commSemiring.proof_6",
  "constType": "∀ (a b : Cardinal.{u_1}), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.allEq",
  "constType": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "Setoid",
   "Equivalence.refl",
   "HasEquiv.Equiv",
   "Setoid.iseqv"],
  "name": "Setoid.refl",
  "constType": "∀ {α : Sort u} [inst : Setoid α] (a : α), a ≈ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.union",
  "constType": "{α : Type u_1} → Set α → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["Sum.casesOn", "Sum", "Sum.inr", "Sum.inl"],
  "name": "Sum.map_map.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : α ⊕ β → Prop) (x : α ⊕ β),\n  (∀ (val : α), motive (Sum.inl val)) → (∀ (val : β), motive (Sum.inr val)) → motive x",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Iff",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "Multiset.mem_ndinsert",
   "Eq"],
  "name": "Finset.mem_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, a ∈ insert b s ↔ a = b ∨ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Injective",
   "Function.Embedding.injective",
   "Function.comp",
   "Function.Injective.comp",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Function.Embedding.trans.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (f : α ↪ β) (g : β ↪ γ), Function.Injective (⇑g ∘ ⇑f)",
  "constCategory": "Theorem"},
 {"references": ["Or", "IsTotal"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references":
  ["Multiset.Le", "And", "Iff", "Iff.rfl", "LT.lt", "Multiset", "Not", "LT.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_3",
  "constType": "∀ {α : Type u_1} (a b : Multiset α), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_true_of_eq_false.match_1",
  "constType":
  "∀ (motive : (x : Bool) → x = false → Prop) (x : Bool) (x_1 : x = false),\n  (∀ (h : true = false), motive true h) → (∀ (x : false = false), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.right_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "Equiv.apply_symm_apply",
  "constType":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : β), e (e.symm x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective",
   "compl_involutive",
   "HasCompl.compl",
   "Function.Involutive.injective",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra"],
  "name": "compl_injective",
  "constType":
  "∀ {α : Type u} [inst : BooleanAlgebra α], Function.Injective compl",
  "constCategory": "Theorem"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_9} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.Perm",
   "of_eq_true",
   "List",
   "Eq.refl",
   "List.nil",
   "List.Perm.rec",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.Perm.length_eq",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Perm l₁ l₂ → List.length l₁ = List.length l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Nat"],
  "name": "Nat.semiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive (Nat.succ n)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Fin.uniqueFinOne.proof_1",
   "Unique.mk",
   "Fin.uniqueFinOne.proof_2",
   "instOfNatNat",
   "Nat",
   "Fin.inhabited",
   "Fin",
   "Unique"],
  "name": "Fin.uniqueFinOne",
  "constType": "Unique (Fin 1)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Sum.elim",
   "Equiv.sumAssoc.proof_1",
   "Equiv.sumAssoc.proof_2",
   "Function.comp",
   "Equiv.mk",
   "Sum",
   "Sum.inr",
   "Sum.inl"],
  "name": "Equiv.sumAssoc",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β) ⊕ γ ≃ α ⊕ β ⊕ γ",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.nil",
   "List.isEmpty.match_1"],
  "name": "List.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.cons",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.cons.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (x x_1 : List α), Setoid.r x x_1 → Quot.mk Setoid.r (a :: x) = Quot.mk Setoid.r (a :: x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "AddCommMonoid.toAddMonoid",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Equiv.sumEmpty",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Equiv.prodSumDistrib",
   "Cardinal.instAddCardinal",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Equiv.sumAssoc",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_7",
  "constType": "∀ (a b c : Cardinal.{u_1}), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["OrderHom", "Preorder"],
  "name": "OrderHom.toFun",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    (∀ (a b c : α), a + b ≤ a + c → b ≤ c) → OrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references": ["congrArg₂", "Eq"],
  "name": "congr_arg₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.inj'",
   "Function.Embedding.toFun",
   "EmbeddingLike.mk",
   "Function.instEmbeddingLikeEmbedding.proof_1",
   "FunLike.mk",
   "EmbeddingLike",
   "Function.Embedding"],
  "name": "Function.instEmbeddingLikeEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → EmbeddingLike (α ↪ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Exists",
   "EmbeddingLike.toFunLike",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Option.noConfusion",
   "Finset.card_map",
   "rfl",
   "instFintypeOption",
   "True",
   "Eq",
   "Fintype",
   "Option.none",
   "eq_false'",
   "and_false",
   "Finset",
   "Finset.cons",
   "instOfNatNat",
   "Function.Embedding",
   "Option.some",
   "Nat",
   "not_false_eq_true",
   "Eq.trans",
   "Option",
   "Membership.mem",
   "funext",
   "False",
   "instAddNat",
   "Mathlib.Data.Finset.Image._auxLemma.1",
   "instHAdd",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "FunLike.coe",
   "Function.Embedding.some",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.map",
   "Finset.univ",
   "And",
   "Std.Logic._auxLemma.31",
   "Function.instEmbeddingLikeEmbedding",
   "congr_arg₂",
   "of_eq_true",
   "congr",
   "Not",
   "Finset.card_cons",
   "congrArg"],
  "name": "Fintype.card_option",
  "constType":
  "∀ {α : Type u_4} [inst : Fintype α], Fintype.card (Option α) = Fintype.card α + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["le_sInf_iff",
   "Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "setOf",
   "PartialOrder.toPreorder",
   "Set",
   "LE.le.trans",
   "InfSet.sInf",
   "OrderHom",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "CompleteLattice",
   "Iff.mp",
   "CompleteSemilatticeInf.toInfSet",
   "OrderHom.mono",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderHom.instPreorderOrderHom",
   "OrderHom.lfp",
   "OrderHom.le_lfp"],
  "name": "OrderHom.map_le_lfp",
  "constType":
  "∀ {α : Type u} [inst : CompleteLattice α] (f : α →o α) {a : α}, a ≤ OrderHom.lfp f → f a ≤ OrderHom.lfp f",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Multiset.instPartialOrderMultiset.proof_2",
   "Multiset.instPartialOrderMultiset.proof_4",
   "Multiset",
   "Multiset.instPartialOrderMultiset.proof_3",
   "Not",
   "Multiset.instPartialOrderMultiset.proof_1",
   "LT.mk",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Multiset.instPartialOrderMultiset",
  "constType": "{α : Type u_1} → PartialOrder (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Multiset", "Multiset.cons", "Insert", "Insert.mk"],
  "name": "Multiset.instInsertMultiset",
  "constType": "{α : Type u_1} → Insert α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.sumCongr",
   "Cardinal.instAddCardinal",
   "Cardinal.mk_congr",
   "instHAdd",
   "HAdd.hAdd",
   "Cardinal",
   "Equiv.ulift",
   "Sum",
   "Equiv.trans",
   "ULift",
   "Cardinal.inductionOn₂",
   "Equiv.symm",
   "Cardinal.lift",
   "Eq"],
  "name": "Cardinal.lift_add",
  "constType":
  "∀ (a b : Cardinal.{u}), Cardinal.lift.{v, u} (a + b) = Cardinal.lift.{v, u} a + Cardinal.lift.{v, u} b",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.mk",
  "constType": "{α : Type u} → (α → ℕ → α) → NatPow α",
  "constCategory": "Other"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableAnd.match_1",
  "constType":
  "{q : Prop} →\n  (motive : Decidable q → Sort u_1) →\n    (dq : Decidable q) → ((hq : q) → motive (isTrue hq)) → ((hq : ¬q) → motive (isFalse hq)) → motive dq",
  "constCategory": "Definition"},
 {"references": ["And", "Function.Surjective", "Function.Injective"],
  "name": "Function.Bijective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Not", "absurd"],
  "name": "instDecidableIff.proof_4",
  "constType": "∀ {p q : Prop}, ¬p → ¬q → (p ↔ q)",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "NeZero.mk",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat"],
  "name": "NeZero.succ",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Definition"},
 {"references": ["IsEmpty.false", "False.elim", "IsEmpty"],
  "name": "isEmptyElim",
  "constType":
  "{α : Sort u_1} → [inst : IsEmpty α] → {p : α → Sort u_4} → (a : α) → p a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "RelHomClass",
  "constType":
  "Type u_5 →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} → outParam (α → α → Prop) → outParam (β → β → Prop) → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x x_3 0) → (∀ (n m k : ℕ), motive n m (Nat.succ k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_1",
  "constType": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Quot.lift", "Quot", "Eq"],
  "name": "Quot.liftOn",
  "constType":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "constCategory": "Definition"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{α : Type u} → [self : Lattice α] → Inf α",
  "constCategory": "Definition"},
 {"references":
  ["Quot.rec",
   "Subsingleton",
   "Quot.recOnSubsingleton'.proof_1",
   "Quot",
   "Quot.mk"],
  "name": "Quot.recOnSubsingleton'",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] → (q : Quot r) → ((a : α) → motive (Quot.mk r a)) → motive q",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "List.isSetoid",
   "List.Sublist",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List.Perm",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "HAppend.hAppend",
   "Multiset.le_iff_exists_add.match_1",
   "AddMonoid.toAddSemigroup",
   "List",
   "Multiset",
   "Multiset.leInductionOn",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.ofList",
   "List.Sublist.exists_perm_append",
   "OrderedAddCommMonoid.toPartialOrder",
   "Quot.sound",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_2",
  "constType": "∀ {α : Type u_1} {a b : Multiset α}, a ≤ b → ∃ c, b = a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Bijective.surjective",
   "Function.Bijective",
   "Function.surjInv",
   "Function.leftInverse_surjInv",
   "Equiv.mk",
   "Equiv.ofBijective.proof_1"],
  "name": "Equiv.ofBijective",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → Function.Bijective f → α ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "instNatPowNat",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "IsEmpty", "Iff.mpr", "Equiv.isEmpty_congr"],
  "name": "Equiv.isEmpty",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2}, α ≃ β → ∀ [inst : IsEmpty β], IsEmpty α",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.zero_add",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references": ["Array", "List"],
  "name": "Array.data",
  "constType": "{α : Type u} → Array α → List α",
  "constCategory": "Definition"},
 {"references":
  ["Option.instMembershipOption",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "implies_true",
   "Std.Data.Option.Basic._auxLemma.1",
   "Finset.instMembershipFinset",
   "Finset.partialOrder",
   "FunLike.coe",
   "OrderEmbedding",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "implies_congr",
   "Mathlib.Data.Finset.Option._auxLemma.3",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Eq",
   "RelHomClass.toFunLike",
   "Finset.univ",
   "Fintype",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "Option.some",
   "Finset.insertNone",
   "Eq.trans",
   "Option"],
  "name": "instFintypeOption.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (a : Option α), a ∈ Finset.insertNone Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "List.finRange",
   "Eq.refl",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range",
   "Eq"],
  "name": "_private.Mathlib.Data.List.Range.0.List.finRange._eq_1",
  "constType":
  "∀ (n : ℕ), List.finRange n = List.pmap Fin.mk (List.range n) (_ : ∀ x ∈ List.range n, x < n)",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.lift₂.proof_1",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.lift₂.proof_2",
   "Eq"],
  "name": "Quotient.lift₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          (f : α → β → φ) →\n            (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n              Quotient s₁ → Quotient s₂ → φ",
  "constCategory": "Definition"},
 {"references": ["rfl", "Eq", "id"],
  "name": "Equiv.refl.proof_2",
  "constType": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Set.InjOn",
   "Set.subset_union_left",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "Disjoint.le_bot",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Iff",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "And.casesOn",
   "Eq.symm",
   "Membership.mem",
   "Ne",
   "False",
   "Lattice.toSemilatticeInf",
   "Or.inr",
   "Union.union",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Set.subset_union_right",
   "Set.InjOn.mono",
   "Or.casesOn",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Or.inl",
   "False.elim",
   "GeneralizedCoheytingAlgebra.toLattice",
   "And.intro",
   "Set.instUnionSet"],
  "name": "Set.injOn_union",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s₁ s₂ : Set α} {f : α → β},\n  Disjoint s₁ s₂ → (Set.InjOn f (s₁ ∪ s₂) ↔ Set.InjOn f s₁ ∧ Set.InjOn f s₂ ∧ ∀ x ∈ s₁, ∀ y ∈ s₂, f x ≠ f y)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.sumComm", "Equiv.sumEmpty", "Sum", "IsEmpty", "Equiv.trans"],
  "name": "Equiv.emptySum",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : IsEmpty α] → α ⊕ β ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List.pmap.proof_3",
   "List.instMembershipList",
   "Mathlib.Data.List.Pairwise._auxLemma.8",
   "Eq.refl",
   "rfl",
   "implies_congr",
   "Std.Data.List.Basic._auxLemma.2",
   "True",
   "iff_self",
   "Eq",
   "Eq.mpr",
   "Iff",
   "List.rec",
   "forall_congr",
   "List.nil",
   "Mathlib.Data.List.Pairwise._auxLemma.2",
   "Std.Data.List.Init.Lemmas._auxLemma.2",
   "And.casesOn",
   "Eq.trans",
   "id",
   "Membership.mem",
   "List.cons",
   "Or",
   "List.pmap",
   "Mathlib.Data.List.Pairwise._auxLemma.10",
   "Iff.intro",
   "List.Pairwise",
   "And",
   "Eq.ndrec",
   "Mathlib.Data.List.Pairwise._auxLemma.9",
   "of_eq_true",
   "propext",
   "List",
   "Eq.mp",
   "congr",
   "List.pmap.proof_4",
   "congrArg",
   "Std.Logic._auxLemma.44"],
  "name": "List.pairwise_pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → α → Prop} {p : β → Prop} {f : (b : β) → p b → α} {l : List β}\n  (h : ∀ x ∈ l, p x),\n  List.Pairwise R (List.pmap f l h) ↔ List.Pairwise (fun b₁ b₂ => ∀ (h₁ : p b₁) (h₂ : p b₂), R (f b₁ h₁) (f b₂ h₂)) l",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.finRange.proof_1",
   "List.pmap",
   "List.mem_range",
   "List.instMembershipList",
   "Fin.val",
   "List.mem_pmap",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "Nat",
   "Eq.symm",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "Fin.casesOn",
   "List.range"],
  "name": "List.mem_finRange",
  "constType": "∀ {n : ℕ} (a : Fin n), a ∈ List.finRange n",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Quotient", "Quotient.mk"],
  "name": "Quotient.mk'",
  "constType": "{α : Sort u} → [s : Setoid α] → α → Quotient s",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_7",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Finset.cons_eq_insert",
   "Std.Logic._auxLemma.2",
   "instDecidableEq",
   "Eq.refl",
   "Multiset.instSingletonMultiset",
   "And.left",
   "Insert.insert",
   "iff_false",
   "True",
   "Multiset.instMembershipMultiset",
   "Mathlib.Data.Multiset.Nodup._auxLemma.4",
   "Eq",
   "And.right",
   "Iff.mp",
   "Iff",
   "Multiset",
   "Finset",
   "Multiset.cons",
   "Finset.cons",
   "or_false",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "Multiset.nodup_cons",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "False",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "or_true",
   "Classical.cases",
   "Multiset.instInsertMultiset",
   "iff_true",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "Singleton.singleton",
   "Not",
   "not_true_eq_false",
   "Finset.mk",
   "congrArg",
   "Mathlib.Data.Finset.Basic._auxLemma.3",
   "Prop.linearOrder",
   "Mathlib.Data.Multiset.Basic._auxLemma.14",
   "and_self",
   "Mathlib.Data.Multiset.Nodup._auxLemma.3"],
  "name": "Prop.fintype.proof_2",
  "constType":
  "∀ (a : Prop), a ∈ { val := {True, False}, nodup := (_ : Multiset.Nodup (True ::ₘ {False})) }",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (α → Sort u_3)} → (coe : F → (a : α) → β a) → Function.Injective coe → FunLike F α β",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "rfl",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "Bool.true",
   "Eq.rec",
   "PUnit",
   "Nat.eq_of_beq_eq_true.match_1",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ"],
  "name": "Nat.eq_of_beq_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = true → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons", "List", "Unit", "Unit.unit", "List.casesOn", "List.nil"],
  "name": "List.length.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → Sort u_2) →\n    (x : List α) → (Unit → motive []) → ((head : α) → (as : List α) → motive (head :: as)) → motive x",
  "constCategory": "Definition"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.Le.proof_1",
   "Quotient.liftOn₂",
   "List",
   "List.Subperm",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Le",
  "constType": "{α : Type u_1} → Multiset α → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["False", "Not", "id"],
  "name": "not_false",
  "constType": "¬False",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Equiv.ulift", "Fintype.ofEquiv", "ULift", "Equiv.symm"],
  "name": "ULift.fintype",
  "constType":
  "(α : Type u_4) → [inst : Fintype α] → Fintype (ULift.{u_5, u_4} α)",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "False",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.ne_of_beq_eq_false.match_1",
   "Nat.zero",
   "Bool.false",
   "Nat.noConfusion",
   "PUnit",
   "Not",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = false → ¬n = m",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "EquivLike.toEmbeddingLike.proof_1",
   "EmbeddingLike.mk",
   "FunLike.mk",
   "EmbeddingLike",
   "EquivLike.toEmbeddingLike.proof_2"],
  "name": "EquivLike.toEmbeddingLike",
  "constType":
  "{E : Sort u_1} → {α : Sort u_3} → {β : Sort u_4} → [iE : EquivLike E α β] → EmbeddingLike E α β",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "compl_le_compl",
   "compl_compl",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Iff.intro",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Iff",
   "Eq.mp",
   "congr",
   "GeneralizedHeytingAlgebra.toLattice",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "congrArg",
   "HeytingAlgebra.toHasCompl"],
  "name": "compl_le_compl_iff_le",
  "constType":
  "∀ {α : Type u} {x y : α} [inst : BooleanAlgebra α], yᶜ ≤ xᶜ ↔ x ≤ y",
  "constCategory": "Theorem"},
 {"references": ["Quot", "Quot.mk"],
  "name": "Quot.ind",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop}, (∀ (a : α), β (Quot.mk r a)) → ∀ (q : Quot r), β q",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Function.RightInverse", "Function.Surjective", "Exists.intro", "Eq"],
  "name": "Function.RightInverse.surjective",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α}, Function.RightInverse g f → Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EquivLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Fin.fintype", "Fintype.card", "Nat", "List.length_finRange", "Fin", "Eq"],
  "name": "Fintype.card_fin",
  "constType": "∀ (n : ℕ), Fintype.card (Fin n) = n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteSemilatticeInf",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "eq_of_heq",
   "Unit",
   "Unit.unit",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Eq.to_iff.match_1",
  "constType":
  "∀ {a : Prop} (motive : (b : Prop) → a = b → Prop) (b : Prop) (x : a = b), (Unit → motive a (_ : a = a)) → motive b x",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references": ["False", "IsEmpty"],
  "name": "IsEmpty.false",
  "constType": "∀ {α : Sort u_4} [self : IsEmpty α], α → False",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOn₂",
  "constType":
  "∀ {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Prop}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂), (∀ (a : α) (b : β), motive ⟦a⟧ ⟦b⟧) → motive q₁ q₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Set", "Decidable", "ite", "Set.instMembershipSet"],
  "name": "Set.piecewise",
  "constType":
  "{α : Type u} →\n  {β : α → Sort v} →\n    (s : Set α) → ((i : α) → β i) → ((i : α) → β i) → [inst : (j : α) → Decidable (j ∈ s)] → (i : α) → β i",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.mem_singleton",
   "Membership.mem",
   "propext",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.14",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Or",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ndinsert",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "List.mem_insert_iff",
   "Eq"],
  "name": "Multiset.mem_ndinsert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {s : Multiset α}, a ∈ Multiset.ndinsert b s ↔ a = b ∨ a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "∀ (n : ℕ), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references": ["Equiv"],
  "name": "Equiv.invFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{α : Type u_1} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Iff",
   "Function.Surjective",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Eq"],
  "name": "Set.range_iff_surjective",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α}, Set.range f = Set.univ ↔ Function.Surjective f",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references": [],
  "name": "HasSubset",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Exists",
   "Exists.choose_spec",
   "Classical.propDecidable",
   "dif_pos",
   "dite",
   "Classical.arbitrary",
   "Nonempty",
   "True",
   "Eq",
   "of_eq_true",
   "Exists.choose",
   "Decidable",
   "Not",
   "congrArg",
   "Eq.trans",
   "Function.invFun",
   "congrFun"],
  "name": "Function.invFun_eq",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} [inst : Nonempty α] {f : α → β} {b : β}, (∃ a, f a = b) → f (Function.invFun f b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toSup : Sup α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ a ⊔ b) →\n        (∀ (a b : α), b ≤ a ⊔ b) → (∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Inf.mk",
   "And.right",
   "Or",
   "DistribLattice",
   "Or.inl",
   "Prop.distribLattice.proof_3",
   "Or.inr",
   "Prop.distribLattice.proof_1",
   "DistribLattice.mk",
   "Prop.distribLattice.proof_2",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Prop.partialOrder",
   "And.left",
   "Sup.mk"],
  "name": "Prop.distribLattice",
  "constType": "DistribLattice Prop",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "Function.Injective", "FunLike.coe"],
  "name": "FunLike.coe_injective'",
  "constType":
  "∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\n  Function.Injective FunLike.coe",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Nat",
   "instLTNat",
   "Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero",
  "constType": "∀ (n : ℕ), ¬n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → ZeroHom M N",
  "constCategory": "Definition"},
 {"references": ["Quot", "Eq"],
  "name": "Quot.lift",
  "constType":
  "{α : Sort u} → {r : α → α → Prop} → {β : Sort v} → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → Quot r → β",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "Quotient.liftOn₂",
   "Iff.rfl",
   "Cardinal.instLECardinal.proof_1",
   "Function.Embedding.trans",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Nonempty",
   "Quotient.sound",
   "Eq",
   "Nonempty.casesOn",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "Setoid.r",
   "And",
   "Nonempty.intro",
   "Function.Embedding.antisymm",
   "LT.lt",
   "Function.Embedding.refl",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Not",
   "Cardinal.isEquivalent",
   "Quot.mk"],
  "name": "Cardinal.partialOrder.proof_4",
  "constType": "∀ (a b : Cardinal.{u_1}), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset"],
  "name": "Fintype.elems",
  "constType": "{α : Type u_4} → [self : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_9",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.nil"],
  "name": "List.rec",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    motive [] → ((head : α) → (tail : List α) → motive tail → motive (head :: tail)) → (t : List α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.instOneCardinal",
   "Equiv.equivOfUnique",
   "OfNat.ofNat",
   "Equiv.cardinal_eq",
   "Cardinal",
   "One.toOfNat1",
   "instOfNatNat",
   "Fin.uniqueFinOne",
   "Cardinal.mk",
   "Nat",
   "Fin",
   "ULift",
   "Eq",
   "ULift.instUniqueULift",
   "Unique"],
  "name": "Cardinal.mk_eq_one",
  "constType": "∀ (α : Type u) [inst : Unique α], Cardinal.mk α = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.mk",
  "constType": "{α : Type u} → (α → α → α) → Union α",
  "constCategory": "Other"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Setoid.refl",
   "Quotient.ind",
   "Quotient.lift",
   "Quotient",
   "HasEquiv.Equiv",
   "Eq"],
  "name": "Quotient.lift₂.proof_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ)\n  (c : ∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) (q₂ : Quotient s₂) (a b : α),\n  a ≈ b →\n    (fun a₁ => Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) a =\n      (fun a₁ => Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "∀ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["And", "Or", "or_and_left", "Iff.mpr"],
  "name": "Prop.distribLattice.proof_3",
  "constType": "∀ (x x_1 x_2 : Prop), (x ∨ x_1) ∧ (x ∨ x_2) → x ∨ x_1 ∧ x_2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Prop.distribLattice",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "Classical.propDecidable",
   "SemilatticeInf.toPartialOrder",
   "instDecidableIff",
   "Prop.le_isTotal",
   "LE.le",
   "Preorder.toLE",
   "instDecidableEqProp"],
  "name": "Prop.linearOrder",
  "constType": "LinearOrder Prop",
  "constCategory": "Definition"},
 {"references": ["Quot", "Relator.LiftFun", "Quot.mk", "Eq", "Quot.sound"],
  "name": "Quot.map.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {ra : α → α → Prop} {rb : β → β → Prop} (f : α → β),\n  (ra ⇒ rb) f f → ∀ (x y : α), ra x y → Quot.mk rb (f x) = Quot.mk rb (f y)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toLinearOrder.proof_4",
   "Lattice.toLinearOrder.proof_2",
   "Min.mk",
   "Lattice.toLinearOrder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "IsTotal",
   "LinearOrder.mk",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Lattice.toLinearOrder.proof_3",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder",
  "constType":
  "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Cardinal.instAddCardinal",
   "instHAdd",
   "HAdd.hAdd",
   "Cardinal",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Eq",
   "Add.mk"],
  "name": "Cardinal.commSemiring.proof_4",
  "constType": "∀ (x : Cardinal.{u_1}), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Multiset.map.proof_1",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.map",
   "Multiset.ofList"],
  "name": "Multiset.map",
  "constType":
  "{α : Type u_1} → {β : Type v} → (α → β) → Multiset α → Multiset β",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references": ["trivial", "Equivalence.mk", "Equivalence", "True"],
  "name": "true_equivalence",
  "constType": "∀ {α : Sort u_1}, Equivalence fun x x => True",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "instLENat", "Fin.val", "LE", "Nat", "LE.le", "Fin"],
  "name": "instLEFin",
  "constType": "{n : ℕ} → LE (Fin n)",
  "constCategory": "Definition"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Function.RightInverse",
   "Function.Surjective",
   "Function.surjInv",
   "Function.surjInv_eq"],
  "name": "Function.rightInverse_surjInv",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (hf : Function.Surjective f), Function.RightInverse (Function.surjInv hf) f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Equiv",
   "Sum.map_id_id",
   "Sum.map_map",
   "Function.comp",
   "FunLike.coe",
   "True",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "of_eq_true",
   "Equiv.symm_comp_self",
   "Sum.map",
   "congr",
   "Sum",
   "congrArg",
   "Eq.trans",
   "Equiv.symm",
   "id",
   "congrFun"],
  "name": "Equiv.sumCongr.proof_1",
  "constType":
  "∀ {α₁ : Type u_1} {α₂ : Type u_3} {β₁ : Type u_2} {β₂ : Type u_4} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) (x : α₁ ⊕ β₁),\n  Sum.map (⇑ea.symm) (⇑eb.symm) (Sum.map (⇑ea) (⇑eb) x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "instHasEquiv",
   "HasEquiv.Equiv",
   "Cardinal.isEquivalent",
   "Nonempty.casesOn"],
  "name": "Cardinal.map.match_1",
  "constType":
  "∀ (α β : Type u_1) (motive : α ≈ β → Prop) (x : α ≈ β), (∀ (e : α ≃ β), motive (_ : Nonempty (α ≃ β))) → motive x",
  "constCategory": "Definition"},
 {"references": ["Cardinal", "Cardinal.isEquivalent", "Quotient.mk'"],
  "name": "Cardinal.mk",
  "constType": "Type u → Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_8",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "Set.mem_compl_iff",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.80",
  "constType": "∀ {α : Type u} (s : Set α) (x : α), (x ∈ sᶜ) = (x ∉ s)",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "Nonempty.intro",
   "Setoid.r",
   "Function.Embedding.refl",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Cardinal.isEquivalent",
   "LE.le",
   "Cardinal.instLECardinal"],
  "name": "Cardinal.partialOrder.proof_1",
  "constType": "∀ (a : Cardinal.{u_1}), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "nsmulRec",
   "Quot.inductionOn",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "List.append_assoc",
   "Nat",
   "List.perm_append_comm",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Multiset.instZeroMultiset",
   "Multiset.instAddMultiset",
   "AddMonoid.mk",
   "instHAppend",
   "Setoid.r",
   "List.instAppendList",
   "HAppend.hAppend",
   "List",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "List.append_nil",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
  "constType": "∀ {α : Type u_1} (s t : Multiset α), s + t = t + s",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.pow",
  "constType": "{α : Type u} → [self : NatPow α] → α → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.mk"],
  "name": "Quotient.mk",
  "constType": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "∀ (n : ℕ), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Sum.rec", "Sum", "Sum.inr", "Sum.inl"],
  "name": "Sum.recOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {motive : α ⊕ β → Sort u_1} →\n      (t : α ⊕ β) → ((val : α) → motive (Sum.inl val)) → ((val : β) → motive (Sum.inr val)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Preorder"],
  "name": "OrderHom",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : Preorder α] → [inst : Preorder β] → Type (max u_6 u_7)",
  "constCategory": "Other"},
 {"references": ["Setoid", "Equivalence"],
  "name": "Setoid.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → Equivalence r → Setoid α",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{α : Type u} → [self : Inf α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Sum.elim",
   "Sum.casesOn",
   "Function.comp",
   "Eq.refl",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "Eq"],
  "name": "Equiv.sumAssoc.proof_1",
  "constType":
  "∀ (α : Type u_2) (β : Type u_1) (γ : Type u_3) (x : (α ⊕ β) ⊕ γ),\n  Sum.elim (Sum.inl ∘ Sum.inl) (Sum.elim (Sum.inl ∘ Sum.inr) Sum.inr)\n      (Sum.elim (Sum.elim Sum.inl (Sum.inr ∘ Sum.inl)) (Sum.inr ∘ Sum.inr) x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero.succ",
   "NeZero",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat"],
  "name": "Fin.uniqueFinOne.proof_1",
  "constType": "NeZero (0 + 1)",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references": ["Sum.casesOn", "Sum"],
  "name": "Sum.elim",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {γ : Sort u_3} → (α → γ) → (β → γ) → α ⊕ β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((x : ℕ) → motive x 0) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "id", "Eq"],
  "name": "Function.injective_id",
  "constType": "∀ {α : Sort u₁}, Function.Injective id",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r", "Setoid", "Quotient", "Quot.inductionOn", "Quotient.mk"],
  "name": "Quotient.inductionOn",
  "constType":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s), (∀ (a : α), motive ⟦a⟧) → motive q",
  "constCategory": "Theorem"},
 {"references":
  ["Set.ext",
   "Membership.mem",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ext_iff",
  "constType": "∀ {α : Type u} {s t : Set α}, s = t ↔ ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "Finset.cons",
   "Finset.val",
   "instOfNatNat",
   "Finset.instMembershipFinset",
   "Not",
   "Multiset.card_cons",
   "Nat",
   "Eq"],
  "name": "Finset.card_cons",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a : α} (h : a ∉ s), Finset.card (Finset.cons a s h) = Finset.card s + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "∀ {α : Type u_1} (a : α), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["instHasEquiv", "Setoid", "Quotient", "HasEquiv.Equiv", "Quot.lift", "Eq"],
  "name": "Quotient.lift",
  "constType":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Sum.elim",
   "Sum.casesOn",
   "Function.comp",
   "Eq.refl",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "Eq"],
  "name": "Equiv.sumAssoc.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_3) (γ : Type u_2) (x : α ⊕ β ⊕ γ),\n  Sum.elim (Sum.elim Sum.inl (Sum.inr ∘ Sum.inl)) (Sum.inr ∘ Sum.inr)\n      (Sum.elim (Sum.inl ∘ Sum.inl) (Sum.elim (Sum.inl ∘ Sum.inr) Sum.inr) x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero.succ",
   "OfNat.ofNat",
   "instOfNatNat",
   "Fin.subsingleton_one",
   "Nat",
   "Fin.inhabited",
   "Inhabited.default",
   "Fin",
   "Eq",
   "Subsingleton.elim"],
  "name": "Fin.uniqueFinOne.proof_2",
  "constType": "∀ (x : Fin 1), x = default",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "setOf", "Set", "Not", "Exists.intro", "Exists.casesOn", "Eq"],
  "name": "Function.cantor_surjective.match_1",
  "constType":
  "∀ {α : Type u_1} (f : α → Set α) (motive : (∃ a, f a = {a | ¬f a a}) → Prop) (x : ∃ a, f a = {a | ¬f a a}),\n  (∀ (D : α) (e : f D = {a | ¬f a a}), motive (_ : ∃ a, f a = {a | ¬f a a})) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "And",
   "Pi.preorder.proof_2",
   "Pi.preorder.proof_1",
   "inferInstanceAs",
   "LE",
   "Not",
   "Pi.preorder.proof_3",
   "LT.mk",
   "Pi.hasLe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Pi.preorder",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → Preorder (α i)] → Preorder ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Trans.trans",
   "Equiv.instTransSortSortSortEquivEquivEquiv",
   "PUnit",
   "Prod",
   "Equiv.prodPUnit",
   "Equiv.prodComm"],
  "name": "Equiv.punitProd",
  "constType": "(α : Type u_1) → PUnit.{u_2 + 1} × α ≃ α",
  "constCategory": "Definition"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references":
  ["instHAppend",
   "Exists",
   "List.instAppendList",
   "List.Perm",
   "HAppend.hAppend",
   "List",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "Multiset.le_iff_exists_add.match_1",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (motive : (∃ l, List.Perm l₂ (l₁ ++ l)) → Prop) (x : ∃ l, List.Perm l₂ (l₁ ++ l)),\n  (∀ (l : List α) (p : List.Perm l₂ (l₁ ++ l)), motive (_ : ∃ l, List.Perm l₂ (l₁ ++ l))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.Perm.length_eq",
   "OfNat.ofNat",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Eq",
   "Quot.liftOn",
   "Zero.toOfNat0",
   "Setoid.r",
   "AddZeroClass.toZero",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card.proof_1",
  "constType":
  "∀ {α : Type u_1},\n  (fun s => Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n      0 =\n    (fun s =>\n        Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n      0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "PUnit.unit",
   "Prod.mk",
   "PUnit",
   "Equiv.mk",
   "Equiv.prodPUnit.proof_2",
   "Prod",
   "Prod.fst",
   "Equiv.prodPUnit.proof_1"],
  "name": "Equiv.prodPUnit",
  "constType": "(α : Type u_1) → α × PUnit.{u_2 + 1} ≃ α",
  "constCategory": "Definition"},
 {"references": ["Multiset.Mem", "Multiset", "Membership.mk", "Membership"],
  "name": "Multiset.instMembershipMultiset",
  "constType": "{α : Type u_1} → Membership α (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.72",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Quotient.inductionOn₂",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "List.isSetoid",
   "Eq.refl",
   "nsmulRec",
   "AddCommMonoid.toAddMonoid",
   "Quot.inductionOn",
   "rfl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Multiset",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.append_assoc",
   "List.perm_append_comm",
   "OrderedAddCommMonoid.toPartialOrder",
   "Add.mk",
   "congr_arg",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "OrderedAddCommMonoid.mk",
   "LE.le",
   "Multiset.instAddMultiset",
   "add_le_add_left",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "instHAppend",
   "Setoid.r",
   "le_of_add_le_add_left",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Zero.mk",
   "Quotient.inductionOn₃",
   "Quotient.inductionOn",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "List.append_nil",
   "Quot.sound",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Quot.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ s₃ : Multiset α), s₁ + s₂ ≤ s₁ + s₃ → s₂ ≤ s₃",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Classical.arbitrary",
  "constType": "(α : Sort u_2) → [h : Nonempty α] → α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "∀ {α : Type u_1} (x : Set α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": ["IsEmpty", "isEmptyElim", "Eq"],
  "name": "Equiv.equivOfIsEmpty.proof_2",
  "constType":
  "∀ (α : Sort u_2) (β : Sort u_1) [inst : IsEmpty α] [inst_1 : IsEmpty β] (a : β),\n  (fun a => isEmptyElim a) ((fun a => isEmptyElim a) a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.equivOfIsEmpty.proof_1",
   "Equiv.mk",
   "Equiv.equivOfIsEmpty.proof_2",
   "IsEmpty",
   "isEmptyElim"],
  "name": "Equiv.equivOfIsEmpty",
  "constType":
  "(α : Sort u_1) → (β : Sort u_2) → [inst : IsEmpty α] → [inst : IsEmpty β] → α ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.insert",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ndinsert.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.ndinsert",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff"],
  "name": "Iff.refl",
  "constType": "∀ (a : Prop), a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Function.Bijective",
   "Function.Surjective",
   "Fintype.ofBijective.match_1",
   "Finset.instMembershipFinset",
   "And.left",
   "Eq",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "And.right",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "Finset",
   "Finset.mem_univ",
   "Finset.mem_map_of_mem"],
  "name": "Fintype.ofBijective.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Fintype α] (f : α → β) (H : Function.Bijective f) (b : β),\n  b ∈ Finset.map { toFun := f, inj' := (_ : Function.Injective f) } Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Sum.elim",
   "Prod.snd",
   "Prod.casesOn",
   "Sum.casesOn",
   "Prod.mk",
   "Prod.map",
   "Sum.map",
   "Eq.refl",
   "Prod",
   "Sum",
   "Prod.fst",
   "Sum.inr",
   "Sum.inl",
   "id",
   "Eq"],
  "name": "Equiv.sumProdDistrib.proof_2",
  "constType":
  "∀ (α : Type u_2) (β : Type u_3) (γ : Type u_1) (x : α × γ ⊕ β × γ),\n  (fun p => Sum.map (fun x => (x, p.2)) (fun x => (x, p.2)) p.1)\n      ((fun s => Sum.elim (Prod.map Sum.inl id) (Prod.map Sum.inr id) s) x) =\n    x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "EmbeddingLike"],
  "name": "EmbeddingLike.toFunLike",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EmbeddingLike F α β] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "AddCommMonoid.toAddMonoid",
   "Cardinal.mk_eq_zero",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "Prod.isEmpty_right",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Cardinal.instAddCardinal",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Equiv.sumAssoc",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_10",
  "constType": "∀ (a : Cardinal.{u_1}), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "List.range'",
   "of_eq_true",
   "List",
   "instOfNatNat",
   "List.length_range'",
   "List.range_eq_range'",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "List.range",
   "Eq"],
  "name": "List.length_range",
  "constType": "∀ (n : ℕ), List.length (List.range n) = n",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references": ["Option.elim.match_1", "Option"],
  "name": "Option.elim",
  "constType": "{α : Type u_1} → {β : Sort u_2} → Option α → β → (α → β) → β",
  "constCategory": "Definition"},
 {"references": ["Monotone", "OrderHom", "OrderHom.toFun", "Preorder"],
  "name": "OrderHom.monotone'",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β), Monotone self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["Fin.veq_of_eq.match_1",
   "Fin.val",
   "LT.lt",
   "Nat",
   "rfl",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Fin.veq_of_eq",
  "constType": "∀ {n : ℕ} {i j : Fin n}, i = j → ↑i = ↑j",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {b c : α}, b ≤ c → ∀ (a : α), a + b ≤ a + c",
  "constCategory": "Theorem"},
 {"references": ["NatPow.pow", "NatPow", "Pow.mk", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "{α : Type u_1} → [inst : NatPow α] → Pow α ℕ",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "PartialOrder.le_antisymm",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_4",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → (α → β) → Singleton α β",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Function.RightInverse", "Function.comp", "Function.LeftInverse.comp"],
  "name": "Function.RightInverse.comp",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.RightInverse f g → Function.RightInverse h i → Function.RightInverse (h ∘ f) (g ∘ i)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["NatPow", "Nat.pow", "Nat", "NatPow.mk"],
  "name": "instNatPowNat",
  "constType": "NatPow ℕ",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : ℕ) → List (Fin n)",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "And.right",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "Function.surjInv",
   "And.left",
   "Function.rightInverse_of_injective_of_leftInverse",
   "Function.rightInverse_surjInv"],
  "name": "Function.leftInverse_surjInv",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (hf : Function.Bijective f),\n  Function.LeftInverse (Function.surjInv (_ : Function.Surjective f)) f",
  "constCategory": "Theorem"},
 {"references": ["Trunc.mk", "Function.comp", "Trunc.bind", "Trunc"],
  "name": "Trunc.map",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α → β) → Trunc α → Trunc β",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.sumProdDistrib.proof_2",
   "Sum.elim",
   "Prod.snd",
   "Prod.mk",
   "Prod.map",
   "Sum.map",
   "Equiv.sumProdDistrib.proof_1",
   "Equiv.mk",
   "Sum",
   "Prod",
   "Prod.fst",
   "Sum.inr",
   "Sum.inl",
   "id"],
  "name": "Equiv.sumProdDistrib",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β) × γ ≃ α × γ ⊕ β × γ",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Injective",
   "EmbeddingLike.injective",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Function.Embedding.injective",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α ↪ β), Function.Injective ⇑f",
  "constCategory": "Theorem"},
 {"references": ["Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.mk",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (toFun : α → β) → Function.Injective toFun → α ↪ β",
  "constCategory": "Other"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Function.comp",
   "Set",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.image_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : β → γ) (g : α → β) (a : Set α), f ∘ g '' a = f '' (g '' a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "List.cons",
   "OfNat.ofNat",
   "List.pmap",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "List.length",
   "True",
   "Eq",
   "List.rec",
   "of_eq_true",
   "List",
   "instOfNatNat",
   "List.nil",
   "List.pmap.proof_4",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.length_pmap",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} {f : (a : α) → p a → β} {l : List α} {H : ∀ a ∈ l, p a},\n  List.length (List.pmap f l H) = List.length l",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "List.finRange.proof_1",
   "List.Nodup",
   "LT.lt",
   "List.finRange",
   "List.Pairwise.pmap",
   "Fin.ne_of_vne",
   "List.nodup_range",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.nodup_finRange",
  "constType": "∀ (n : ℕ), List.Nodup (List.finRange n)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_17",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → (toFun : M → N) → toFun 0 = 0 → ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Equivalence.mk",
   "Equiv.refl",
   "Equivalence",
   "Equiv.trans",
   "Nonempty",
   "Equiv.symm",
   "Cardinal.isEquivalent.match_1"],
  "name": "Cardinal.isEquivalent.proof_1",
  "constType": "Equivalence fun α β => Nonempty (α ≃ β)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "List.cons",
   "PUnit.unit",
   "List.rec",
   "List.below",
   "List",
   "PUnit",
   "List.nil",
   "PProd.mk"],
  "name": "List.brecOn",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.toEmbedding",
   "Function.Embedding",
   "Function.Embedding.trans",
   "Equiv.symm"],
  "name": "Function.Embedding.congr",
  "constType":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → {δ : Sort x} → α ≃ β → γ ≃ δ → (α ↪ γ) → β ↪ δ",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Finset.nodup",
   "Function.Embedding.inj'",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Multiset.Nodup.map",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "Finset.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α ↪ β) (s : Finset α), Multiset.Nodup (Multiset.map (⇑f) s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "ZeroHom.mk",
   "Multiset.card.proof_2",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "Quot.liftOn",
   "Multiset.card.proof_1",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card",
  "constType": "{α : Type u_1} → Multiset α →+ ℕ",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "instDecidableEqProd.match_2",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} → (motive : α × β → Sort u_3) → (x : α × β) → ((a' : α) → (b' : β) → motive (a', b')) → motive x",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.mk",
   "DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "OrderBot.mk",
   "BooleanAlgebra.toBot",
   "BooleanAlgebra.bot_le",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toTop",
   "Preorder.toLE",
   "BooleanAlgebra",
   "BoundedOrder"],
  "name": "BooleanAlgebra.toBoundedOrder",
  "constType": "{α : Type u} → [h : BooleanAlgebra α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "instNatPowNat",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal", "Cardinal.mk", "Cardinal.isEquivalent", "Quotient.inductionOn₃"],
  "name": "Cardinal.inductionOn₃",
  "constType":
  "∀ {p : Cardinal.{u_1} → Cardinal.{u_2} → Cardinal.{u_3} → Prop} (c₁ : Cardinal.{u_1}) (c₂ : Cardinal.{u_2})\n  (c₃ : Cardinal.{u_3}),\n  (∀ (α : Type u_1) (β : Type u_2) (γ : Type u_3), p (Cardinal.mk α) (Cardinal.mk β) (Cardinal.mk γ)) → p c₁ c₂ c₃",
  "constCategory": "Theorem"},
 {"references":
  ["Option.some_injective",
   "Function.Embedding.mk",
   "Function.Embedding",
   "Option.some",
   "Option"],
  "name": "Function.Embedding.some",
  "constType": "{α : Type u_1} → α ↪ Option α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Inhabited", "Unique"],
  "name": "Unique.toInhabited",
  "constType": "{α : Sort u} → Unique α → Inhabited α",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "∀ (x x_1 : ℕ), (fun m n => m * n) (x + 1) x_1 = x_1 + (fun m n => m * n) x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instLENat",
   "Bool.true",
   "of_decide_eq_true",
   "Subsingleton",
   "Eq.refl",
   "Fin.subsingleton_iff_le_one",
   "instOfNatNat",
   "Bool",
   "Nat",
   "LE.le",
   "Nat.decLe",
   "Fin",
   "Iff.mpr"],
  "name": "Fin.subsingleton_one",
  "constType": "Subsingleton (Fin 1)",
  "constCategory": "Definition"},
 {"references": ["False", "Classical.cases_on", "True"],
  "name": "Classical.cases",
  "constType": "∀ {p : Prop → Prop}, p True → p False → ∀ (a : Prop), p a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "List.range_loop_range'",
   "Nat.zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.range.loop",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "List.range",
   "id"],
  "name": "List.range_eq_range'",
  "constType": "∀ (n : ℕ), List.range n = List.range' 0 n",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Eq"],
  "name": "Function.Surjective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.RightInverse",
   "EquivLike.coe_injective'",
   "Eq.rec",
   "Function.LeftInverse.eq_rightInverse",
   "EquivLike.right_inv",
   "Eq.symm",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Eq"],
  "name": "EquivLike.toEmbeddingLike.proof_1",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → e = g",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.ndinsert",
   "Finset.mk",
   "Finset.instInsertFinset.proof_1",
   "Insert",
   "Insert.mk"],
  "name": "Finset.instInsertFinset",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Insert α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] →\n        [inst_1 : AddZeroClass N] → [toAddHomClass : AddHomClass F M N] → (∀ (f : F), f 0 = 0) → AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Function.RightInverse",
   "Equiv.invFun",
   "Function.comp",
   "Equiv.right_inv",
   "FunLike.coe",
   "Function.RightInverse.comp",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_2",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.RightInverse (⇑e₁.symm ∘ e₂.invFun) (e₂.toFun ∘ ⇑e₁)",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Equiv.ulift", "Equiv.isEmpty", "IsEmpty", "ULift"],
  "name": "ULift.instIsEmptyULift",
  "constType": "∀ {α : Type u} [inst : IsEmpty α], IsEmpty (ULift.{u_1, u} α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "OfNat.ofNat",
   "Equiv.cardinal_eq",
   "Cardinal",
   "Fin.isEmpty'",
   "Equiv.equivOfIsEmpty",
   "instOfNatNat",
   "Cardinal.mk",
   "Nat",
   "IsEmpty",
   "Fin",
   "ULift",
   "Eq"],
  "name": "Cardinal.mk_eq_zero",
  "constType": "∀ (α : Type u) [inst : IsEmpty α], Cardinal.mk α = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "List.instMembershipList",
   "List",
   "List.casesOn",
   "List.nil"],
  "name": "List.pmap.match_1",
  "constType":
  "{α : Type u_1} →\n  {p : α → Prop} →\n    (motive : (x : List α) → (∀ a ∈ x, p a) → Sort u_2) →\n      (x : List α) →\n        (x_1 : ∀ a ∈ x, p a) →\n          ((x : ∀ a ∈ [], p a) → motive [] x) →\n            ((a : α) → (l : List α) → (H : ∀ a_1 ∈ a :: l, p a_1) → motive (a :: l) H) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Iff", "forall₃_congr", "forall_congr'"],
  "name": "forall₄_congr",
  "constType":
  "∀ {α : Sort u_1} {β : α → Sort u_2} {γ : (a : α) → β a → Sort u_3} {δ : (a : α) → (b : β a) → γ a b → Sort u_4}\n  {p q : (a : α) → (b : β a) → (c : γ a b) → δ a b c → Prop},\n  (∀ (a : α) (b : β a) (c : γ a b) (d : δ a b c), p a b c d ↔ q a b c d) →\n    ((∀ (a : α) (b : β a) (c : γ a b) (d : δ a b c), p a b c d) ↔\n      ∀ (a : α) (b : β a) (c : γ a b) (d : δ a b c), q a b c d)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "ULift.down_up",
   "ULift.up",
   "ULift.down",
   "Equiv.mk",
   "ULift.up_down",
   "ULift"],
  "name": "Equiv.ulift",
  "constType": "{α : Type v} → ULift.{u, v} α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["Function.Embedding.casesOn",
   "Function.Injective",
   "Function.Embedding.mk",
   "Function.Embedding"],
  "name": "Function.Embedding.antisymm.match_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (motive : (α ↪ β) → (β ↪ α) → Prop) (x : α ↪ β) (x_1 : β ↪ α),\n  (∀ (toFun : α → β) (h₁ : Function.Injective toFun) (toFun_1 : β → α) (h₂ : Function.Injective toFun_1),\n      motive { toFun := toFun, inj' := h₁ } { toFun := toFun_1, inj' := h₂ }) →\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["PUnit.unique.proof_1",
   "PUnit.unit",
   "Unique.mk",
   "PUnit",
   "Inhabited.mk",
   "Unique"],
  "name": "PUnit.unique",
  "constType": "Unique PUnit.{u}",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Finset",
   "HasSubset.Subset",
   "Not",
   "HasSSubset",
   "HasSSubset.mk",
   "Finset.instHasSubsetFinset"],
  "name": "Finset.instHasSSubsetFinset",
  "constType": "{α : Type u_1} → HasSSubset (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.punitProd",
   "Equiv.prodCongr",
   "Equiv.refl",
   "Equiv.equivPUnit",
   "PUnit",
   "Prod",
   "Equiv.trans",
   "Unique"],
  "name": "Equiv.uniqueProd",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : Unique β] → β × α ≃ α",
  "constCategory": "Definition"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap.proof_4",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_10",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "funext",
   "Function.comp",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "Eq",
   "id",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.self_comp_symm",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), ⇑e ∘ ⇑e.symm = id",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv.prodCongr", "Cardinal", "Prod", "Mul", "Cardinal.map₂", "Mul.mk"],
  "name": "Cardinal.instMulCardinal",
  "constType": "Mul Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Fintype.ofBijective",
   "Fintype",
   "Equiv.bijective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Fintype.ofEquiv",
  "constType":
  "{β : Type u_2} → (α : Type u_4) → [inst : Fintype α] → α ≃ β → Fintype β",
  "constCategory": "Definition"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "outParam",
   "Function.RightInverse",
   "EquivLike.inv"],
  "name": "EquivLike.right_inv",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e : E),\n  Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references":
  ["eq_true",
   "OfNat.ofNat",
   "List.Nodup",
   "List.range'",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "optParam",
   "instLTNat",
   "True",
   "Eq",
   "List.nodup_range'"],
  "name": "Mathlib.Data.List.Range._auxLemma.2",
  "constType":
  "∀ (s n : ℕ) (step : optParam ℕ 1), autoParam (0 < step) _auto✝ → List.Nodup (List.range' s n step) = True",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Zero M] → [inst : Zero N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Trunc.eq", "Trunc", "Eq"],
  "name": "Trunc.bind.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → Trunc β) (x x_1 : α), f x = f x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Equiv.equivOfUnique", "PUnit", "PUnit.unique", "Unique"],
  "name": "Equiv.equivPUnit",
  "constType": "(α : Sort u) → [inst : Unique α] → α ≃ PUnit.{v}",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "List.instMembershipList",
   "Std.Data.List.Lemmas._auxLemma.112",
   "HAdd.hAdd",
   "List.range_eq_range'",
   "instLTNat",
   "LE.le",
   "True",
   "iff_self",
   "Nat.zero_add",
   "And",
   "Iff",
   "instLENat",
   "of_eq_true",
   "List",
   "LT.lt",
   "congr",
   "instOfNatNat",
   "Std.Data.List.Lemmas._auxLemma.107",
   "Nat",
   "congrArg",
   "Eq.trans",
   "List.range",
   "congrFun"],
  "name": "List.mem_range",
  "constType": "∀ {m n : ℕ}, m ∈ List.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NatPow",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeInf.mk",
  "constType":
  "{α : Type u_9} →\n  [toPartialOrder : PartialOrder α] →\n    [toInfSet : InfSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) → CompleteSemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat"],
  "name": "Mathlib.SetTheory.Cardinal.Basic._auxLemma.7",
  "constType": "∀ {α : Type u_1} [inst : AddMonoidWithOne α], 2 = 1 + 1",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "Sum.map",
   "Sum.recOn",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "rfl",
   "Eq",
   "id"],
  "name": "Sum.map_id_id",
  "constType": "∀ {α : Type u_1} {β : Type u_2}, Sum.map id id = id",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Cardinal.mk_congr",
   "instHPow",
   "Cardinal",
   "Cardinal.instPowCardinal",
   "Equiv.ulift",
   "Cardinal.mk",
   "Equiv.arrowCongr",
   "ULift",
   "Cardinal.lift",
   "Eq",
   "Equiv.symm"],
  "name": "Cardinal.mk_arrow",
  "constType":
  "∀ (α : Type u) (β : Type v),\n  Cardinal.mk (α → β) = Cardinal.lift.{u, v} (Cardinal.mk β) ^ Cardinal.lift.{v, u} (Cardinal.mk α)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{α : Type u_1} → α → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Eq.ndrec",
   "Function.comp",
   "Eq.refl",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.comp",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.LeftInverse f g → Function.LeftInverse h i → Function.LeftInverse (h ∘ f) (g ∘ i)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
   "AddSemigroup.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "OrderedAddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
   "nsmulRec",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
   "Multiset.instAddMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
   "AddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
   "Multiset",
   "OrderedCancelAddCommMonoid.mk",
   "Zero.mk",
   "Add.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset",
  "constType": "{α : Type u_1} → OrderedCancelAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Cardinal.mk_eq_zero",
   "NonUnitalNonAssocSemiring.mk",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "Equiv.prodAssoc",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Equiv.sumProdDistrib",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "ULift.instUniqueULift",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "One.mk",
   "Prod.isEmpty_right",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Prod.isEmpty_left",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Cardinal.instOneCardinal",
   "Equiv.prodSumDistrib",
   "Cardinal.instAddCardinal",
   "Equiv.prodUnique",
   "NonUnitalSemiring.mk",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Fin.uniqueFinOne",
   "Equiv.sumAssoc",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_13",
  "constType": "∀ (a : Cardinal.{u_1}), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "False.elim", "Iff.mp", "False", "Iff", "propext", "Not", "Eq"],
  "name": "iff_false",
  "constType": "∀ (p : Prop), (p ↔ False) = ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : ℕ) → Decidable (n = m)",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Relator.LiftFun",
  "constType":
  "{α : Sort u₁} →\n  {β : Sort u₂} → {γ : Sort v₁} → {δ : Sort v₂} → (α → β → Prop) → (γ → δ → Prop) → (α → γ) → (β → δ) → Prop",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Setoid", "Quot"],
  "name": "Quotient",
  "constType": "{α : Sort u} → Setoid α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_true",
   "Bool.true",
   "of_decide_eq_true",
   "Decidable",
   "Bool",
   "True",
   "Eq"],
  "name": "eq_true_of_decide",
  "constType": "∀ {p : Prop} {x : Decidable p}, decide p = true → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "EmbeddingLike.toFunLike",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Finset.cons_subset_cons",
   "Eq.refl",
   "Option.noConfusion",
   "Preorder.toLE",
   "True",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Option.none",
   "eq_false'",
   "and_false",
   "Finset",
   "Finset.cons",
   "Function.Embedding",
   "Option.some",
   "Finset.map_subset_map",
   "not_false_eq_true",
   "Eq.trans",
   "id",
   "Option",
   "Membership.mem",
   "funext",
   "False",
   "Mathlib.Data.Finset.Image._auxLemma.1",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Finset.partialOrder",
   "FunLike.coe",
   "LE.le",
   "Function.Embedding.some",
   "Finset.map",
   "And",
   "Finset.le_iff_subset",
   "Eq.ndrec",
   "Std.Logic._auxLemma.31",
   "Function.instEmbeddingLikeEmbedding",
   "of_eq_true",
   "propext",
   "Not",
   "Finset.instHasSubsetFinset",
   "congrArg"],
  "name": "Finset.insertNone.proof_2",
  "constType":
  "∀ {α : Type u_1} (s t : Finset α),\n  Finset.cons none (Finset.map Function.Embedding.some s) (_ : none ∉ Finset.map Function.Embedding.some s) ≤\n      Finset.cons none (Finset.map Function.Embedding.some t) (_ : none ∉ Finset.map Function.Embedding.some t) ↔\n    s ≤ t",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Exists.intro",
   "Quot",
   "rfl",
   "Quot.inductionOn",
   "Quot.mk",
   "Eq"],
  "name": "Quot.exists_rep",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (q : Quot r), ∃ a, Quot.mk r a = q",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Iff",
   "Set",
   "Singleton.singleton",
   "Iff.trans",
   "eq_iff_eq_cancel_left",
   "Set.ext_iff",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.singleton_eq_singleton_iff",
  "constType": "∀ {α : Type u} {x y : α}, {x} = {y} ↔ x = y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Fintype",
   "DecidableEq",
   "Fintype.truncEquivFin",
   "Trunc.map",
   "Fintype.truncEquivFinOfCardEq",
   "Trunc.bind",
   "Trunc",
   "Fintype.card",
   "Nat",
   "Equiv.trans",
   "Fin",
   "Equiv.symm",
   "Eq"],
  "name": "Fintype.truncEquivOfCardEq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : Fintype α] →\n      [inst_1 : Fintype β] →\n        [inst_2 : DecidableEq α] → [inst_3 : DecidableEq β] → Fintype.card α = Fintype.card β → Trunc (α ≃ β)",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "RelEmbedding",
   "Eq.refl",
   "RelEmbedding.toEmbedding",
   "FunLike.coe",
   "RelEmbedding.mk",
   "RelEmbedding.casesOn",
   "Eq",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Eq.ndrec",
   "Function.Embedding.toFun",
   "Function.Embedding.casesOn",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "Function.Embedding"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {r : α → α → Prop} {s : β → β → Prop} (f g : r ↪r s),\n  (fun x => x.toFun) f = (fun x => x.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv.sumCongr",
   "Cardinal.instAddCardinal",
   "Cardinal.mk_congr",
   "instHAdd",
   "HAdd.hAdd",
   "Cardinal",
   "Equiv.ulift",
   "Sum",
   "Cardinal.mk",
   "ULift",
   "Cardinal.lift",
   "Eq",
   "Equiv.symm"],
  "name": "Cardinal.mk_sum",
  "constType":
  "∀ (α : Type u) (β : Type v),\n  Cardinal.mk (α ⊕ β) = Cardinal.lift.{v, u} (Cardinal.mk α) + Cardinal.lift.{u, v} (Cardinal.mk β)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp",
   "Function.Injective",
   "Option.some",
   "Option.some_inj",
   "Option",
   "Eq"],
  "name": "Option.some_injective",
  "constType": "∀ (α : Type u_5), Function.Injective some",
  "constCategory": "Theorem"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["Finset", "Finset.val", "Multiset.Nodup"],
  "name": "Finset.nodup",
  "constType": "∀ {α : Type u_4} (self : Finset α), Multiset.Nodup self.val",
  "constCategory": "Definition"},
 {"references":
  ["Prod.mk.eta.match_1", "Prod.mk", "Prod.swap", "Prod", "rfl", "Eq"],
  "name": "Prod.swap_swap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (x : α × β), Prod.swap (Prod.swap x) = x",
  "constCategory": "Theorem"},
 {"references": ["Multiset", "Add", "Multiset.add", "Add.mk"],
  "name": "Multiset.instAddMultiset",
  "constType": "{α : Type u_1} → Add (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Finset.partialOrder.proof_1",
   "HasSSubset.SSubset",
   "Finset.partialOrder.proof_3",
   "Finset",
   "Finset.partialOrder.proof_4",
   "HasSubset.Subset",
   "Finset.partialOrder.proof_2",
   "LT.mk",
   "Finset.instHasSSubsetFinset",
   "Finset.instHasSubsetFinset",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Finset.partialOrder",
  "constType": "{α : Type u_1} → PartialOrder (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.Range._hyg.236",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.9",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] → [inst_1 : Zero N] → [self : ZeroHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Function.LeftInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.inv",
  "constType":
  "{E : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EquivLike E α β] → E → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Eq.refl",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "eq_iff_eq_cancel_left",
  "constType": "∀ {α : Sort u_1} {b c : α}, (∀ {a : α}, a = b ↔ a = c) ↔ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List.Subperm.refl",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le"],
  "name": "Multiset.instPartialOrderMultiset.proof_1",
  "constType": "∀ {α : Type u_1} (a : Multiset α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat"],
  "name": "Nat.le.refl",
  "constType": "∀ {n : ℕ}, Nat.le n n",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{α : Type u_1} → Singleton α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Sum.elim",
   "Sum.casesOn",
   "Eq.refl",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "IsEmpty",
   "isEmptyElim",
   "id",
   "Eq"],
  "name": "Equiv.sumEmpty.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : IsEmpty β] (s : α ⊕ β), Sum.inl (Sum.elim id (fun a => isEmptyElim a) s) = s",
  "constCategory": "Theorem"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "eq_self",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "List.length",
   "True",
   "Eq",
   "Nat.zero_add",
   "instHAppend",
   "List.instAppendList",
   "List.rec",
   "of_eq_true",
   "List",
   "HAppend.hAppend",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Eq.trans"],
  "name": "List.length_append",
  "constType":
  "∀ {α : Type u} (as bs : List α), List.length (as ++ bs) = List.length as + List.length bs",
  "constCategory": "Theorem"},
 {"references": ["ULift.up", "ULift.down", "rfl", "Eq"],
  "name": "ULift.down_up",
  "constType": "∀ {α : Type u} (a : α), { down := a }.down = a",
  "constCategory": "Theorem"},
 {"references": ["Iff.mp", "False", "Iff", "Not", "Iff.mpr"],
  "name": "iff_not_self",
  "constType": "∀ {a : Prop}, ¬(a ↔ ¬a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype.complete",
   "Fintype",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Finset.mem_univ",
  "constType": "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "∀ {α : Type u_1} (x y : Set α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references":
  ["Quotient.map₂",
   "Equiv",
   "Cardinal.map₂.proof_1",
   "Cardinal",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.map₂",
  "constType":
  "(f : Type u → Type v → Type w) →\n  ((α β : Type u) → (γ δ : Type v) → α ≃ β → γ ≃ δ → f α γ ≃ f β δ) → Cardinal.{u} → Cardinal.{v} → Cardinal.{w}",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableEq α] [inst_2 : DecidableRel fun x x_1 => x < x_1] (a b : α),\n  compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Fin"],
  "name": "Fin.val",
  "constType": "{n : ℕ} → Fin n → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Multiset.instAddMultiset",
   "add_le_add_left",
   "Preorder.toLE",
   "Eq",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Eq.mp",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.15",
   "Multiset",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "Multiset.zero_le",
   "congrFun",
   "id",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.le_add_right",
  "constType": "∀ {α : Type u_1} (s t : Multiset α), s ≤ s + t",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "Unit", "Eq.to_iff.match_1", "Eq"],
  "name": "Eq.to_iff",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddMonoidHom.rec",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.casesOn",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {motive : (M →+ N) → Sort u} →\n          (t : M →+ N) →\n            ((toZeroHom : ZeroHom M N) →\n                (map_add' :\n                    ∀ (x y : M),\n                      ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n                  motive { toZeroHom := toZeroHom, map_add' := map_add' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "or_false.match_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ False → Prop) (x : p ∨ False), (∀ (h : p), motive (_ : p ∨ False)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Function.Injective",
   "Set",
   "Set.InjOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.injOn_of_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Lean.Name",
  "constCategory": "Other"},
 {"references": ["False", "IsEmpty.mk", "IsEmpty", "id"],
  "name": "instIsEmptyFalse",
  "constType": "IsEmpty False",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "∀ {α : Type u_1} (x y : Set α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "sInf_le_sInf",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "InfSet.sInf",
   "LE.le.trans",
   "OrderHom",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "CompleteLattice",
   "CompleteSemilatticeInf.toInfSet",
   "OrderHom.toFun",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderHom.instPreorderOrderHom"],
  "name": "OrderHom.lfp.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLattice α] (x x_1 : α →o α), x ≤ x_1 → sInf {a | x a ≤ a} ≤ sInf {a | x_1 a ≤ a}",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.mk", "Prod.swap", "Prod", "Prod.swap_swap"],
  "name": "Equiv.prodComm",
  "constType": "(α : Type u_1) → (β : Type u_2) → α × β ≃ β × α",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.mk",
  "constType": "{α : Type u_3} → (α → α) → HasCompl α",
  "constCategory": "Other"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instHAdd",
   "HAdd.hAdd",
   "PUnit",
   "Nat",
   "Add",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "nsmulRec",
  "constType": "{M : Type u} → [inst : Zero M] → [inst : Add M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.Equiv",
  "constType": "{α : Sort u} → [self : HasEquiv α] → α → α → Sort v",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.rec",
  "constType":
  "{n : ℕ} →\n  {motive : Fin n → Sort u} →\n    ((val : ℕ) → (isLt : val < n) → motive { val := val, isLt := isLt }) → (t : Fin n) → motive t",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Multiset.Le",
   "List.Subperm.trans",
   "Iff.rfl",
   "List.isSetoid",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "Setoid.r",
   "And",
   "List",
   "List.Subperm.refl",
   "LT.lt",
   "Quot.ind",
   "List.Subperm.antisymm",
   "Multiset",
   "Not",
   "Quot.sound",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_4",
  "constType": "∀ {α : Type u_1} (a b : Multiset α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasEquiv",
  "constType": "Sort u → Sort (max u (v + 1))",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.instMulCardinal",
   "HPow.hPow",
   "Cardinal.inductionOn₃",
   "instHMul",
   "Cardinal.instAddCardinal",
   "Cardinal.mk_congr",
   "instHAdd",
   "instHPow",
   "HAdd.hAdd",
   "Equiv.sumArrowEquivProdArrow",
   "Cardinal",
   "HMul.hMul",
   "Cardinal.instPowCardinal",
   "Prod",
   "Sum",
   "Eq"],
  "name": "Cardinal.power_add",
  "constType": "∀ {a b c : Cardinal.{u_1}}, a ^ (b + c) = a ^ b * a ^ c",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Perm",
  "constType": "{α : Type u_1} → List α → List α → Prop",
  "constCategory": "Other"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Pairwise",
  "constType": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "constCategory": "Other"},
 {"references": ["Inhabited", "Inhabited.mk", "Inhabited.default"],
  "name": "instInhabitedForAll_1",
  "constType":
  "(α : Sort u) → {β : α → Sort v} → [inst : (a : α) → Inhabited (β a)] → Inhabited ((a : α) → β a)",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "npowRec.match_1",
  "constType":
  "{M : Type u_2} →\n  (motive : ℕ → M → Sort u_1) →\n    (x : ℕ) → (x_1 : M) → ((x : M) → motive 0 x) → ((n : ℕ) → (a : M) → motive (Nat.succ n) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Function.isEmpty", "Prod", "Prod.fst", "IsEmpty"],
  "name": "Prod.isEmpty_left",
  "constType":
  "∀ {α : Type u_4} {β : Type u_5} [inst : IsEmpty α], IsEmpty (α × β)",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u_1} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Cardinal", "Pow.mk", "Cardinal.map₂", "Pow", "Equiv.arrowCongr"],
  "name": "Cardinal.instPowCardinal",
  "constType": "Pow Cardinal.{u} Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "OfNat.ofNat",
   "HMod.hMod",
   "instOfNatNat",
   "Nat.mod_lt",
   "Nat",
   "instLTNat",
   "Fin",
   "Fin.mk",
   "GT.gt"],
  "name": "Fin.ofNat'",
  "constType": "{n : ℕ} → ℕ → n > 0 → Fin n",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Fin.rec", "Nat", "instLTNat", "Fin.mk", "Fin"],
  "name": "Fin.casesOn",
  "constType":
  "{n : ℕ} →\n  {motive : Fin n → Sort u} →\n    (t : Fin n) → ((val : ℕ) → (isLt : val < n) → motive { val := val, isLt := isLt }) → motive t",
  "constCategory": "Definition"},
 {"references": ["List", "List.range.loop", "List.nil", "Nat"],
  "name": "List.range",
  "constType": "ℕ → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Iff.mp",
   "not_iff_comm",
   "Not",
   "IsEmpty",
   "not_nonempty_iff",
   "Nonempty"],
  "name": "not_isEmpty_iff",
  "constType": "∀ {α : Sort u_1}, ¬IsEmpty α ↔ Nonempty α",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Equiv.piUnique", "Unique"],
  "name": "Equiv.funUnique",
  "constType":
  "(α : Sort u) → (β : Sort u_1) → [inst : Unique α] → (α → β) ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "∀ {α : Type u_1} (x : Set α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Finset.map",
   "Finset.insertNone.proof_1",
   "PartialOrder.toPreorder",
   "Finset.insertNone.proof_2",
   "Option.none",
   "OrderEmbedding.ofMapLEIff",
   "Finset",
   "Finset.cons",
   "Finset.partialOrder",
   "OrderEmbedding",
   "Preorder.toLE",
   "Function.Embedding.some",
   "Option"],
  "name": "Finset.insertNone",
  "constType": "{α : Type u_1} → Finset α ↪o Finset (Option α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.Embedding.mk",
   "Equiv.injective",
   "Function.Embedding",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → α ↪ β",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M →+ N) (x y : M),\n  ZeroHom.toFun (↑self) (x + y) = ZeroHom.toFun (↑self) x + ZeroHom.toFun (↑self) y",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": ["Equiv", "RelIso"],
  "name": "RelIso.toEquiv",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → α ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Equiv",
   "Sum.map_id_id",
   "Sum.map_map",
   "Function.comp",
   "FunLike.coe",
   "True",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "of_eq_true",
   "Sum.map",
   "Equiv.self_comp_symm",
   "congr",
   "Sum",
   "congrArg",
   "Eq.trans",
   "Equiv.symm",
   "id",
   "congrFun"],
  "name": "Equiv.sumCongr.proof_2",
  "constType":
  "∀ {α₁ : Type u_3} {α₂ : Type u_1} {β₁ : Type u_4} {β₂ : Type u_2} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) (x : α₂ ⊕ β₂),\n  Sum.map (⇑ea) (⇑eb) (Sum.map (⇑ea.symm) (⇑eb.symm) x) = x",
  "constCategory": "Theorem"},
 {"references": ["OrderHom", "Monotone", "Preorder"],
  "name": "OrderHom.mk",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (toFun : α → β) → Monotone toFun → α →o β",
  "constCategory": "Other"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Definition"},
 {"references": ["outParam", "RelHomClass", "LE", "LE.le"],
  "name": "OrderHomClass",
  "constType":
  "Type u_6 →\n  (α : outParam (Type u_7)) → (β : outParam (Type u_8)) → [inst : LE α] → [inst : LE β] → Type (max (max u_6 u_7) u_8)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
  "constType": "∀ {α : Type u_1} (x : Multiset α), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_9} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["Sum.elim",
   "PUnit.unit",
   "Eq.ndrec",
   "Option.none",
   "Option.elim",
   "PUnit",
   "Eq.refl",
   "Option.some",
   "Sum",
   "Option.casesOn",
   "Sum.inr",
   "Eq.symm",
   "Sum.inl",
   "Eq",
   "Option"],
  "name": "Equiv.optionEquivSumPUnit.proof_1",
  "constType":
  "∀ (α : Type u_1) (o : Option α),\n  (fun s => Sum.elim some (fun x => none) s) ((fun o => Option.elim o (Sum.inr PUnit.unit) Sum.inl) o) = o",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "And.right",
   "propext",
   "And.intro",
   "True",
   "Eq"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "constCategory": "Other"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_on",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r), (∀ (a : α), β (Quot.mk r a)) → β q",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.beq",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Pi.booleanAlgebra.proof_1",
   "Pi.booleanAlgebra.proof_7",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra.proof_2",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "Preorder.toLE",
   "OrderTop.toTop",
   "BooleanAlgebra.toBiheytingAlgebra",
   "DistribLattice",
   "SDiff.mk",
   "Pi.booleanAlgebra.proof_5",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "Lattice.toSemilatticeSup",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "Pi.booleanAlgebra.proof_3",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "SDiff.sdiff",
   "HeytingAlgebra.toOrderBot",
   "Pi.distribLattice",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Pi.booleanAlgebra.proof_6",
   "OrderBot.toBot",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "BooleanAlgebra.toSDiff",
   "Pi.booleanAlgebra.proof_4"],
  "name": "Pi.booleanAlgebra",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → BooleanAlgebra (α i)] → BooleanAlgebra ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["And.right",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective"],
  "name": "Function.Bijective.surjective",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → Function.Surjective f",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Unique",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "iff_not_self",
   "Exists",
   "congr_arg",
   "False",
   "setOf",
   "Function.Surjective",
   "Function.cantor_surjective.match_1",
   "Set",
   "Not",
   "iff_of_eq",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Function.cantor_surjective",
  "constType": "∀ {α : Type u_1} (f : α → Set α), ¬Function.Surjective f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "add_assoc",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.rec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "congr",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["RelEmbedding.instRelHomClassRelEmbedding.proof_2",
   "Function.Embedding.toFun",
   "RelEmbedding",
   "RelEmbedding.instRelHomClassRelEmbedding.proof_1",
   "RelHomClass",
   "FunLike.mk",
   "RelEmbedding.toEmbedding",
   "RelHomClass.mk"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → RelHomClass (r ↪r s) r s",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.sumEmpty.proof_2",
   "Sum.elim",
   "Equiv.sumEmpty.proof_1",
   "Equiv.mk",
   "Sum",
   "Sum.inl",
   "IsEmpty",
   "isEmptyElim",
   "id"],
  "name": "Equiv.sumEmpty",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → [inst : IsEmpty β] → α ⊕ β ≃ α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references": ["CommMonoid", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toCommMonoid",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → CommMonoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Prop.booleanAlgebra",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_16",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "False",
   "Classical.propDecidable",
   "implies_true",
   "Mathlib.Logic.Basic._auxLemma.2",
   "dite",
   "or_true",
   "Mathlib.Logic.IsEmpty._auxLemma.1",
   "LE.le",
   "True",
   "eq_false",
   "eq_true",
   "Mathlib.Logic.Basic._auxLemma.43",
   "of_eq_true",
   "instIsEmptyFalse",
   "IsTotal",
   "true_or",
   "congr",
   "Not",
   "IsTotal.mk",
   "Prop.le",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Prop.le_isTotal",
  "constType": "IsTotal Prop fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Finset.nodup",
   "DecidableEq",
   "Finset",
   "Multiset.ndinsert",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.ndinsert"],
  "name": "Finset.instInsertFinset.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), Multiset.Nodup (Multiset.ndinsert a s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Sum.elim",
   "Eq.ndrec",
   "Prod.snd",
   "Prod.casesOn",
   "Prod.mk",
   "Function.comp",
   "Eq.refl",
   "Sum",
   "Prod",
   "Prod.fst",
   "Sum.inr",
   "Eq.symm",
   "Sum.inl",
   "Eq"],
  "name": "Equiv.sumArrowEquivProdArrow.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_3) (γ : Type u_2) (p : (α → γ) × (β → γ)),\n  (fun f => (f ∘ Sum.inl, f ∘ Sum.inr)) ((fun p => Sum.elim p.1 p.2) p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "Eq.mpr",
   "Function.RightInverse.comp_eq_id",
   "Eq.ndrec",
   "Trans.trans",
   "Function.RightInverse",
   "Function.comp.right_id",
   "Function.comp",
   "Function.comp.left_id",
   "Function.comp.assoc",
   "Eq.refl",
   "instTransEq",
   "Function.LeftInverse.comp_eq_id",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.eq_rightInverse",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g₁ g₂ : β → α},\n  Function.LeftInverse g₁ f → Function.RightInverse g₂ f → g₁ = g₂",
  "constCategory": "Theorem"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_1} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Classical.choose", "Function.Surjective", "Eq"],
  "name": "Function.surjInv",
  "constType":
  "{α : Sort u} → {β : Sort v} → {f : α → β} → Function.Surjective f → β → α",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["BiheytingAlgebra",
   "OrderTop.mk",
   "BooleanAlgebra.le_top",
   "BooleanAlgebra.toBiheytingAlgebra.proof_2",
   "PartialOrder.toPreorder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra.proof_1",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff",
   "BooleanAlgebra",
   "Preorder.toLE",
   "HNot.mk",
   "DistribLattice.toLattice",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "BooleanAlgebra.toHImp",
   "GeneralizedCoheytingAlgebra",
   "BiheytingAlgebra.mk",
   "HeytingAlgebra.mk",
   "BooleanAlgebra.toSDiff",
   "GeneralizedCoheytingAlgebra.toOrderBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toBiheytingAlgebra.proof_3",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra",
  "constType": "{α : Type u} → [inst : BooleanAlgebra α] → BiheytingAlgebra α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.Perm", "List"],
  "name": "List.Perm.cons",
  "constType":
  "∀ {α : Type u_1} (x : α) {l₁ l₂ : List α}, List.Perm l₁ l₂ → List.Perm (x :: l₁) (x :: l₂)",
  "constCategory": "Other"},
 {"references":
  ["Finset.map",
   "Finset.card",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "FunLike.coe",
   "Nat",
   "Multiset.card_map",
   "Eq"],
  "name": "Finset.card_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} (f : α ↪ β), Finset.card (Finset.map f s) = Finset.card s",
  "constCategory": "Theorem"},
 {"references": ["Decidable"],
  "name": "Decidable.isTrue",
  "constType": "{p : Prop} → p → Decidable p",
  "constCategory": "Other"},
 {"references": ["Multiset", "List.nil", "Multiset.ofList"],
  "name": "Multiset.zero",
  "constType": "{α : Type u_1} → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "instLENat",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "LE.le",
   "True",
   "Eq"],
  "name": "Std.Data.List.Lemmas._auxLemma.112",
  "constType": "∀ (n : ℕ), (0 ≤ n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_zero",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Iff", "propext", "eq_iff_iff", "Eq"],
  "name": "Std.Logic._auxLemma.2",
  "constType": "∀ {p q : Prop}, (p = q) = (p ↔ q)",
  "constCategory": "Theorem"},
 {"references": ["Inhabited", "Inhabited.default", "Unique", "Eq"],
  "name": "Unique.mk",
  "constType":
  "{α : Sort u} → (toInhabited : Inhabited α) → (∀ (a : α), a = default) → Unique α",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.toFun", "ZeroHom", "Eq"],
  "name": "ZeroHom.map_zero'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ZeroHom.toFun self 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Sum",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Sum.elim",
   "Prod.snd",
   "Sum.casesOn",
   "Prod.casesOn",
   "Prod.mk",
   "Sum.map",
   "Prod.map",
   "Eq.refl",
   "Sum",
   "Prod",
   "Prod.fst",
   "Sum.inr",
   "Sum.inl",
   "id",
   "Eq"],
  "name": "Equiv.sumProdDistrib.proof_1",
  "constType":
  "∀ (α : Type u_2) (β : Type u_1) (γ : Type u_3) (x : (α ⊕ β) × γ),\n  (fun s => Sum.elim (Prod.map Sum.inl id) (Prod.map Sum.inr id) s)\n      ((fun p => Sum.map (fun x => (x, p.2)) (fun x => (x, p.2)) p.1) x) =\n    x",
  "constCategory": "Theorem"},
 {"references": ["Sum.elim", "Function.comp", "Sum", "Sum.inr", "Sum.inl"],
  "name": "Sum.map",
  "constType":
  "{α : Type u_1} → {α' : Type u_2} → {β : Type u_3} → {β' : Type u_4} → (α → α') → (β → β') → α ⊕ β → α' ⊕ β'",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.choose"],
  "name": "Exists.choose",
  "constType": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.List.Basic._auxLemma.71",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Quot.liftOn",
   "Setoid.r",
   "List.instMembershipList",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Mem.proof_1"],
  "name": "Multiset.Mem",
  "constType": "{α : Type u_1} → α → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((a : ℕ) → motive a Nat.zero) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "Multiset",
   "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
   "inferInstanceAs",
   "OrderBot.bot_le",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_1",
  "constType": "∀ {α : Type u_1} (a : Multiset α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Equiv",
   "funext",
   "of_eq_true",
   "Function.comp",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.arrowCongr.proof_2",
  "constType":
  "∀ {α₁ : Sort u_4} {β₁ : Sort u_3} {α₂ : Sort u_1} {β₂ : Sort u_2} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) (f : α₂ → β₂),\n  (fun f => ⇑e₂ ∘ f ∘ ⇑e₁.symm) ((fun f => ⇑e₂.symm ∘ f ∘ ⇑e₁) f) = f",
  "constCategory": "Theorem"},
 {"references": ["RelEmbedding", "LE", "LE.le"],
  "name": "OrderEmbedding",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : LE α] → [inst : LE β] → Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "HAdd.hAdd",
   "ULift",
   "Eq",
   "Cardinal.inductionOn₃",
   "Zero.toOfNat0",
   "Cardinal.instZeroCardinal",
   "ULift.instIsEmptyULift",
   "Cardinal.instAddCardinal",
   "Fin.isEmpty'",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Cardinal.inductionOn",
   "Sum",
   "Equiv.sumAssoc",
   "Nat",
   "Fin",
   "Add.mk"],
  "name": "Cardinal.commSemiring.proof_3",
  "constType": "∀ (a : Cardinal.{u_1}), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "List.insert",
   "DecidableEq",
   "List.Perm.insert",
   "List",
   "List.isSetoid",
   "Quot",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.ndinsert.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (x x_1 : List α),\n  Setoid.r x x_1 → Quot.mk Setoid.r (List.insert a x) = Quot.mk Setoid.r (List.insert a x_1)",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Equiv.mk", "Sum.swap", "Sum", "Sum.swap_swap"],
  "name": "Equiv.sumComm",
  "constType": "(α : Type u_1) → (β : Type u_2) → α ⊕ β ≃ β ⊕ α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_6",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Fin.isEmpty", "IsEmpty", "Fin"],
  "name": "Fin.isEmpty'",
  "constType": "IsEmpty (Fin Nat.zero)",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.casesOn",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup", "Finset.univ", "Fintype", "Finset.val", "Multiset.Nodup"],
  "name": "Fintype.truncEquivFin.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Fintype α], Multiset.Nodup Finset.univ.val",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Equiv", "Cardinal.mk_congr", "Cardinal", "Cardinal.mk", "Eq"],
  "name": "Equiv.cardinal_eq",
  "constType": "∀ {α β : Type u}, α ≃ β → Cardinal.mk α = Cardinal.mk β",
  "constCategory": "Theorem"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u_1} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Finset.map",
   "Finset.univ",
   "Fintype.ofBijective.proof_2",
   "Fintype.mk",
   "Fintype",
   "Function.Bijective",
   "Function.Embedding.mk",
   "Fintype.ofBijective.proof_1"],
  "name": "Fintype.ofBijective",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Fintype α] → (f : α → β) → Function.Bijective f → Fintype β",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Equiv",
   "funext",
   "of_eq_true",
   "Function.comp",
   "Equiv.symm_apply_apply",
   "FunLike.coe",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.arrowCongr.proof_1",
  "constType":
  "∀ {α₁ : Sort u_1} {β₁ : Sort u_2} {α₂ : Sort u_4} {β₂ : Sort u_3} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) (f : α₁ → β₁),\n  (fun f => ⇑e₂.symm ∘ f ∘ ⇑e₁) ((fun f => ⇑e₂ ∘ f ∘ ⇑e₁.symm) f) = f",
  "constCategory": "Theorem"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Min.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "inf_eq_minDefault",
   "Lattice.toInf",
   "IsTotal",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Cardinal.instPowCardinal",
   "One.toOfNat1",
   "_private.Mathlib.SetTheory.Cardinal.Basic.0.Cardinal.mul_comm'",
   "Eq",
   "Cardinal.instMulCardinal",
   "instHMul",
   "Cardinal.instOneCardinal",
   "Eq.mpr",
   "Eq.ndrec",
   "Cardinal.instAddCardinal",
   "Nat.cast",
   "Cardinal.instNatCastCardinal",
   "Cardinal.power_add",
   "instHPow",
   "Cardinal",
   "HMul.hMul",
   "instOfNatNat",
   "Cardinal.cast_succ",
   "Nat",
   "Cardinal.power_one",
   "id"],
  "name": "Cardinal.commSemiring.proof_15",
  "constType": "∀ (n : ℕ) (c : Cardinal.{u_1}), c ^ ↑(n + 1) = c * c ^ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Fintype",
   "RelIso.toEquiv",
   "DecidableEq",
   "Fintype.truncEquivFin",
   "Fin.castIso",
   "Trunc.map",
   "Trunc",
   "instLEFin",
   "Fintype.card",
   "Nat",
   "LE.le",
   "Equiv.trans",
   "Fin",
   "Eq"],
  "name": "Fintype.truncEquivFinOfCardEq",
  "constType":
  "{α : Type u_1} → [inst : Fintype α] → [inst_1 : DecidableEq α] → {n : ℕ} → Fintype.card α = n → Trunc (α ≃ Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["compl_compl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "Function.Involutive",
   "BooleanAlgebra"],
  "name": "compl_involutive",
  "constType":
  "∀ {α : Type u} [inst : BooleanAlgebra α], Function.Involutive compl",
  "constCategory": "Theorem"},
 {"references": ["Function.LeftInverse"],
  "name": "Function.RightInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Iff.mp",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "LE.le",
   "Multiset.instAddMultiset",
   "ContravariantClass",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "∀ {α : Type u_1}, ContravariantClass (Multiset α) (Multiset α) (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Injective",
   "EmbeddingLike.injective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe"],
  "name": "EquivLike.injective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Injective ⇑e",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike",
   "Function.LeftInverse",
   "outParam",
   "Function.RightInverse",
   "Eq"],
  "name": "EquivLike.mk",
  "constType":
  "{E : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      (coe : E → α → β) →\n        (inv : E → β → α) →\n          (∀ (e : E), Function.LeftInverse (inv e) (coe e)) →\n            (∀ (e : E), Function.RightInverse (inv e) (coe e)) →\n              (∀ (e g : E), coe e = coe g → inv e = inv g → e = g) → EquivLike E α β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Finset",
   "Multiset",
   "Finset.instMembershipFinset",
   "Multiset.Nodup",
   "Finset.mk",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_mk",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Multiset α} {nd : Multiset.Nodup s}, a ∈ { val := s, nodup := nd } ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{α : Type u_1} → InfSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Membership.mem",
   "Equiv",
   "AddHomClass.toFunLike",
   "List.isSetoid",
   "Multiset.Nodup",
   "AddCommMonoid.toAddMonoid",
   "Trunc.instSubsingletonTrunc",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "instSubsingletonForAll",
   "Multiset.instMembershipMultiset",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Subsingleton",
   "Multiset",
   "Trunc",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "Fin",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Quot.mk"],
  "name": "Fintype.truncEquivFin.proof_1",
  "constType":
  "∀ (α : Type u_1) (a : List α),\n  Subsingleton\n    ((∀ (x : α), x ∈ Quot.mk Setoid.r a) →\n      Multiset.Nodup (Quot.mk Setoid.r a) → Trunc (α ≃ Fin (Multiset.card (Quot.mk Setoid.r a))))",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Multiset.instAddMultiset",
   "Eq",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
  "constType":
  "∀ {α : Type u_1} (n : ℕ) (x : Multiset α), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instZeroCardinal",
  "constType": "Zero Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.range'",
   "Nat.decLt",
   "_auto._@.Mathlib.Data.List.Range._hyg.236",
   "Eq.refl",
   "Mathlib.Data.List.Range._auxLemma.2",
   "eq_true_of_decide",
   "List.range_eq_range'",
   "autoParam",
   "optParam",
   "instDecidableTrue",
   "Lean.Syntax",
   "instLTNat",
   "True",
   "List.Nodup",
   "of_eq_true",
   "List",
   "Bool.true",
   "LT.lt",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "List.range"],
  "name": "List.nodup_range",
  "constType": "∀ (n : ℕ), List.Nodup (List.range n)",
  "constCategory": "Theorem"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{α : Type u_1} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.cons",
   "DecidableEq",
   "List.instMembershipList",
   "List",
   "List.insert.proof_1",
   "List.instDecidableMemListInstMembershipList",
   "instBEq",
   "ite"],
  "name": "List.insert",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → List α",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references": ["Equiv"],
  "name": "Equiv.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → α → β",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.lfp.proof_1",
   "OrderHom.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "setOf",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "InfSet.sInf",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderHom.instPreorderOrderHom",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.lfp",
  "constType": "{α : Type u} → [inst : CompleteLattice α] → (α →o α) →o α",
  "constCategory": "Definition"},
 {"references":
  ["Function.Embedding.mk",
   "Function.Embedding",
   "Function.injective_id",
   "id"],
  "name": "Function.Embedding.refl",
  "constType": "(α : Sort u_1) → α ↪ α",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.commSemiring.proof_14",
   "Semiring.mk",
   "Cardinal.commSemiring.proof_10",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Cardinal.commSemiring.proof_15",
   "nsmulRec",
   "_private.Mathlib.SetTheory.Cardinal.Basic.0.Cardinal.mul_comm'",
   "NatCast.mk",
   "NonUnitalNonAssocSemiring.mk",
   "Zero.toOfNat0",
   "Cardinal.commSemiring.proof_13",
   "Nat.cast",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "Cardinal.commSemiring.proof_2",
   "Cardinal.commSemiring.proof_11",
   "Cardinal.mk",
   "Nat",
   "Cardinal.commSemiring.proof_5",
   "Add.mk",
   "HPow.hPow",
   "AddSemigroup.mk",
   "instHAdd",
   "CommSemiring.mk",
   "One.mk",
   "Cardinal.instPowCardinal",
   "One.toOfNat1",
   "Cardinal.commSemiring.proof_6",
   "Cardinal.power_zero",
   "Cardinal.commSemiring.proof_3",
   "AddMonoid.mk",
   "Cardinal.instZeroCardinal",
   "Cardinal.instMulCardinal",
   "instHMul",
   "Cardinal.commSemiring.proof_12",
   "Cardinal.instOneCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.instAddCardinal",
   "Cardinal.commSemiring.proof_4",
   "NonUnitalSemiring.mk",
   "Cardinal.commSemiring.proof_8",
   "Cardinal",
   "Zero.mk",
   "Cardinal.commSemiring.proof_1",
   "HMul.hMul",
   "Cardinal.commSemiring.proof_9",
   "Cardinal.commSemiring.proof_7",
   "Cardinal.cast_succ",
   "Fin",
   "Cardinal.lift",
   "Mul.mk"],
  "name": "Cardinal.commSemiring",
  "constType": "CommSemiring Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.toFun",
   "Equiv.invFun",
   "Function.comp",
   "Function.LeftInverse.comp",
   "Equiv.left_inv",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.LeftInverse (⇑e₁.symm ∘ e₂.invFun) (e₂.toFun ∘ ⇑e₁)",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff", "Iff.rfl", "Eq.rec", "Not", "Eq"],
  "name": "instDecidableEqProp.proof_1",
  "constType": "∀ {p q : Prop}, ¬(p ↔ q) → p = q → False",
  "constCategory": "Theorem"},
 {"references":
  ["Set.piecewise",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "forall₄_congr",
   "BooleanAlgebra.toHasCompl",
   "Set.InjOn",
   "disjoint_compl_right",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Eq.mpr",
   "Iff",
   "Decidable",
   "Eq.symm",
   "HeytingAlgebra.toHasCompl",
   "id",
   "Membership.mem",
   "Ne",
   "Set.injective_iff_injOn_univ",
   "Union.union",
   "Set.union_compl_self",
   "HasCompl.compl",
   "Set.piecewise_eq_of_mem",
   "Set.univ",
   "Set.EqOn.injOn_iff",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instMembershipSet",
   "Set.piecewise_eqOn",
   "And",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Function.Injective",
   "propext",
   "Set.piecewise_eq_of_not_mem",
   "Set.injOn_union",
   "Not",
   "Set.piecewise_eqOn_compl",
   "and_congr",
   "Set.instUnionSet"],
  "name": "Set.injective_piecewise_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Set α) [inst : (j : α) → Decidable (j ∈ s)] {f g : α → β},\n  Function.Injective (Set.piecewise s f g) ↔ Set.InjOn f s ∧ Set.InjOn g sᶜ ∧ ∀ x ∈ s, ∀ y ∉ s, f x ≠ g y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype",
   "Multiset",
   "Finset.val",
   "Finset.mem_univ",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.mem_univ_val",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ.val",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap.proof_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → p a",
  "constCategory": "Theorem"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["List.nil_sublist",
   "Zero.toOfNat0",
   "Setoid.r",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "List",
   "Multiset.instZeroMultiset",
   "List.isSetoid",
   "Multiset",
   "List.nil",
   "LE.le",
   "Quot.inductionOn",
   "Preorder.toLE",
   "List.Sublist.subperm",
   "Multiset.instPartialOrderMultiset"],
  "name": "Multiset.zero_le",
  "constType": "∀ {α : Type u_1} (s : Multiset α), 0 ≤ s",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Iff.mp",
   "Or.inl",
   "Or.inr",
   "em",
   "Function.comp",
   "Not",
   "IsEmpty",
   "not_isEmpty_iff",
   "Nonempty",
   "Or.elim"],
  "name": "isEmpty_or_nonempty",
  "constType": "∀ (α : Sort u_1), IsEmpty α ∨ Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Exists.choose",
   "Classical.propDecidable",
   "Not",
   "dite",
   "Classical.arbitrary",
   "Nonempty",
   "Eq"],
  "name": "Function.invFun",
  "constType":
  "{α : Sort u} → {β : Sort u_3} → [inst : Nonempty α] → (α → β) → β → α",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Sum.elim",
   "Equiv.optionEquivSumPUnit.proof_1",
   "PUnit.unit",
   "Option.none",
   "Option.elim",
   "PUnit",
   "Equiv.mk",
   "Option.some",
   "Sum",
   "Sum.inr",
   "Equiv.optionEquivSumPUnit.proof_2",
   "Sum.inl",
   "Option"],
  "name": "Equiv.optionEquivSumPUnit",
  "constType": "(α : Type u_1) → Option α ≃ α ⊕ PUnit.{u_2 + 1}",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{α : Type u} → BooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{α : Type u_1} → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.succ_le_succ.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (x : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m x",
  "constCategory": "Definition"},
 {"references": ["propext", "IsEmpty.forall_iff", "IsEmpty", "True", "Eq"],
  "name": "Mathlib.Logic.IsEmpty._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} [inst : IsEmpty α] {p : α → Prop}, (∀ (a : α), p a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "congr_arg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "List.isSetoid",
   "rfl",
   "Quot.inductionOn",
   "Multiset.instAddMultiset",
   "Eq",
   "Zero.toOfNat0",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "Multiset",
   "Zero.mk",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Quot.mk",
   "Add.mk"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
  "constType": "∀ {α : Type u_1} (s : Multiset α), 0 + s = s",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.atom",
  "constType": "Lean.SourceInfo → String → Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["Prod.snd", "Function.isEmpty", "Prod", "IsEmpty"],
  "name": "Prod.isEmpty_right",
  "constType":
  "∀ {α : Type u_4} {β : Type u_5} [inst : IsEmpty β], IsEmpty (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap.proof_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["HasSSubset"],
  "name": "HasSSubset.SSubset",
  "constType": "{α : Type u} → [self : HasSSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrder.mk",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Unique.mk",
   "Inhabited",
   "Unique.mk'.proof_1",
   "Subsingleton",
   "Inhabited.mk",
   "Inhabited.default",
   "Unique"],
  "name": "Unique.mk'",
  "constType":
  "(α : Sort u) → [h₁ : Inhabited α] → [inst : Subsingleton α] → Unique α",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.sumCongr.proof_2",
   "Sum.map",
   "Equiv.mk",
   "Sum",
   "FunLike.coe",
   "Equiv.sumCongr.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.sumCongr",
  "constType":
  "{α₁ : Type u_1} → {α₂ : Type u_2} → {β₁ : Type u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ ⊕ β₁ ≃ α₂ ⊕ β₂",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike.bijective",
   "Function.Bijective",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.bijective",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Bijective ⇑e",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Pairwise",
   "And",
   "List.cons",
   "List.pairwise_cons",
   "List.instMembershipList",
   "propext",
   "List",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) = ((∀ a' ∈ l, R a a') ∧ List.Pairwise R l)",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "congr_arg",
   "HAppend.hAppend",
   "instHAdd",
   "List",
   "HAdd.hAdd",
   "List.isSetoid",
   "Multiset",
   "List.append_assoc",
   "Quotient.inductionOn₃",
   "Multiset.instAddMultiset",
   "Quot.mk",
   "Add.mk",
   "Eq"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
  "constType":
  "∀ {α : Type u_1} (s₁ s₂ s₃ : Multiset α), s₁ + s₂ + s₃ = s₁ + (s₂ + s₃)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.prodAssoc.match_1",
   "Prod.snd",
   "Prod.mk",
   "Prod",
   "Prod.fst",
   "rfl",
   "Eq"],
  "name": "Equiv.prodAssoc.proof_1",
  "constType":
  "∀ (α : Type u_2) (β : Type u_1) (γ : Type u_3) (x : (α × β) × γ),\n  (fun p => ((p.1, p.2.1), p.2.2)) ((fun p => (p.1.1, p.1.2, p.2)) x) = x",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.symm",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "imp_iff_right",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.univ",
   "Set.univ_subset_iff",
   "forall_congr'",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_iff_forall",
  "constType": "∀ {α : Type u} {s : Set α}, s = Set.univ ↔ ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_3",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Bot.bot",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_15",
  "constType": "∀ {α : Type u_1} (a : α → Prop), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Quotient.ind", "Quotient", "Quotient.mk"],
  "name": "Quotient.inductionOn₃",
  "constType":
  "∀ {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid φ}\n  {motive : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃),\n  (∀ (a : α) (b : β) (c : φ), motive ⟦a⟧ ⟦b⟧ ⟦c⟧) → motive q₁ q₂ q₃",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddHomClass.toFunLike",
   "HAdd.hAdd",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Quot.inductionOn",
   "Eq",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Multiset.cons",
   "instOfNatNat",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "Quot.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card_cons",
  "constType":
  "∀ {α : Type u_1} (a : α) (s : Multiset α), Multiset.card (a ::ₘ s) = Multiset.card s + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.instEquivLikeEquiv.proof_1",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "EquivLike.mk"],
  "name": "Equiv.instEquivLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → EquivLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Subsingleton.intro",
   "HAdd.hAdd",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "instLTNat",
   "rfl",
   "True",
   "Fin.subsingleton_iff_le_one.match_3",
   "Subsingleton.elim",
   "Eq",
   "Decidable.decide",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "Fin.subsingleton_iff_le_one.match_1",
   "Subsingleton",
   "instOfNatNat",
   "Nat",
   "Fin.subsingleton_iff_le_one.match_2",
   "Eq.trans",
   "Nat.decLe",
   "Fin.mk",
   "id",
   "instAddNat",
   "of_decide_eq_false",
   "instHAdd",
   "Unit",
   "Init.Data.Nat.Basic._auxLemma.1",
   "LE.le",
   "Fin.zero_lt_one",
   "iff_true",
   "Fin.ne_of_lt",
   "LT.lt",
   "Init.Data.Nat.Basic._auxLemma.2",
   "Bool",
   "iff_of_false",
   "congrArg",
   "Fin"],
  "name": "Fin.subsingleton_iff_le_one",
  "constType": "∀ {n : ℕ}, Subsingleton (Fin n) ↔ n ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Setoid",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Multiset",
   "_private.Mathlib.Data.Multiset.Basic.0.Multiset.add_le_add_iff_left'",
   "CovariantClass.mk",
   "LE.le",
   "Multiset.instAddMultiset",
   "Iff.mpr",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name":
  "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
  "constType":
  "∀ {α : Type u_1}, CovariantClass (Multiset α) (Multiset α) (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Ne", "Fin.veq_of_eq", "False", "Fin.val", "Nat", "absurd", "Fin", "Eq"],
  "name": "Fin.ne_of_vne",
  "constType": "∀ {n : ℕ} {i j : Fin n}, ↑i ≠ ↑j → i ≠ j",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{α : Type u_1} → [toLattice : Lattice α] → (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) → DistribLattice α",
  "constCategory": "Other"},
 {"references": ["ULift"],
  "name": "ULift.up",
  "constType": "{α : Type s} → α → ULift.{r, s} α",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["Iff.symm", "Iff", "iff_iff_eq", "Eq"],
  "name": "eq_iff_iff",
  "constType": "∀ {p q : Prop}, p = q ↔ (p ↔ q)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "Equiv.mk"],
  "name": "Equiv.symm",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_succ",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "LE"],
  "name": "Prop.le",
  "constType": "LE Prop",
  "constCategory": "Definition"},
 {"references":
  ["NeZero.pos",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Nat.canonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "NeZero",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Fin.instOfNatFin.proof_1",
  "constType": "∀ {n : ℕ} [inst : NeZero n], 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.cons",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.cons",
  "constType": "{α : Type u_1} → α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Equiv",
   "AddZeroClass.toAdd",
   "Multiset.card",
   "List.instMembershipList",
   "Finset.mem_univ_val",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Multiset.instMembershipMultiset",
   "Quot.recOnSubsingleton'",
   "Fintype",
   "Nat.addMonoid",
   "Trunc.mk",
   "Fintype.truncEquivFin.proof_2",
   "Multiset",
   "Finset.val",
   "Trunc",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Equiv.symm",
   "id",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "Multiset.Nodup",
   "Fintype.card",
   "FunLike.coe",
   "List.length",
   "Setoid.r",
   "Finset.univ",
   "List.Nodup",
   "DecidableEq",
   "List",
   "Fintype.truncEquivFin.proof_1",
   "AddMonoidHomClass.toAddHomClass",
   "List.Nodup.getEquivOfForallMemList",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "Fin",
   "AddMonoidHom",
   "Quot.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Fintype.truncEquivFin",
  "constType":
  "(α : Type u_4) → [inst : DecidableEq α] → [inst : Fintype α] → Trunc (α ≃ Fin (Fintype.card α))",
  "constCategory": "Definition"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.image_comp",
   "Function.LeftInverse",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.image_id",
   "Function.comp",
   "Set",
   "Eq.refl",
   "Function.LeftInverse.comp_eq_id",
   "Set.image",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Function.LeftInverse.image_image",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {f : α → β} {g : β → α}, Function.LeftInverse g f → ∀ (s : Set α), g '' (f '' s) = s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ULift",
  "constType": "Type s → Type (max s r)",
  "constCategory": "Other"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.inductionOn",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r), (∀ (a : α), motive (Quot.mk r a)) → motive q",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "of_eq_true",
   "List.rec",
   "List",
   "instOfNatNat",
   "List.map",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.length_map",
  "constType":
  "∀ {α : Type u} {β : Type v} (as : List α) (f : α → β), List.length (List.map f as) = List.length as",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective", "Function.Embedding.mk", "Function.Embedding"],
  "name": "Function.Embedding.rec",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : (α ↪ β) → Sort u} →\n      ((toFun : α → β) → (inj' : Function.Injective toFun) → motive { toFun := toFun, inj' := inj' }) →\n        (t : α ↪ β) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Exists", "Function.Bijective", "Exists.intro", "Exists.casesOn"],
  "name": "Function.Embedding.antisymm.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : (∃ h, Function.Bijective h) → Prop) (x : ∃ h, Function.Bijective h),\n  (∀ (f : α → β) (hf : Function.Bijective f), motive (_ : ∃ h, Function.Bijective h)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "String",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "constCategory": "Definition"},
 {"references": ["Quot"],
  "name": "Quot.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → α → Quot r",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Set.piecewise",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "compl_compl",
   "OrderHom",
   "compl_injective",
   "BooleanAlgebra.toHasCompl",
   "Set.injective_piecewise_iff",
   "Exists.casesOn",
   "Function.LeftInverse.image_image",
   "Nonempty",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Empty",
   "Eq.mpr",
   "Function.leftInverse_invFun",
   "Set.image",
   "And.casesOn",
   "Set.compl_subset_compl",
   "Eq.trans",
   "OrderHom.lfp",
   "Equiv.symm",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "Or",
   "Classical.propDecidable",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Or.casesOn",
   "IsEmpty",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "And",
   "Function.Injective.injOn",
   "of_eq_true",
   "Set.range_piecewise",
   "Function.Injective",
   "propext",
   "Eq.mp",
   "congr",
   "Not",
   "And.intro",
   "OrderHom.map_lfp",
   "congrArg",
   "OrderHom.instPreorderOrderHom",
   "Exists",
   "Equiv.equivEmpty",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Set.InjOn",
   "True",
   "Set.range",
   "OrderHom.mk",
   "Function.LeftInverse",
   "Function.isEmpty",
   "Equiv.bijective",
   "Set.image_subset",
   "Eq.symm",
   "Equiv.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "False",
   "Function.Bijective",
   "Or.inr",
   "Function.Surjective",
   "Set.union_compl_self",
   "Union.union",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "Set.univ",
   "LE.le",
   "Equiv.instFunLikeEquiv",
   "Set.range_iff_surjective",
   "Set.instHasSubsetSet",
   "Or.inl",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.instUnionSet",
   "isEmpty_or_nonempty",
   "Function.invFun"],
  "name": "Function.Embedding.schroeder_bernstein",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "congr_arg",
   "Trans.trans",
   "Function.Injective",
   "instTransEq",
   "Eq.symm",
   "Eq"],
  "name": "Function.LeftInverse.injective",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {g : β → α} {f : α → β}, Function.LeftInverse g f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddMonoidHomClass (M →+ N) M N",
  "constCategory": "Definition"},
 {"references": ["Prod.snd", "Prod.mk", "Prod", "Prod.fst"],
  "name": "Prod.swap",
  "constType": "{α : Type u_1} → {β : Type u_2} → α × β → β × α",
  "constCategory": "Definition"},
 {"references": ["List.append", "List", "Append.mk", "Append"],
  "name": "List.instAppendList",
  "constType": "{α : Type u} → Append (List α)",
  "constCategory": "Definition"},
 {"references": ["Array", "List.nil", "Nat", "Array.mk"],
  "name": "Array.mkEmpty",
  "constType": "{α : Type u} → ℕ → Array α",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "EquivLike.toEmbeddingLike",
   "EquivLike.surjective",
   "FunLike.coe",
   "And.intro",
   "EquivLike.injective"],
  "name": "EquivLike.bijective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Bijective ⇑e",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Add M] →\n        [inst_1 : Add N] →\n          [toFunLike : FunLike F M fun x => N] → (∀ (f : F) (x y : M), f (x + y) = f x + f y) → AddHomClass F M N",
  "constCategory": "Other"},
 {"references": ["Setoid"],
  "name": "Setoid.r",
  "constType": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "LinearOrderedCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "LinearOrderedCommMonoid.toCommMonoid",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "HMul.hMul",
   "LinearOrderedCommMonoid.toLinearOrder",
   "LinearOrder.toPartialOrder",
   "CommMonoid.toMonoid"],
  "name": "LinearOrderedCommMonoidWithZero.mk",
  "constType":
  "{α : Type u_1} →\n  [toLinearOrderedCommMonoid : LinearOrderedCommMonoid α] →\n    [toZero : Zero α] → (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → 0 ≤ 1 → LinearOrderedCommMonoidWithZero α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.not_mem_zero",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.7",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Set.EqOn.symm",
   "Iff",
   "Set",
   "Set.EqOn",
   "Set.InjOn.congr",
   "Set.InjOn"],
  "name": "Set.EqOn.injOn_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {f₁ f₂ : α → β}, Set.EqOn f₁ f₂ s → (Set.InjOn f₁ s ↔ Set.InjOn f₂ s)",
  "constCategory": "Theorem"},
 {"references": ["Sum"],
  "name": "Sum.inl",
  "constType": "{α : Type u} → {β : Type v} → α → α ⊕ β",
  "constCategory": "Other"},
 {"references":
  ["instDecidableIff.proof_4",
   "instDecidableIff.proof_2",
   "Iff",
   "Decidable.isFalse",
   "instDecidableIff.proof_1",
   "instDecidableIff.proof_3",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite"],
  "name": "instDecidableIff",
  "constType":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Embedding.mk",
   "Function.comp",
   "Function.Embedding",
   "FunLike.coe",
   "Function.Embedding.trans.proof_1"],
  "name": "Function.Embedding.trans",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α ↪ β) → (β ↪ γ) → α ↪ γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "List.instMembershipList",
   "List",
   "List.attach",
   "True",
   "Subtype",
   "Eq",
   "List.mem_attach"],
  "name": "Mathlib.Data.List.Basic._auxLemma.69",
  "constType":
  "∀ {α : Type u} (l : List α) (x : { x // x ∈ l }), (x ∈ List.attach l) = True",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.Nodup",
   "Iff",
   "List.Perm",
   "List.Perm.pairwise_iff",
   "List",
   "Ne.symm"],
  "name": "List.Perm.nodup_iff",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Perm l₁ l₂ → (List.Nodup l₁ ↔ List.Nodup l₂)",
  "constCategory": "Theorem"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "EmbeddingLike.toFunLike",
   "And",
   "Exists",
   "Function.instEmbeddingLikeEmbedding",
   "propext",
   "Finset",
   "Finset.mem_map",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Eq"],
  "name": "Mathlib.Data.Finset.Image._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} {b : β}, (b ∈ Finset.map f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RelEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Ne",
   "List.cons",
   "List.instMembershipList",
   "Mathlib.Data.List.Nodup._auxLemma.1",
   "True",
   "iff_self",
   "Eq",
   "List.Pairwise",
   "And",
   "List.Nodup",
   "Iff",
   "of_eq_true",
   "List",
   "Mathlib.Data.List.Nodup._auxLemma.3",
   "Not",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "List.nodup_cons",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, List.Nodup (a :: l) ↔ a ∉ l ∧ List.Nodup l",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "eq_self",
   "FunLike.coe",
   "True",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "of_eq_true",
   "Prod.mk",
   "Equiv.prodCongr.match_1",
   "Prod.map",
   "Equiv.symm_apply_apply",
   "congr",
   "Prod",
   "congrArg",
   "Eq.trans",
   "Equiv.symm",
   "congrFun"],
  "name": "Equiv.prodCongr.proof_1",
  "constType":
  "∀ {α₁ : Type u_1} {α₂ : Type u_3} {β₁ : Type u_2} {β₂ : Type u_4} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) (x : α₁ × β₁),\n  Prod.map (⇑e₁.symm) (⇑e₂.symm) (Prod.map (⇑e₁) (⇑e₂) x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid.r",
   "instHasEquiv",
   "Setoid",
   "Quotient",
   "HasEquiv.Equiv",
   "Relator.LiftFun",
   "Quot.map"],
  "name": "Quotient.map",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] → (f : α → β) → ((fun x x_1 => x ≈ x_1) ⇒ fun x x_1 => x ≈ x_1) f f → Quotient sa → Quotient sb",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.Surjective",
   "Equiv.surjective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Equiv.symm"],
  "name": "Equiv.unique.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (e : α ≃ β), Function.Surjective ⇑e.symm",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{α : Type u_1} → {ι : Sort u_4} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.instOneCardinal",
   "OfNat.ofNat",
   "Cardinal.mk_eq_one",
   "Cardinal",
   "One.toOfNat1",
   "instOfNatNat",
   "Fin.uniqueFinOne",
   "Nat",
   "Fin",
   "ULift",
   "Cardinal.lift",
   "Eq",
   "ULift.instUniqueULift"],
  "name": "Cardinal.lift_one",
  "constType": "Cardinal.lift.{u_2, u_1} 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "sup_compl_eq_top",
   "IsCompl.of_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "IsCompl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "inf_compl_eq_bot'",
   "BooleanAlgebra"],
  "name": "isCompl_compl",
  "constType": "∀ {α : Type u} {x : α} [inst : BooleanAlgebra α], IsCompl x xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ", "Nat.le.rec"],
  "name": "Nat.le.casesOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {a : ℕ} (t : Nat.le n a),\n  motive n (_ : Nat.le n n) → (∀ {m : ℕ} (a : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive a t",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.lift.proof_2",
   "LE.mk",
   "Preorder.toLT",
   "LT.lt",
   "LT.mk",
   "Preorder",
   "Preorder.lift.proof_3",
   "LE.le",
   "Preorder.lift.proof_1",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Preorder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : Preorder β] → (α → β) → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instLECardinal.match_1",
   "Iff.intro",
   "Equiv",
   "Nonempty.intro",
   "Function.Embedding.congr",
   "instHasEquiv",
   "propext",
   "Function.Embedding",
   "Cardinal.map.match_1",
   "HasEquiv.Equiv",
   "Cardinal.isEquivalent",
   "Nonempty",
   "Equiv.symm",
   "Eq"],
  "name": "Cardinal.instLECardinal.proof_1",
  "constType":
  "∀ (x x_1 x_2 x_3 : Type u_1),\n  x ≈ x_2 → x_1 ≈ x_3 → (fun α β => Nonempty (α ↪ β)) x x_1 = (fun α β => Nonempty (α ↪ β)) x_2 x_3",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_cons",
   "Or",
   "propext",
   "Multiset",
   "Multiset.cons",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Basic._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {a b : α} {s : Multiset α}, (a ∈ b ::ₘ s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "AddHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Nat.addMonoid",
   "Finset",
   "Multiset",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["exists_prop_congr", "Exists", "Iff", "propext", "Iff.mpr", "Eq"],
  "name": "exists_prop_congr'",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{α : Type u_1} → List α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Eq.to_iff", "Iff", "Eq"],
  "name": "iff_of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.SourceInfo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references": ["outParam", "HAppend"],
  "name": "HAppend.hAppend",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAppend α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Sum.rec", "Sum", "Sum.inr", "Sum.inl"],
  "name": "Sum.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {motive : α ⊕ β → Sort u_1} →\n      (t : α ⊕ β) → ((val : α) → motive (Sum.inl val)) → ((val : β) → motive (Sum.inr val)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Cardinal.mk_eq_zero",
   "NonUnitalNonAssocSemiring.mk",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "Equiv.prodAssoc",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Equiv.sumProdDistrib",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "ULift.instUniqueULift",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "One.mk",
   "Prod.isEmpty_right",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Prod.isEmpty_left",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Cardinal.instOneCardinal",
   "Equiv.prodSumDistrib",
   "Cardinal.instAddCardinal",
   "NonUnitalSemiring.mk",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Fin.uniqueFinOne",
   "Equiv.uniqueProd",
   "Equiv.sumAssoc",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_12",
  "constType": "∀ (a : Cardinal.{u_1}), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective", "Set", "Set.InjOn", "Set.injOn_of_injective"],
  "name": "Function.Injective.injOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s",
  "constCategory": "Theorem"},
 {"references": ["Equivalence"],
  "name": "Equivalence.mk",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop},\n  (∀ (x : α), r x x) → (∀ {x y : α}, r x y → r y x) → (∀ {x y z : α}, r x y → r y z → r x z) → Equivalence r",
  "constCategory": "Other"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ"],
  "name": "Nat.le.rec",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop},\n  motive n (_ : Nat.le n n) →\n    (∀ {m : ℕ} (a : Nat.le n m), motive m a → motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) →\n      ∀ {a : ℕ} (t : Nat.le n a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddSemigroup",
   "AddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddMonoid M",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Cardinal.instPowCardinal",
   "One.toOfNat1",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "Cardinal.instZeroCardinal",
   "ULift.instIsEmptyULift",
   "Cardinal.instOneCardinal",
   "Cardinal.mk_eq_one",
   "instHPow",
   "Fin.isEmpty'",
   "Cardinal",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Fin",
   "Pi.uniqueOfIsEmpty"],
  "name": "Cardinal.power_zero",
  "constType": "∀ {a : Cardinal.{u_1}}, a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.nil",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.rec",
  "constType":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → List.Perm a a_1 → Prop},\n  motive [] [] (_ : List.Perm [] []) →\n    (∀ (x : α) {l₁ l₂ : List α} (a : List.Perm l₁ l₂),\n        motive l₁ l₂ a → motive (x :: l₁) (x :: l₂) (_ : List.Perm (x :: l₁) (x :: l₂))) →\n      (∀ (x y : α) (l : List α), motive (y :: x :: l) (x :: y :: l) (_ : List.Perm (y :: x :: l) (x :: y :: l))) →\n        (∀ {l₁ l₂ l₃ : List α} (a : List.Perm l₁ l₂) (a_1 : List.Perm l₂ l₃),\n            motive l₁ l₂ a → motive l₂ l₃ a_1 → motive l₁ l₃ (_ : List.Perm l₁ l₃)) →\n          ∀ {a a_1 : List α} (t : List.Perm a a_1), motive a a_1 t",
  "constCategory": "Other"},
 {"references": ["False", "propext", "imp_false", "Not", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.2",
  "constType": "∀ {a : Prop}, (a → False) = ¬a",
  "constCategory": "Theorem"},
 {"references": ["Exists", "False", "Not", "exists_false.match_1"],
  "name": "exists_false",
  "constType": "∀ {α : Sort u_1}, ¬∃ _a, False",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Cardinal.instAddCardinal",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Cardinal",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Eq",
   "Add.mk"],
  "name": "Cardinal.commSemiring.proof_5",
  "constType":
  "∀ (n : ℕ) (x : Cardinal.{u_1}), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "Function.LeftInverse",
   "EquivLike",
   "outParam",
   "EquivLike.inv"],
  "name": "EquivLike.left_inv",
  "constType":
  "∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e : E),\n  Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "nsmulRec",
   "Cardinal.mk_eq_zero",
   "NonUnitalNonAssocSemiring.mk",
   "ULift",
   "Eq",
   "Zero.toOfNat0",
   "ULift.instIsEmptyULift",
   "Equiv.prodAssoc",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Equiv.sumProdDistrib",
   "Fin.isEmpty'",
   "Cardinal.inductionOn",
   "instOfNatNat",
   "Nat",
   "Add.mk",
   "Equiv.sumComm",
   "instAddNat",
   "Cardinal.mk_congr",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Equiv.sumEmpty",
   "Prod.isEmpty_right",
   "NonUnitalNonAssocSemiring.toMul",
   "Prod.isEmpty_left",
   "AddMonoid.mk",
   "Cardinal.instMulCardinal",
   "Cardinal.inductionOn₃",
   "Cardinal.instZeroCardinal",
   "instHMul",
   "Equiv.emptySum",
   "Equiv.prodSumDistrib",
   "Cardinal.instAddCardinal",
   "Cardinal",
   "HMul.hMul",
   "Zero.mk",
   "Prod",
   "Sum",
   "Equiv.sumAssoc",
   "Cardinal.inductionOn₂",
   "Fin",
   "Mul.mk"],
  "name": "Cardinal.commSemiring.proof_11",
  "constType": "∀ (a b c : Cardinal.{u_1}), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_refl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_1",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "∀ {α : Type u_1} (a : Set α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "HasSSubset.SSubset",
   "Iff.rfl",
   "LT.lt",
   "Finset",
   "LT.mk",
   "Finset.instHasSSubsetFinset"],
  "name": "Finset.partialOrder.proof_3",
  "constType": "∀ {α : Type u_1} (a b : Finset α), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "FunLike", "Function.Injective", "EmbeddingLike", "FunLike.coe"],
  "name": "EmbeddingLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      [toFunLike : FunLike F α fun x => β] → (∀ (f : F), Function.Injective ⇑f) → EmbeddingLike F α β",
  "constCategory": "Other"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EmbeddingLike.injective'",
   "Function.Injective",
   "EmbeddingLike",
   "FunLike.coe"],
  "name": "EmbeddingLike.injective",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [i : EmbeddingLike F α β] (f : F), Function.Injective ⇑f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Setoid.r",
   "DecidableEq",
   "List.Nodup.insert",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ndinsert",
   "Multiset.Nodup",
   "Quot.inductionOn"],
  "name": "Multiset.Nodup.ndinsert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Multiset α} (a : α),\n  Multiset.Nodup s → Multiset.Nodup (Multiset.ndinsert a s)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references":
  ["PUnit.unit", "Prod.mk", "PUnit", "Prod", "Prod.fst", "rfl", "Eq"],
  "name": "Equiv.prodPUnit.proof_2",
  "constType":
  "∀ (α : Type u_1) (x : α), (fun p => p.1) ((fun a => (a, PUnit.unit)) x) = (fun p => p.1) ((fun a => (a, PUnit.unit)) x)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.le.step",
  "constType": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Nonempty.intro", "Nonempty", "Nonempty.casesOn"],
  "name": "Cardinal.isEquivalent.match_1",
  "constType":
  "∀ {x y : Type u_1} (motive : Nonempty (x ≃ y) → Prop) (x_1 : Nonempty (x ≃ y)),\n  (∀ (e : x ≃ y), motive (_ : Nonempty (x ≃ y))) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "propext",
   "Multiset",
   "Multiset.cons",
   "Multiset.nodup_cons",
   "Not",
   "Multiset.Nodup",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Multiset.Nodup._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Multiset α}, Multiset.Nodup (a ::ₘ s) = (a ∉ s ∧ Multiset.Nodup s)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Unique.instSubsingleton",
   "Unique.instInhabited",
   "Inhabited.default",
   "Eq",
   "instInhabitedForAll_1",
   "Subsingleton.elim",
   "Unique"],
  "name": "Equiv.equivOfUnique.proof_1",
  "constType":
  "∀ (α : Sort u_1) (β : Sort u_2) [inst : Unique α] [inst_1 : Unique β] (x : α), default (default x) = x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "RelHomClass", "FunLike.coe"],
  "name": "RelHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} →\n          [toFunLike : FunLike F α fun x => β] → (∀ (f : F) {a b : α}, r a b → s (f a) (f b)) → RelHomClass F r s",
  "constCategory": "Other"},
 {"references": ["Equivalence"],
  "name": "Equivalence.refl",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.concat.match_1",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil"],
  "name": "List.concat",
  "constType": "{α : Type u} → List α → α → List α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_2",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Function.Injective", "Function.comp", "Eq"],
  "name": "Function.Injective.comp",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},\n  Function.Injective g → Function.Injective f → Function.Injective (g ∘ f)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.le_top",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_14",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Surjective.unique",
   "Equiv.unique.proof_1",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv",
   "Unique"],
  "name": "Equiv.unique",
  "constType":
  "{α : Sort u} → {β : Sort v} → [inst : Unique β] → α ≃ β → Unique α",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "instHasEquiv",
   "Cardinal.map.match_1",
   "HasEquiv.Equiv",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.map₂.proof_1",
  "constType":
  "∀ (f : Type u_1 → Type u_2 → Type u_3),\n  ((α β : Type u_1) → (γ δ : Type u_2) → α ≃ β → γ ≃ δ → f α γ ≃ f β δ) →\n    ∀ (α β : Type u_1), α ≈ β → ∀ (γ δ : Type u_2), γ ≈ δ → (fun x x_1 => x ≈ x_1) (f α γ) (f β δ)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableEqProp.match_1",
  "constType":
  "{p q : Prop} →\n  (motive : Decidable (p ↔ q) → Sort u_1) →\n    (d : Decidable (p ↔ q)) → ((h : p ↔ q) → motive (isTrue h)) → ((h : ¬(p ↔ q)) → motive (isFalse h)) → motive d",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DecidableEq", "Classical.propDecidable", "Eq"],
  "name": "Classical.decEq",
  "constType": "(α : Sort u) → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "∀ {α : Sort u}, α → Nonempty α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["List.forall_mem_ne",
   "Membership.mem",
   "List.instMembershipList",
   "propext",
   "List",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.List.Nodup._auxLemma.1",
  "constType":
  "∀ {α : Type u} {a : α} {l : List α}, (∀ a' ∈ l, ¬a = a') = (a ∉ l)",
  "constCategory": "Theorem"},
 {"references": ["Option.none", "Option.rec", "Option.some", "Option"],
  "name": "Option.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : Option α → Sort u_1} → (t : Option α) → motive none → ((val : α) → motive (some val)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Function.LeftInverse", "funext", "Function.comp", "Eq", "id"],
  "name": "Function.LeftInverse.comp_eq_id",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.LeftInverse f g → f ∘ g = id",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Add M] → [inst_1 : Add N] → [self : AddHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "List.mem_range",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "List.range"],
  "name": "List.finRange.proof_1",
  "constType": "∀ (n x : ℕ), x ∈ List.range n → x < n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Or",
   "False",
   "Multiset.instZeroMultiset",
   "Mathlib.Data.Multiset.Basic._auxLemma.6",
   "Multiset.instSingletonMultiset",
   "Multiset.instMembershipMultiset",
   "True",
   "iff_self",
   "Eq",
   "Mathlib.Data.Multiset.Basic._auxLemma.7",
   "Zero.toOfNat0",
   "Mathlib.Data.Multiset.Basic._auxLemma.13",
   "Iff",
   "of_eq_true",
   "Multiset",
   "Multiset.cons",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Multiset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Decidable.isFalse",
   "propext",
   "instDecidableEqProp.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqProp.proof_1",
   "Eq"],
  "name": "instDecidableEqProp",
  "constType": "{p q : Prop} → [d : Decidable (p ↔ q)] → Decidable (p = q)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "Equiv.mk",
   "Equiv.trans.proof_2",
   "FunLike.coe",
   "Equiv.trans.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans",
  "constType":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → α ≃ β → β ≃ γ → α ≃ γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "HasSubset.Subset",
   "Exists.intro",
   "implies_congr",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Set.image_subset.match_1",
   "forall_congr",
   "And.intro",
   "Set.image",
   "id"],
  "name": "Set.image_subset",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a b : Set α} (f : α → β), a ⊆ b → f '' a ⊆ f '' b",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.map",
   "Membership.mem",
   "And",
   "Exists",
   "EmbeddingLike.toFunLike",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Multiset.mem_map",
   "Finset.instMembershipFinset",
   "Function.Embedding",
   "FunLike.coe",
   "Eq"],
  "name": "Finset.mem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} {b : β}, b ∈ Finset.map f s ↔ ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.mk"],
  "name": "Trunc.mk",
  "constType": "{α : Sort u_1} → α → Trunc α",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective",
   "Function.Embedding.mk",
   "Function.Embedding.rec",
   "Function.Embedding"],
  "name": "Function.Embedding.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {motive : (α ↪ β) → Sort u} →\n      (t : α ↪ β) →\n        ((toFun : α → β) → (inj' : Function.Injective toFun) → motive { toFun := toFun, inj' := inj' }) → motive t",
  "constCategory": "Definition"},
 {"references": ["IsEmpty", "isEmptyElim", "Eq"],
  "name": "Equiv.equivOfIsEmpty.proof_1",
  "constType":
  "∀ (α : Sort u_1) (β : Sort u_2) [inst : IsEmpty α] [inst_1 : IsEmpty β] (a : α),\n  (fun a => isEmptyElim a) ((fun a => isEmptyElim a) a) = a",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["Sum.elim",
   "funext",
   "Prod.snd",
   "Sum.casesOn",
   "Prod.mk",
   "Function.comp",
   "Eq.refl",
   "Prod",
   "Sum",
   "Prod.fst",
   "Sum.inr",
   "Sum.inl",
   "Eq"],
  "name": "Equiv.sumArrowEquivProdArrow.proof_1",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) (γ : Type u_3) (f : α ⊕ β → γ),\n  (fun p => Sum.elim p.1 p.2) ((fun f => (f ∘ Sum.inl, f ∘ Sum.inr)) f) = f",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "And.left"],
  "name": "Fintype.ofBijective.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Bijective f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Eq.refl",
   "Option.casesOn",
   "Option.noConfusionType",
   "Eq",
   "Option"],
  "name": "Option.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {v1 v2 : Option α} → v1 = v2 → Option.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.rec"],
  "name": "Prop.distribLattice.proof_1",
  "constType": "∀ (x x_1 x_2 : Prop), (x → x_2) → (x_1 → x_2) → x ∨ x_1 → x_2",
  "constCategory": "Theorem"},
 {"references": ["PProd", "List.rec", "List", "PUnit"],
  "name": "List.below",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max 1 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["Set.piecewise",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "Set",
   "Decidable",
   "HasCompl.compl",
   "Set.piecewise_eq_of_not_mem",
   "Set.EqOn",
   "BooleanAlgebra.toHasCompl",
   "Set.instMembershipSet"],
  "name": "Set.piecewise_eqOn_compl",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Set α) [inst : (j : α) → Decidable (j ∈ s)] (f g : α → β),\n  Set.EqOn (Set.piecewise s f g) g sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.lift_id",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "Eq",
   "Cardinal.mk_sum",
   "Eq.mpr",
   "Cardinal.instOneCardinal",
   "Equiv.cardinal_eq",
   "Cardinal.mk_eq_one",
   "Cardinal.instAddCardinal",
   "Eq.ndrec",
   "Equiv.optionEquivSumPUnit",
   "Cardinal",
   "PUnit",
   "Sum",
   "Cardinal.mk",
   "PUnit.unique",
   "Cardinal.lift",
   "Option",
   "id"],
  "name": "Cardinal.mk_option",
  "constType": "∀ {α : Type u}, Cardinal.mk (Option α) = Cardinal.mk α + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Set.piecewise",
   "Membership.mem",
   "Set",
   "Decidable",
   "Not",
   "if_neg",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.piecewise_eq_of_not_mem",
  "constType":
  "∀ {α : Type u_1} {δ : α → Sort u_6} (s : Set α) (f g : (i : α) → δ i) [inst : (j : α) → Decidable (j ∈ s)] {i : α},\n  i ∉ s → Set.piecewise s f g i = g i",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Or",
   "Multiset.mem_cons",
   "Iff",
   "Finset",
   "Finset.cons",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Not",
   "Eq"],
  "name": "Finset.mem_cons",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : a ∉ s}, b ∈ Finset.cons a s h ↔ b = a ∨ b ∈ s",
  "constCategory": "Theorem"},
 {"references": ["HAppend.mk", "HAppend", "Append", "Append.append"],
  "name": "instHAppend",
  "constType": "{α : Type u_1} → [inst : Append α] → HAppend α α α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Fintype.mk",
   "False",
   "Multiset",
   "Prop.fintype.proof_2",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Insert.insert",
   "Multiset.instInsertMultiset",
   "True",
   "Prop.fintype.proof_1"],
  "name": "Prop.fintype",
  "constType": "Fintype Prop",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Set.Subset", "Set", "LE"],
  "name": "Set.instLESet",
  "constType": "{α : Type u_1} → LE (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommMonoidWithZero",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "SemilatticeSup.mk",
   "And.intro",
   "Prop.partialOrder",
   "Sup.mk",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Or.rec"],
  "name": "Prop.distribLattice.proof_2",
  "constType": "∀ (x x_1 x_2 : Prop), x ≤ x_1 → x ≤ x_2 → x → x_1 ∧ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype.ofEquiv_card",
   "Fintype",
   "ULift.fintype",
   "Fintype.card",
   "Equiv.ulift",
   "Nat",
   "ULift",
   "Eq",
   "Equiv.symm"],
  "name": "Fintype.card_ulift",
  "constType":
  "∀ (α : Type u_4) [inst : Fintype α], Fintype.card (ULift.{u_5, u_4} α) = Fintype.card α",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "optParam",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "List",
   "List.range'.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.range'",
  "constType": "ℕ → ℕ → optParam ℕ 1 → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "List",
   "List.pmap.proof_1",
   "PUnit",
   "List.pmap.proof_2",
   "List.nil",
   "List.pmap.match_1"],
  "name": "List.pmap",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (l : List α) → (∀ a ∈ l, p a) → List β",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "False",
   "Std.Logic._auxLemma.2",
   "Multiset.Nodup",
   "Multiset.instSingletonMultiset",
   "iff_false",
   "Mathlib.Data.Multiset.Nodup._auxLemma.4",
   "True",
   "Multiset.instMembershipMultiset",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Multiset",
   "Multiset.cons",
   "congr",
   "not_true_eq_false",
   "Singleton.singleton",
   "Not",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans",
   "and_self",
   "Mathlib.Data.Multiset.Basic._auxLemma.14",
   "Mathlib.Data.Multiset.Nodup._auxLemma.3"],
  "name": "Prop.fintype.proof_1",
  "constType": "Multiset.Nodup (True ::ₘ {False})",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Setoid.r",
   "List.nodup_cons",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.cons",
   "Not",
   "Multiset.Nodup",
   "Quot.induction_on",
   "Multiset.instMembershipMultiset"],
  "name": "Multiset.nodup_cons",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Multiset α}, Multiset.Nodup (a ::ₘ s) ↔ a ∉ s ∧ Multiset.Nodup s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{α : Type u_1} → SupSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "propext",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "LE.le",
   "AddZeroClass",
   "le_add_iff_nonneg_right",
   "ContravariantClass",
   "Eq"],
  "name": "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.15",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b : α}, (a ≤ a + b) = (0 ≤ b)",
  "constCategory": "Theorem"},
 {"references": ["False", "Iff.mp", "Iff", "Not"],
  "name": "instDecidableIff.proof_2",
  "constType": "∀ {p q : Prop}, p → ¬q → (p ↔ q) → False",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instNatPowNat",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "∀ (n : ℕ), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Decidable", "LinearOrder.decidableEq", "Eq"],
  "name": "instDecidableEq",
  "constType":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Equiv.mk",
   "Unique.instInhabited",
   "Equiv.equivOfUnique.proof_1",
   "Equiv.equivOfUnique.proof_2",
   "Inhabited.default",
   "instInhabitedForAll_1",
   "Unique"],
  "name": "Equiv.equivOfUnique",
  "constType":
  "(α : Sort u) → (β : Sort v) → [inst : Unique α] → [inst : Unique β] → α ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.map₂.proof_1",
   "instHasEquiv",
   "Setoid",
   "Quotient.lift₂",
   "Quotient",
   "HasEquiv.Equiv",
   "Relator.LiftFun",
   "Quotient.mk"],
  "name": "Quotient.map₂",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        {γ : Sort u_4} →\n          [sc : Setoid γ] →\n            (f : α → β → γ) →\n              ((fun x x_1 => x ≈ x_1) ⇒ (fun x x_1 => x ≈ x_1) ⇒ fun x x_1 => x ≈ x_1) f f →\n                Quotient sa → Quotient sb → Quotient sc",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.le_add_right",
   "PartialOrder.toPreorder",
   "OrderBot",
   "Preorder.toLE",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_2",
   "Multiset.instPartialOrderMultiset",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_1",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Multiset",
   "OrderBot.toBot",
   "CanonicallyOrderedAddCommMonoid",
   "inferInstanceAs",
   "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderBot.mk",
   "CanonicallyOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
  "constType": "{α : Type u_1} → CanonicallyOrderedAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Setoid", "Cardinal.isEquivalent.proof_1", "Setoid.mk", "Nonempty"],
  "name": "Cardinal.isEquivalent",
  "constType": "Setoid (Type u)",
  "constCategory": "Definition"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{α : Type u_4} → (val : Multiset α) → Multiset.Nodup val → Finset α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Cardinal.mk_fintype",
   "HAdd.hAdd",
   "Eq.refl",
   "ULift",
   "instFintypeOption",
   "True",
   "Fintype.card_fin",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "instOfNatNat",
   "ULift.fintype",
   "Cardinal.mk",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Option",
   "eq_self",
   "instAddNat",
   "Fintype.card_ulift",
   "instHAdd",
   "One.toOfNat1",
   "Fintype.card",
   "Fin.fintype",
   "Fintype.card_option",
   "Cardinal.instOneCardinal",
   "Cardinal.instAddCardinal",
   "Eq.ndrec",
   "Cardinal.instNatCastCardinal",
   "of_eq_true",
   "Cardinal",
   "Cardinal.mk_option",
   "congr",
   "congrArg",
   "Fin",
   "congrFun"],
  "name": "Cardinal.cast_succ",
  "constType": "∀ (n : ℕ), ↑(n + 1) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Cardinal.isEquivalent"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Add M] → [inst : Add N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Pi.booleanAlgebra",
   "Not",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_3",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), ∀ t ∈ s, ∀ a ∈ t, ∃ t ∈ s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Finset", "Finset.instMembershipFinset", "id"],
  "name": "Finset.partialOrder.proof_1",
  "constType": "∀ {α : Type u_1} (s : Finset α), ∀ a ∈ s, a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["List.Pairwise", "Ne", "List"],
  "name": "List.Nodup",
  "constType": "{α : Type u_1} → List α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["List.attach.proof_1",
   "Membership.mem",
   "List.pmap",
   "List.instMembershipList",
   "List",
   "Subtype.mk",
   "Subtype"],
  "name": "List.attach",
  "constType": "{α : Type u_1} → (l : List α) → List { x // x ∈ l }",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty"],
  "name": "Nonempty.rec",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop}, (∀ (val : α), motive (_ : Nonempty α)) → ∀ (t : Nonempty α), motive t",
  "constCategory": "Other"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Iff.symm",
   "Membership.mem",
   "Iff",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Iff.trans",
   "Multiset.Nodup.ext",
   "Finset.val_inj",
   "Eq"],
  "name": "Finset.ext_iff",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, s₁ = s₂ ↔ ∀ (a : α), a ∈ s₁ ↔ a ∈ s₂",
  "constCategory": "Theorem"},
 {"references":
  ["IsCompl.disjoint",
   "PartialOrder.toPreorder",
   "Disjoint.symm",
   "IsCompl.mk",
   "IsCompl",
   "IsCompl.codisjoint",
   "BoundedOrder.toOrderTop",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "Codisjoint.symm",
   "BoundedOrder",
   "PartialOrder"],
  "name": "IsCompl.symm",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → IsCompl y x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "CommMonoid.mul_comm",
   "CommMonoidWithZero",
   "CommSemiring.toCommMonoidWithZero.proof_1",
   "CommSemiring.toCommMonoidWithZero.proof_2",
   "CommMonoid",
   "CommSemiring",
   "AddMonoid.toZero",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "CommMonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.range'",
   "instAddNat",
   "List.instMembershipList",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "instLTNat",
   "Eq",
   "List.mem_range'_1",
   "And",
   "instLENat",
   "propext",
   "List",
   "LT.lt",
   "instOfNatNat",
   "Nat"],
  "name": "Std.Data.List.Lemmas._auxLemma.107",
  "constType": "∀ {m s n : ℕ}, (m ∈ List.range' s n) = (s ≤ m ∧ m < s + n)",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references": ["eq_false", "False", "Eq"],
  "name": "eq_false'",
  "constType": "∀ {p : Prop}, (p → False) → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8834",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8800",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toCompletelyDistribLattice : CompletelyDistribLattice α] →\n    (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) →\n      [toHasCompl : HasCompl α] →\n        [toSDiff : SDiff α] →\n          [toHImp : HImp α] →\n            (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n              (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                  autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ →\n                    (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) →\n                      (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteAtomicBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["List.Perm",
   "List.Perm.nil",
   "List",
   "List.Perm.trans",
   "List.Perm.rec",
   "List.Perm.swap",
   "List.Perm.cons"],
  "name": "List.Perm.symm",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Perm l₁ l₂ → List.Perm l₂ l₁",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.instMulCardinal",
   "instHMul",
   "Cardinal.mk_congr",
   "Cardinal",
   "HMul.hMul",
   "Prod",
   "Equiv.prodComm",
   "Cardinal.inductionOn₂",
   "Eq"],
  "name": "_private.Mathlib.SetTheory.Cardinal.Basic.0.Cardinal.mul_comm'",
  "constType": "∀ (a b : Cardinal.{u}), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq"],
  "name": "congrArg₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "List.cons",
   "List.Perm.rfl",
   "Unit",
   "List.Sublist",
   "Exists.intro",
   "List.Sublist.exists_perm_append.match_1",
   "List.Perm.cons",
   "List.Perm.symm",
   "instHAppend",
   "List.Perm",
   "List.instAppendList",
   "List",
   "HAppend.hAppend",
   "List.perm_middle",
   "List.Perm.trans",
   "List.nil",
   "List.Sublist.exists_perm_append.match_2._@.Std.Data.List.Perm._hyg.3839",
   "List.Sublist.brecOn",
   "List.Sublist.below"],
  "name": "List.Sublist.exists_perm_append",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Sublist l₁ l₂ → ∃ l, List.Perm l₂ (l₁ ++ l)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set",
   "Eq.refl",
   "Cardinal.partialOrder",
   "Cardinal.instLECardinal.proof_1",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff.mp",
   "Function.Embedding.casesOn",
   "instHPow",
   "Preorder.toLT",
   "Function.Embedding.mk",
   "instOfNatNat",
   "Cardinal.inductionOn",
   "Function.Embedding",
   "Cardinal.mk",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "id",
   "HPow.hPow",
   "False",
   "Quotient.liftOn₂",
   "Cardinal.instPowCardinal",
   "Cardinal.mk_set",
   "Nonempty.intro",
   "Cardinal.instNatCastCardinal",
   "Eq.ndrec",
   "Function.Injective",
   "Function.cantor_injective",
   "LT.lt",
   "Set.singleton_eq_singleton_iff",
   "Cardinal",
   "instNatAtLeastTwo",
   "Singleton.singleton",
   "Not",
   "And.intro",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.cantor",
  "constType": "∀ (a : Cardinal.{u}), a < 2 ^ a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "CommMonoid",
   "LinearOrderedCommMonoid",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "CommMonoid.toMonoid",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toLinearOrder : LinearOrder α] →\n    [toCommMonoid : CommMonoid α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b) → LinearOrderedCommMonoid α",
  "constCategory": "Other"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references":
  ["trivial", "Iff.intro", "Iff", "propext", "Iff.mpr", "True", "Eq"],
  "name": "iff_true",
  "constType": "∀ (p : Prop), (p ↔ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.toFun", "Function.Injective", "Function.Embedding"],
  "name": "Function.Embedding.inj'",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ↪ β), Function.Injective self.toFun",
  "constCategory": "Definition"},
 {"references": ["Option.casesOn", "Eq", "Option"],
  "name": "Option.noConfusionType",
  "constType": "{α : Type u} → Sort u_1 → Option α → Option α → Sort u_1",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "Setoid", "Equivalence"],
  "name": "Setoid.iseqv",
  "constType": "∀ {α : Sort u} [self : Setoid α], Equivalence Setoid.r",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.attach.proof_1",
   "List.pmap",
   "_private.Mathlib.Data.List.Basic.0.List.attach._eq_1",
   "List.instMembershipList",
   "Subtype.val",
   "Eq.refl",
   "rfl",
   "List.attach",
   "Eq",
   "List.map_pmap",
   "Subtype.property",
   "Eq.mpr",
   "Eq.ndrec",
   "List",
   "List.map",
   "List.pmap_congr",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "List.pmap_eq_map_attach",
  "constType":
  "∀ {α : Type u} {β : Type v} {p : α → Prop} (f : (a : α) → p a → β) (l : List α) (H : ∀ a ∈ l, p a),\n  List.pmap f l H = List.map (fun x => f ↑x (_ : p ↑x)) (List.attach l)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "List.Perm",
   "List.instMembershipList",
   "propext",
   "List",
   "List.Perm.mem_iff",
   "Eq"],
  "name": "Multiset.Mem.proof_1",
  "constType":
  "∀ {α : Type u_1} (a : α) (l₁ l₂ : List α), List.Perm l₁ l₂ → (fun l => a ∈ l) l₁ = (fun l => a ∈ l) l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Cardinal.lift_id'", "Cardinal", "Cardinal.lift", "Eq"],
  "name": "Cardinal.lift_id",
  "constType": "∀ (a : Cardinal.{u}), Cardinal.lift.{u, u} a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.prodCongr.proof_2",
   "Prod.map",
   "Equiv.mk",
   "Prod",
   "FunLike.coe",
   "Equiv.prodCongr.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.prodCongr",
  "constType":
  "{α₁ : Type u_1} → {α₂ : Type u_2} → {β₁ : Type u_3} → {β₂ : Type u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → α₁ × β₁ ≃ α₂ × β₂",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Exists",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderBot",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_1} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    [toOrderBot : OrderBot α] →\n      (∀ {a b : α}, a ≤ b → ∃ c, b = a + c) → (∀ (a b : α), a ≤ a + b) → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → HEq a a_1 → Sort u_1} →\n      motive a (_ : HEq a a) → {β : Sort u} → {a_1 : β} → (t : HEq a a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "False", "propext", "or_false.match_1", "Eq"],
  "name": "or_false",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["Function.LeftInverse",
   "Function.Injective",
   "Function.invFun_eq",
   "Exists.intro",
   "rfl",
   "Function.invFun",
   "Nonempty",
   "Eq"],
  "name": "Function.leftInverse_invFun",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} [inst : Nonempty α] {f : α → β},\n  Function.Injective f → Function.LeftInverse (Function.invFun f) f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.ext_iff",
   "Iff",
   "Finset",
   "Finset.instMembershipFinset",
   "Iff.mpr",
   "Eq"],
  "name": "Finset.ext",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Union",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Empty",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{α : Type u} → (α → α → α) → Inf α",
  "constCategory": "Other"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop} (t : Nonempty α), (∀ (val : α), motive (_ : Nonempty α)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "optParam",
  "constType": "(α : Sort u) → α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nonempty.intro",
   "Setoid.r",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Function.Embedding.trans",
   "Cardinal.isEquivalent",
   "LE.le",
   "Nonempty.casesOn",
   "Quot.mk",
   "Cardinal.instLECardinal"],
  "name": "Cardinal.partialOrder.proof_2",
  "constType": "∀ (a b c : Cardinal.{u_1}), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["RelEmbedding", "Function.Embedding"],
  "name": "RelEmbedding.toEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → α ↪ β",
  "constCategory": "Definition"},
 {"references": ["Trunc.bind.proof_1", "Trunc", "Trunc.liftOn"],
  "name": "Trunc.bind",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → Trunc α → (α → Trunc β) → Trunc β",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.toBiheytingAlgebra",
   "IsCompl.compl_eq",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "BooleanAlgebra.toBoundedOrder",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "BooleanAlgebra.toDistribLattice",
   "IsCompl.symm",
   "BiheytingAlgebra.toHeytingAlgebra",
   "BooleanAlgebra",
   "Eq"],
  "name": "compl_compl",
  "constType": "∀ {α : Type u} [inst : BooleanAlgebra α] (x : α), xᶜᶜ = x",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Setoid.mk", "True", "true_equivalence"],
  "name": "trueSetoid",
  "constType": "{α : Sort u_1} → Setoid α",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{α : Type u_1} → Union (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset",
   "Multiset",
   "Finset.instMembershipFinset",
   "Multiset.Nodup",
   "Finset.mem_mk",
   "Finset.mk",
   "Multiset.instMembershipMultiset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {a : α} {s : Multiset α} {nd : Multiset.Nodup s}, (a ∈ { val := s, nodup := nd }) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references": ["Array", "List"],
  "name": "Array.mk",
  "constType": "{α : Type u} → List α → Array α",
  "constCategory": "Other"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → ({a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) → Trans r s t",
  "constCategory": "Other"},
 {"references":
  ["instDecidableFalse",
   "False",
   "instDecidableNot",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "instDecidableIff",
   "instDecidableTrue",
   "instDecidableEqProp",
   "True",
   "Eq"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Bot.mk",
   "OrderBot",
   "OrderBot.mk",
   "Preorder.toLE",
   "Multiset.zero_le",
   "Multiset.instPartialOrderMultiset"],
  "name": "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
  "constType": "{α : Type u_1} → OrderBot (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "propext", "iff_of_eq", "Eq"],
  "name": "iff_iff_eq",
  "constType": "∀ {a b : Prop}, (a ↔ b) ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pow.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : FunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.Perm",
   "List.rec",
   "List.Perm.nil",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.Perm.refl.match_1",
   "List.nil",
   "List.Perm.cons"],
  "name": "List.Perm.refl",
  "constType": "∀ {α : Type u_1} (l : List α), List.Perm l l",
  "constCategory": "Theorem"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (toZeroHom : ZeroHom M N) →\n          (∀ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n            M →+ N",
  "constCategory": "Other"},
 {"references":
  ["Equiv.arrowCongr.proof_1",
   "Equiv",
   "Function.comp",
   "Equiv.mk",
   "FunLike.coe",
   "Equiv.arrowCongr.proof_2",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.arrowCongr",
  "constType":
  "{α₁ : Sort u_1} → {β₁ : Sort u_2} → {α₂ : Sort u_3} → {β₂ : Sort u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → (α₁ → β₁) ≃ (α₂ → β₂)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddSemigroup.mk",
   "Cardinal.mk_congr",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "ULift",
   "Eq",
   "Cardinal.inductionOn₃",
   "Zero.toOfNat0",
   "Cardinal.instZeroCardinal",
   "ULift.instIsEmptyULift",
   "Equiv.emptySum",
   "Cardinal.instAddCardinal",
   "Fin.isEmpty'",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Cardinal.inductionOn",
   "Sum",
   "Equiv.sumAssoc",
   "Nat",
   "Fin",
   "Add.mk"],
  "name": "Cardinal.commSemiring.proof_2",
  "constType": "∀ (a : Cardinal.{u_1}), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["List.Subperm.trans",
   "Multiset.Le",
   "LE.mk",
   "Setoid.r",
   "List",
   "Quot.ind",
   "List.isSetoid",
   "Multiset",
   "LE.le",
   "Quot.mk"],
  "name": "Multiset.instPartialOrderMultiset.proof_2",
  "constType": "∀ {α : Type u_1} (a b c : Multiset α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.concat.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → α → Sort u_2) →\n    (x : List α) →\n      (x_1 : α) → ((b : α) → motive [] b) → ((a : α) → (as : List α) → (b : α) → motive (a :: as) b) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{α : Type u_4} → (elems : Finset α) → (∀ (x : α), x ∈ elems) → Fintype α",
  "constCategory": "Other"},
 {"references":
  ["Sum.elim", "Sum.inl", "IsEmpty", "rfl", "isEmptyElim", "Eq", "id"],
  "name": "Equiv.sumEmpty.proof_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_2) [inst : IsEmpty β] (x : α),\n  Sum.elim id (fun a => isEmptyElim a) (Sum.inl x) = Sum.elim id (fun a => isEmptyElim a) (Sum.inl x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "AddHomClass.toFunLike",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "List.length_map",
   "Quot.inductionOn",
   "Eq",
   "Multiset.map",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card_map",
  "constType":
  "∀ {α : Type u_1} {β : Type v} (f : α → β) (s : Multiset α), Multiset.card (Multiset.map f s) = Multiset.card s",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "List.Perm.length_eq",
   "OfNat.ofNat",
   "Quotient.inductionOn₂",
   "List.length_append",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card.proof_2",
  "constType":
  "∀ {α : Type u_1} (s t : Multiset α),\n  ZeroHom.toFun\n      {\n        toFun := fun s =>\n          Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n        map_zero' :=\n          (_ :\n            (fun s =>\n                  Quot.liftOn s List.length\n                    (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                0 =\n              (fun s =>\n                  Quot.liftOn s List.length\n                    (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                0) }\n      (s + t) =\n    ZeroHom.toFun\n        {\n          toFun := fun s =>\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        s +\n      ZeroHom.toFun\n        {\n          toFun := fun s =>\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        t",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Sum.elim",
   "Equiv.sumArrowEquivProdArrow.proof_1",
   "Prod.snd",
   "Prod.mk",
   "Function.comp",
   "Equiv.mk",
   "Prod",
   "Sum",
   "Prod.fst",
   "Sum.inr",
   "Equiv.sumArrowEquivProdArrow.proof_2",
   "Sum.inl"],
  "name": "Equiv.sumArrowEquivProdArrow",
  "constType":
  "(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α ⊕ β → γ) ≃ (α → γ) × (β → γ)",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Trans", "Trans.mk", "Equiv.trans"],
  "name": "Equiv.instTransSortSortSortEquivEquivEquiv",
  "constType": "Trans Equiv Equiv Equiv",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_1",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Empty", "Equiv.equivOfIsEmpty", "instIsEmptyEmpty", "IsEmpty"],
  "name": "Equiv.equivEmpty",
  "constType": "(α : Sort u) → [inst : IsEmpty α] → α ≃ Empty",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.le_sup_left",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_5",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Equiv.prodAssoc.match_2",
  "constType":
  "∀ (α : Type u_1) (β : Type u_3) (γ : Type u_2) (motive : α × β × γ → Prop) (x : α × β × γ),\n  (∀ (fst : α) (fst_1 : β) (snd : γ), motive (fst, fst_1, snd)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.inductionOn₃",
   "Cardinal.instAddCardinal",
   "Cardinal.mk_congr",
   "instHAdd",
   "HAdd.hAdd",
   "Cardinal",
   "Sum",
   "Equiv.sumAssoc",
   "Add.mk",
   "Eq"],
  "name": "Cardinal.commSemiring.proof_1",
  "constType": "∀ (a b c : Cardinal.{u_1}), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_11",
  "constType":
  "∀ {α : Type u_1} (x y z : α → Prop), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Cardinal.mk_fintype",
   "Set",
   "HAdd.hAdd",
   "Cardinal.lift_id'",
   "True",
   "Eq",
   "Cardinal.lift_one",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Cardinal.commSemiring",
   "instHPow",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "instOfNat",
   "Eq.trans",
   "Nat.cast_one",
   "Cardinal.mk_arrow",
   "eq_self",
   "HPow.hPow",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.7",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Cardinal.instPowCardinal",
   "Fintype.card",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Cardinal.lift_add",
   "Nat.cast_add",
   "Prop.fintype",
   "Cardinal.instOneCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.instAddCardinal",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Cardinal",
   "instNatAtLeastTwo",
   "congr",
   "congrArg",
   "congrFun",
   "Nat.semiring",
   "Cardinal.lift"],
  "name": "Cardinal.mk_set",
  "constType": "∀ {α : Type u}, Cardinal.mk (Set α) = 2 ^ Cardinal.mk α",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} → [self : RelHomClass F r s] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Set.piecewise",
   "Membership.mem",
   "if_pos",
   "Set",
   "Decidable",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.piecewise_eq_of_mem",
  "constType":
  "∀ {α : Type u_1} {δ : α → Sort u_6} (s : Set α) (f g : (i : α) → δ i) [inst : (j : α) → Decidable (j ∈ s)] {i : α},\n  i ∈ s → Set.piecewise s f g i = f i",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Injective",
   "Function.Involutive.leftInverse",
   "Function.LeftInverse.injective",
   "Function.Involutive"],
  "name": "Function.Involutive.injective",
  "constType":
  "∀ {α : Sort u} {f : α → α}, Function.Involutive f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_2",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Option.instMembershipOption",
   "Membership.mem",
   "propext",
   "Option.some",
   "Option.mem_def",
   "Eq",
   "Option"],
  "name": "Std.Data.Option.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {a : α} {b : Option α}, (a ∈ b) = (b = some a)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Sum.map_map.match_1",
   "Function.comp",
   "Sum.map",
   "Sum",
   "Sum.inr",
   "Sum.inl",
   "rfl",
   "Eq"],
  "name": "Sum.map_map",
  "constType":
  "∀ {α' : Type u_1} {α'' : Type u_2} {β' : Type u_3} {β'' : Type u_4} {α : Type u_5} {β : Type u_6} (f' : α' → α'')\n  (g' : β' → β'') (f : α → α') (g : β → β') (x : α ⊕ β), Sum.map f' g' (Sum.map f g x) = Sum.map (f' ∘ f) (g' ∘ g) x",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.lift₂",
   "HasEquiv.Equiv",
   "Quotient",
   "Eq"],
  "name": "Quotient.liftOn₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → φ) → (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) → φ",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{α : Type u} →\n  [toInf : Inf α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ⊓ b ≤ a) →\n        (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → SemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["List.Pairwise",
   "Membership.mem",
   "List.cons",
   "List.Pairwise.nil",
   "List.Pairwise.rec",
   "List.instMembershipList",
   "List",
   "List.mem_cons_of_mem",
   "List.mem_cons_self",
   "List.nil",
   "List.Pairwise.cons"],
  "name": "List.Pairwise.imp_of_mem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {R S : α → α → Prop},\n  (∀ {a b : α}, a ∈ l → b ∈ l → R a b → S a b) → List.Pairwise R l → List.Pairwise S l",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "List.mem_replicate.match_1",
   "List.range'",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "List.length",
   "optParam",
   "rfl",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "List.length_range'",
  "constType": "∀ (s step n : ℕ), List.length (List.range' s n step) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Eq.refl", "Bool", "Eq"],
  "name": "Nat.decEq.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (x = true → motive true) → (x = false → motive false) → motive x",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.trans",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["OrderHom.monotone",
   "Monotone",
   "OrderHom",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "FunLike.coe",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike"],
  "name": "OrderHom.mono",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β), Monotone ⇑f",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec",
   "Function.Injective",
   "Function.Embedding.casesOn",
   "Function.Embedding.toFun",
   "Function.Embedding.mk",
   "Eq.rec",
   "Eq.refl",
   "Function.Embedding",
   "Eq.symm",
   "Eq"],
  "name": "Function.instEmbeddingLikeEmbedding.proof_1",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f g : α ↪ β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references": ["SDiff"],
  "name": "SDiff.mk",
  "constType": "{α : Type u} → (α → α → α) → SDiff α",
  "constCategory": "Other"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "eq_self",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "True",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "of_eq_true",
   "Prod.mk",
   "Equiv.prodCongr.match_1",
   "Prod.map",
   "congr",
   "Prod",
   "congrArg",
   "Eq.trans",
   "Equiv.symm",
   "congrFun"],
  "name": "Equiv.prodCongr.proof_2",
  "constType":
  "∀ {α₁ : Type u_3} {α₂ : Type u_1} {β₁ : Type u_4} {β₂ : Type u_2} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) (x : α₂ × β₂),\n  Prod.map (⇑e₁) (⇑e₂) (Prod.map (⇑e₁.symm) (⇑e₂.symm) x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "IsCompl",
   "disjoint_compl_left",
   "IsCompl.codisjoint",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "IsCompl.disjoint",
   "LE.le.antisymm'",
   "HeytingAlgebra.toBoundedOrder",
   "GeneralizedHeytingAlgebra.toLattice",
   "Disjoint.le_compl_left",
   "Disjoint.le_of_codisjoint",
   "HeytingAlgebra.toHasCompl"],
  "name": "IsCompl.compl_eq",
  "constType":
  "∀ {α : Type u_2} [inst : HeytingAlgebra α] {a b : α}, IsCompl a b → aᶜ = b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Quotient.liftOn₂",
   "Cardinal.instLECardinal.proof_1",
   "Cardinal.partialOrder.proof_2",
   "LT.mk",
   "LE.le",
   "Nonempty",
   "PartialOrder",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "And",
   "Cardinal.partialOrder.proof_1",
   "Cardinal.partialOrder.proof_3",
   "Cardinal",
   "Cardinal.partialOrder.proof_4",
   "Function.Embedding",
   "Not",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.partialOrder",
  "constType": "PartialOrder Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": ["ULift"],
  "name": "ULift.down",
  "constType": "{α : Type s} → ULift.{r, s} α → α",
  "constCategory": "Definition"},
 {"references": ["Setoid", "List.Perm", "List", "Setoid.mk", "List.Perm.eqv"],
  "name": "List.isSetoid",
  "constType": "(α : Type u_1) → Setoid (List α)",
  "constCategory": "Definition"},
 {"references":
  ["instIsAntisymmLeToLEToPreorder",
   "PartialOrder.toPreorder",
   "Iff",
   "RelEmbedding.ofMapRelIff",
   "OrderEmbedding",
   "instIsReflLeToLE",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderEmbedding.ofMapLEIff",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} →\n    [inst : PartialOrder α] → [inst_1 : Preorder β] → (f : α → β) → (∀ (a b : α), f a ≤ f b ↔ a ≤ b) → α ↪o β",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references":
  ["OrderHom.mk",
   "Eq.ndrec",
   "Eq.rec",
   "Eq.refl",
   "Monotone",
   "OrderHom",
   "OrderHom.casesOn",
   "OrderHom.toFun",
   "Preorder",
   "Eq.symm",
   "Eq"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] (f g : α →o β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["Unique.mk'",
   "Function.Surjective",
   "Unique.instInhabited",
   "Function.Surjective.unique.proof_1",
   "Inhabited.mk",
   "Inhabited.default",
   "Unique"],
  "name": "Function.Surjective.unique",
  "constType":
  "{α : Sort u} → {β : Sort u_1} → (f : α → β) → Function.Surjective f → [inst : Unique α] → Unique β",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Prop.heytingAlgebra",
   "Prop.booleanAlgebra.proof_5",
   "Top.top",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "DistribLattice.mk",
   "Classical.em",
   "HasCompl.mk",
   "HeytingAlgebra.toOrderBot",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "BooleanAlgebra.mk",
   "Preorder.toLE",
   "Prop.booleanAlgebra.proof_4",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "OrderTop.toTop",
   "DistribLattice",
   "SDiff.mk",
   "OrderBot.toBot",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "Prop.booleanAlgebra.proof_3",
   "Not",
   "Prop.booleanAlgebra.proof_1",
   "Lattice.toSemilatticeSup",
   "Prop.booleanAlgebra.proof_2",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prop.booleanAlgebra",
  "constType": "BooleanAlgebra Prop",
  "constCategory": "Definition"}]