[{"references": [],
  "name": "Dvd",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.add_zero",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "Units.val",
   "Nat.monoid",
   "Exists.intro",
   "IsUnit",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.isUnit_iff.match_2",
  "constType":
  "∀ {n : ℕ} (motive : IsUnit n → Prop) (x : IsUnit n), (∀ (u : ℕˣ) (hu : ↑u = n), motive (_ : ∃ u, ↑u = n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.zero_ne_one",
  "constType": "0 ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_left",
  "constType": "∀ {a b c : Prop}, (a → b) → a ∨ c → b ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.le_total",
  "constType": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["AddCancelCommMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelCommMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["IsCancelMulZero.mk",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommMonoidWithZero.toZero",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "IsCancelMulZero.toIsRightCancelMulZero",
   "CommMonoidWithZero.toCommMonoid",
   "CommMagma.toMul",
   "CancelCommMonoidWithZero",
   "CommMonoid.toCommSemigroup",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "IsCancelMulZero.toIsLeftCancelMulZero",
   "IsCancelMulZero",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero.proof_1",
   "MonoidWithZero.toZero",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCancelMonoidWithZero.proof_2",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CancelCommMonoidWithZero M₀], IsCancelMulZero M₀",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "inferInstance",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "Units.instGroupUnits.proof_2",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : αˣ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Nat"],
  "name": "Nat.monoid",
  "constType": "Monoid ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Eq"],
  "name": "CommMonoid.mul_comm",
  "constType": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "False",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Nat.mod_zero.match_1",
   "Eq",
   "ite",
   "And",
   "Nat.instModNat",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "Eq.rec",
   "LT.lt",
   "Nat.lt_irrefl",
   "HMod.hMod",
   "Not",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "if_neg",
   "Nat.decLe"],
  "name": "Nat.mod_zero",
  "constType": "∀ (a : ℕ), a % 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a : α) (motive : _a ≤ _a ∧ ¬_a ≤ _a → Prop) (x : _a ≤ _a ∧ ¬_a ≤ _a),\n  (∀ (h1 : _a ≤ _a) (h2 : ¬_a ≤ _a), motive (_ : _a ≤ _a ∧ ¬_a ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.npow",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Semiring.npow_zero",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_11",
  "constType": "∀ (x : ℕ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Max",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_5",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Or",
   "Nat.below",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "LE.le",
   "instLTNat",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.eq_or_lt_of_le.match_2",
   "instLENat",
   "Nat.zero",
   "Or.inl",
   "Nat.le_of_succ_le_succ",
   "Nat.eq_or_lt_of_le.match_1",
   "Eq.rec",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.zero_le",
   "absurd",
   "Nat.succ"],
  "name": "Nat.eq_or_lt_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n = m ∨ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.lt_wfRel.proof_1",
   "WellFoundedRelation",
   "Nat.lt",
   "Nat",
   "WellFoundedRelation.mk"],
  "name": "Nat.lt_wfRel",
  "constType": "WellFoundedRelation ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Zero", "IsCancelMulZero", "Mul", "IsLeftCancelMulZero"],
  "name": "IsCancelMulZero.toIsLeftCancelMulZero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsCancelMulZero M₀], IsLeftCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "Exists.elim.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ x, p x) → Prop) (h₁ : ∃ x, p x),\n  (∀ (a : α) (h : p a), motive (_ : ∃ x, p x)) → motive h₁",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "CommSemigroup.mk",
   "CommMonoid",
   "CommMonoid.mul_comm",
   "CommMonoid.toMonoid",
   "CommSemigroup"],
  "name": "CommMonoid.toCommSemigroup",
  "constType": "{M : Type u} → [self : CommMonoid M] → CommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "False",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "Nat.not_le_of_gt",
   "Eq.rec",
   "LT.lt",
   "HMod.hMod",
   "Not",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "if_neg",
   "Nat.decLe"],
  "name": "Nat.mod_eq_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a % b = a",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["zpowRec",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "instOfNatInt",
   "MulOneClass",
   "MulOneClass.toOne",
   "Units.inv_val",
   "Eq.refl",
   "Units.inv",
   "Inv.mk",
   "Eq",
   "Units.val_inv",
   "Units",
   "inferInstance",
   "Units.instMulOneClassUnits",
   "Units.val",
   "Units.mk",
   "Int"],
  "name": "Units.instGroupUnits.proof_8",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (a : αˣ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instHAdd",
   "Nat.lt_of_lt_of_le",
   "HAdd.hAdd",
   "Nat.add_lt_add_left",
   "LE.le",
   "instLTNat",
   "Eq",
   "GT.gt",
   "instHMul",
   "instLENat",
   "Nat.mul_le_mul_left",
   "LT.lt",
   "Eq.rec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.mul_lt_mul_of_pos_left",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → k * n < k * m",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Zero", "Mul"],
  "name": "IsRightCancelMulZero",
  "constType": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.not_succ_le_self", "Not", "Nat", "instLTNat"],
  "name": "Nat.lt_irrefl",
  "constType": "∀ (n : ℕ), ¬n < n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "Ne.symm",
   "NeZero.out"],
  "name": "NeZero.ne'",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], 0 ≠ n",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "Function.Injective",
   "mul_left_cancel₀",
   "HMul.hMul",
   "Mul",
   "IsLeftCancelMulZero"],
  "name": "mul_right_injective₀",
  "constType":
  "∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀] {a : M₀},\n  a ≠ 0 → Function.Injective fun x => a * x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "Nat.le.dest.match_2",
   "Exists",
   "Nat.add_comm",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Exists.intro",
   "LE.le",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.zero",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "Nat.succ"],
  "name": "Nat.le.dest",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.gcd_dvd_right",
   "Nat.gcd_dvd_left",
   "Nat.gcd",
   "Nat.dvd_antisymm",
   "Nat",
   "Nat.dvd_gcd",
   "Eq"],
  "name": "Nat.gcd_comm",
  "constType": "∀ (m n : ℕ), Nat.gcd m n = Nat.gcd n m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references": ["Monoid"],
  "name": "Units",
  "constType": "(α : Type u) → [inst : Monoid α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "And",
   "OfNat.ofNat",
   "instLENat",
   "instSubNat",
   "Nat.div.inductionOn",
   "LT.lt",
   "HSub.hSub",
   "Not",
   "instOfNatNat",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod.inductionOn",
  "constType":
  "{motive : ℕ → ℕ → Sort u} →\n  (x y : ℕ) →\n    ((x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) →\n      ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y) → motive x y",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Eq.rec", "Nat.le_refl", "Nat", "LE.le", "Eq"],
  "name": "Nat.le_of_eq",
  "constType": "∀ {n m : ℕ}, n = m → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["maxOfLe", "instLENat", "Max", "Nat", "Nat.decLe"],
  "name": "Nat.instMaxNat",
  "constType": "Max ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4011",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "lt_of_lt_of_le.match_2",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddRightCancelMonoid"],
  "name": "AddRightCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "inferInstance",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "Monoid",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Units.instGroupUnits.proof_3",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : αˣ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Or",
   "Iff",
   "False",
   "Or.inl",
   "Or.inr",
   "Decidable.not_and_iff_or_not.match_1",
   "Decidable",
   "And.comm.match_1",
   "Not",
   "And.intro",
   "Decidable.not_and_iff_or_not.match_2",
   "absurd"],
  "name": "Decidable.not_and_iff_or_not",
  "constType":
  "∀ (p q : Prop) [d₁ : Decidable p] [d₂ : Decidable q], ¬(p ∧ q) ↔ ¬p ∨ ¬q",
  "constCategory": "Theorem"},
 {"references":
  ["le_self_add",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "id"],
  "name": "le_add_self",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.decEq.match_1",
   "Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Decidable",
   "Decidable.isTrue",
   "Bool",
   "rfl",
   "Eq"],
  "name": "Bool.decEq",
  "constType": "(a b : Bool) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsRightCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddRightCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_false", "False", "LT.lt", "Nat.lt_irrefl", "Nat", "instLTNat", "Eq"],
  "name": "Init.Data.Nat.Basic._auxLemma.3",
  "constType": "∀ (n : ℕ), (n < n) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.ne_of_lt",
   "Nat.zero_lt_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.linearOrderedCommSemiring.proof_5",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "lt_of_lt_of_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LT.lt.trans_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["And.right", "Nat.gcd_dvd", "Nat.instDvdNat", "Nat.gcd", "Dvd.dvd", "Nat"],
  "name": "Nat.gcd_dvd_right",
  "constType": "∀ (m n : ℕ), Nat.gcd m n ∣ n",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "forall_congr'",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∀ (a : α), q a)",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivisionMonoid.toDivInvOneMonoid.proof_1",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.zpow_neg'",
   "DivInvMonoid.zpow",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [inst : DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b : G), a + b = b + a) → AddCommSemigroup G",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommMonoid", "OrderedCancelAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedCancelAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid",
   "Eq.ndrec",
   "HEq",
   "Monoid.toOne",
   "HEq.refl",
   "Irreducible",
   "eq_of_heq",
   "Eq.refl",
   "One.toOfNat1",
   "Eq.casesOn",
   "Eq.symm",
   "Eq"],
  "name": "Irreducible.ne_one.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (motive : (x : α) → Irreducible x → x = 1 → Prop) (x : α) (x_1 : Irreducible x)\n  (x_2 : x = 1), (∀ (hp : Irreducible 1), motive 1 hp (_ : 1 = 1)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.div_rec_lemma.match_1",
  "constType":
  "∀ {x y : ℕ} (motive : 0 < y ∧ y ≤ x → Prop) (x_1 : 0 < y ∧ y ≤ x),\n  (∀ (ypos : 0 < y) (ylex : y ≤ x), motive (_ : 0 < y ∧ y ≤ x)) → motive x_1",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references": ["Min.min", "Eq.refl", "Nat", "instMinNat", "Eq"],
  "name": "Nat.linearOrder.proof_1",
  "constType": "∀ (a b : ℕ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.casesOn"],
  "name": "Nat.not_succ_le_zero.match_3",
  "constType":
  "∀ (motive : (x : ℕ) → Nat.succ x ≤ 0 → Prop) (x : ℕ) (x_1 : Nat.succ x ≤ 0),\n  (∀ (h : Nat.succ 0 ≤ 0), motive 0 h) →\n    (∀ (n : ℕ) (h : Nat.succ (Nat.succ n) ≤ 0), motive (Nat.succ n) h) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm",
   "Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "mul_left_cancel₀",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "IsRightCancelMulZero",
   "IsRightCancelMulZero.mk",
   "CommMagma.toMul",
   "IsLeftCancelMulZero",
   "CommSemigroup",
   "Eq.trans",
   "Eq"],
  "name": "IsLeftCancelMulZero.to_isRightCancelMulZero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CommSemigroup M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀],\n  IsRightCancelMulZero M₀",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoid : CommMonoid M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → CommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4053",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Not"],
  "name": "Decidable.isFalse",
  "constType": "{p : Prop} → ¬p → Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_le.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive Nat.zero) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["invImage", "WellFoundedRelation", "Nat.lt_wfRel", "Nat"],
  "name": "measure",
  "constType": "{α : Sort u} → (α → ℕ) → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.le_total.match_1",
  "constType":
  "∀ (m n : ℕ) (motive : m < n ∨ m ≥ n → Prop) (x : m < n ∨ m ≥ n),\n  (∀ (h : m < n), motive (_ : m < n ∨ m ≥ n)) → (∀ (h : m ≥ n), motive (_ : m < n ∨ m ≥ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Nat.gt_of_not_le",
   "instLENat",
   "Iff.mp",
   "Nat.not_le_of_gt",
   "LT.lt",
   "Not",
   "Nat",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_not_ge",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.le_of_ble_eq_true.match_1",
   "Nat.succ_le_succ",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.zero_le",
   "Nat.succ"],
  "name": "Nat.le_of_ble_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.ble n m = true → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.mul_zero",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "One",
   "PUnit",
   "HMul.hMul",
   "One.toOfNat1",
   "Nat",
   "Mul",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "npowRec",
  "constType": "{M : Type u} → [inst : One M] → [inst : Mul M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "OrderedSemiring",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        0 ≤ 1 →\n          (∀ (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b) →\n            (∀ (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c) → OrderedSemiring α",
  "constCategory": "Other"},
 {"references": ["Zero", "OfNat.ofNat", "OfNat", "Zero.mk"],
  "name": "Zero.ofOfNat0",
  "constType": "{α : Type u_1} → [inst : OfNat α 0] → Zero α",
  "constCategory": "Definition"},
 {"references": ["Not", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_not_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x ≤ x_1 → ¬x_1 ≤ x → Prop) (x x_1 : α) (x_2 : x ≤ x_1)\n  (x_3 : ¬x_1 ≤ x), (∀ (_a _b : α) (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive _a _b hab hba) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "DivisionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toDivisionMonoid : DivisionMonoid G] → (∀ (a b : G), a * b = b * a) → DivisionCommMonoid G",
  "constCategory": "Other"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "mul_lt_mul_of_pos_left",
   "Eq.trans",
   "Or",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Order.Basic._auxLemma.1",
   "Or.casesOn",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "instHMul",
   "Decidable.eq_or_lt_of_le",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "le_refl",
   "congr",
   "HMul.hMul",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] (a b c : α),\n  a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.le.step",
   "Nat.le",
   "Nat.below",
   "Nat.brecOn",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.le_trans.match_1"],
  "name": "Nat.le_trans",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references": ["Units", "Monoid"],
  "name": "Units.val",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_2",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "zpowRec",
   "Monoid",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Units.inv_val",
   "Eq.refl",
   "Units.inv",
   "Inv.mk",
   "Eq",
   "Units.val_inv",
   "Units",
   "inferInstance",
   "Units.instMulOneClassUnits",
   "Units.val",
   "Nat",
   "Nat.succ",
   "Units.mk"],
  "name": "Units.instGroupUnits.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (n : ℕ) (a : αˣ),\n  zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.symm.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∧ b → Prop) (x : a ∧ b), (∀ (ha : a) (hb : b), motive (_ : a ∧ b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "CommMonoidWithZero.mul_zero",
   "Monoid.toSemigroup",
   "CommMonoidWithZero.toZero",
   "Ne",
   "OfNat.ofNat",
   "Nat.pos_of_ne_zero",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoidWithZero",
   "Eq",
   "Nat.eq_of_mul_eq_mul_left",
   "Zero.toOfNat0",
   "instHMul",
   "inferInstance",
   "Nat.commSemiring",
   "CommMonoidWithZero.zero_mul",
   "IsLeftCancelMulZero.mk",
   "HMul.hMul",
   "CommMonoidWithZero.mk",
   "Nat",
   "CommMonoid.toMonoid",
   "CommSemiring.toCommMonoidWithZero",
   "IsLeftCancelMulZero"],
  "name": "Nat.cancelCommMonoidWithZero.proof_1",
  "constType": "IsLeftCancelMulZero ℕ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "False",
   "instLENat",
   "Nat.not_le_of_gt",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "Nat.ge_of_not_lt",
   "instMulNat",
   "Nat",
   "Nat.mul_lt_mul_of_pos_left",
   "absurd",
   "instLTNat",
   "LE.le"],
  "name": "Nat.le_of_mul_le_mul_left",
  "constType": "∀ {a b c : ℕ}, c * a ≤ c * b → 0 < c → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "inferInstance",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_10",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : OrderedCancelAddCommMonoid α] → AddCancelCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Nat.add_sub_of_le",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat",
   "LE.le",
   "id",
   "Eq"],
  "name": "Nat.sub_add_cancel",
  "constType": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "left_inv_eq_right_inv",
   "HMul.hMul",
   "inv_mul_self",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {a b : G}, a * b = 1 → a⁻¹ = b",
  "constCategory": "Theorem"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat", "instHAdd", "HAdd.hAdd", "Nat", "Nat.succ", "rfl", "Eq"],
  "name": "Nat.add_succ",
  "constType": "∀ (n m : ℕ), n + Nat.succ m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["WellFoundedRelation.rel", "WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.wf",
  "constType":
  "∀ {α : Sort u} [self : WellFoundedRelation α], WellFounded WellFoundedRelation.rel",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Nat.linearOrderedCommSemiring.proof_4",
  "constType": "∀ (a b : ℕ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4053",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4011",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u} → α → Bot α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.symm",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "one_add_one_eq_two",
  "constType": "∀ {α : Type u_1} [inst : AddMonoidWithOne α], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Or.symm",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.eq_or_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "Nat.lt_iff_le_not_le.match_1",
   "LT.lt",
   "Not",
   "Nat.le_of_lt",
   "And.intro",
   "Nat",
   "Nat.lt_of_not_ge",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_iff_le_not_le",
  "constType": "∀ {m n : ℕ}, m < n ↔ m ≤ n ∧ ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "AddCommMagma.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b : G), a + b = b + a) → AddCommMagma G",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "Mul",
   "IsLeftCancelMulZero",
   "Eq"],
  "name": "IsLeftCancelMulZero.mul_left_cancel_of_ne_zero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Int",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_zero'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Semiring.toMonoidWithZero",
   "Not",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Nat.semiring",
   "Irreducible.ne_zero"],
  "name": "Nat.not_prime_zero",
  "constType": "¬Nat.Prime 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.units_eq_one",
   "One.toOfNat1",
   "Exists.intro",
   "Nat.isUnit_iff.match_1",
   "rfl",
   "Eq",
   "Iff.intro",
   "Units",
   "InvOneClass.toOne",
   "Iff",
   "Nat.commMonoid",
   "Units.instCommGroupUnits",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionCommMonoid.toDivisionMonoid",
   "Eq.rec",
   "Units.val",
   "Nat.monoid",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Eq.symm",
   "DivisionMonoid.toDivInvOneMonoid",
   "Nat.isUnit_iff.match_2",
   "CommGroup.toDivisionCommMonoid"],
  "name": "Nat.isUnit_iff",
  "constType": "∀ {n : ℕ}, IsUnit n ↔ n = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "le_iff_exists_add",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelMonoid.add_right_cancel",
  "constType":
  "∀ {M : Type u} [self : AddCancelMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_mul",
   "OfNat.ofNat",
   "Or",
   "Or.inr",
   "instAddNat",
   "instHAdd",
   "Nat.eq_zero_of_mul_eq_zero.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "rfl",
   "Eq",
   "Nat.eq_zero_of_add_eq_zero_left",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Or.inl",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.eq_zero_of_mul_eq_zero",
  "constType": "∀ {n m : ℕ}, n * m = 0 → n = 0 ∨ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_succ_le_zero.match_3",
   "Nat.not_succ_le_zero.match_2",
   "OfNat.ofNat",
   "False",
   "instLENat",
   "Nat.not_succ_le_zero.match_1",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.not_succ_le_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.not_prime_one",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "Nat.Prime",
   "False.elim",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "le_add_self",
   "Nat.canonicallyOrderedCommSemiring",
   "instOfNatNat",
   "Nat",
   "Nat.not_prime_zero",
   "LE.le",
   "Nat.Prime.two_le.match_1"],
  "name": "Nat.Prime.two_le",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 2 ≤ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references": ["Min", "LE", "Min.mk", "LE.le", "ite", "DecidableRel"],
  "name": "minOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_of_dvd.match_1",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "instLTNat",
   "LE.le",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "False.elim",
   "instLENat",
   "Eq.ndrec",
   "Init.Data.Nat.Basic._auxLemma.3",
   "Nat.mul_le_mul_left",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "Nat.dvd_add.match_1",
   "Nat.succ_pos",
   "id"],
  "name": "Nat.le_of_dvd",
  "constType": "∀ {m n : ℕ}, 0 < n → m ∣ n → m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.gt_of_not_le.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat",
   "LE.le",
   "GT.gt"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvOneClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Nat.instDvdNat",
   "HMul.hMul",
   "instOfNatNat",
   "Dvd.dvd",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.eq_zero_of_zero_dvd.match_1",
  "constType":
  "∀ {a : ℕ} (motive : 0 ∣ a → Prop) (h : 0 ∣ a), (∀ (c : ℕ) (H' : a = 0 * c), motive (_ : ∃ c, a = 0 * c)) → motive h",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.propIntro",
   "Eq"],
  "name": "Nat.succ.injEq",
  "constType": "∀ (n n_1 : ℕ), (Nat.succ n = Nat.succ n_1) = (n = n_1)",
  "constCategory": "Theorem"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Eq",
   "inferInstance",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Ordering"],
  "name": "Ordering.eq",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "instNatPowNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Array",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Max.mk", "LE", "Max", "LE.le", "ite", "DecidableRel"],
  "name": "maxOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Max α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.eq_zero_of_mul_eq_zero.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (m : ℕ), motive 0 m) → (∀ (n m : ℕ), motive (Nat.succ n) m) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Eq.ndrec", "Bool", "Bool.noConfusionType", "Eq"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalCommSemiring.mk",
  "constType":
  "{α : Type u} → [toNonUnitalSemiring : NonUnitalSemiring α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommSemiring α",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["Nat.gcd.proof_1",
   "measure",
   "WellFoundedRelation.rel",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
   "Nat",
   "WellFounded.fix",
   "id"],
  "name": "Nat.gcd",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.zero",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Nat.casesOn"],
  "name": "Nat.gcd.induction.match_1",
  "constType":
  "∀ {P : ℕ → ℕ → Prop} (motive : (x : ℕ) → (∀ m < x, (fun m => ∀ (n : ℕ), P m n) m) → Prop) (x : ℕ)\n  (x_1 : ∀ m < x, (fun m => ∀ (n : ℕ), P m n) m),\n  (∀ (x : ∀ m < 0, (fun m => ∀ (n : ℕ), P m n) m), motive 0 x) →\n    (∀ (n : ℕ) (IH : ∀ m < n + 1, (fun m => ∀ (n : ℕ), P m n) m), motive (Nat.succ n) IH) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["And",
   "Nat.eq_zero_of_add_eq_zero.match_1",
   "OfNat.ofNat",
   "instAddNat",
   "Nat.noConfusion",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.eq_zero_of_add_eq_zero",
  "constType": "∀ {n m : ℕ}, n + m = 0 → n = 0 ∧ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.zero_mul",
  "constType":
  "∀ {M₀ : Type u_4} [self : CommMonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Nat.zero",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "Nat.Prime.two_le.match_1",
  "constType":
  "∀ (motive : (x : ℕ) → Nat.Prime x → Prop) (x : ℕ) (x_1 : Nat.Prime x),\n  (∀ (h : Nat.Prime 0), motive 0 h) →\n    (∀ (h : Nat.Prime 1), motive 1 h) →\n      (∀ (n : ℕ) (x : Nat.Prime (n + 2)), motive (Nat.succ (Nat.succ n)) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mul_zero",
  "constType":
  "∀ {M₀ : Type u_4} [self : CommMonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Monoid",
   "False",
   "Monoid.toOne",
   "Irreducible",
   "Irreducible.ne_one.match_1",
   "not_irreducible_one",
   "One.toOfNat1",
   "Eq"],
  "name": "Irreducible.ne_one",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, Irreducible p → p ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Units.mk",
  "constType":
  "{α : Type u} → [inst : Monoid α] → (val inv : α) → val * inv = 1 → inv * val = 1 → αˣ",
  "constCategory": "Other"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x < x_1 → x_1 ≤ x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x < x_1) (x_4 : x_1 ≤ x_2),\n  (∀ (_a _b _c : α) (hab : _a < _b) (hbc : _b ≤ _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{α : Type u} → [self : Div α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) →\n          [toNontrivial : Nontrivial α] →\n            0 ≤ 1 →\n              (∀ (a b c : α), a < b → 0 < c → c * a < c * b) →\n                (∀ (a b c : α), a < b → 0 < c → a * c < b * c) → StrictOrderedSemiring α",
  "constCategory": "Other"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.gcd_rec.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (m : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive m",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "OfNat.ofNat",
   "eq_zero_of_zero_dvd",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero.toMulZeroClass",
   "True",
   "MulZeroClass.toMul",
   "SemigroupWithZero",
   "Eq",
   "Iff.intro",
   "SemigroupWithZero.toSemigroup",
   "Zero.toOfNat0",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "zero_dvd_iff",
  "constType":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "instTransEq",
   "add_lt_add_left",
   "add_zero",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "lt_add_of_pos_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a < a + b",
  "constCategory": "Theorem"},
 {"references": ["Acc.intro", "Acc"],
  "name": "Acc.rec",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : (a : α) → Acc r a → Sort u_1} →\n      ((x : α) →\n          (h : ∀ (y : α), r y x → Acc r y) →\n            ((y : α) → (a : r y x) → motive y (_ : Acc r y)) → motive x (_ : Acc r x)) →\n        {a : α} → (t : Acc r a) → motive a t",
  "constCategory": "Other"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma", "instHAdd", "HAdd.hAdd", "AddCommMagma.toAdd", "Eq"],
  "name": "AddCommMagma.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Nat"],
  "name": "Nat.semiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive (Nat.succ n)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Or.casesOn",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod_lt.match_1",
  "constType":
  "∀ (x y : ℕ) (motive : ¬0 < y ∨ ¬y ≤ x → Prop) (h₁ : ¬0 < y ∨ ¬y ≤ x),\n  (∀ (h₁ : ¬0 < y), motive (_ : ¬0 < y ∨ ¬y ≤ x)) → (∀ (h₁ : ¬y ≤ x), motive (_ : ¬0 < y ∨ ¬y ≤ x)) → motive h₁",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    (∀ (a b c : α), a + b ≤ a + c → b ≤ c) → OrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.modCore",
   "Nat.mod.match_1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.mod",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.mk",
  "constType": "{α : Type u} → (α → ℕ → α) → NatPow α",
  "constCategory": "Other"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references": ["Ne", "Function.Injective", "mt", "Eq"],
  "name": "Function.Injective.ne",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a₁ a₂ : α}, a₁ ≠ a₂ → f a₁ ≠ f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "Units.val",
   "HMul.hMul",
   "One.toOfNat1",
   "Units.inv",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Units.inv_val",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (self : αˣ), self.inv * ↑self = 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "inv_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "of_eq_true",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "congr",
   "HDiv.hDiv",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_rev",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "inv_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a b : α), (a / b)⁻¹ = b / a",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "NeZero.mk",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat"],
  "name": "NeZero.succ",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ContravariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "LT.lt.ne'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "dvd_mul_right",
   "And.left",
   "Nat.Prime.two_le",
   "MulZeroClass.toMul",
   "Eq",
   "And.right",
   "Semiring.toNonAssocSemiring",
   "Nat.Prime",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "Nat",
   "Nat.Prime.eq_one_or_self_of_dvd",
   "instOfNat",
   "Nat.isUnit_iff",
   "Nat.strictOrderedSemiring",
   "Or",
   "MulOneClass.toOne",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.canonicallyOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MulZeroOneClass.toMulZeroClass",
   "mul_right_inj'",
   "Iff.intro",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Nat.zero",
   "AddCancelMonoid.toIsCancelAdd",
   "AddMonoidWithOne.toOne",
   "Nat.orderedSemiring",
   "propext",
   "LT.lt",
   "instNatAtLeastTwo",
   "congr",
   "mul_one",
   "And.intro",
   "congrArg",
   "CancelMonoidWithZero.toMonoidWithZero",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "pos_of_gt",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "LT.lt.trans_le",
   "Nat.instDvdNat",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "Or.imp_right",
   "one_lt_two",
   "Zero.toOfNat0",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Nat.semigroup",
   "AddMonoidWithOne.toNatCast",
   "instLENat",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Nat.monoid",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat.cancelCommMonoidWithZero",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "id",
   "NeZero.succ",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Dvd.dvd",
   "mt",
   "Irreducible.mk",
   "LE.le",
   "Monoid.toMulOneClass",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "HMul.hMul",
   "IsUnit",
   "Mathlib.Data.Nat.Prime._auxLemma.1",
   "Nat.semiring"],
  "name": "Nat.prime_def_lt''",
  "constType":
  "∀ {p : ℕ}, Nat.Prime p ↔ 2 ≤ p ∧ ∀ (m : ℕ), m ∣ p → m = 1 ∨ m = p",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x x_3 0) → (∀ (n m k : ℕ), motive n m (Nat.succ k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommMonoid",
   "CommSemiring",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.mk",
   "CommMonoid.mul_comm"],
  "name": "CommSemiring.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [inst : CommSemiring α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "instNatPowNat",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.zero_add",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "Monoid.mk",
   "OfNat.ofNat",
   "MulOneClass",
   "HAdd.hAdd",
   "Eq.refl",
   "npowRec",
   "Inv.mk",
   "Eq",
   "Units.val_inv",
   "inferInstance",
   "mul_assoc",
   "Div.mk",
   "MulOneClass.one_mul",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Units.mk",
   "Semigroup.mk",
   "instHDiv",
   "Monoid",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "Units.inv_val",
   "DivInvMonoid.div'",
   "Units.inv",
   "instHMul",
   "Units",
   "MulOneClass.mul_one",
   "Units.ext",
   "Units.instMulOneClassUnits",
   "Units.val",
   "HMul.hMul"],
  "name": "Units.instGroupUnits.proof_7",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a b : αˣ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references": ["Array", "List"],
  "name": "Array.data",
  "constType": "{α : Type u} → Array α → List α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionCommMonoid.mk",
   "Group.toDivisionMonoid",
   "DivisionMonoid",
   "CommGroup.toGroup",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.inv_inv",
   "CommGroup",
   "CommGroup.mul_comm",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "Group.toDivInvMonoid"],
  "name": "CommGroup.toDivisionCommMonoid",
  "constType": "{G : Type u_1} → [inst : CommGroup G] → DivisionCommMonoid G",
  "constCategory": "Definition"},
 {"references": ["CancelMonoidWithZero", "MonoidWithZero"],
  "name": "CancelMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references": ["Mod"],
  "name": "Mod.mk",
  "constType": "{α : Type u} → (α → α → α) → Mod α",
  "constCategory": "Other"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x < x_1 → Prop) (x x_1 : α) (x_2 : x < x_1),\n  (∀ (_a _b : α) (hab : _a < _b), motive _a _b hab) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Inv"],
  "name": "DivInvMonoid.toInv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt.ne'",
   "PartialOrder.toPreorder",
   "Nat.prime_def_lt",
   "Nat.instDvdNat",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "zero_dvd_iff",
   "SemigroupWithZero.toZero",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Nat.Prime",
   "instLENat",
   "instOfNatNat",
   "Nat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "Nat.strictOrderedSemiring",
   "Ne",
   "False",
   "Dvd.dvd",
   "LE.le",
   "SemigroupWithZero.toSemigroup",
   "And",
   "Nat.commSemiring",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "propext",
   "LT.lt",
   "Nat.Coprime.eq_one_of_dvd",
   "Nat.Coprime.symm",
   "Eq.mp",
   "Nat.Coprime",
   "NonUnitalSemiring.toSemigroupWithZero",
   "And.intro"],
  "name": "Nat.prime_of_coprime",
  "constType":
  "∀ (n : ℕ), 1 < n → (∀ m < n, m ≠ 0 → Nat.Coprime n m) → Nat.Prime n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_1",
  "constType": "∀ (a : ℕ), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["WellFounded.apply", "WellFounded.fixF", "WellFounded"],
  "name": "WellFounded.fix",
  "constType":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DivisionMonoid",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toDivInvMonoid : DivInvMonoid G] →\n    (∀ (x : G), x⁻¹⁻¹ = x) →\n      (∀ (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹) → (∀ (a b : G), a * b = 1 → a⁻¹ = b) → DivisionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["WellFounded.intro",
   "OfNat.ofNat",
   "Or",
   "Nat.lt_wfRel.match_1",
   "Nat.lt",
   "Acc",
   "instLTNat",
   "Eq",
   "Nat.rec",
   "Eq.ndrec",
   "Nat.le_of_succ_le_succ",
   "Acc.inv",
   "LT.lt",
   "WellFounded",
   "instOfNatNat",
   "Nat",
   "Acc.intro",
   "absurd",
   "Nat.not_lt_zero",
   "Nat.succ",
   "Nat.eq_or_lt_of_le"],
  "name": "Nat.lt_wfRel.proof_1",
  "constType": "WellFounded Nat.lt",
  "constCategory": "Theorem"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.gcd_dvd", "Nat.instDvdNat", "Nat.gcd", "Dvd.dvd", "Nat", "And.left"],
  "name": "Nat.gcd_dvd_left",
  "constType": "∀ (m n : ℕ), Nat.gcd m n ∣ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "IsCancelMulZero",
   "IsRightCancelMulZero",
   "Mul",
   "IsLeftCancelMulZero"],
  "name": "IsCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [toIsLeftCancelMulZero : IsLeftCancelMulZero M₀]\n  [toIsRightCancelMulZero : IsRightCancelMulZero M₀], IsCancelMulZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (x : α), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["instLENat", "Nat.le.refl", "Nat", "LE.le"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["WellFoundedRelation"],
  "name": "WellFoundedRelation.rel",
  "constType": "{α : Sort u} → [self : WellFoundedRelation α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoid.toMonoid",
   "IsLeftCancelMulZero",
   "CommMonoidWithZero",
   "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoidWithZero : CommMonoidWithZero M₀] →\n    [toIsLeftCancelMulZero : IsLeftCancelMulZero M₀] → CancelCommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "Mod",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.succ_le_succ",
   "Nat.zero_le",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.zero_lt_succ",
  "constType": "∀ (n : ℕ), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddLeftCancelMonoid.add_zero",
   "AddCommMonoid.mk",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddCancelCommMonoid.add_comm",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddMonoid.mk",
   "AddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCommMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddCommMonoid M",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Other"},
 {"references": ["Units", "Exists", "Monoid", "Units.val", "Eq"],
  "name": "IsUnit",
  "constType": "{M : Type u_1} → [inst : Monoid M] → M → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "PosMulStrictMono",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toPosMulStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], PosMulStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "∀ (n : ℕ), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references": ["Dvd"],
  "name": "Dvd.mk",
  "constType": "{α : Type u_1} → (α → α → Prop) → Dvd α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_6",
  "constType": "∀ (a b c : ℕ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddSemigroup.toAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "IsLeftCancelAdd",
   "IsLeftCancelAdd.mk"],
  "name": "AddLeftCancelSemigroup.toIsLeftCancelAdd",
  "constType":
  "∀ (G : Type u) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Monoid", "DivInvMonoid"],
  "name": "DivInvMonoid.toMonoid",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveInv.toInv",
   "InvolutiveInv.inv_inv",
   "InvolutiveInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_inv",
  "constType": "∀ {G : Type u_1} [inst : InvolutiveInv G] (a : G), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
  "constCategory": "Theorem"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Not",
   "Nat",
   "instLTNat",
   "Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero",
  "constType": "∀ (n : ℕ), ¬n < 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step", "instLENat", "Nat.le.refl", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ",
  "constType": "∀ (n : ℕ), n ≤ Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.nil"],
  "name": "List.rec",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    motive [] → ((head : α) → (tail : List α) → motive tail → motive (head :: tail)) → (t : List α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivInvMonoid",
   "Nat",
   "Nat.succ",
   "Int",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_neg'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_right",
  "constType": "∀ {b c a : Prop}, (b → c) → a ∨ b → a ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toContravariantClassLeLeft",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.le",
   "Eq.ge",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "Eq",
   "LE.le.antisymm",
   "le_of_add_le_add_left",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b c : α), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references": ["Zero", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toZero",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Zero S₀",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "rfl", "Eq"],
  "name": "Nat.gcd_zero_left",
  "constType": "∀ (y : ℕ), Nat.gcd 0 y = y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["DivisionMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group.toDivisionMonoid.proof_1",
   "Group.toDivisionMonoid.proof_2",
   "DivisionMonoid.mk",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Group.toDivisionMonoid",
  "constType": "{G : Type u_1} → [inst : Group G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Or",
   "Nat.below",
   "Or.inr",
   "Unit",
   "GE.ge",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.lt_or_ge.match_2",
   "Nat.le_succ_of_le",
   "PProd.fst",
   "Nat.rec",
   "Or.inl",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "Eq.rec",
   "LT.lt",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.zero_le",
   "Nat.succ",
   "Nat.eq_or_lt_of_le",
   "Nat.lt_or_ge.match_1"],
  "name": "Nat.lt_or_ge",
  "constType": "∀ (n m : ℕ), n < m ∨ n ≥ m",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Sort u) → Trans Eq r r",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.not_succ_le_self.match_1",
   "LE.le",
   "Nat.not_succ_le_zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.not_succ_le_self",
  "constType": "∀ (n : ℕ), ¬Nat.succ n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.instDvdNat",
   "Dvd.dvd",
   "dite",
   "instDecidableEqNat",
   "Eq",
   "Nat.zero",
   "Eq.ndrec",
   "instOfNatNat",
   "Not",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "Nat.dvd_antisymm.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ∣ x_1 → x_1 ∣ x → Prop) (x x_1 : ℕ) (x_2 : x ∣ x_1) (x_3 : x_1 ∣ x),\n  (∀ (x : ℕ) (x_4 : x ∣ 0) (h₂ : 0 ∣ x), motive x 0 x_4 h₂) →\n    (∀ (x : ℕ) (h₁ : 0 ∣ x) (x_4 : x ∣ 0), motive 0 x h₁ x_4) →\n      (∀ (n n_1 : ℕ) (h₁ : n + 1 ∣ n_1 + 1) (h₂ : n_1 + 1 ∣ n + 1), motive (Nat.succ n) (Nat.succ n_1) h₁ h₂) →\n        motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["namedPattern",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.mod.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    ((x : ℕ) → motive 0 x) →\n      ((x n : ℕ) → (h : x = n + 1) → (y : ℕ) → motive (namedPattern x (Nat.succ n) h) y) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "Semigroup",
   "SemigroupWithZero",
   "Eq"],
  "name": "SemigroupWithZero.mk",
  "constType":
  "{S₀ : Type u} →\n  [toSemigroup : Semigroup S₀] →\n    [toZero : Zero S₀] → (∀ (a : S₀), 0 * a = 0) → (∀ (a : S₀), a * 0 = 0) → SemigroupWithZero S₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["DecidableEq", "Bool.decEq", "Bool"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "PosMulStrictMono",
   "Preorder",
   "Mul",
   "Subtype.mk",
   "Subtype",
   "CovariantClass.elim"],
  "name": "mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],\n  b < c → 0 < a → a * b < a * c",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group",
   "mul_left_inv",
   "Group.toDivInvMonoid",
   "Eq",
   "DivInvMonoid.toInv",
   "Inv.inv"],
  "name": "Group.toDivisionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.pow",
  "constType": "{α : Type u} → [self : NatPow α] → α → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Exists",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Nat",
   "congrArg",
   "Eq.trans",
   "LE.le",
   "Eq"],
  "name": "Nat.add_le_add_left",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), k + n ≤ k + m",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "Semiring.npow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_12",
  "constType": "∀ (n x : ℕ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "∀ (n : ℕ), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α], 0 ≤ 1 → ZeroLEOneClass α",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_succ",
   "Nat.succ_le_of_lt",
   "instLENat",
   "Nat.lt_of_succ_le",
   "instAddNat",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Nat.add_le_add_left",
   "Eq"],
  "name": "Nat.add_lt_add_left",
  "constType": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), k + n < k + m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((x : ℕ) → motive x 0) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Irreducible.ne_zero.match_1",
   "Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "False",
   "MonoidWithZero.toMonoid",
   "Irreducible",
   "not_irreducible_zero",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "Irreducible.ne_zero",
  "constType":
  "∀ {α : Type u_1} [inst : MonoidWithZero α] {p : α}, Irreducible p → p ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.ble",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.ble_succ_eq_true.match_1",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.ble_succ_eq_true",
  "constType":
  "∀ {n m : ℕ}, Nat.ble n m = true → Nat.ble n (Nat.succ m) = true",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "CommSemigroup.mul_comm",
  "constType":
  "∀ {G : Type u} [self : CommSemigroup G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Covariant",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Definition"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.compare",
  "constType": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "if_pos",
   "Eq.mpr",
   "Or",
   "Eq.ndrec",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "Eq.refl",
   "Not",
   "Or.casesOn",
   "Eq.symm",
   "if_neg",
   "id",
   "ite",
   "Eq"],
  "name": "ite_congr",
  "constType":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedCancelAddCommMonoid α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references": ["instLENat", "LT.lt", "Nat", "Nat.succ", "LE.le", "instLTNat"],
  "name": "Nat.succ_le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → Nat.succ n ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "IsRightCancelMulZero",
   "Mul",
   "Eq"],
  "name": "IsRightCancelMulZero.mul_right_cancel_of_ne_zero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsRightCancelMulZero M₀] {a b c : M₀},\n  b ≠ 0 → a * b = c * b → a = c",
  "constCategory": "Definition"},
 {"references": ["WellFounded.rec", "WellFounded", "Acc"],
  "name": "WellFounded.apply",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, WellFounded r → ∀ (a : α), Acc r a",
  "constCategory": "Definition"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat", "One", "InvOneClass", "One.toOfNat1", "Inv", "Inv.inv", "Eq"],
  "name": "InvOneClass.mk",
  "constType":
  "{G : Type u_2} → [toOne : One G] → [toInv : Inv G] → 1⁻¹ = 1 → InvOneClass G",
  "constCategory": "Other"},
 {"references":
  ["Nat.le",
   "instLENat",
   "Nat.lt_of_le_of_lt",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "instLTNat",
   "absurd",
   "Nat.succ",
   "rfl",
   "LE.le",
   "Eq",
   "Nat.le_antisymm.match_1"],
  "name": "Nat.le_antisymm",
  "constType": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "DivInvMonoid",
   "HMul.hMul",
   "Nat",
   "DivInvMonoid.toMonoid",
   "Nat.succ",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_succ'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Or",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "GE.ge",
   "HSub.hSub",
   "Nat.mod_eq_sub_mod.match_1",
   "instDecidableAnd",
   "LE.le",
   "rfl",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "ite",
   "Eq",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "if_pos",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "LT.lt",
   "Eq.rec",
   "HMod.hMod",
   "Nat.sub_zero",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Eq.symm",
   "Nat.decLe"],
  "name": "Nat.mod_eq_sub_mod",
  "constType": "∀ {a b : ℕ}, a ≥ b → a % b = (a - b) % b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Ne",
   "Iff",
   "congr_arg",
   "Function.Injective",
   "Function.Injective.ne",
   "mt",
   "Eq"],
  "name": "Function.Injective.ne_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {x y : α}, f x ≠ f y ↔ x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "LE.le", "Preorder.toLE", "Eq", "PartialOrder"],
  "name": "PartialOrder.le_antisymm",
  "constType":
  "∀ {α : Type u} [self : PartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Definition"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.gcd_eq_left",
   "Nat.Coprime.gcd_eq_one",
   "Nat.instDvdNat",
   "Eq.refl",
   "Nat.Coprime",
   "Nat.gcd",
   "instOfNatNat",
   "Dvd.dvd",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.Coprime.eq_one_of_dvd",
  "constType": "∀ {k m : ℕ}, Nat.Coprime k m → k ∣ m → k = 1",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instModNat",
  "constType": "Mod ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "le_antisymm",
   "mt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["NatPow.pow", "NatPow", "Pow.mk", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "{α : Type u_1} → [inst : NatPow α] → Pow α ℕ",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "LE.le",
   "ExistsAddOfLE",
   "Eq"],
  "name": "ExistsAddOfLE.exists_add_of_le",
  "constType":
  "∀ {α : Type u} [inst : Add α] [inst_1 : LE α] [self : ExistsAddOfLE α] {a b : α}, a ≤ b → ∃ c, b = a + c",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (h : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m h",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le.dest.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : (∃ k, n + k = m) → Prop) (this : ∃ k, n + k = m),\n  (∀ (k : ℕ) (h : n + k = m), motive (_ : ∃ k, n + k = m)) → motive this",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHMul",
   "Nat.mul_assoc",
   "of_eq_true",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Nat.dvd_trans.match_1",
   "Dvd.dvd",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "Nat.dvd_trans",
  "constType": "∀ {a b c : ℕ}, a ∣ b → b ∣ c → a ∣ c",
  "constCategory": "Theorem"},
 {"references": ["Nat.modCore._unary", "PSigma.mk", "Nat"],
  "name": "Nat.modCore",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.gcd.induction.match_1",
   "HMod.hMod",
   "instOfNatNat",
   "Nat.mod_lt",
   "Nat.strongInductionOn",
   "Nat",
   "instLTNat",
   "Nat.succ_pos"],
  "name": "Nat.gcd.induction",
  "constType":
  "∀ {P : ℕ → ℕ → Prop} (m n : ℕ), (∀ (n : ℕ), P 0 n) → (∀ (m n : ℕ), 0 < m → P (n % m) m → P m n) → P m n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CancelMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "IsCancelMulZero",
   "MonoidWithZero.toZero",
   "MonoidWithZero"],
  "name": "CancelMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toMonoidWithZero : MonoidWithZero M₀] → [toIsCancelMulZero : IsCancelMulZero M₀] → CancelMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : ContravariantClass M N μ r],\n  Contravariant M N μ r",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Nat.mul_lt_mul_of_pos_left",
   "instLTNat",
   "Eq",
   "GT.gt"],
  "name": "Nat.mul_lt_mul_of_pos_right",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → n * k < m * k",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat.pow", "Nat", "NatPow.mk"],
  "name": "instNatPowNat",
  "constType": "NatPow ℕ",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mul_inv_rev",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inv",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.nsmul_succ",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (n : ℕ) (x : α),\n  AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Zero", "IsCancelMulZero", "IsRightCancelMulZero", "Mul"],
  "name": "IsCancelMulZero.toIsRightCancelMulZero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsCancelMulZero M₀], IsRightCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "List.cons",
   "PUnit.unit",
   "List.rec",
   "List.below",
   "List",
   "PUnit",
   "List.nil",
   "PProd.mk"],
  "name": "List.brecOn",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "constCategory": "Other"},
 {"references": ["instLENat", "LT.lt", "Nat", "instLTNat", "Nat.succ", "LE.le"],
  "name": "Nat.lt_of_succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat", "LT.lt", "Nat", "LE.le", "Nat.le_of_succ_le", "instLTNat"],
  "name": "Nat.le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "inferInstance",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.linearOrderedSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_9",
  "constType": "NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references": ["Bool.false", "Bool.true", "Bool.rec", "Bool"],
  "name": "Bool.casesOn",
  "constType":
  "{motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "instNatPowNat",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "∀ (x x_1 : ℕ), (fun m n => m * n) (x + 1) x_1 = x_1 + (fun m n => m * n) x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Or",
   "MulOneClass.toMul",
   "Monoid",
   "Irreducible",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Irreducible.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, ¬IsUnit p → (∀ (a b : α), p = a * b → IsUnit a ∨ IsUnit b) → Irreducible p",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Inv",
   "Inv.inv"],
  "name": "DivInvMonoid.div'",
  "constType": "{G : Type u} → [inst : Monoid G] → [inst : Inv G] → G → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5134",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5095",
   "Inv",
   "Eq",
   "instHMul",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5056",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Int",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5173",
   "Inv.inv"],
  "name": "DivInvMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toMonoid : Monoid G] →\n    [toInv : Inv G] →\n      [toDiv : Div G] →\n        autoParam (∀ (a b : G), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G → G) →\n            autoParam (∀ (a : G), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  DivInvMonoid G",
  "constCategory": "Other"},
 {"references":
  ["instDecidableAnd.proof_2",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "And.intro",
   "instDecidableAnd.proof_1"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "lt_add_of_pos_right",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder",
   "AddZeroClass.toZero",
   "NeZero",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "zero_lt_one",
   "AddZeroClass"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] [inst_5 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HMod",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Nat.div", "Div.mk", "Div", "Nat"],
  "name": "Nat.instDivNat",
  "constType": "Div ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Int"],
  "name": "DivInvMonoid.zpow",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{α : Type u} → (α → α) → Inv α",
  "constCategory": "Other"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (n : ℕ) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroup",
   "HMul.hMul",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "CommGroup.mk",
  "constType":
  "{G : Type u} → [toGroup : Group G] → (∀ (a b : G), a * b = b * a) → CommGroup G",
  "constCategory": "Other"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_trans.match_1",
  "constType":
  "∀ {n m : ℕ} (motive : (k : ℕ) → n ≤ m → m ≤ k → Prop) (k : ℕ) (x : n ≤ m) (x_1 : m ≤ k),\n  (∀ (h : n ≤ m), motive m h (_ : Nat.le m m)) →\n    (∀ (h₁ : n ≤ m) (m_1 : ℕ) (h₂ : Nat.le m m_1), motive (Nat.succ m_1) h₁ (_ : Nat.le m (Nat.succ m_1))) →\n      motive k x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instLENat",
   "Bot.mk",
   "instOfNatNat",
   "OrderBot",
   "OrderBot.mk",
   "Nat.zero_le",
   "Nat"],
  "name": "Nat.orderBot",
  "constType": "OrderBot ℕ",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.mk",
   "Nat.decLt",
   "Nat",
   "compareOfLessAndEq",
   "instLTNat",
   "instDecidableEqNat",
   "Ord"],
  "name": "instOrdNat",
  "constType": "Ord ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "False",
   "GE.ge",
   "instLTNat",
   "LE.le",
   "GT.gt",
   "Eq",
   "Nat.le_total.match_1",
   "instLENat",
   "Eq.subst",
   "LT.lt",
   "Nat.lt_trans",
   "Nat.lt_irrefl",
   "Not",
   "Nat.lt_or_ge",
   "Nat",
   "Nat.le_antisymm",
   "absurd"],
  "name": "Nat.not_le_of_gt",
  "constType": "∀ {n m : ℕ}, n > m → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Units.instGroupUnits.proof_4",
   "zpowRec",
   "MulOneClass.toMul",
   "Monoid.mk",
   "Units.instInv",
   "Units.instGroupUnits.proof_8",
   "MulOneClass",
   "Units.instGroupUnits.proof_7",
   "npowRec",
   "Units.instGroupUnits.proof_10",
   "Inv.mk",
   "Units.val_inv",
   "inferInstance",
   "Group.mk",
   "Div.mk",
   "Group",
   "Units.mk",
   "Units.instGroupUnits.proof_3",
   "Semigroup.mk",
   "Units.instGroupUnits.proof_11",
   "Units.instGroupUnits.proof_2",
   "Monoid",
   "MulOneClass.toOne",
   "Units.inv_val",
   "Units.instGroupUnits.proof_5",
   "DivInvMonoid.mk",
   "Units.instGroupUnits.proof_1",
   "DivInvMonoid.div'",
   "Units.inv",
   "Units.instGroupUnits.proof_9",
   "Units",
   "Units.instMulOneClassUnits",
   "Units.instGroupUnits.proof_6",
   "Units.val",
   "Inv.inv"],
  "name": "Units.instGroupUnits",
  "constType": "{α : Type u} → [inst : Monoid α] → Group αˣ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMod α β γ",
  "constCategory": "Other"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatPow",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "zpowRec",
   "MulOneClass.toMul",
   "Monoid.mk",
   "OfNat.ofNat",
   "Units.instInv",
   "Monoid.toOne",
   "instOfNatInt",
   "MulOneClass",
   "HAdd.hAdd",
   "Eq.refl",
   "npowRec",
   "Inv.mk",
   "Eq",
   "Units.val_inv",
   "inferInstance",
   "mul_assoc",
   "Div.mk",
   "MulOneClass.one_mul",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Units.mk",
   "Semigroup.mk",
   "Monoid.toSemigroup",
   "instHDiv",
   "Monoid",
   "instAddNat",
   "Units.inv_val",
   "MulOneClass.toOne",
   "instHAdd",
   "One.toOfNat1",
   "DivInvMonoid.mk",
   "Units.inv",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.div'",
   "DivInvMonoid.toInv",
   "instHMul",
   "Units",
   "MulOneClass.mul_one",
   "Units.ext",
   "Units.instMulOneClassUnits",
   "Int.negSucc",
   "Units.val",
   "HMul.hMul",
   "Int",
   "Inv.inv"],
  "name": "Units.instGroupUnits.proof_11",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (u : αˣ), u⁻¹ * u = 1",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.zero_mul",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["Mod"],
  "name": "Mod.mod",
  "constType": "{α : Type u} → [self : Mod α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{α : Type u} → (α → α → α) → Div α",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoid.toMonoid",
   "IsLeftCancelMulZero",
   "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
  "constType":
  "∀ {M₀ : Type u_4} [self : CancelCommMonoidWithZero M₀], IsLeftCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.dvd_add_iff_right.match_2",
   "Nat.mul_sub_left_distrib",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "Nat.dvd_add_iff_right.match_1",
   "HAdd.hAdd",
   "Nat.instDvdNat",
   "HSub.hSub",
   "Eq.refl",
   "Dvd.dvd",
   "Exists.intro",
   "Eq",
   "Iff.intro",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Nat.add_sub_cancel_left",
   "Eq.ndrec",
   "Nat.dvd_add",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "id"],
  "name": "Nat.dvd_add_iff_right",
  "constType": "∀ {k m n : ℕ}, k ∣ m → (k ∣ n ↔ k ∣ m + n)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : ℕ) → Decidable (n = m)",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references":
  ["add_left_cancel",
   "Function.Injective",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_right_injective",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G), Function.Injective fun x => a + x",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "False",
   "false_and",
   "Mathlib.Algebra.Associated._auxLemma.3",
   "Irreducible",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "True",
   "Mathlib.Algebra.Group.Units._auxLemma.25",
   "Eq",
   "And",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "not_true_eq_false",
   "Not",
   "IsUnit",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "not_irreducible_one",
  "constType": "∀ {α : Type u_1} [inst : Monoid α], ¬Irreducible 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHDiv",
   "inv_eq_one_div",
   "Monoid.toOne",
   "DivInvMonoid",
   "One.toOfNat1",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Eq",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv",
   "Inv.inv"],
  "name": "one_div",
  "constType": "∀ {G : Type u_3} [inst : DivInvMonoid G] (a : G), 1 / a = a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, (∀ (a : α), Acc r a) → WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ≠ a + c ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelMonoid", "Nat"],
  "name": "AddRightCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Nat",
   "Nat.dvd_add_iff_right",
   "Eq",
   "id"],
  "name": "Nat.dvd_add_iff_left",
  "constType": "∀ {k m n : ℕ}, k ∣ n → (k ∣ m ↔ k ∣ m + n)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "Mul",
   "IsLeftCancelMulZero",
   "Eq"],
  "name": "IsLeftCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀],\n  (∀ {a b c : M₀}, a ≠ 0 → a * b = a * c → b = c) → IsLeftCancelMulZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Units.instGroupUnits",
   "Units",
   "CommGroup.mk",
   "CommMonoid",
   "CommGroup",
   "CommMonoid.toMonoid",
   "Units.instCommGroupUnits.proof_1"],
  "name": "Units.instCommGroupUnits",
  "constType": "{α : Type u_1} → [inst : CommMonoid α] → CommGroup αˣ",
  "constCategory": "Definition"},
 {"references":
  ["ContravariantClass.elim",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["le_self_add",
   "AddZeroClass.toAdd",
   "Exists",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "LE.le",
   "ExistsAddOfLE.exists_add_of_le",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.ndrec",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "le_iff_exists_add",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b ↔ ∃ c, b = a + c",
  "constCategory": "Theorem"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_of_le_of_lt.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare", "Ordering", "Eq.refl", "instOrdNat", "Nat", "Eq"],
  "name": "Nat.linearOrder.proof_3",
  "constType": "∀ (a b : ℕ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["Eq.rec", "le_refl", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat"],
  "name": "Nat.le.refl",
  "constType": "∀ {n : ℕ}, Nat.le n n",
  "constCategory": "Other"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.ble_succ_eq_true.match_1",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → Nat.ble x x_1 = true → Prop) (x x_1 : ℕ) (x_2 : Nat.ble x x_1 = true),\n  (∀ (x : ℕ) (x_3 : Nat.ble 0 x = true), motive 0 x x_3) →\n    (∀ (n n_1 : ℕ) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) →\n      motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references":
  ["instHDiv",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.dvd_mul_right",
   "Nat.dvd_trans",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Eq",
   "Nat.instModNat",
   "instHMul",
   "instHMod",
   "Eq.ndrec",
   "Iff",
   "Nat.mod_add_div",
   "Eq.mp",
   "Nat.dvd_add_iff_left",
   "HMod.hMod",
   "HMul.hMul",
   "HDiv.hDiv",
   "Nat.instDivNat",
   "Nat",
   "instMulNat"],
  "name": "Nat.dvd_mod_iff",
  "constType": "∀ {k m n : ℕ}, k ∣ n → (k ∣ m % n ↔ k ∣ m)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b : M), a + b = b + a) → AddCancelCommMonoid M",
  "constCategory": "Other"},
 {"references": [],
  "name": "DivInvOneMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["WellFoundedRelation.wf",
   "WellFoundedRelation.rel",
   "LT.lt",
   "Nat.lt_wfRel",
   "Nat",
   "WellFounded.fix",
   "instLTNat"],
  "name": "Nat.strongInductionOn",
  "constType":
  "{motive : ℕ → Sort u} → (n : ℕ) → ((n : ℕ) → ((m : ℕ) → m < n → motive m) → motive n) → motive n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "OfNat.ofNat",
   "instSubNat",
   "HAdd.hAdd",
   "Nat.decLt",
   "Eq.refl",
   "instLTNat",
   "True",
   "Eq",
   "ite",
   "Nat.sub_add_cancel",
   "And.right",
   "Eq.mpr",
   "Nat.mod_eq",
   "instLENat",
   "instOfNatNat",
   "Nat.instDivNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.trans",
   "Nat.decLe",
   "id",
   "eq_self",
   "Nat.mul_succ",
   "instHSub",
   "instHDiv",
   "False",
   "instAddNat",
   "instHAdd",
   "HSub.hSub",
   "instDecidableAnd",
   "instDecidableTrue",
   "LE.le",
   "ite_congr",
   "Nat.mod.inductionOn",
   "instDecidableFalse",
   "And",
   "instHMul",
   "Nat.instModNat",
   "eq_false",
   "eq_true",
   "instHMod",
   "Eq.ndrec",
   "of_eq_true",
   "LT.lt",
   "congr",
   "HMul.hMul",
   "HMod.hMod",
   "Not",
   "instMulNat",
   "congrArg",
   "Nat.div_eq",
   "and_self",
   "congrFun"],
  "name": "Nat.mod_add_div",
  "constType": "∀ (m k : ℕ), m % k + k * (m / k) = m",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4053",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4011",
   "Nat",
   "autoParam",
   "Eq"],
  "name": "AddRightCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddRightCancelSemigroup : AddRightCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddRightCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CancelMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "IsCancelMulZero",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero"],
  "name": "CancelMonoidWithZero.toIsCancelMulZero",
  "constType":
  "∀ {M₀ : Type u_4} [self : CancelMonoidWithZero M₀], IsCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat.le_trans",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_le_of_lt",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Min",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.mul_one",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.gt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["IsCancelMulZero.mk",
   "Zero",
   "IsRightCancelMulZero.mul_right_cancel_of_ne_zero",
   "CommSemigroup.toCommMagma",
   "IsCancelMulZero",
   "IsRightCancelMulZero.mk",
   "IsRightCancelMulZero",
   "IsLeftCancelMulZero.to_isRightCancelMulZero",
   "CommMagma.toMul",
   "IsLeftCancelMulZero",
   "CommSemigroup"],
  "name": "IsLeftCancelMulZero.to_isCancelMulZero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CommSemigroup M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀], IsCancelMulZero M₀",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left.match_1",
  "constType":
  "∀ {a b c : ℕ} (motive : (∃ k, a + b + k = a + c) → Prop) (x : ∃ k, a + b + k = a + c),\n  (∀ (d : ℕ) (hd : a + b + d = a + c), motive (_ : ∃ k, a + b + k = a + c)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.zero_mul",
   "CommMonoidWithZero.toZero",
   "MonoidWithZero.mk",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "MonoidWithZero"],
  "name": "CommMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "rfl",
   "absurd",
   "ite",
   "Eq"],
  "name": "if_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "Nat.linearOrderedCommSemiring.proof_3",
  "constType": "∀ (a b : ℕ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["CancelCommMonoidWithZero.toIsLeftCancelMulZero",
   "CommMonoidWithZero.toZero",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "IsLeftCancelMulZero.to_isCancelMulZero",
   "CommSemigroup.toCommMagma",
   "CommMonoidWithZero.toCommMonoid",
   "IsCancelMulZero",
   "CommMagma.toMul",
   "CommMonoid.toCommSemigroup",
   "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCancelMonoidWithZero.proof_1",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CancelCommMonoidWithZero M₀], IsCancelMulZero M₀",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.zero_mul",
   "CommMonoidWithZero.toZero",
   "Nat.commSemiring",
   "inferInstance",
   "Nat.cancelCommMonoidWithZero.proof_1",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoidWithZero.mk",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "CommMonoidWithZero",
   "CancelCommMonoidWithZero",
   "CancelCommMonoidWithZero.mk"],
  "name": "Nat.cancelCommMonoidWithZero",
  "constType": "CancelCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5056",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.decLt",
   "Nat.modCore",
   "HSub.hSub",
   "Eq.refl",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "Nat.instModNat",
   "And",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "instLENat",
   "LT.lt",
   "HMod.hMod",
   "Nat.modCore_eq_mod",
   "instOfNatNat",
   "Nat",
   "_private.Init.Data.Nat.Div.0.Nat.modCore._eq_1",
   "Eq.symm",
   "Nat.decLe",
   "id"],
  "name": "Nat.mod_eq",
  "constType": "∀ (x y : ℕ), x % y = if 0 < y ∧ y ≤ x then (x - y) % y else x",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool"],
  "name": "Bool.noConfusionType",
  "constType": "Sort u → Bool → Bool → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "One.toOfNat1",
   "Eq",
   "Units",
   "InvOneClass.toOne",
   "Eq.ndrec",
   "Nat.commMonoid",
   "HEq.refl",
   "Units.instCommGroupUnits",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionCommMonoid.toDivisionMonoid",
   "Units.val",
   "Nat.monoid",
   "IsUnit",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "DivisionMonoid.toDivInvOneMonoid",
   "CommGroup.toDivisionCommMonoid"],
  "name": "Nat.isUnit_iff.match_1",
  "constType":
  "∀ (motive : (n : ℕ) → (u : ℕˣ) → ↑u = n → u = 1 → IsUnit n → Prop) (n : ℕ) (u : ℕˣ) (hu : ↑u = n) (x : u = 1)\n  (x_1 : IsUnit n), (∀ (x : IsUnit ↑1), motive (↑1) 1 (_ : ↑1 = ↑1) (_ : 1 = 1) x) → motive n u hu x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.gcd_dvd_left",
   "Nat.instDvdNat",
   "Nat.dvd_refl",
   "Nat.gcd",
   "Dvd.dvd",
   "Nat.dvd_antisymm",
   "Nat",
   "Nat.dvd_gcd",
   "Eq"],
  "name": "Nat.gcd_eq_left",
  "constType": "∀ {m n : ℕ}, m ∣ n → Nat.gcd m n = m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_of_le_of_lt",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "pos_of_gt",
  "constType":
  "∀ {M : Type u_1} [inst : CanonicallyOrderedAddCommMonoid M] {n m : M}, n < m → 0 < m",
  "constCategory": "Theorem"},
 {"references": ["Nat.div._unary", "PSigma.mk", "Nat"],
  "name": "Nat.div",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddLeftCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Acc.rec", "Acc"],
  "name": "WellFounded.fixF",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} → {C : α → Sort v} → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → Acc r x → C x",
  "constCategory": "Definition"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Contravariant M N μ r → ContravariantClass M N μ r",
  "constCategory": "Other"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "constCategory": "Other"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_irrefl.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x : α) → x < x → Prop) (x : α) (x_1 : x < x),\n  (∀ (_a : α) (haa : _a < _a), motive _a haa) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_4",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.one_mul",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "OfNat.ofNat",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "LE.le",
   "instLTNat"],
  "name": "Nat.mod_zero.match_1",
  "constType":
  "∀ (a : ℕ) (motive : 0 < 0 ∧ 0 ≤ a → Prop) (x : 0 < 0 ∧ 0 ≤ a),\n  (∀ (h₁ : 0 < 0) (right : 0 ≤ a), motive (_ : 0 < 0 ∧ 0 ≤ a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "add_assoc",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.rec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "congr",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references": ["Units", "Monoid"],
  "name": "Units.inv",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Eq.rec",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "Eq.symm",
   "absurd",
   "instLTNat",
   "Eq"],
  "name": "Nat.ne_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references": ["CommMonoid", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toCommMonoid",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → CommMonoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "Or",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "autoParam",
   "NatCast.natCast",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4212",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4173",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) →\n            (∀ (a : α), a * 0 = 0) →\n              (∀ (a b c : α), a * b * c = a * (b * c)) →\n                [toOne : One α] →\n                  (∀ (a : α), 1 * a = a) →\n                    (∀ (a : α), a * 1 = a) →\n                      [toNatCast : NatCast α] →\n                        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n                          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                            (npow : ℕ → α → α) →\n                              autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                                autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ →\n                                  (∀ (a b : α), a * b = b * a) →\n                                    (∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0) → CanonicallyOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references": ["WellFoundedRelation", "WellFounded"],
  "name": "WellFoundedRelation.mk",
  "constType":
  "{α : Sort u} → (rel : α → α → Prop) → WellFounded rel → WellFoundedRelation α",
  "constCategory": "Other"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "IsRightCancelMulZero",
   "Mul",
   "Eq"],
  "name": "IsRightCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀],\n  (∀ {a b c : M₀}, b ≠ 0 → a * b = c * b → a = c) → IsRightCancelMulZero M₀",
  "constCategory": "Other"},
 {"references": ["Decidable"],
  "name": "Decidable.isTrue",
  "constType": "{p : Prop} → p → Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_wfRel.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : m = n ∨ m < n → Prop) (this : m = n ∨ m < n),\n  (∀ (e : m = n), motive (_ : m = n ∨ m < n)) → (∀ (e : m < n), motive (_ : m = n ∨ m < n)) → motive this",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCancelCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_1",
  "constType":
  "∀ (motive : Nat.succ 0 ≤ 0 → Prop) (h : Nat.succ 0 ≤ 0), motive h",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.wf",
   "measure",
   "WellFoundedRelation.rel",
   "WellFounded",
   "Nat",
   "id"],
  "name": "Nat.gcd.proof_1",
  "constType": "WellFounded WellFoundedRelation.rel",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Preorder.toLT", "LT.lt", "Ne.symm", "Preorder", "LT.lt.ne"],
  "name": "LT.lt.ne'",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddRightCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Group"],
  "name": "Group.toDivInvMonoid",
  "constType": "{G : Type u} → [self : Group G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFoundedRelation",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "ZeroLEOneClass.zero_le_one",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "zero_le_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "instHMul",
   "Units",
   "mul_assoc",
   "MulOneClass.toMul",
   "Monoid",
   "Units.ext",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "Units.val",
   "HMul.hMul",
   "Eq"],
  "name": "Units.instGroupUnits.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (x x_1 x_2 : αˣ), x * x_1 * x_2 = x * (x_1 * x_2)",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((a : ℕ) → motive a Nat.zero) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "forall_exists_index.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ x, p x) → Prop) (x : ∃ x, p x),\n  (∀ (x : α) (hpx : p x), motive (_ : ∃ x, p x)) → motive x",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivInvMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["WellFounded.apply",
   "WellFounded.intro",
   "WellFounded",
   "InvImage",
   "InvImage.accessible"],
  "name": "InvImage.wf",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} (f : α → β), WellFounded r → WellFounded (InvImage r f)",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_inv",
  "constType": "∀ {G : Type u} [self : DivisionMonoid G] (x : G), x⁻¹⁻¹ = x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gcd.induction",
   "Nat.gcd_zero_left",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Nat.dvd_refl",
   "Nat.dvd_zero",
   "And.left",
   "Nat.dvd_mod_iff",
   "instLTNat",
   "Nat.gcd_rec",
   "Eq",
   "Nat.instModNat",
   "And",
   "And.right",
   "instHMod",
   "Eq.mpr",
   "Iff.mp",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "HMod.hMod",
   "Nat.gcd",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Nat.gcd_dvd",
  "constType": "∀ (m n : ℕ), Nat.gcd m n ∣ m ∧ Nat.gcd m n ∣ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "Mul", "Eq"],
  "name": "CommMagma.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b : G), a * b = b * a) → CommMagma G",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x ≤ x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x ≤ x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a ≤ _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "OfNat.ofNat",
   "HEq",
   "instLENat",
   "HEq.refl",
   "Nat.noConfusion",
   "Eq.refl",
   "Nat.le.refl",
   "instOfNatNat",
   "Nat.le.casesOn",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.not_succ_le_zero.match_2",
  "constType":
  "∀ (n : ℕ) (motive : Nat.succ (Nat.succ n) ≤ 0 → Prop) (h : Nat.succ (Nat.succ n) ≤ 0), motive h",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (x : α), (∀ (y : α), r y x → Acc r y) → Acc r x",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Exists.elim",
   "Dvd.dvd",
   "semigroupDvd",
   "Semigroup",
   "Eq"],
  "name": "Dvd.elim",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] {P : Prop} {a b : α}, a ∣ b → (∀ (c : α), b = a * c → P) → P",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Nat", "LE.le", "Nat.succ", "Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ Nat.succ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["Acc.recOn", "Acc"],
  "name": "Acc.inv",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {x y : α}, Acc r x → r y x → Acc r y",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "inferInstance",
   "CommMonoid",
   "CommSemiring.toCommMonoid",
   "Nat"],
  "name": "Nat.commMonoid",
  "constType": "CommMonoid ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SemigroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → Prop) (x : _a ≤ _b ∧ ¬_b ≤ _a),\n  (∀ (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive (_ : _a ≤ _b ∧ ¬_b ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Dvd",
   "Eq"],
  "name": "Nat.instDvdNat",
  "constType": "Dvd ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["lt_of_le_not_le",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "dite",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.lt_or_eq_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Preorder.lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Unit",
   "Nat.ble_self_eq_true",
   "Nat.ble_eq_true_of_le.match_1",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.ble_succ_eq_true",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.ble n m = true",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references":
  ["Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulOneClass",
   "One.mk",
   "Units.instMulOneClassUnits.proof_4",
   "One.toOfNat1",
   "Units.instMulOneClassUnits.proof_2",
   "MulOneClass.mk",
   "Units.inv",
   "Units.instMulOneClassUnits.proof_1",
   "Monoid.toMulOneClass",
   "Units",
   "instHMul",
   "Units.instMulOneClassUnits.proof_5",
   "Units.val",
   "HMul.hMul",
   "Units.mk",
   "Units.instMulOneClassUnits.proof_3",
   "Mul.mk"],
  "name": "Units.instMulOneClassUnits",
  "constType": "{α : Type u} → [inst : Monoid α] → MulOneClass αˣ",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelMonoid.toZero",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff.mp",
   "Iff",
   "And.symm.match_1",
   "And.intro",
   "Iff.mpr"],
  "name": "and_congr_right",
  "constType": "∀ {a b c : Prop}, (a → (b ↔ c)) → (a ∧ b ↔ a ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references": ["Decidable.isFalse", "Decidable", "Decidable.isTrue", "Not"],
  "name": "Decidable.rec",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → (t : Decidable p) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_7",
  "constType": "∀ (a : ℕ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "Or",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Nat.instDvdNat",
   "Eq.refl",
   "One.toOfNat1",
   "Dvd.dvd",
   "NonAssocSemiring.toMulZeroOneClass",
   "Exists.casesOn",
   "Or.imp_right",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.Prime",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "Eq.mp",
   "Nat.monoid",
   "HMul.hMul",
   "Irreducible.isUnit_or_isUnit",
   "mul_one",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.isUnit_iff",
   "Nat.semiring",
   "id"],
  "name": "Nat.Prime.eq_one_or_self_of_dvd",
  "constType": "∀ {p : ℕ}, Nat.Prime p → ∀ (m : ℕ), m ∣ p → m = 1 ∨ m = p",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Eq.refl", "Nat", "Nat.instMaxNat", "Eq"],
  "name": "Nat.linearOrder.proof_2",
  "constType": "∀ (a b : ℕ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "False",
   "instLENat",
   "Bool.true",
   "Not",
   "Bool",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "absurd",
   "LE.le",
   "Eq"],
  "name": "Nat.not_le_of_not_ble_eq_true",
  "constType": "∀ {n m : ℕ}, ¬Nat.ble n m = true → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHMul",
   "OfNat.ofNat",
   "of_eq_true",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Dvd.dvd",
   "instOfNatNat",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.dvd_zero",
  "constType": "∀ (a : ℕ), a ∣ 0",
  "constCategory": "Theorem"},
 {"references": ["WellFounded.intro", "WellFounded", "Acc"],
  "name": "WellFounded.rec",
  "constType":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : WellFounded r → Sort u_1} →\n      ((h : ∀ (a : α), Acc r a) → motive (_ : WellFounded r)) → (t : WellFounded r) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "and_congr_right",
   "Nat.le_of_dvd",
   "Nat.instDvdNat",
   "Nat.ne_of_lt",
   "Or.resolve_right",
   "Dvd.dvd",
   "Nat.le_of_succ_le",
   "LE.le",
   "instLTNat",
   "Eq",
   "Iff.intro",
   "And",
   "Or.imp_left",
   "Nat.Prime",
   "Iff",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "LE.le.lt_or_eq_dec",
   "Iff.trans",
   "instOfNatNat",
   "Nat",
   "Nat.prime_def_lt''",
   "Nat.succ",
   "Nat.decLe",
   "Nat.strictOrderedSemiring",
   "forall_congr'"],
  "name": "Nat.prime_def_lt",
  "constType": "∀ {p : ℕ}, Nat.Prime p ↔ 2 ≤ p ∧ ∀ m < p, m ∣ p → m = 1",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "CancelMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "Units.val",
   "HMul.hMul",
   "One.toOfNat1",
   "Units.casesOn",
   "Units.mk",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Units.ext.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (motive : (x x_1 : αˣ) → ↑x = ↑x_1 → Prop) (x x_1 : αˣ) (x_2 : ↑x = ↑x_1),\n  (∀ (v i₁ : α) (vi₁ : v * i₁ = 1) (iv₁ : i₁ * v = 1) (v' i₂ : α) (vi₂ : v' * i₂ = 1) (iv₂ : i₂ * v' = 1)\n      (e :\n        ↑{ val := v, inv := i₁, val_inv := vi₁, inv_val := iv₁ } =\n          ↑{ val := v', inv := i₂, val_inv := vi₂, inv_val := iv₂ }),\n      motive { val := v, inv := i₁, val_inv := vi₁, inv_val := iv₁ }\n        { val := v', inv := i₂, val_inv := vi₂, inv_val := iv₂ } e) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "CanonicallyOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["WellFoundedRelation.rel",
   "invImage.proof_1",
   "WellFoundedRelation",
   "InvImage",
   "WellFoundedRelation.mk"],
  "name": "invImage",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (α → β) → WellFoundedRelation β → WellFoundedRelation α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Or",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Order.Basic._auxLemma.1",
   "Or.casesOn",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "instHMul",
   "Decidable.eq_or_lt_of_le",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "le_refl",
   "mul_lt_mul_of_pos_right",
   "congr",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] (a b c : α),\n  a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.succ_le_succ.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (x : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "HMod.hMod",
   "Nat.gcd",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.gcd_succ",
  "constType":
  "∀ (x y : ℕ), Nat.gcd (Nat.succ x) y = Nat.gcd (y % Nat.succ x) (Nat.succ x)",
  "constCategory": "Theorem"},
 {"references":
  ["add_left_cancel",
   "AddCommMagma",
   "add_comm",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "IsRightCancelAdd.mk",
   "AddCommMagma.toAdd",
   "Eq.trans",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ (G : Type u) [inst : AddCommMagma G] [inst_1 : IsLeftCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.atom",
  "constType": "Lean.SourceInfo → String → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references": ["Monoid", "Semigroup"],
  "name": "Monoid.toSemigroup",
  "constType": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.inv_inv",
   "DivisionMonoid.toDivInvMonoid",
   "InvolutiveInv",
   "DivInvMonoid.toInv",
   "InvolutiveInv.mk"],
  "name": "DivisionMonoid.toInvolutiveInv",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → InvolutiveInv G",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Or",
   "False",
   "Irreducible",
   "MulZeroClass.mul_zero",
   "MulZeroOneClass.toMulZeroClass",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "not_irreducible_zero.match_1",
   "MonoidWithZero.toMonoid",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "Or.elim",
   "MonoidWithZero"],
  "name": "not_irreducible_zero",
  "constType": "∀ {α : Type u_1} [inst : MonoidWithZero α], ¬Irreducible 0",
  "constCategory": "Theorem"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_left_cancel",
   "Exists",
   "Nat.le_of_add_le_add_left.match_1",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.mp",
   "Eq.refl",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left",
  "constType": "∀ {a b c : ℕ}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Nat.monoid",
   "Not",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Irreducible.ne_one"],
  "name": "Nat.not_prime_one",
  "constType": "¬Nat.Prime 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Nat.zero_mul",
   "Nat.instDvdNat",
   "HMul.hMul",
   "instOfNatNat",
   "Dvd.dvd",
   "instMulNat",
   "Nat",
   "Eq.trans",
   "Nat.eq_zero_of_zero_dvd.match_1",
   "Eq"],
  "name": "Nat.eq_zero_of_zero_dvd",
  "constType": "∀ {a : ℕ}, 0 ∣ a → a = 0",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["DivInvOneMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.mk",
  "constType":
  "{G : Type u_2} → [toDivInvMonoid : DivInvMonoid G] → 1⁻¹ = 1 → DivInvOneMonoid G",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "Eq",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4173",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4212",
   "One",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            autoParam (∀ (x : M), npow 0 x = 1) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), npow (n + 1) x = x * npow n x) _auto✝¹ → Monoid M",
  "constCategory": "Other"},
 {"references":
  ["Nat.ne_of_gt",
   "OfNat.ofNat",
   "Nat.pos_of_ne_zero",
   "Eq.rec",
   "Nat.eq_zero_of_zero_dvd",
   "LT.lt",
   "Nat.instDvdNat",
   "instOfNatNat",
   "Dvd.dvd",
   "Nat",
   "instLTNat",
   "Eq"],
  "name": "Nat.pos_of_dvd_of_pos",
  "constType": "∀ {m n : ℕ}, m ∣ n → 0 < n → 0 < m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "Semigroup.toMul",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "SemigroupWithZero.toZero",
   "Eq",
   "SemigroupWithZero"],
  "name": "SemigroupWithZero.zero_mul",
  "constType":
  "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "LinearOrder.toPartialOrder",
   "Preorder.le_trans",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Nat.le_of_mul_le_mul_left",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "Nat.le_antisymm",
   "Nat.le_of_eq",
   "instLTNat",
   "Eq"],
  "name": "Nat.eq_of_mul_eq_mul_left",
  "constType": "∀ {m k n : ℕ}, 0 < n → n * m = n * k → m = k",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ord",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references":
  ["mul_comm",
   "Semigroup.toMul",
   "Units.instGroupUnits",
   "Monoid.toSemigroup",
   "instHMul",
   "Units",
   "Units.ext",
   "CommMonoid",
   "CommSemigroup.toCommMagma",
   "Units.val",
   "HMul.hMul",
   "Group.toDivInvMonoid",
   "CommMonoid.toMonoid",
   "DivInvMonoid.toMonoid",
   "CommMonoid.toCommSemigroup",
   "Eq"],
  "name": "Units.instCommGroupUnits.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoid α] (x x_1 : αˣ), x * x_1 = x_1 * x",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma.add_comm",
   "AddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "DivInvMonoid.div_eq_mul_inv",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "Semiring.npow",
   "CommMonoid",
   "CommSemiring",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommSemiring.toCommMonoid",
  "constType": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.inv_one",
  "constType": "∀ {G : Type u_2} [self : DivInvOneMonoid G], 1⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "String",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "IsLeftCancelMulZero.mul_left_cancel_of_ne_zero",
   "Mul",
   "IsLeftCancelMulZero",
   "Eq"],
  "name": "mul_left_cancel₀",
  "constType":
  "∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5134",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "propext",
   "Nat.monoid",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Nat.isUnit_iff",
   "Eq"],
  "name": "Mathlib.Data.Nat.Prime._auxLemma.1",
  "constType": "∀ {n : ℕ}, IsUnit n = (n = 1)",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "CommMagma",
   "CommMagma.mk",
   "CommSemigroup.mul_comm",
   "CommSemigroup",
   "CommSemigroup.toSemigroup"],
  "name": "CommSemigroup.toCommMagma",
  "constType": "{G : Type u} → [self : CommSemigroup G] → CommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "LT.lt",
   "HMod.hMod",
   "Nat.mod_lt",
   "Nat.zero_lt_succ",
   "Nat",
   "instLTNat",
   "Nat.succ"],
  "name": "_private.Init.Data.Nat.Gcd.0.Nat.gcdF.proof_1",
  "constType": "∀ (x y : ℕ), y % Nat.succ x < Nat.succ x",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.nil", "Nat", "Array.mk"],
  "name": "Array.mkEmpty",
  "constType": "{α : Type u} → ℕ → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ.injEq",
   "implies_congr",
   "Eq",
   "Nat.zero_add",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "id"],
  "name": "Nat.add_left_cancel",
  "constType": "∀ {n m k : ℕ}, n + m = n + k → m = k",
  "constCategory": "Theorem"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    (Unit → motive Nat.zero Nat.zero) →\n      ((n : ℕ) → motive Nat.zero (Nat.succ n)) →\n        ((n : ℕ) → motive (Nat.succ n) Nat.zero) → ((n m : ℕ) → motive (Nat.succ n) (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "Semigroup",
   "Eq"],
  "name": "CommSemigroup.mk",
  "constType":
  "{G : Type u} → [toSemigroup : Semigroup G] → (∀ (a b : G), a * b = b * a) → CommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.succ_pos",
  "constType": "∀ (n : ℕ), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["Monoid", "CommMonoid"],
  "name": "CommMonoid.toMonoid",
  "constType": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "Group",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "Group.mk",
  "constType":
  "{G : Type u} → [toDivInvMonoid : DivInvMonoid G] → (∀ (a : G), a⁻¹ * a = 1) → Group G",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Nat.commSemiring",
   "inferInstance",
   "NonUnitalSemiring.toSemigroupWithZero",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Semigroup"],
  "name": "Nat.semigroup",
  "constType": "Semigroup ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddRightCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = c + b → a = c) → AddRightCancelSemigroup G",
  "constCategory": "Other"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_1",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ", "Nat.le.rec"],
  "name": "Nat.le.casesOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {a : ℕ} (t : Nat.le n a),\n  motive n (_ : Nat.le n n) → (∀ {m : ℕ} (a : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive a t",
  "constCategory": "Definition"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Nat.zero_lt_succ",
   "LE.le",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Nat.commSemiring",
   "instLENat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat.le_of_lt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.linearOrderedCommSemiring.proof_6",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusionType",
  "constType": "Sort u → ℕ → ℕ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lean.SourceInfo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd",
   "AddCommMagma.toAdd",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M], IsRightCancelAdd M",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gcd_comm",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat.gcd",
   "Nat",
   "Eq.trans"],
  "name": "Nat.Coprime.symm",
  "constType": "∀ {n m : ℕ}, Nat.Coprime n m → Nat.Coprime m n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "constCategory": "Other"},
 {"references": ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ"],
  "name": "Nat.le.rec",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop},\n  motive n (_ : Nat.le n n) →\n    (∀ {m : ℕ} (a : Nat.le n m), motive m a → motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) →\n      ∀ {a : ℕ} (t : Nat.le n a), motive a t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4053",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4011",
   "Nat",
   "autoParam",
   "AddSemigroup",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "CancelMonoidWithZero",
   "OfNat.ofNat",
   "Function.Injective.eq_iff",
   "MulZeroOneClass.toMulZeroClass",
   "CancelMonoidWithZero.toIsCancelMulZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "mul_right_injective₀",
   "IsCancelMulZero.toIsLeftCancelMulZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero"],
  "name": "mul_right_inj'",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, a ≠ 0 → (a * b = a * c ↔ b = c)",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "inferInstance",
   "instHMul",
   "Units",
   "mul_assoc",
   "MulOneClass.toMul",
   "Monoid",
   "Units.ext",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "Units.val",
   "HMul.hMul",
   "Eq"],
  "name": "Units.instGroupUnits.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (x x_1 x_2 : αˣ), x * x_1 * x_2 = x * (x_1 * x_2)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.mul_comm",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_8",
   "OrderBot",
   "Nat.canonicallyOrderedCommSemiring.proof_12",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.nontrivial",
   "OrderedAddCommMonoid",
   "Nat.eq_zero_of_mul_eq_zero",
   "inferInstance",
   "instLENat",
   "Semiring.npow",
   "Nat.canonicallyOrderedCommSemiring.proof_10",
   "Nat.canonicallyOrderedCommSemiring.proof_3",
   "CommSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Nat",
   "Nat.canonicallyOrderedCommSemiring.proof_7",
   "Nat.linearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.add_le_add_left",
   "Nat.canonicallyOrderedCommSemiring.proof_5",
   "CanonicallyOrderedCommSemiring.mk",
   "Nat.le_add_right",
   "OrderedAddCommMonoid.mk",
   "OrderBot.bot_le",
   "Nat.canonicallyOrderedCommSemiring.proof_11",
   "Nat.canonicallyOrderedCommSemiring.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.canonicallyOrderedCommSemiring.proof_6",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.toOne",
   "Nat.commSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_9",
   "Nat.canonicallyOrderedCommSemiring.proof_1",
   "Nat.orderedSemiring",
   "OrderBot.toBot",
   "Nat.canonicallyOrderedCommSemiring.proof_4",
   "LinearOrderedSemiring",
   "Nontrivial",
   "OrderBot.mk",
   "Nat.orderBot",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.le.dest.match_2",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ≤ x_1 → Prop) (x x_1 : ℕ) (x_2 : x ≤ x_1),\n  (∀ (x : Nat.zero ≤ Nat.zero), motive Nat.zero Nat.zero x) →\n    (∀ (n : ℕ) (x : Nat.zero ≤ Nat.succ n), motive Nat.zero (Nat.succ n) x) →\n      (∀ (n : ℕ) (h : Nat.succ n ≤ Nat.zero), motive (Nat.succ n) Nat.zero h) →\n        (∀ (n m : ℕ) (h : Nat.succ n ≤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Dvd.dvd",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.dvd_add.match_1",
  "constType":
  "∀ {a c : ℕ} (motive : a ∣ c → Prop) (h₂ : a ∣ c),\n  (∀ (e : ℕ) (he : c = a * e), motive (_ : ∃ c_1, c = a * c_1)) → motive h₂",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Ordering"],
  "name": "Ordering.lt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["WellFoundedRelation.wf",
   "WellFoundedRelation.rel",
   "InvImage.wf",
   "WellFoundedRelation",
   "WellFounded",
   "InvImage"],
  "name": "invImage.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (h : WellFoundedRelation β),\n  WellFounded (InvImage WellFoundedRelation.rel f)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.le",
   "instLENat",
   "Nat.pred",
   "Nat.pred_le_pred.match_1",
   "Nat.le_succ",
   "Nat.le_trans",
   "instOfNatNat",
   "Nat.le.refl",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.pred_le_pred",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.pred n ≤ Nat.pred m",
  "constCategory": "Theorem"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvImage",
  "constType":
  "{α : Sort u} → {β : Sort v} → (β → β → Prop) → (α → β) → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddSemigroup"],
  "name": "AddLeftCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddLeftCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.le.step",
  "constType": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr", "Function.comp", "Or.elim"],
  "name": "Or.imp",
  "constType": "∀ {a c b d : Prop}, (a → c) → (b → d) → a ∨ b → c ∨ d",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "Nat.le_of_dvd",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.eq_zero_of_zero_dvd",
   "Nat.instDvdNat",
   "instOfNatNat",
   "Nat.dvd_antisymm.match_1",
   "Dvd.dvd",
   "Nat",
   "Nat.le_antisymm",
   "Eq.symm",
   "Nat.succ_pos",
   "Eq"],
  "name": "Nat.dvd_antisymm",
  "constType": "∀ {m n : ℕ}, m ∣ n → n ∣ m → m = n",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.concat.match_1",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.nil"],
  "name": "List.concat",
  "constType": "{α : Type u} → List α → α → List α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Dvd.dvd",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.dvd_trans.match_1",
  "constType":
  "∀ {a b c : ℕ} (motive : a ∣ b → b ∣ c → Prop) (h₁ : a ∣ b) (h₂ : b ∣ c),\n  (∀ (d : ℕ) (h₃ : b = a * d) (e : ℕ) (h₄ : c = b * e), motive (_ : ∃ c, b = a * c) (_ : ∃ c_1, c = b * c_1)) →\n    motive h₁ h₂",
  "constCategory": "Definition"},
 {"references": ["Nat", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["One", "InvOneClass"],
  "name": "InvOneClass.toOne",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → One G",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Nat.gcd_zero_left",
   "Eq.refl",
   "Nat.gcd_succ",
   "Eq",
   "Nat.instModNat",
   "Eq.mpr",
   "instHMod",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "HMod.hMod",
   "Nat.gcd",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.casesOn",
   "id"],
  "name": "Nat.gcd_zero_right",
  "constType": "∀ (n : ℕ), Nat.gcd n 0 = n",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "congr_arg", "Function.Injective", "Eq"],
  "name": "Function.Injective.eq_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α}, f a = f b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.le_self_add",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "le_self_add",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a c : α}, a ≤ a + c",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Div"],
  "name": "DivInvMonoid.toDiv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat", "Nat.Coprime", "instOfNatNat", "Nat.gcd", "Nat", "Eq", "id"],
  "name": "Nat.Coprime.gcd_eq_one",
  "constType": "∀ {m n : ℕ}, Nat.Coprime m n → Nat.gcd m n = 1",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_add_one",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddMonoidWithOne",
   "Eq.mpr",
   "NeZero",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "LT.lt",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "id"],
  "name": "one_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], 1 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5095",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Semigroup.toMul",
   "MulZeroClass.mk",
   "MulZeroClass",
   "SemigroupWithZero.mul_zero",
   "SemigroupWithZero.zero_mul",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero"],
  "name": "SemigroupWithZero.toMulZeroClass",
  "constType":
  "{S₀ : Type u} → [self : SemigroupWithZero S₀] → MulZeroClass S₀",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Dvd.intro",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.eq_one_of_dvd_one",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "Exists.intro",
   "Units.inv",
   "Monoid.toMulOneClass",
   "Eq",
   "Units.val_inv",
   "instHMul",
   "Units",
   "InvOneClass.toOne",
   "Units.ext",
   "Nat.commMonoid",
   "Units.instCommGroupUnits",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionCommMonoid.toDivisionMonoid",
   "Units.val",
   "Nat.monoid",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "DivisionMonoid.toDivInvOneMonoid",
   "CommGroup.toDivisionCommMonoid"],
  "name": "Nat.units_eq_one",
  "constType": "∀ (u : ℕˣ), u = 1",
  "constCategory": "Theorem"},
 {"references":
  ["inv_div",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "one_div",
   "One.toOfNat1",
   "inv_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "Eq",
   "DivInvMonoid.toInv",
   "DivInvMonoid.zpow",
   "DivInvMonoid.zpow_neg'",
   "DivisionMonoid",
   "Eq.mp",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "congrArg",
   "Eq.trans",
   "id",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "DivisionMonoid.toDivInvOneMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : DivisionMonoid α], 1⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["PProd", "List.rec", "List", "PUnit"],
  "name": "List.below",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max 1 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references": ["CommMonoidWithZero", "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCommMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelCommMonoidWithZero M₀] → CommMonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Nat.zero",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.le_of_dvd.match_1",
  "constType":
  "∀ {m n : ℕ} (motive : (k : ℕ) → n = m * k → Prop) (k : ℕ) (e : n = m * k),\n  (∀ (e : n = m * 0), motive 0 e) → (∀ (pk : ℕ) (e : n = m * (pk + 1)), motive (Nat.succ pk) e) → motive k e",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gcd.induction",
   "Nat.gcd_zero_left",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Nat.dvd_mod_iff",
   "instLTNat",
   "Iff.mpr",
   "Nat.gcd_rec",
   "Eq",
   "Nat.instModNat",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "LT.lt",
   "HMod.hMod",
   "Nat.gcd",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "Nat.dvd_gcd",
  "constType": "∀ {k m n : ℕ}, k ∣ m → k ∣ n → k ∣ Nat.gcd m n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "Semigroup.toMul",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "SemigroupWithZero.toZero",
   "Eq",
   "SemigroupWithZero"],
  "name": "SemigroupWithZero.mul_zero",
  "constType":
  "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Or.resolve_left",
   "Ne",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.pos_of_ne_zero",
  "constType": "∀ {n : ℕ}, n ≠ 0 → 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "ContravariantClass",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "ContravariantClass.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toContravariantClassLeLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α],\n  ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references": ["DivInvOneMonoid", "DivInvMonoid"],
  "name": "DivInvOneMonoid.toDivInvMonoid",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.add_right_cancel",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsRightCancelAdd G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Irreducible", "Nat.monoid", "Nat"],
  "name": "Nat.Prime",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instNatPowNat",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "∀ (n : ℕ), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.le_trans",
   "Nat",
   "LE.le",
   "instLTNat",
   "Nat.succ"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "MulPosStrictMono",
   "Subtype.mk",
   "Subtype",
   "CovariantClass.elim"],
  "name": "mul_lt_mul_of_pos_right",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],\n  b < c → 0 < a → b * a < c * a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Unit", "Unit.unit", "Bool"],
  "name": "Bool.decEq.match_1",
  "constType":
  "(motive : Bool → Bool → Sort u_1) →\n  (a b : Bool) →\n    (Unit → motive false false) →\n      (Unit → motive false true) → (Unit → motive true false) → (Unit → motive true true) → motive a b",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Unit",
   "Eq.refl",
   "Nat.mod_zero",
   "Nat.gcd_zero_right",
   "Eq",
   "Nat.gcd_rec.match_1",
   "Nat.instModNat",
   "instHMod",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "HMod.hMod",
   "Nat.gcd",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.gcd_rec",
  "constType": "∀ (m n : ℕ), Nat.gcd m n = Nat.gcd (n % m) m",
  "constCategory": "Theorem"},
 {"references": ["CommSemigroup", "Semigroup"],
  "name": "CommSemigroup.toSemigroup",
  "constType": "{G : Type u} → [self : CommSemigroup G] → Semigroup G",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.gt_of_not_le",
   "instSubNat",
   "Nat.decLt",
   "Eq.refl",
   "instLTNat",
   "Nat.mod_eq_of_lt",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff.mp",
   "instOfNatNat",
   "Nat",
   "Decidable.not_and_iff_or_not",
   "Eq.symm",
   "absurd",
   "Nat.decLe",
   "id",
   "instHSub",
   "Or",
   "HSub.hSub",
   "LE.le",
   "Nat.mod.inductionOn",
   "GT.gt",
   "And",
   "Nat.instModNat",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Eq.ndrec",
   "LT.lt",
   "Eq.mp",
   "HMod.hMod",
   "Not",
   "Nat.mod_lt.match_1",
   "Nat.mod_eq_sub_mod"],
  "name": "Nat.mod_lt",
  "constType": "∀ (x : ℕ) {y : ℕ}, y > 0 → x % y < y",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.elim.match_1"],
  "name": "Exists.elim",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {b : Prop}, (∃ x, p x) → (∀ (a : α), p a → b) → b",
  "constCategory": "Theorem"},
 {"references": ["Dvd"],
  "name": "Dvd.dvd",
  "constType": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Unit",
   "Nat.not_succ_le_self.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_self_eq_true",
  "constType": "∀ (n : ℕ), Nat.ble n n = true",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Dvd.dvd",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.dvd_mul_right",
  "constType": "∀ (a b : ℕ), a ∣ a * b",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroup.toGroup",
   "CommGroup",
   "HMul.hMul",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "CommGroup.mul_comm",
  "constType": "∀ {G : Type u} [self : CommGroup G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "CommMonoid.mul_comm",
   "CommMonoidWithZero",
   "CommSemiring.toCommMonoidWithZero.proof_1",
   "CommSemiring.toCommMonoidWithZero.proof_2",
   "CommMonoid",
   "CommSemiring",
   "AddMonoid.toZero",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "CommMonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_3",
  "constType": "∀ (a b c : ℕ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulPosStrictMono",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toMulPosStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], MulPosStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4212",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CancelCommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoid.zero_add",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "MonoidWithZero.toMonoid",
   "Irreducible",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "Eq",
   "MonoidWithZero"],
  "name": "Irreducible.ne_zero.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : MonoidWithZero α] (motive : (x : α) → Irreducible x → x = 0 → Prop) (x : α)\n  (x_1 : Irreducible x) (x_2 : x = 0), (∀ (hp : Irreducible 0), motive 0 hp (_ : 0 = 0)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "MulOneClass.toOne",
   "Eq.refl",
   "instOfNatNat",
   "npowRec",
   "Nat",
   "Eq"],
  "name": "Units.instGroupUnits.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (x : αˣ), npowRec 0 x = npowRec 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CancelMonoidWithZero",
   "CancelMonoidWithZero.mk",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero.proof_2",
   "CommSemigroup.toCommMagma",
   "CommMonoidWithZero.toCommMonoid",
   "IsCancelMulZero",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero.proof_1",
   "CommMagma.toMul",
   "CommMonoid.toCommSemigroup",
   "CancelCommMonoidWithZero",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCancelMonoidWithZero",
  "constType":
  "{M₀ : Type u_1} → [inst : CancelCommMonoidWithZero M₀] → CancelMonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["_private.Init.Data.Nat.Div.0.Nat.div._eq_1",
   "instHSub",
   "instHDiv",
   "OfNat.ofNat",
   "Nat.div",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "Nat.decLt",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "LT.lt",
   "instOfNatNat",
   "Nat.instDivNat",
   "HDiv.hDiv",
   "Nat",
   "Nat.decLe",
   "id"],
  "name": "Nat.div_eq",
  "constType":
  "∀ (x y : ℕ), x / y = if 0 < y ∧ y ≤ x then (x - y) / y + 1 else 0",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "_private.Init.Data.Nat.Gcd.0.Nat.gcdF.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((x : ℕ) → motive (Nat.succ x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.zero_lt_succ",
   "instLTNat"],
  "name": "Nat.zero_lt_one",
  "constType": "0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["InvOneClass.mk",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid.inv_one",
   "InvOneClass",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq",
   "Units",
   "instHMul",
   "mul_assoc",
   "one_mul",
   "Eq.ndrec",
   "Function.Injective",
   "Units.val",
   "Eq.rec",
   "Eq.mp",
   "congr",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Units.ext.match_1",
   "Eq.trans",
   "Units.mk",
   "congrFun"],
  "name": "Units.ext",
  "constType": "∀ {α : Type u} [inst : Monoid α], Function.Injective Units.val",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Nat.instModNat",
   "instHMod",
   "OfNat.ofNat",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF.proof_1",
   "Unit",
   "LT.lt",
   "HMod.hMod",
   "instOfNatNat",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF.match_1",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
  "constType": "(x : ℕ) → ((x₁ : ℕ) → x₁ < x → ℕ → ℕ) → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), a * b = 1 → a⁻¹ = b",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.not_succ_le_self.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Dvd.elim",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero.toMulZeroClass",
   "Eq.trans",
   "Eq",
   "SemigroupWithZero"],
  "name": "eq_zero_of_zero_dvd",
  "constType":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a → a = 0",
  "constCategory": "Theorem"},
 {"references": ["Monoid"],
  "name": "Irreducible",
  "constType": "{α : Type u_1} → [inst : Monoid α] → α → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "StrictOrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.pos_of_dvd_of_pos",
   "OfNat.ofNat",
   "Nat.le_of_dvd",
   "Bool.true",
   "Nat.decLt",
   "LT.lt",
   "of_decide_eq_true",
   "Nat.instDvdNat",
   "Eq.refl",
   "instOfNatNat",
   "Dvd.dvd",
   "Bool",
   "Nat",
   "Nat.le_antisymm",
   "instLTNat",
   "Eq"],
  "name": "Nat.eq_one_of_dvd_one",
  "constType": "∀ {n : ℕ}, n ∣ 1 → n = 1",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.le_self_add",
  "constType":
  "∀ {α : Type u_1} [self : CanonicallyOrderedAddCommMonoid α] (a b : α), a ≤ a + b",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "Exists",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderBot",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_1} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    [toOrderBot : OrderBot α] →\n      (∀ {a b : α}, a ≤ b → ∃ c, b = a + c) → (∀ (a b : α), a ≤ a + b) → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → HEq a a_1 → Sort u_1} →\n      motive a (_ : HEq a a) → {β : Sort u} → {a_1 : β} → (t : HEq a a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.zero_ne_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.nontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "Or.inl",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Unit",
   "Nat.zero_add.match_1",
   "instOfNatNat",
   "Nat",
   "rfl",
   "instLTNat",
   "Nat.succ_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.eq_zero_or_pos",
  "constType": "∀ (n : ℕ), n = 0 ∨ n > 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddLeftCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Dvd.intro",
   "rfl",
   "Semigroup"],
  "name": "dvd_mul_right",
  "constType": "∀ {α : Type u_1} [inst : Semigroup α] (a b : α), a ∣ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Eq",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "mul_inv_cancel_left",
   "Group",
   "Group.toDivInvMonoid",
   "mul_right_inv",
   "id",
   "Inv.inv"],
  "name": "Group.toDivisionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelSemigroup", "AddSemigroup"],
  "name": "AddRightCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddRightCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4212",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4173",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Array", "List"],
  "name": "Array.mk",
  "constType": "{α : Type u} → List α → Array α",
  "constCategory": "Other"},
 {"references": ["instLENat", "Min", "minOfLe", "Nat", "Nat.decLe"],
  "name": "instMinNat",
  "constType": "Min ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "LE.le.lt_or_eq_dec",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvMonoid",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Or.elim.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∨ b → Prop) (h : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.pow.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((n : ℕ) → motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.eq_zero_of_add_eq_zero",
   "And.right",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.eq_zero_of_add_eq_zero_left",
  "constType": "∀ {n m : ℕ}, n + m = 0 → m = 0",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Or",
   "MulOneClass.toMul",
   "Monoid",
   "Irreducible",
   "HMul.hMul",
   "IsUnit",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Irreducible.isUnit_or_isUnit'",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, Irreducible p → ∀ (a b : α), p = a * b → IsUnit a ∨ IsUnit b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["And", "instLENat", "Not", "And.intro", "Nat", "And.casesOn", "LE.le"],
  "name": "Nat.lt_iff_le_not_le.match_1",
  "constType":
  "∀ {m n : ℕ} (motive : m ≤ n ∧ ¬n ≤ m → Prop) (x : m ≤ n ∧ ¬n ≤ m),\n  (∀ (left : m ≤ n) (h : ¬n ≤ m), motive (_ : m ≤ n ∧ ¬n ≤ m)) → motive x",
  "constCategory": "Definition"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["CommGroup", "Group"],
  "name": "CommGroup.toGroup",
  "constType": "{G : Type u} → [self : CommGroup G] → Group G",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5173",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "ExistsAddOfLE.mk",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "ExistsAddOfLE",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "CanonicallyOrderedAddCommMonoid.exists_add_of_le",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
  "constType":
  "∀ (α : Type u) [h : CanonicallyOrderedAddCommMonoid α], ExistsAddOfLE α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Group",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["List.cons", "List", "List.casesOn", "List.nil"],
  "name": "List.concat.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → α → Sort u_2) →\n    (x : List α) →\n      (x_1 : α) → ((b : α) → motive [] b) → ((a : α) → (as : List α) → (b : α) → motive (a :: as) b) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4173",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsLeftCancelAdd.add_left_cancel",
   "Add",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_left_cancel",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "Units.val",
   "HMul.hMul",
   "One.toOfNat1",
   "Units.inv",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Units.val_inv",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (self : αˣ), ↑self * self.inv = 1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["zpowRec",
   "Monoid",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Units.inv_val",
   "Eq.refl",
   "Units.inv",
   "Inv.mk",
   "Eq",
   "Units.val_inv",
   "Units",
   "inferInstance",
   "Units.instMulOneClassUnits",
   "Int.negSucc",
   "Units.val",
   "Nat",
   "Units.mk"],
  "name": "Units.instGroupUnits.proof_10",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (n : ℕ) (a : αˣ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Acc",
  "constType": "{α : Sort u} → (α → α → Prop) → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "Semigroup",
   "Dvd",
   "Eq"],
  "name": "semigroupDvd",
  "constType": "{α : Type u_1} → [inst : Semigroup α] → Dvd α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "instHMul",
   "OfNat.ofNat",
   "of_eq_true",
   "Nat.instDvdNat",
   "HMul.hMul",
   "Dvd.dvd",
   "Nat.mul_one",
   "instOfNatNat",
   "Exists.intro",
   "instMulNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "True",
   "Eq"],
  "name": "Nat.dvd_refl",
  "constType": "∀ (a : ℕ), a ∣ a",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.le_of_ble_eq_true.match_1",
  "constType":
  "∀ (motive : (n m : ℕ) → Nat.ble n m = true → Prop) (n m : ℕ) (h : Nat.ble n m = true),\n  (∀ (x : ℕ) (h : Nat.ble 0 x = true), motive 0 x h) →\n    (∀ (n n_1 : ℕ) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) →\n      motive n m h",
  "constCategory": "Definition"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references": ["Zero", "Mul"],
  "name": "IsLeftCancelMulZero",
  "constType": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Or",
   "MulOneClass.toMul",
   "Monoid",
   "Irreducible",
   "Irreducible.isUnit_or_isUnit'",
   "HMul.hMul",
   "IsUnit",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Irreducible.isUnit_or_isUnit",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {p : α}, Irreducible p → ∀ {a b : α}, p = a * b → IsUnit a ∨ IsUnit b",
  "constCategory": "Theorem"},
 {"references": ["Zero", "Mul"],
  "name": "IsCancelMulZero",
  "constType": "(M₀ : Type u) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instLENat",
   "instAddNat",
   "Nat.le_add_right",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le.intro",
  "constType": "∀ {n m k : ℕ}, n + k = m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "Nat",
   "Nat.decLe",
   "Nat.strictOrderedSemiring"],
  "name": "Nat.orderedSemiring",
  "constType": "OrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.noConfusionType", "Eq.ndrec", "Eq.refl", "Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : ℕ} → v1 = v2 → Nat.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.mk",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Exists.imp",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid",
   "inferInstance",
   "Nat.le.dest",
   "AddMonoid.toAddSemigroup",
   "Nat.orderedSemiring",
   "Nat",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_1",
  "constType": "∀ {x x_1 : ℕ}, x ≤ x_1 → ∃ a, x_1 = x + a",
  "constCategory": "Theorem"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Units",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "instAddNat",
   "Units.instMulOneClassUnits",
   "MulOneClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "instOfNatNat",
   "npowRec",
   "Nat",
   "Eq"],
  "name": "Units.instGroupUnits.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (n : ℕ) (x : αˣ), npowRec (n + 1) x = npowRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "LE.le",
   "PProd",
   "Nat.le_succ_of_le",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_antisymm.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → m ≤ n → Prop) (m : ℕ) (h₁ : n ≤ m) (h₂ : m ≤ n),\n  (∀ (h₂ : n ≤ n), motive n (_ : Nat.le n n) h₂) →\n    (∀ (m : ℕ) (h : Nat.le n m) (h₂ : Nat.succ m ≤ n), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m)) h₂) →\n      motive m h₁ h₂",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.trans",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (n : ℕ) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_8",
  "constType": "∀ (a : ℕ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["Units.val_inv",
   "Units",
   "Monoid",
   "Units.inv_val",
   "Units.val",
   "Units.inv",
   "Units.mk",
   "Inv",
   "Inv.mk"],
  "name": "Units.instInv",
  "constType": "{α : Type u} → [inst : Monoid α] → Inv αˣ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"}]