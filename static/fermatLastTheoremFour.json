[{"references":
  ["StrictOrderedRing.toPartialOrder",
   "Ord.compare",
   "Ordering",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedRing.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "Eq"],
  "name": "LinearOrderedRing.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "Nontrivial"],
  "name": "StrictOrderedSemiring.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references": ["Ring", "Int"],
  "name": "Ring.zsmul",
  "constType": "{R : Type u} → [self : Ring R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Int.instAddInt",
   "Int.le_trans.match_1",
   "Int.le.dest",
   "Eq.mpr",
   "Int.ofNat_add",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "Int.add_assoc",
   "Nat",
   "Int.le.intro",
   "Eq.symm",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.le_trans",
  "constType": "∀ {a b c : ℤ}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Nat.xgcd", "Prod.fst", "Nat", "Int"],
  "name": "Nat.gcdA",
  "constType": "ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LinearOrderedRing.toMin",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_comm",
   "True",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.one_mul",
   "HMul.hMul",
   "Int.add_mul",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.instCommRingInt.proof_6",
  "constType": "∀ (m : ℕ) (n : ℤ), (↑m + 1) * n = n + ↑m * n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "HMul.hMul",
   "HasDistribNeg",
   "Neg.neg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mk",
  "constType":
  "{α : Type u_1} →\n  [inst : Mul α] →\n    [toInvolutiveNeg : InvolutiveNeg α] →\n      (∀ (x y : α), -x * y = -(x * y)) → (∀ (x y : α), x * -y = -(x * y)) → HasDistribNeg α",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Or.resolve_right",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial.mk",
   "IsRightCancelMulZero.mk",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "LinearOrderedRing",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "LinearOrderedRing.noZeroDivisors",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "IsCancelMulZero.mk",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "sub_mul",
   "HSub.hSub",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toMul",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Nontrivial.exists_pair_ne",
   "Or.resolve_left",
   "instHMul",
   "mul_sub",
   "Eq.ndrec",
   "IsLeftCancelMulZero.mk",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsDomain.mk",
   "Eq.mp",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nontrivial",
   "sub_eq_zero",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero"],
  "name": "LinearOrderedRing.isDomain",
  "constType": "∀ {α : Type u} [inst : LinearOrderedRing α], IsDomain α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Nat"],
  "name": "Nat.monoid",
  "constType": "Monoid ℕ",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass",
   "Neg",
   "Eq"],
  "name": "NegZeroClass.mk",
  "constType":
  "{G : Type u_2} → [toZero : Zero G] → [toNeg : Neg G] → -0 = 0 → NegZeroClass G",
  "constCategory": "Other"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Int.zero_lt_one",
   "Semiring.toOne",
   "DistribLattice.toLattice",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "le_of_lt",
   "Int.instLinearOrderInt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.instCommRingInt"],
  "name": "Int.linearOrderedCommRing.proof_2",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{K : Type u} → [self : DivisionRing K] → Ring K",
  "constCategory": "Definition"},
 {"references": ["Sub", "Int", "Int.sub", "Sub.mk"],
  "name": "Int.instSubInt",
  "constType": "Sub ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LE.mk", "LE", "Int.le", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Semiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mk",
  "constType":
  "{α : Type u_4} →\n  [toSemiring : Semiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → DivisionSemiring α",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.toDiv",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "True",
   "pow_add",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "mul_mul_mul_comm",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {ea eb e : ℕ} {a₂ b₂ c : R} (x : R),\n  ea + eb = e → a₂ * b₂ = c → x ^ ea * a₂ * (x ^ eb * b₂) = x ^ e * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "Zero",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
  "constType":
  "∀ {M₀ : Type u_4} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.npow",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Semiring.npow_zero",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_11",
  "constType": "∀ (x : ℕ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.inv_zero",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card", "Finset.range", "Multiset.card_range", "Nat", "Eq"],
  "name": "Finset.card_range",
  "constType": "∀ (n : ℕ), Finset.card (Finset.range n) = n",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "pow_nonneg.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Monoid.npow",
   "Eq"],
  "name": "Monoid.npow_succ",
  "constType":
  "∀ {M : Type u} [self : Monoid M] (n : ℕ) (x : M), Monoid.npow (n + 1) x = x * Monoid.npow n x",
  "constCategory": "Definition"},
 {"references": ["Zero", "IsCancelMulZero", "Mul", "IsLeftCancelMulZero"],
  "name": "IsCancelMulZero.toIsLeftCancelMulZero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsCancelMulZero M₀], IsLeftCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} → [self : Ring R] → Neg R",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "CommSemigroup.mk",
   "CommMonoid",
   "CommMonoid.mul_comm",
   "CommMonoid.toMonoid",
   "CommSemigroup"],
  "name": "CommMonoid.toCommSemigroup",
  "constType": "{M : Type u} → [self : CommMonoid M] → CommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "inferInstance",
   "Rat",
   "LinearOrderedSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Rat.instLinearOrderedFieldRat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "Rat.instLinearOrderedSemiringRat",
  "constType": "LinearOrderedSemiring ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "_private.Std.Data.Int.Lemmas.0.Ne._eq_1",
   "instOfNatInt",
   "Iff.rfl",
   "Eq.refl",
   "Nat.pos_iff_ne_zero",
   "Int.natAbs_eq_zero",
   "instLTNat",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Not",
   "instOfNatNat",
   "Nat",
   "Int",
   "Int.natAbs",
   "id"],
  "name": "Int.natAbs_pos",
  "constType": "∀ {a : ℤ}, 0 < Int.natAbs a ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instOfNatInt",
   "instNatCastInt",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "Nat.succ",
   "Int",
   "rfl",
   "Int.instAddInt",
   "Eq"],
  "name": "Int.ofNat_succ",
  "constType": "∀ (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.gcd_dvd_right",
   "Nat.gcd_dvd_left",
   "Nat.gcd",
   "Nat.dvd_antisymm",
   "Nat",
   "Nat.dvd_gcd",
   "Eq"],
  "name": "Nat.gcd_comm",
  "constType": "∀ (m n : ℕ), Nat.gcd m n = Nat.gcd n m",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.exists_pair_ne",
  "constType": "∀ {α : Type u_3} [self : Nontrivial α], ∃ x y, x ≠ y",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "add_comm",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMagma.toAdd",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "CommRing.toNonUnitalCommRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Exists", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "Even",
  "constType": "{α : Type u_2} → [inst : Add α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "HPow.hPow",
   "Finset.card",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Finset.card_range",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "IsCoprime",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Finset.range",
   "CommSemiring",
   "Finset",
   "Finset.prod",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "Nat",
   "Eq.symm",
   "IsCoprime.prod_right",
   "Finset.prod_const",
   "id"],
  "name": "IsCoprime.pow_right",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y : R} {n : ℕ}, IsCoprime x y → IsCoprime x (y ^ n)",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["DivisionCommMonoid.mk",
   "DivisionMonoid",
   "DivisionMonoid.mul_inv_rev",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.inv_inv",
   "CommGroupWithZero",
   "GroupWithZero.toDivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "CommGroupWithZero.toDivisionCommMonoid.proof_1"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Fermat42",
   "Iff.mp",
   "instLENat",
   "Fermat42.comm",
   "Fermat42.Minimal",
   "And.intro",
   "Fermat42.minimal_comm.match_1",
   "Nat",
   "LE.le",
   "Int",
   "Int.natAbs"],
  "name": "Fermat42.minimal_comm",
  "constType": "∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "bit0",
   "StrictOrderedRing.toPartialOrder",
   "HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "instAddNat",
   "Semiring.toMonoidWithZero",
   "Ne.symm",
   "StrictOrderedSemiring.toSemiring",
   "pow_ne_zero",
   "pow_bit0_nonneg",
   "Zero.toOfNat0",
   "IsDomain.to_noZeroDivisors",
   "LE.le.lt_of_ne",
   "LinearOrderedRing",
   "MonoidWithZero.toMonoid",
   "Preorder.toLT",
   "instHPow",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedRing.isDomain",
   "MonoidWithZero.toZero",
   "Nat"],
  "name": "pow_bit0_pos",
  "constType":
  "∀ {R : Type u_2} [inst : LinearOrderedRing R] {a : R}, a ≠ 0 → ∀ (n : ℕ), 0 < a ^ bit0 n",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedAddCommGroup.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommGroup α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield",
   "Semifield.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "lt_of_lt_of_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LT.lt.trans_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references": ["Rat.ofInt", "IntCast.mk", "Rat", "IntCast"],
  "name": "Rat.instIntCastRat",
  "constType": "IntCast ℚ",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "Field",
   "CommRing.toRing",
   "One.toOfNat1",
   "Field.zpow",
   "Ring.toSemiring",
   "Int",
   "Eq"],
  "name": "Field.zpow_zero'",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "Sub",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Neg",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddGroupWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toIntCast : IntCast R] →\n    [toAddMonoidWithOne : AddMonoidWithOne R] →\n      [toNeg : Neg R] →\n        [toSub : Sub R] →\n          autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n            (zsmul : ℤ → R → R) →\n              autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                  autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                    (∀ (a : R), -a + a = 0) →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → AddGroupWithOne R",
  "constCategory": "Other"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivisionMonoid.toDivInvOneMonoid.proof_1",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.zpow_neg'",
   "DivInvMonoid.zpow",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [inst : DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references": ["Field", "Div"],
  "name": "Field.toDiv",
  "constType": "{K : Type u} → [self : Field K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "OfNat.ofNat",
   "Int.negOfNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Int.instAddInt",
   "Nat.zero_add",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Int",
   "Nat.succ",
   "Nat.casesOn",
   "id"],
  "name": "Int.negOfNat_add",
  "constType":
  "∀ (m n : ℕ), Int.negOfNat m + Int.negOfNat n = Int.negOfNat (m + n)",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length.match_1",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.zero_mul",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Preorder.toLT",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "instHMul",
   "StrictOrderedSemiring.toPartialOrder",
   "mul_le_mul_right",
   "MulPosStrictMono.toMulPosReflectLE",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toMulPosMono",
   "congrArg",
   "congrFun"],
  "name": "zero_le_mul_right",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α] {b c : α}, 0 < c → (0 ≤ b * c ↔ 0 ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.Basic._auxLemma.1",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * b + a * c = a * (b + c)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "MulOneClass.toMul",
   "CommMonoid",
   "instHPow",
   "CommSemigroup.toCommMagma",
   "Commute.all",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Commute.mul_pow",
   "CommMonoid.toMonoid",
   "Nat",
   "Monoid.toMulOneClass",
   "CommMonoid.toCommSemigroup",
   "Eq"],
  "name": "mul_pow",
  "constType":
  "∀ {M : Type u} [inst : CommMonoid M] (a b : M) (n : ℕ), (a * b) ^ n = a ^ n * b ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "LinearOrderedSemiring.toMin",
   "Eq"],
  "name": "LinearOrderedSemiring.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv", "Rat", "Eq.refl", "HDiv.hDiv", "Eq", "Rat.instDivRat"],
  "name": "Rat.commGroupWithZero.proof_3",
  "constType": "∀ (a b : ℚ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "left_distrib",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.mul_zero",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat.ofNat", "OfNat", "Zero.mk"],
  "name": "Zero.ofOfNat0",
  "constType": "{α : Type u_1} → [inst : OfNat α 0] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "DivisionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toDivisionMonoid : DivisionMonoid G] → (∀ (a b : G), a * b = b * a) → DivisionCommMonoid G",
  "constCategory": "Other"},
 {"references": ["Field", "Inv"],
  "name": "Field.toInv",
  "constType": "{K : Type u} → [self : Field K] → Inv K",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instOfNatInt",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Eq.refl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Int.natAbs_neg",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Monoid.toNatPow",
   "Int.instNegInt",
   "Fermat42.Minimal",
   "instOfNatNat",
   "Nat",
   "Int.instMonoidInt",
   "And.casesOn",
   "Eq.symm",
   "neg_sq",
   "Int.instCommRingInt",
   "id",
   "HPow.hPow",
   "Ne",
   "Fermat42",
   "instHAdd",
   "Neg.neg",
   "LE.le",
   "Monoid.toMulOneClass",
   "Int.instAddInt",
   "And",
   "Eq.ndrec",
   "And.intro",
   "Int",
   "Int.natAbs"],
  "name": "Fermat42.neg_of_minimal",
  "constType":
  "∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instMulInt",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_mul_emod_self",
   "Int.mul_comm",
   "Eq",
   "Int.instAddInt",
   "Int.instModInt_1",
   "instHMul",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "HMod.hMod",
   "HMul.hMul",
   "Int",
   "id"],
  "name": "Int.add_mul_emod_self_left",
  "constType": "∀ (a b c : ℤ), (a + b * c) % b = a % b",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemigroup",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instCommSemigroupInt",
  "constType": "CommSemigroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.Prime.two_le",
   "instLTNat"],
  "name": "Nat.Prime.one_lt",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 1 < p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.decLe",
   "LE.mk",
   "Int.le_refl",
   "LinearOrder",
   "Int.instLinearOrderInt.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Int.instLinearOrderInt.proof_2",
   "Int.decLt",
   "Int.instMaxInt",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Int.instLTInt",
   "Preorder.mk",
   "Int.le_trans",
   "Int.lt_iff_le_not_le",
   "Int.instLinearOrderInt.proof_3",
   "inferInstance",
   "Int.le_antisymm",
   "Int.instDecidableEqInt",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Int.instMinInt",
   "LinearOrder.mk",
   "instOrdInt",
   "Int.le_total",
   "Int",
   "Int.instLEInt",
   "DecidableRel"],
  "name": "Int.instLinearOrderInt",
  "constType": "LinearOrder ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "Commute",
   "True",
   "Eq",
   "Eq.mpr",
   "one_mul",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "id",
   "eq_self",
   "HPow.hPow",
   "Monoid.toSemigroup",
   "Monoid",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "One.toOfNat1",
   "Commute.right_comm",
   "Mathlib.Algebra.GroupPower.Basic._auxLemma.1",
   "Monoid.toMulOneClass",
   "pow_zero",
   "Commute.pow_left",
   "instHMul",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "HMul.hMul",
   "congr",
   "pow_succ",
   "congrArg",
   "congrFun"],
  "name": "Commute.mul_pow",
  "constType":
  "∀ {M : Type u} [inst : Monoid M] {a b : M}, Commute a b → ∀ (n : ℕ), (a * b) ^ n = a ^ n * b ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommSemiring : LinearOrderedCommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → LinearOrderedSemifield α",
  "constCategory": "Other"},
 {"references": ["Int.decLe", "Min", "minOfLe", "Int", "Int.instLEInt"],
  "name": "Int.instMinInt",
  "constType": "Min ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "inferInstance",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_10",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : OrderedCancelAddCommMonoid α] → AddCancelCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "instOfNatInt",
   "Int.emod_two_eq_zero_or_one",
   "of_decide_eq_true",
   "Int.dvd_of_emod_eq_zero",
   "Eq.refl",
   "IsCoprime",
   "Exists.intro",
   "Int.dvd_gcd",
   "Int.gcd_eq_one_iff_coprime",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "Nat.cast",
   "Bool.true",
   "Fermat42.Minimal",
   "instOfNatNat",
   "Fermat42.coprime_of_minimal",
   "Nat",
   "Fermat42.minimal_comm",
   "Int.instDvdInt",
   "Fermat42",
   "Or",
   "False",
   "Or.inr",
   "Int.instCommSemiringInt",
   "Dvd.dvd",
   "Or.casesOn",
   "Int.gcd",
   "forall_prop_decidable",
   "Int.instModInt_1",
   "And",
   "Int.decidableDvd",
   "instDecidableFalse",
   "Fermat42.exists_minimal",
   "instHMod",
   "Eq.ndrec",
   "Or.inl",
   "False.elim",
   "instNatCastInt",
   "Eq.mp",
   "HMod.hMod",
   "And.intro",
   "Bool",
   "Int"],
  "name": "Fermat42.exists_odd_minimal",
  "constType":
  "∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommGroupWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.mk",
  "constType": "{R : Type u} → (ℤ → R) → IntCast R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "ne_of_lt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mul_nonneg",
   "Rat.instOfNatRat",
   "Rat.isDomain",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "IsDomain.to_noZeroDivisors",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "le_of_lt",
   "Rat.instMulRat",
   "Rat.linearOrder",
   "Rat",
   "mul_ne_zero",
   "Ne.symm",
   "NonUnitalNonAssocSemiring.toMul",
   "Rat.field",
   "Ring.toSemiring",
   "Rat.instPreorderRat",
   "lt_of_le_of_ne",
   "Rat.instPartialOrderRat",
   "instHMul",
   "Rat.divisionRing",
   "LT.lt",
   "CommRing.toRing",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.instLinearOrderedFieldRat.proof_3",
  "constType": "∀ (a b : ℚ), 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Rat.divInt.proof_1",
   "Rat.normalize",
   "Rat",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "mkRat",
   "inline",
   "Nat.succ",
   "Rat.divInt.match_2",
   "Int"],
  "name": "Rat.divInt",
  "constType": "ℤ → ℤ → ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α] (motive : Mathlib.Meta.NormNum.IsInt a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsInt a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsInt a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List",
   "List.casesOn",
   "List.nil",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "List.get!.match_1",
  "constType":
  "{α : Type u_1} →\n  (motive : List α → ℕ → Sort u_2) →\n    (x : List α) →\n      (x_1 : ℕ) →\n        ((a : α) → (tail : List α) → motive (a :: tail) 0) →\n          ((head : α) → (as : List α) → (n : ℕ) → motive (head :: as) (Nat.succ n)) →\n            ((x : List α) → (x_2 : ℕ) → motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "Subtype"],
  "name": "PosMulStrictMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommGroup",
   "OfNat.ofNat",
   "IsCancelAdd.toIsLeftCancelAdd",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "neg_neg_iff_pos",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Zero.toOfNat0",
   "AddCancelMonoid.toIsCancelAdd",
   "Preorder.toLT",
   "LT.lt",
   "AddGroup.toAddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Distrib"],
  "name": "Distrib.toMul",
  "constType": "{R : Type u_1} → [self : Distrib R] → Mul R",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "le_iff_exists_add",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "DivInvMonoid.toMonoid",
   "CommMonoid.mk",
   "DivisionCommMonoid.mul_comm"],
  "name": "DivisionCommMonoid.toCommMonoid",
  "constType": "{G : Type u} → [self : DivisionCommMonoid G] → CommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddLeftCancelMonoid.mk",
   "Eq.symm",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_mul",
   "OfNat.ofNat",
   "Or",
   "Or.inr",
   "instAddNat",
   "instHAdd",
   "Nat.eq_zero_of_mul_eq_zero.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "rfl",
   "Eq",
   "Nat.eq_zero_of_add_eq_zero_left",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Or.inl",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.eq_zero_of_mul_eq_zero",
  "constType": "∀ {n m : ℕ}, n * m = 0 → n = 0 ∨ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "PartialOrder"],
  "name": "OrderedAddCommGroup.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.refl",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.toInv",
   "Field.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.div_eq_mul_inv",
  "constType": "∀ {K : Type u} [self : Field K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_zero'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a : G), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instAddNat",
   "instNatCastInt",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "Int",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Int.instCommRingInt.proof_3",
  "constType": "∀ (x : ℕ), NatCast.natCast (x + 1) = NatCast.natCast (x + 1)",
  "constCategory": "Theorem"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "instHAdd",
   "Int.mul_add",
   "HAdd.hAdd",
   "True",
   "Int.mul_comm",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "congr",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.add_mul",
  "constType": "∀ (a b c : ℤ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InvOneClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Eq",
   "inferInstance",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instSubInt",
   "instOfNatInt",
   "Int.emod_def",
   "HAdd.hAdd",
   "Eq.refl",
   "dite",
   "Int.add_comm",
   "Int.mul_comm",
   "Eq",
   "Eq.mpr",
   "Int.add_zero",
   "Int.instDecidableEqInt",
   "Int.sub_sub",
   "Int.instDivInt_1",
   "HDiv.hDiv",
   "Int.add_sub_cancel",
   "Eq.symm",
   "Int.add_mul_ediv_right",
   "id",
   "instHSub",
   "Int.instMulInt",
   "instHDiv",
   "instHAdd",
   "Int.mul_add",
   "HSub.hSub",
   "Int.instAddInt",
   "Int.instModInt_1",
   "Int.mul_zero",
   "instHMul",
   "instHMod",
   "Eq.ndrec",
   "HMul.hMul",
   "HMod.hMod",
   "Not",
   "Int"],
  "name": "Int.add_mul_emod_self",
  "constType": "∀ {a b c : ℤ}, (a + b * c) % c = a % c",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references": ["Int.mul", "Mul", "Int", "Mul.mk"],
  "name": "Int.instMulInt",
  "constType": "Mul ℤ",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.add.match_1",
  "constType":
  "(motive : ℤ → ℤ → Sort u_1) →\n  (m n : ℤ) →\n    ((m n : ℕ) → motive (Int.ofNat m) (Int.ofNat n)) →\n      ((m n : ℕ) → motive (Int.ofNat m) (Int.negSucc n)) →\n        ((m n : ℕ) → motive (Int.negSucc m) (Int.ofNat n)) →\n          ((m n : ℕ) → motive (Int.negSucc m) (Int.negSucc n)) → motive m n",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "instNatPowNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedSemifield.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mt",
   "mul_eq_zero_of_right",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "right_ne_zero_of_mul",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MulZeroClass M₀] {a b : M₀}, a * b ≠ 0 → b ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedRing", "Nontrivial"],
  "name": "StrictOrderedRing.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], Nontrivial α",
  "constCategory": "Definition"},
 {"references": ["Semiring"],
  "name": "IsDomain",
  "constType": "(α : Type u) → [inst : Semiring α] → Prop",
  "constCategory": "Other"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["GroupWithZero", "Int"],
  "name": "GroupWithZero.zpow",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → ℤ → G₀ → G₀",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toMul",
   "instHAdd",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Eq.refl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "IsCoprime",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "CommMagma.toMul",
   "CommRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "mul_comm",
   "CommRing.toCommSemiring",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "HMul.hMul",
   "IsCoprime.add_mul_left_left",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "id"],
  "name": "IsCoprime.add_mul_right_left",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {x y : R}, IsCoprime x y → ∀ (z : R), IsCoprime (x + z * y) y",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalCommSemiring.mk",
  "constType":
  "{α : Type u} → [toNonUnitalSemiring : NonUnitalSemiring α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.gcd.proof_1",
   "measure",
   "WellFoundedRelation.rel",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
   "Nat",
   "WellFounded.fix",
   "id"],
  "name": "Nat.gcd",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "GCDMonoid.gcd",
   "Nat.cast",
   "IsDomain.toCancelCommMonoidWithZero",
   "instNatCastInt",
   "Int.instCommSemiringInt",
   "Int.linearOrderedCommRing",
   "LinearOrderedRing.isDomain",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing",
   "rfl",
   "Int",
   "Eq",
   "Int.gcd"],
  "name": "Int.coe_gcd",
  "constType": "∀ (i j : ℤ), ↑(Int.gcd i j) = gcd i j",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring.proof_1",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "Units.exists_iff_ne_zero",
   "IsUnit",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "Iff.mpr"],
  "name": "Ne.isUnit",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → IsUnit a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Nat.decidablePrime1",
   "instOfNatNat",
   "Bool",
   "Nat"],
  "name": "Nat.prime_two",
  "constType": "Nat.Prime 2",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Int",
   "Eq",
   "Int.instHPowIntNat"],
  "name": "Int.instCommRingInt.proof_4",
  "constType": "∀ (x : ℤ), (fun n x => x ^ n) 0 x = (fun n x => x ^ n) 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{α : Type u} → [self : Div α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Rat", "Nat"],
  "name": "Rat.den",
  "constType": "ℚ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat"],
  "name": "Odd.proof_1",
  "constType": "Nat.AtLeastTwo (0 + 2)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.isNat_eq_false.match_1",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Nat.ne_of_beq_eq_false",
   "Not",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "id"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_false",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → Nat.beq a' b' = false → ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroLEOneClass",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "Nat.cast_zero",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "NeZero",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "Nat.strictOrderedSemiring",
   "False",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.5",
   "LE.le",
   "PartialOrder",
   "Mathlib.Order.Basic._auxLemma.2",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Nat.zero",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "CovariantClass",
   "congr",
   "congrArg",
   "AddCommMonoidWithOne",
   "Nat.casesOn",
   "Std.Data.Nat.Lemmas._auxLemma.6"],
  "name": "Nat.cast_pos'",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "instTransEq",
   "add_lt_add_left",
   "add_zero",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "lt_add_of_pos_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Or.elim",
   "le_total",
   "Eq"],
  "name": "lt_trichotomy",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a = b ∨ b < a",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveNeg", "Neg.neg", "Neg", "Eq"],
  "name": "InvolutiveNeg.mk",
  "constType":
  "{A : Type u_2} → [toNeg : Neg A] → (∀ (x : A), - -x = x) → InvolutiveNeg A",
  "constCategory": "Other"},
 {"references": ["DivisionSemiring", "Inv"],
  "name": "DivisionSemiring.toInv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Int.negOfNat.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((m : ℕ) → motive (Nat.succ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedCommRing",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.min_def",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [d : LinearOrderedCommRing α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.mk",
  "constType": "{α : Type u} → (α → ℕ → α) → NatPow α",
  "constCategory": "Other"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "NeZero.mk",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat"],
  "name": "NeZero.succ",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references": ["Int", "Neg", "Int.neg", "Neg.mk"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{α : Type u} → [self : Lattice α] → Inf α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "HEq",
   "eq_of_heq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Ring.toSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsNat",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "instHPow",
   "Ring.toIntCast",
   "Ring",
   "Monoid.toNatPow",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Int",
   "Int.pow",
   "Nat.semiring"],
  "name": "Mathlib.Meta.NormNum.isInt_pow.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → ℕ → α) →\n      (x_1 : α) →\n        (x_2 : ℕ) →\n          (x_3 : ℤ) →\n            (x_4 : ℕ) →\n              (x_5 : ℤ) →\n                x = HPow.hPow →\n                  Mathlib.Meta.NormNum.IsInt x_1 x_3 →\n                    Mathlib.Meta.NormNum.IsNat x_2 x_4 → Int.pow x_3 x_4 = x_5 → Prop)\n  (x : α → ℕ → α) (x_1 : α) (x_2 : ℕ) (x_3 : ℤ) (x_4 : ℕ) (x_5 : ℤ) (x_6 : x = HPow.hPow)\n  (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3) (x_8 : Mathlib.Meta.NormNum.IsNat x_2 x_4) (x_9 : Int.pow x_3 x_4 = x_5),\n  (∀ (n : ℤ) (n_1 : ℕ),\n      motive HPow.hPow (↑n) (↑n_1) n n_1 (Int.pow n n_1) (_ : HPow.hPow = HPow.hPow)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1)\n        (_ : Int.pow n n_1 = Int.pow n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommMonoid",
   "CommSemiring",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.mk",
   "CommMonoid.mul_comm"],
  "name": "CommSemiring.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [inst : CommSemiring α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.zero_add",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Nat.cast_add",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.add a' b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionCommMonoid.mk",
   "Group.toDivisionMonoid",
   "DivisionMonoid",
   "CommGroup.toGroup",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.inv_inv",
   "CommGroup",
   "CommGroup.mul_comm",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "Group.toDivInvMonoid"],
  "name": "CommGroup.toDivisionCommMonoid",
  "constType": "{G : Type u_1} → [inst : CommGroup G] → DivisionCommMonoid G",
  "constCategory": "Definition"},
 {"references": ["CancelMonoidWithZero", "MonoidWithZero"],
  "name": "CancelMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.casesOn",
   "Int.ofNat",
   "Int.instMulInt",
   "Int.ofNat_mul_negOfNat",
   "Int.negOfNat",
   "Int.negSucc_mul_negOfNat",
   "Eq.refl",
   "Int.negOfNat_mul_negSucc",
   "True",
   "Int.negOfNat_mul_ofNat",
   "Eq",
   "instHMul",
   "Nat.mul_assoc",
   "Eq.ndrec",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.mul_assoc",
  "constType": "∀ (a b c : ℤ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "add_neg_cancel_right",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "eq_add_neg_iff_add_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a = b + -c ↔ a + c = b",
  "constCategory": "Theorem"},
 {"references": ["Mod"],
  "name": "Mod.mk",
  "constType": "{α : Type u} → (α → α → α) → Mod α",
  "constCategory": "Other"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x < x_1 → Prop) (x x_1 : α) (x_2 : x < x_1),\n  (∀ (_a _b : α) (hab : _a < _b), motive _a _b hab) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Rat.add_le_add_left",
   "Rat.instLERat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Rat",
   "LinearOrder.toPartialOrder",
   "Rat.linearOrder",
   "LE.le",
   "Rat.instAddRat",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "Rat.instLinearOrderedFieldRat.proof_1",
  "constType": "∀ (a b : ℚ), a ≤ b → ∀ (c : ℚ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Inv"],
  "name": "DivInvMonoid.toInv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Div"],
  "name": "DivisionSemiring.toDiv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toDivInvMonoid : DivInvMonoid G] →\n    (∀ (x : G), x⁻¹⁻¹ = x) →\n      (∀ (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹) → (∀ (a b : G), a * b = 1 → a⁻¹ = b) → DivisionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne", "AddMonoidWithOne.toNatCast", "Nat.cast", "Nat"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "Semiring.toMonoidWithZero",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "pow_abs",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Eq.symm"],
  "name": "abs_pow",
  "constType":
  "∀ {R : Type u₁} [inst : LinearOrderedRing R] (a : R) (n : ℕ), |a ^ n| = |a| ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "IsCancelMulZero",
   "IsRightCancelMulZero",
   "Mul",
   "IsLeftCancelMulZero"],
  "name": "IsCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [toIsLeftCancelMulZero : IsLeftCancelMulZero M₀]\n  [toIsRightCancelMulZero : IsRightCancelMulZero M₀], IsCancelMulZero M₀",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "left_ne_zero_of_mul_eq_one",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "inv_mul_cancel_left₀",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero.toNontrivial",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "mul_one",
   "Eq.symm",
   "Inv.inv",
   "GroupWithZero.toInv",
   "id"],
  "name": "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b : G₀}, a * b = 1 → a⁻¹ = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "Exists",
   "OfNat.ofNat",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Odd.proof_1",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "instOfNat"],
  "name": "Odd",
  "constType": "{α : Type u_2} → [inst : Semiring α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "CommMagma.toMul",
   "CommSemigroup",
   "dvd_mul_of_dvd_right",
   "CommSemigroup.toSemigroup"],
  "name": "Dvd.dvd.mul_left",
  "constType":
  "∀ {α : Type u_1} [inst : CommSemigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHDiv",
   "div_pow",
   "DivisionCommMonoid.toDivisionMonoid",
   "instHPow",
   "DivisionMonoid.toDivInvMonoid",
   "Monoid.toNatPow",
   "DivisionCommMonoid",
   "HDiv.hDiv",
   "Nat",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Eq",
   "DivInvMonoid.toDiv"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b : α) (n : ℕ), a ^ n / b ^ n = (a / b) ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Exists",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.ofNat_zero",
   "Eq",
   "Int.le_trans.match_1",
   "Eq.mpr",
   "Int.add_zero",
   "Nat.cast",
   "Int.ofNat_add",
   "instOfNatNat",
   "Int.ofNat.inj",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "id",
   "instAddNat",
   "instHAdd",
   "Int.add_left_cancel",
   "LE.le",
   "Int.instAddInt",
   "Nat.eq_zero_of_add_eq_zero_left",
   "Int.le_antisymm.match_1",
   "Int.le.dest",
   "Eq.ndrec",
   "instNatCastInt",
   "Eq.mp",
   "Int.add_assoc",
   "Int",
   "Int.instLEInt"],
  "name": "Int.le_antisymm",
  "constType": "∀ {a b : ℤ}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HSub.hSub",
   "zero_sub",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegMonoid.sub_eq_add_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "congr",
   "Eq.symm",
   "congrArg",
   "neg_sub",
   "Eq.trans",
   "SubNegMonoid.zsmul_zero'",
   "id"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : SubtractionMonoid α], -0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mod",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Neg.toHasAbs",
   "Nat.cast",
   "SemilatticeSup.toSup",
   "instNatCastInt",
   "instDistribLattice",
   "Int.instNegInt",
   "Int.instLinearOrderInt",
   "Int.abs_eq_natAbs",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "Int",
   "Abs.abs",
   "Eq",
   "Int.natAbs"],
  "name": "Int.coe_natAbs",
  "constType": "∀ (n : ℤ), ↑(Int.natAbs n) = |n|",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Associated",
   "LT.lt.ne'",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "GCDMonoid",
   "pow_dvd_of_mul_eq_pow",
   "dite",
   "Units.val_mkOfMulEqOne",
   "Associated.symm",
   "Exists.casesOn",
   "instLTNat",
   "CommMonoid.toCommSemigroup",
   "MulZeroClass.toMul",
   "Nat.eq_zero_or_pos",
   "Iff.mpr",
   "Eq",
   "mul_pow",
   "Units.mkOfMulEqOne",
   "mul_assoc",
   "Eq.mpr",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "Subsingleton",
   "Nat",
   "And.casesOn",
   "Associated.refl",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "Ne",
   "Or",
   "MulOneClass.toOne",
   "CommMonoidWithZero.toCommMonoid",
   "Classical.propDecidable",
   "Or.casesOn",
   "CommMagma.toMul",
   "mul_right_inj'",
   "MulZeroOneClass.toMulZeroClass",
   "pow_zero",
   "SemigroupWithZero.toSemigroup",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "False.elim",
   "propext",
   "Eq.mp",
   "mul_one",
   "Not",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero",
   "associated_one_iff_isUnit",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero",
   "CommMonoidWithZero.toZero",
   "Exists",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "subsingleton_or_nontrivial",
   "gcd_zero_right'",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "semigroupDvd",
   "Exists.intro",
   "NeZero.one",
   "one_pow",
   "CancelCommMonoidWithZero",
   "Subsingleton.elim",
   "mul_comm",
   "Zero.toOfNat0",
   "GCDMonoid.gcd",
   "one_mul",
   "zero_ne_one",
   "instHPow",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "dvd_pow_self",
   "exists_dvd_and_dvd_of_dvd_mul",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "zero_pow",
   "id",
   "CommMonoidWithZero.toMonoidWithZero",
   "False",
   "Or.inr",
   "Dvd.dvd",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Associated.isUnit_iff",
   "GT.gt",
   "Units",
   "Eq.ndrec",
   "Or.inl",
   "Associated.trans",
   "StrictOrderedSemiring.toPartialOrder",
   "CommSemigroup.toCommMagma",
   "Units.val",
   "HMul.hMul",
   "Nontrivial",
   "IsUnit",
   "gcd_comm'"],
  "name": "exists_associated_pow_of_mul_eq_pow",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] {a b c : α},\n  IsUnit (gcd a b) → ∀ {k : ℕ}, a * b = c ^ k → ∃ d, Associated (d ^ k) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.instDvdNat",
   "Dvd.dvd",
   "decidable_of_iff'",
   "instDecidableAnd",
   "LE.le",
   "instLTNat",
   "And",
   "Nat.Prime",
   "instLENat",
   "instDecidableNot",
   "LT.lt",
   "Decidable",
   "Nat.decidable_dvd",
   "instOfNatNat",
   "Not",
   "Nat.prime_def_lt'",
   "Nat",
   "Nat.decLe",
   "Nat.decidableLoHi"],
  "name": "Nat.decidablePrime1",
  "constType": "(p : ℕ) → Decidable (Nat.Prime p)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "∀ (n : ℕ), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_6",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["Dvd"],
  "name": "Dvd.mk",
  "constType": "{α : Type u_1} → (α → α → Prop) → Dvd α",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Iff",
   "instOfNatInt",
   "not_congr",
   "instOfNatNat",
   "Int.natAbs_eq_zero",
   "Nat",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.natAbs_ne_zero",
  "constType": "∀ {a : ℤ}, Int.natAbs a ≠ 0 ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "Exists",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instOfNatInt",
   "neg_pos",
   "AddGroup.toSubtractionMonoid",
   "Int.linearOrderedCommRing",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "And.left",
   "Iff.mpr",
   "Fermat42.exists_odd_minimal",
   "Eq",
   "Zero.toOfNat0",
   "instLENat",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Preorder.toLT",
   "AddGroup.toAddCancelMonoid",
   "Int.instNegInt",
   "Fermat42.Minimal",
   "Int.instLinearOrderInt",
   "Nat",
   "And.casesOn",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Fermat42",
   "Or",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Fermat42.neg_of_minimal",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Or.casesOn",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Int.instLTInt",
   "Int.instModInt_1",
   "And",
   "instHMod",
   "Int.instAddGroupInt",
   "False.elim",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "HMod.hMod",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Int",
   "Fermat42.ne_zero",
   "lt_trichotomy",
   "Int.natAbs"],
  "name": "Fermat42.exists_pos_odd_minimal",
  "constType":
  "∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_6",
  "constType": "∀ (a b c : ℕ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "not_congr", "Not"],
  "name": "Iff.not",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "DivInvMonoid"],
  "name": "DivInvMonoid.toMonoid",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "Mathlib.Tactic.PushNeg.not_ne_eq",
   "implies_congr",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "zero_pow'",
   "instOfNatNat",
   "Not",
   "Mathlib.Tactic.Contrapose.mtr",
   "Nat",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "MonoidWithZero",
   "id"],
  "name": "ne_zero_pow",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] {a : M} {n : ℕ}, n ≠ 0 → a ^ n ≠ 0 → a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.rec",
  "constType":
  "{α : Type u_1} →\n  [inst : AddMonoidWithOne α] →\n    {a : α} →\n      {n : ℕ} →\n        {motive : Mathlib.Meta.NormNum.IsNat a n → Sort u} →\n          ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsNat a n)) →\n            (t : Mathlib.Meta.NormNum.IsNat a n) → motive t",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references": ["Min.min", "Int.instMinInt", "Eq.refl", "Int", "Eq"],
  "name": "Int.instLinearOrderInt.proof_1",
  "constType": "∀ (a b : ℤ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} → [self : InvolutiveNeg A] → Neg A",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.nil"],
  "name": "List.rec",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    motive [] → ((head : α) → (tail : List α) → motive tail → motive (head :: tail)) → (t : List α) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "LinearOrderedCommRing"],
  "name": "LinearOrderedField.toLinearOrderedCommRing",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedField α] → LinearOrderedCommRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Left.neg_nonpos_iff",
   "LE",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonpos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "True",
   "Nat.cast_mul",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "Nat.cast_one",
   "id",
   "HPow.hPow",
   "eq_self",
   "instAddNat",
   "instHAdd",
   "Semiring",
   "One.toOfNat1",
   "pow_succ'",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "Nat.rec",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "congr",
   "HMul.hMul",
   "instMulNat",
   "congrArg"],
  "name": "Nat.cast_pow",
  "constType":
  "∀ {R : Type u₁} [inst : Semiring R] (n m : ℕ), ↑(n ^ m) = ↑n ^ m",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "mul_left_comm",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₃ c : R} (b₁ : R) (b₂ : ℕ), a * b₃ = c → a * (b₁ ^ b₂ * b₃) = b₁ ^ b₂ * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Abs",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "Set",
   "Set.Nonempty",
   "Eq.refl",
   "Exists.intro",
   "Set.decidableSetOf",
   "Exists.casesOn",
   "Eq",
   "Nat.find_min'",
   "Eq.mpr",
   "instLENat",
   "Fermat42.Minimal",
   "Nat",
   "And.casesOn",
   "Eq.symm",
   "id",
   "Membership.mem",
   "Fermat42",
   "Prod.snd",
   "setOf",
   "Classical.propDecidable",
   "Prod.fst",
   "LE.le",
   "Set.instMembershipSet",
   "And",
   "Nat.find_spec",
   "Eq.ndrec",
   "Prod.mk",
   "Set.mem_setOf_eq",
   "Nat.find",
   "Prod",
   "And.intro",
   "Int",
   "Int.natAbs"],
  "name": "Fermat42.exists_minimal",
  "constType":
  "∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "congr_arg",
   "instOfNatInt",
   "Rat",
   "Rat.num",
   "Rat.zero_mk",
   "Rat.instOfNatRat",
   "Rat.mk'",
   "Rat.rec",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.ndrec",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Int",
   "Int.natAbs"],
  "name": "Rat.num_eq_zero",
  "constType": "∀ {q : ℚ}, q.num = 0 ↔ q = 0",
  "constCategory": "Theorem"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "Semigroup",
   "SemigroupWithZero",
   "Eq"],
  "name": "SemigroupWithZero.mk",
  "constType":
  "{S₀ : Type u} →\n  [toSemigroup : Semigroup S₀] →\n    [toZero : Zero S₀] → (∀ (a : S₀), 0 * a = 0) → (∀ (a : S₀), a * 0 = 0) → SemigroupWithZero S₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "Eq.rec", "Add", "rfl", "Eq"],
  "name": "Mathlib.Tactic.LinearCombination.add_pf",
  "constType":
  "∀ {α : Type u_1} {a₁ b₁ a₂ b₂ : α} [inst : Add α], a₁ = b₁ → a₂ = b₂ → a₁ + a₂ = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.add_left_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonAssocRing",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.one_mul",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonAssocRing.toOne",
   "NonAssocRing.mul_one",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonAssocRing.natCast_succ",
   "SubNegMonoid.toAddMonoid",
   "NonAssocRing.toNatCast",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonAssocRing.natCast_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.toNonAssocSemiring",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Rat.divInt_one_one",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Rat.instOfNatRat",
   "MulZeroClass.toMul",
   "Eq",
   "Eq.mpr",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Rat.divInt_mul_right",
   "Rat.instMulRat",
   "Nat",
   "LinearOrderedRing.noZeroDivisors",
   "not_false_eq_true",
   "Eq.trans",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "or_self",
   "Ne",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommMagma.toMul",
   "Rat.divInt",
   "Rat.numDenCasesOn'",
   "instHMul",
   "of_eq_true",
   "Eq.mp",
   "congr",
   "Not",
   "mul_one",
   "congrArg",
   "Int",
   "congrFun",
   "Inv.inv",
   "Rat.mul_def'",
   "instOfNatInt",
   "CommRing.toNonUnitalCommRing",
   "Int.linearOrderedCommRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "Rat.inv_def'",
   "True",
   "Zero.toOfNat0",
   "mul_comm",
   "Int.instRingInt",
   "AddMonoidWithOne.toNatCast",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "Rat.instInvRat",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Eq.symm",
   "id",
   "eq_self",
   "Rat.zero_divInt",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "False",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "mt",
   "eq_false",
   "Eq.ndrec",
   "StrictOrderedSemiring.to_charZero",
   "instNatCastInt",
   "Int.instSemiringInt",
   "HMul.hMul",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3"],
  "name": "Rat.mul_inv_cancel",
  "constType": "∀ (a : ℚ), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_two",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "sq",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["NoZeroDivisors",
   "IsDomain.toIsCancelMulZero",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelMulZero.toIsRightCancelMulZero",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "IsRightCancelMulZero.to_noZeroDivisors",
   "Ring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MonoidWithZero.toZero",
   "Ring.toSemiring",
   "Ring.toNonAssocRing"],
  "name": "IsDomain.to_noZeroDivisors",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] [inst_1 : IsDomain α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.instCommSemiringInt",
   "IsCoprime",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "sq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "IsCoprime.mul_add_left_left",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "IsCoprime.mul_left",
   "Nat",
   "Int.instMonoidInt",
   "Int",
   "Int.instCommRingInt",
   "id"],
  "name": "Int.coprime_of_sq_sum",
  "constType": "∀ {r s : ℤ}, IsCoprime s r → IsCoprime (r ^ 2 + s ^ 2) r",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.pow",
  "constType": "{α : Type u} → [self : NatPow α] → α → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "Semiring.npow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_12",
  "constType": "∀ (n x : ℕ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α], 0 ≤ 1 → ZeroLEOneClass α",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "pow_mul",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "instNatPowNat",
   "Nat",
   "Nat.pow",
   "instOfNat",
   "Eq.trans",
   "Int.instCommRingInt",
   "HPow.hPow",
   "instPowNat",
   "Int.instHPowIntNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "congr",
   "Nat.cast_pow",
   "congrArg",
   "Int",
   "Int.ofNat",
   "two_mul",
   "CommRing.toNonUnitalCommRing",
   "Int.negOfNat_eq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "True",
   "Nat.cast_mul",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.instMonoidInt",
   "Eq.symm",
   "id",
   "eq_self",
   "Int.negOfNat",
   "instAddNat",
   "instHAdd",
   "neg_pow_two",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "pow_add",
   "pow_eq",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.instSemiringInt",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "instMulNat",
   "Int.pow",
   "Nat.semiring"],
  "name": "Mathlib.Meta.NormNum.intPow_negOfNat_bit0",
  "constType":
  "∀ {a b' : ℕ} {c' b c : ℕ}, Nat.pow a b' = c' → 2 * b' = b → c' * c' = c → Int.pow (Int.negOfNat a) b = Int.ofNat c",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((x : ℕ) → motive x 0) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length",
   "instLTNat",
   "List.get.proof_1",
   "PProd",
   "PProd.fst",
   "List.get.match_1",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Fin.mk",
   "Fin"],
  "name": "List.get",
  "constType": "{α : Type u} → (as : List α) → Fin (List.length as) → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "Ring.toSemiring",
   "LinearOrderedRing.max_def",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "LinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "CommSemigroup.mul_comm",
  "constType":
  "∀ {G : Type u} [self : CommSemigroup G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.add_assoc.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → ℤ → Prop) (x x_1 x_2 : ℤ),\n  (∀ (m n : ℕ) (c : ℤ), motive (Int.ofNat m) (Int.ofNat n) c) →\n    (∀ (m : ℕ) (b : ℤ) (k : ℕ), motive (Int.ofNat m) b (Int.ofNat k)) →\n      (∀ (a : ℤ) (n k : ℕ), motive a (Int.ofNat n) (Int.ofNat k)) →\n        (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.negSucc n) (Int.ofNat k)) →\n          (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.ofNat n) (Int.negSucc k)) →\n            (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.negSucc n) (Int.negSucc k)) →\n              (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.negSucc n) (Int.negSucc k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Nat.instModNat",
   "instHMod",
   "Int.emod.match_1",
   "HMod.hMod",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.subNatNat",
   "Int.natAbs"],
  "name": "Int.emod",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "One", "InvOneClass", "One.toOfNat1", "Inv", "Inv.inv", "Eq"],
  "name": "InvOneClass.mk",
  "constType":
  "{G : Type u_2} → [toOne : One G] → [toInv : Inv G] → 1⁻¹ = 1 → InvOneClass G",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat", "Int.negOfNat", "Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.neg",
  "constType": "ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "∀ {M : Type u_1} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Monoid.toNatPow",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.pow_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' : R} {b b' : ℕ} {c : R}, a = a' → b = b' → a' ^ b' = c → a ^ b = c",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Field.toInv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Field.mul_inv_cancel",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["Add", "Mul"],
  "name": "RightDistribClass",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro", "IsCoprime.symm", "Iff", "CommSemiring", "IsCoprime"],
  "name": "isCoprime_comm",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y : R}, IsCoprime x y ↔ IsCoprime y x",
  "constCategory": "Theorem"},
 {"references":
  ["GroupWithZero.toDivisionMonoid.proof_1",
   "DivisionMonoid.mk",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "Inv.mk",
   "GroupWithZero.toDiv",
   "DivisionMonoid",
   "GroupWithZero.toDivisionMonoid.proof_2",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero",
   "GroupWithZero.zpow_zero'",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "Inv.inv",
   "GroupWithZero.toInv",
   "GroupWithZero.zpow",
   "GroupWithZero.zpow_neg'"],
  "name": "GroupWithZero.toDivisionMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : GroupWithZero G₀] → DivisionMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Group.toDivisionMonoid",
   "Units.instGroupUnits",
   "InvOneClass.toOne",
   "Units",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "DivInvOneMonoid.toInvOneClass",
   "Units.val",
   "One.toOfNat1",
   "IsUnit",
   "Exists.intro",
   "DivisionMonoid.toDivInvOneMonoid",
   "rfl",
   "Eq"],
  "name": "isUnit_one",
  "constType": "∀ {M : Type u_1} [inst : Monoid M], IsUnit 1",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "List",
   "LT.lt",
   "Exists.intro",
   "List.get",
   "List.length",
   "Nat",
   "Exists.casesOn",
   "instLTNat",
   "Fin.mk",
   "Eq"],
  "name": "List.get?_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}\n  (motive : (∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a) → Prop)\n  (x : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a),\n  (∀ (w : n < List.length l) (e : List.get l { val := n, isLt := w } = a),\n      motive (_ : ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a)) →\n    motive x",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.mul_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.casesOn",
   "instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "Eq.ndrec",
   "instOfNatInt",
   "Int.negSucc",
   "Eq.refl",
   "HMul.hMul",
   "Nat",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "Int.mul_zero",
  "constType": "∀ (a : ℤ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.instMulInt",
   "Int.negOfNat",
   "Eq.refl",
   "Int.negSucc_mul_negOfNat",
   "Int.mul_comm",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Int.negSucc",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Int",
   "Nat.succ",
   "id"],
  "name": "Int.negOfNat_mul_negSucc",
  "constType":
  "∀ (m n : ℕ), Int.negOfNat n * Int.negSucc m = Int.ofNat (n * Nat.succ m)",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "CommSemiring",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instCommSemiringInt",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemifield",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CancelMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "IsCancelMulZero",
   "MonoidWithZero.toZero",
   "MonoidWithZero"],
  "name": "CancelMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toMonoidWithZero : MonoidWithZero M₀] → [toIsCancelMulZero : IsCancelMulZero M₀] → CancelMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Int.add_zero", "Int.le.intro", "LE.le", "Int", "Int.instLEInt"],
  "name": "Int.le_refl",
  "constType": "∀ (a : ℤ), a ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LinearOrderedRing", "Max"],
  "name": "LinearOrderedRing.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Max α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NegZeroClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Ring", "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt",
  "constType": "{α : Type u_1} → [inst : Ring α] → α → ℤ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedCommSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedCommSemiring α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat.pow", "Nat", "NatPow.mk"],
  "name": "instNatPowNat",
  "constType": "NatPow ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mul_inv_rev",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mpr",
   "OfNat.ofNat",
   "Rat.inv",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "Rat.num",
   "Rat",
   "Eq.refl",
   "Rat.den",
   "Rat.inv_def",
   "Rat.instOfNatRat",
   "Int",
   "Rat.divInt",
   "id",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_8",
  "constType": "Rat.inv 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoid.mul_comm",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "CommGroupWithZero.toDivisionCommMonoid.proof_1",
  "constType":
  "∀ {G₀ : Type u_1} [inst : CommGroupWithZero G₀] (a b : G₀), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "RightDistribClass.right_distrib",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "AddZeroClass",
   "Left.add_neg"],
  "name": "add_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Zero", "IsCancelMulZero", "IsRightCancelMulZero", "Mul"],
  "name": "IsCancelMulZero.toIsRightCancelMulZero",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsCancelMulZero M₀], IsRightCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "HPow.hPow",
   "Finset.card",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Finset.card_range",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "IsCoprime.prod_left",
   "IsCoprime",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Finset.range",
   "CommSemiring",
   "Finset",
   "Finset.prod",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "Nat",
   "Eq.symm",
   "Finset.prod_const",
   "id"],
  "name": "IsCoprime.pow_left",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y : R} {m : ℕ}, IsCoprime x y → IsCoprime (x ^ m) y",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "instOfNatInt",
   "Int.zero_ne_one",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Int"],
  "name": "Int.instNontrivialInt",
  "constType": "Nontrivial ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["Abs"],
  "name": "Abs.mk",
  "constType": "{α : Type u_1} → (α → α) → Abs α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "LeftDistribClass",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "LeftDistribClass.mk",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R], (∀ (a b c : R), a * (b + c) = a * b + a * c) → LeftDistribClass R",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references":
  ["Rat.commGroupWithZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "div_zero",
   "Rat.instOfNatRat",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Int.instDecidableEqInt",
   "HDiv.hDiv",
   "Eq.trans",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instHDiv",
   "MulOneClass.toOne",
   "Int.instCommSemiringInt",
   "GroupWithZero.toDivInvMonoid",
   "Rat.divInt",
   "DivInvMonoid.toInv",
   "Int.cast_zero",
   "instHMul",
   "of_eq_true",
   "Int.cast",
   "CommRing.toRing",
   "congr",
   "mul_one",
   "Not",
   "one_ne_zero",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "Inv.inv",
   "CommMonoidWithZero.toZero",
   "Rat.mul_def'",
   "instOfNatInt",
   "Rat.instIntCastRat",
   "Int.linearOrderedCommRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Rat.inv_def'",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Rat.commRing",
   "one_mul",
   "Rat.instInvRat",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Rat.coe_int_eq_divInt",
   "CommSemiring.toCommMonoidWithZero",
   "NeZero.charZero_one",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "CommGroupWithZero.toGroupWithZero",
   "Rat",
   "division_def",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "Rat.instDivRat",
   "Semiring.toOne",
   "Rat.divInt_zero",
   "StrictOrderedSemiring.to_charZero",
   "Int.instSemiringInt",
   "HMul.hMul",
   "NegZeroClass.toZero"],
  "name": "Rat.divInt_eq_div",
  "constType": "∀ (n d : ℤ), Rat.divInt n d = ↑n / ↑d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "∀ (x x_1 : ℕ), (fun m n => m * n) (x + 1) x_1 = x_1 + (fun m n => m * n) x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.instEmptyCollectionFinset",
   "MulOneClass.toMul",
   "EmptyCollection.emptyCollection",
   "Eq.refl",
   "IsCoprime",
   "Insert.insert",
   "Finset.prod_insert",
   "And.left",
   "Eq",
   "Eq.mpr",
   "And.right",
   "CommSemiring",
   "Finset",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "isCoprime_one_left",
   "id",
   "Membership.mem",
   "Finset.instInsertFinset",
   "Classical.propDecidable",
   "Finset.instMembershipFinset",
   "Monoid.toMulOneClass",
   "instHMul",
   "And",
   "Eq.ndrec",
   "propext",
   "Finset.prod",
   "Eq.mp",
   "HMul.hMul",
   "Not",
   "IsCoprime.mul_left",
   "Finset.forall_mem_insert",
   "Finset.induction_on"],
  "name": "IsCoprime.prod_left",
  "constType":
  "∀ {R : Type u} {I : Type v} [inst : CommSemiring R] {x : R} {s : I → R} {t : Finset I},\n  (∀ i ∈ t, IsCoprime (s i) x) → IsCoprime (Finset.prod t fun i => s i) x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_right_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "sub_mul",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), (a - b) * c = a * c - b * c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Int.cast_pow",
   "Semiring.toMonoidWithZero",
   "Ring.toSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.isInt_pow.match_1",
   "True",
   "Int.instHPowIntNat",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsNat",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "instHPow",
   "Ring.toIntCast",
   "Ring",
   "Monoid.toNatPow",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int",
   "Int.pow",
   "Nat.semiring"],
  "name": "Mathlib.Meta.NormNum.isInt_pow",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → ℕ → α} {a : α} {b : ℕ} {a' : ℤ} {b' : ℕ} {c : ℤ},\n  f = HPow.hPow →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Int.pow a' b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "IsDomain",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "IsDomain.toCancelCommMonoidWithZero.proof_1",
   "CancelCommMonoidWithZero",
   "CancelCommMonoidWithZero.mk"],
  "name": "IsDomain.toCancelCommMonoidWithZero",
  "constType":
  "{α : Type u_1} → [inst : CommSemiring α] → [inst : IsDomain α] → CancelCommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "lt_add_of_pos_right",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder",
   "AddZeroClass.toZero",
   "NeZero",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "zero_lt_one",
   "AddZeroClass"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] [inst_5 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt.match_1",
   "Ne",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "absurd",
   "lt_trichotomy",
   "GT.gt",
   "Eq"],
  "name": "lt_or_gt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≠ b → a < b ∨ a > b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Function.Injective",
   "Nat"],
  "name": "CharZero.mk",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R], Function.Injective Nat.cast → CharZero R",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.mk",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLE",
   "Ring.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Ring.toSub",
   "LinearOrderedAddCommGroup.mk",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
   "AddCommGroup.mk",
   "LinearOrderedAddCommGroup",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
   "AddGroup.mk",
   "LinearOrderedRing.decidableEq",
   "Ring.toSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.min_def",
   "SubNegMonoid.mk",
   "Ring.zsmul",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Int.instMulInt",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "PythagoreanTriple",
  "constType": "ℤ → ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Distrib",
   "Distrib.toMul",
   "Eq"],
  "name": "Distrib.right_distrib",
  "constType":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toInv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.inv_zero",
  "constType": "∀ {α : Type u_4} [self : Semifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instLENat",
   "Bot.mk",
   "instOfNatNat",
   "OrderBot",
   "OrderBot.mk",
   "Nat.zero_le",
   "Nat"],
  "name": "Nat.orderBot",
  "constType": "OrderBot ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} → [self : Field K] → DivisionRing K",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toMulPosMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x * x_2 ≤ x_1 * x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "One.toOfNat1",
   "DivisionSemiring.zpow",
   "Int",
   "Eq"],
  "name": "DivisionSemiring.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), DivisionSemiring.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Zero", "Mul"],
  "name": "NoZeroDivisors",
  "constType": "(M₀ : Type u_4) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Int.instAddCommSemigroupInt",
   "AddCommSemigroup.toAddCommMagma",
   "Int.instMulInt",
   "add_comm",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "IsCoprime.mul_right",
   "Eq.refl",
   "Int.instCommSemiringInt",
   "IsCoprime",
   "isCoprime_comm",
   "AddCommMagma.toAdd",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Eq.mpr",
   "Int.coprime_of_sq_sum",
   "Eq.ndrec",
   "Iff.mp",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Int.instMonoidInt",
   "Int",
   "id"],
  "name": "Int.coprime_of_sq_sum'",
  "constType": "∀ {r s : ℤ}, IsCoprime r s → IsCoprime (r ^ 2 + s ^ 2) (r * s)",
  "constCategory": "Theorem"},
 {"references": ["Nat.gcd", "Nat", "Int", "Int.natAbs"],
  "name": "Int.gcd",
  "constType": "ℤ → ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing.proof_4",
   "IsDomain.toCancelCommMonoidWithZero",
   "GCDMonoid",
   "Int.instCommSemiringInt",
   "Int.linearOrderedCommRing",
   "Int.dvd_gcd",
   "GCDMonoid.mk",
   "Int.gcd_dvd_left",
   "Int.gcd",
   "Nat.cast",
   "Int.lcm",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing.proof_2",
   "instNatCastInt",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing.proof_1",
   "Int.gcd_dvd_right",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing.proof_3",
   "LinearOrderedRing.isDomain",
   "Int"],
  "name":
  "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing",
  "constType": "GCDMonoid ℤ",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMod α β γ",
  "constCategory": "Other"},
 {"references": ["Rat", "Int"],
  "name": "Rat.num",
  "constType": "ℚ → ℤ",
  "constCategory": "Definition"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatPow",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "AddMonoid.toZero",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Mathlib.Tactic.Ring.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Exists",
   "OfNat.ofNat",
   "two_mul",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "CanonicallyOrderedCommSemiring.toOne",
   "Exists.casesOn",
   "Iff.mpr",
   "Odd.proof_1",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "Preorder.toLT",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "Odd",
   "Nat",
   "Eq.trans",
   "instOfNat",
   "id",
   "HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "instAddNat",
   "instHAdd",
   "bit1",
   "Nat.canonicallyOrderedCommSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "pow_bit1_neg_iff",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "Nat.semiring"],
  "name": "Odd.pow_neg",
  "constType":
  "∀ {R : Type u_4} [inst : LinearOrderedRing R] {a : R} {n : ℕ}, Odd n → a < 0 → a ^ n < 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.zero_mul",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Rat.commRing",
   "Rat",
   "IsDomain.toNontrivial",
   "Nontrivial",
   "Rat.isDomain"],
  "name": "Rat.nontrivial",
  "constType": "Nontrivial ℚ",
  "constCategory": "Definition"},
 {"references": ["Mod"],
  "name": "Mod.mod",
  "constType": "{α : Type u} → [self : Mod α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{α : Type u_1} → [inst : Mul α] → [self : HasDistribNeg α] → InvolutiveNeg α",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{α : Type u} → (α → α → α) → Div α",
  "constCategory": "Other"},
 {"references": ["Int"],
  "name": "Int.cast_injective.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ), (∀ (x x_2 : ℤ), motive x x_2) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references":
  ["Rat.ofInt.proof_1",
   "OfNat.ofNat",
   "Rat",
   "Rat.ofInt.proof_2",
   "instOfNatNat",
   "Nat",
   "Rat.mk'",
   "Int"],
  "name": "Rat.ofInt",
  "constType": "ℤ → ℚ",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Preorder.toLT",
   "instHAdd",
   "Left.add_pos",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "AddZeroClass"],
  "name": "add_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "HEq",
   "Semiring",
   "eq_of_heq",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.mul",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_mul.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℕ) →\n          x = HMul.hMul →\n            Mathlib.Meta.NormNum.IsNat x_1 x_3 → Mathlib.Meta.NormNum.IsNat x_2 x_4 → Nat.mul x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℕ) (x_6 : x = HMul.hMul) (x_7 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsNat x_2 x_4) (x_9 : Nat.mul x_3 x_4 = x_5),\n  (∀ (n n_1 : ℕ),\n      motive HMul.hMul (↑n) (↑n_1) n n_1 (Nat.mul n n_1) (_ : HMul.hMul = HMul.hMul)\n        (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1)\n        (_ : Nat.mul n n_1 = Nat.mul n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "eq_of_heq",
   "Ring.toIntCast",
   "Ring",
   "Eq.refl",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1) → Prop)\n  (x : α) (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1)),\n  (∀ (a : ℕ), motive (↑(Int.ofNat a)) a (_ : Mathlib.Meta.NormNum.IsInt (↑(Int.ofNat a)) (Int.ofNat a))) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.instMembershipList",
   "List.get?_eq_some",
   "List.length",
   "instLTNat",
   "Eq",
   "Iff.mp",
   "List",
   "Eq.rec",
   "LT.lt",
   "List.get_mem",
   "Option.some",
   "Nat",
   "List.get?",
   "List.get",
   "List.get?_mem.match_1",
   "Fin.mk",
   "Option"],
  "name": "List.get?_mem",
  "constType":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}, List.get? l n = some a → a ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "max_eq_right",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_of_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, a ≤ 0 → |a| = -a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["Associated",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "mul_neg",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "exists_associated_pow_of_mul_eq_pow",
   "MulZeroOneClass.toMulOneClass",
   "Mathlib.Algebra.CharZero.Lemmas._auxLemma.10",
   "Exists.casesOn",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "Mathlib.Algebra.CharZero.Lemmas._auxLemma.9",
   "HasDistribNeg.toInvolutiveNeg",
   "true_or",
   "Nat",
   "LinearOrderedRing.noZeroDivisors",
   "NonAssocRing.toNonAssocSemiring",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "Int.instCommRingInt",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "Or",
   "MulOneClass.toOne",
   "OrderedSemiring.zeroLEOneClass",
   "Int.instCommSemiringInt",
   "or_true",
   "MulZeroOneClass.toZero",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Int.instGCDMonoidIntToCancelCommMonoidWithZeroInstCommSemiringIntIsDomainToLinearOrderedRingLinearOrderedCommRing",
   "Int.instCommMonoidInt",
   "Int.gcd",
   "instHMul",
   "Nat.zero",
   "of_eq_true",
   "Nat.orderedSemiring",
   "DivInvOneMonoid.toInvOneClass",
   "LT.lt",
   "Int.coe_gcd",
   "instNatAtLeastTwo",
   "congr",
   "Mathlib.Algebra.GroupPower.Ring._auxLemma.1",
   "mul_one",
   "MonoidWithZero.toZero",
   "congrArg",
   "DivisionMonoid.toDivInvOneMonoid",
   "Int",
   "CommGroup.toDivisionCommMonoid",
   "congrFun",
   "isUnit_one",
   "Exists",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "instOfNatInt",
   "CommRing.toNonUnitalCommRing",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "Exists.intro",
   "Int.units_eq_one_or",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "GCDMonoid.gcd",
   "AddMonoidWithOne.toNatCast",
   "Int.ofNat_one",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "instHPow",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "Int.instNegInt",
   "instOfNatNat",
   "LinearOrderedRing.isDomain",
   "Int.instMonoidInt",
   "Eq.symm",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "NeZero.succ",
   "eq_self",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Or.inr",
   "IsDomain.toCancelCommMonoidWithZero",
   "Units.instNegUnits",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "AddMonoidWithOne.toAddMonoid",
   "Neg.neg",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Units",
   "InvOneClass.toOne",
   "StrictOrderedSemiring.to_charZero",
   "Eq.ndrec",
   "Or.inl",
   "instNatCastInt",
   "StrictOrderedSemiring.toPartialOrder",
   "Units.instCommGroupUnits",
   "Units.val",
   "Int.instSemiringInt",
   "HMul.hMul",
   "IsUnit",
   "Mathlib.Algebra.Order.Monoid.NatCast._auxLemma.1",
   "Nat.semiring"],
  "name": "Int.sq_of_gcd_eq_one",
  "constType":
  "∀ {a b c : ℤ}, Int.gcd a b = 1 → a * b = c ^ 2 → ∃ a0, a = a0 ^ 2 ∨ a = -a0 ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_of_le_of_lt.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["not_le_of_gt",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "Preorder",
   "Preorder.toLE"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "And",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHPow",
   "instHAdd",
   "HAdd.hAdd",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Int.instMonoidInt",
   "Nat",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "Fermat42",
  "constType": "ℤ → ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Int.instSubInt",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Int.instNegInt",
   "Neg.neg",
   "rfl",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "Int.sub_eq_add_neg",
  "constType": "∀ {a b : ℤ}, a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "Monoid.toNatPow",
   "Nat",
   "MonoidWithZero.toZero"],
  "name": "FermatLastTheoremWith",
  "constType": "(α : Type u_1) → [inst : Semiring α] → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "DivisionCommMonoid.toDivisionMonoid",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.instMonoidInt",
   "Nat",
   "Int.instCommRingInt",
   "id",
   "Or",
   "Int.natAbs_eq",
   "Units.instNegUnits",
   "Neg.neg",
   "One.toOfNat1",
   "Int.instCommMonoidInt",
   "Int.units_natAbs",
   "InvOneClass.toOne",
   "Units",
   "Mathlib.Data.Int.Units._auxLemma.1",
   "Units.instCommGroupUnits",
   "instNatCastInt",
   "DivInvOneMonoid.toInvOneClass",
   "Units.val",
   "Eq.mp",
   "congr",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Int",
   "CommGroup.toDivisionCommMonoid",
   "Int.natAbs"],
  "name": "Int.units_eq_one_or",
  "constType": "∀ (u : ℤˣ), u = 1 ∨ u = -1",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.intCast",
  "constType": "{R : Type u} → [self : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Rat.instSemilatticeInfRat",
   "Rat",
   "SemilatticeInf.toPartialOrder",
   "PartialOrder"],
  "name": "Rat.instPartialOrderRat",
  "constType": "PartialOrder ℚ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommRing.toCommMonoid",
   "zpowRec",
   "OfNat.ofNat",
   "Rat.commRing",
   "Monoid.toOne",
   "instOfNatInt",
   "Rat.instInvRat",
   "Rat",
   "Eq.refl",
   "CommMonoid.toMonoid",
   "Int",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_4",
  "constType": "∀ (a : ℚ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["HPow", "Nat", "Int.pow", "Int", "HPow.mk"],
  "name": "Int.instHPowIntNat",
  "constType": "HPow ℤ ℕ ℤ",
  "constCategory": "Definition"},
 {"references": ["Add", "Int.add", "Int", "Add.mk"],
  "name": "Int.instAddInt",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "Eq"],
  "name": "SubNegMonoid.sub_eq_add_neg",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivInvOneMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "Exists",
   "OfNat.ofNat",
   "False",
   "instOfNatInt",
   "Fermat42.not_minimal",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.casesOn",
   "Int.instLTInt",
   "Eq",
   "Int.instAddInt",
   "Int.instModInt_1",
   "And",
   "Fermat42.exists_pos_odd_minimal",
   "instHMod",
   "instHPow",
   "LT.lt",
   "HMod.hMod",
   "Monoid.toNatPow",
   "Fermat42.Minimal",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Int.instMonoidInt",
   "And.casesOn",
   "Int"],
  "name": "not_fermat_42",
  "constType": "∀ {a b c : ℤ}, a ≠ 0 → b ≠ 0 → a ^ 4 + b ^ 4 ≠ c ^ 2",
  "constCategory": "Theorem"},
 {"references": ["False", "IsEmpty.mk", "IsEmpty", "id"],
  "name": "instIsEmptyFalse",
  "constType": "IsEmpty False",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "max_eq_left",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "neg_nonpos"],
  "name": "abs_of_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ a → |a| = a",
  "constCategory": "Theorem"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "one_le_two",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "zero_lt_one",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "zero_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.natAbs_mul_self.match_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ), (∀ (a : ℕ), motive (Int.ofNat a)) → (∀ (a : ℕ), motive (Int.negSucc a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Unit",
   "Int.neg_neg.match_1",
   "Int.subNatNat_self",
   "Neg.neg",
   "rfl",
   "True",
   "Eq",
   "Int.instAddInt",
   "of_eq_true",
   "Int.instNegInt",
   "Nat",
   "congrArg",
   "Int",
   "Nat.succ",
   "Eq.trans",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.add_left_neg",
  "constType": "∀ (a : ℤ), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "of_eq_true",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "congr",
   "AddCommSemigroup.toAddSemigroup",
   "congrArg",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "Eq.trans",
   "True",
   "Eq"],
  "name": "add_add_add_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.mul_one",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Distrib.rightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "add_mul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b c₁ a₂ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "Nat.even_xor_odd",
   "instAddNat",
   "Xor'.or",
   "Even",
   "Odd",
   "Nat",
   "Nat.semiring"],
  "name": "Nat.even_or_odd",
  "constType": "∀ (n : ℕ), Even n ∨ Odd n",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references": ["Int.emod", "Mod.mk", "Mod", "Int"],
  "name": "Int.instModInt_1",
  "constType": "Mod ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Ring",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Ne",
   "OfNat.ofNat",
   "Or",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mt",
   "Iff.mpr",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "not_or",
   "instHMul",
   "And",
   "HMul.hMul",
   "Not",
   "And.intro",
   "Mul"],
  "name": "mul_ne_zero",
  "constType":
  "∀ {M₀ : Type u_2} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : NoZeroDivisors M₀] {a b : M₀}, a ≠ 0 → b ≠ 0 → a * b ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemifield", "Int"],
  "name": "LinearOrderedSemifield.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocRing α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Exists.casesOn",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "Nat.cast_zero",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Iff",
   "Nat.cast",
   "Int.instSemigroupInt",
   "Int.ofNat.inj",
   "Nat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
   "Eq.trans",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Int.instDvdInt",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Iff.intro",
   "instHMul",
   "Std.Classes.Order._auxLemma.4",
   "Mathlib.Algebra.Divisibility.Basic._auxLemma.2",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "congr",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "congrFun",
   "Exists",
   "Int.eq_ofNat_of_zero_le",
   "Int.coe_nat_dvd.match_2",
   "CommRing.toNonUnitalCommRing",
   "Nat.instDvdNat",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "Int.linearOrderedCommRing",
   "Exists.intro",
   "Int.coe_nat_dvd.match_1",
   "Dvd.intro",
   "True",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Nat.monoid",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "Eq.symm",
   "Or.elim",
   "id",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "nonneg_of_mul_nonneg_right",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "GT.gt",
   "Eq.ndrec",
   "StrictOrderedSemiring.to_charZero",
   "instNatCastInt",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "HMul.hMul",
   "Int.ofNat_mul",
   "instMulNat",
   "Int.instNontrivialInt",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2"],
  "name": "Int.coe_nat_dvd",
  "constType": "∀ {m n : ℕ}, ↑m ∣ ↑n ↔ m ∣ n",
  "constCategory": "Theorem"},
 {"references": ["Nat.pow", "Nat", "Nat.one_pow", "Eq"],
  "name": "Mathlib.Meta.NormNum.one_natPow",
  "constType": "∀ {b : ℕ}, Nat.pow 1 b = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Int.instMulInt",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Eq.refl",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "sq",
   "instNatCastInt",
   "instHPow",
   "Int.natAbs_mul_self'",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int.instMonoidInt",
   "Int",
   "id",
   "Int.natAbs"],
  "name": "Int.natAbs_sq",
  "constType": "∀ (x : ℤ), ↑(Int.natAbs x) ^ 2 = x ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Field",
   "Field.toInv",
   "Field.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "Field.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "NonAssocSemiring",
   "Eq",
   "Nat.cast_mul"],
  "name": "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑m * ↑n = ↑(m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_eq_of_add",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), a + b = 0 → -a = b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.beq",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Field",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toInv",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.inv_zero",
  "constType": "∀ {K : Type u} [self : Field K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_4",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "MonoidWithZero.toMonoid",
   "instOfNatInt",
   "GroupWithZero",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "Int",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_zero'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), GroupWithZero.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "StrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHAdd",
   "HAdd.hAdd",
   "LeftDistribClass",
   "Dvd.dvd",
   "semigroupDvd",
   "Dvd.intro",
   "True",
   "Eq",
   "instHMul",
   "of_eq_true",
   "Dvd.elim",
   "HMul.hMul",
   "congr",
   "Add",
   "congrArg",
   "left_distrib",
   "Eq.trans",
   "Semigroup"],
  "name": "dvd_add",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Semigroup α] [inst_2 : LeftDistribClass α] {a b c : α},\n  a ∣ b → a ∣ c → a ∣ b + c",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "add_assoc",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.rec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "congr",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Nat.gcd_comm", "Nat", "Int", "Int.gcd", "Eq", "Int.natAbs"],
  "name": "Int.gcd_comm",
  "constType": "∀ (i j : ℤ), Int.gcd i j = Int.gcd j i",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "Or",
   "OfNat.ofNat",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "autoParam",
   "NatCast.natCast",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "instOfNatNat",
   "Nat",
   "Mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) →\n            (∀ (a : α), a * 0 = 0) →\n              (∀ (a b c : α), a * b * c = a * (b * c)) →\n                [toOne : One α] →\n                  (∀ (a : α), 1 * a = a) →\n                    (∀ (a : α), a * 1 = a) →\n                      [toNatCast : NatCast α] →\n                        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n                          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                            (npow : ℕ → α → α) →\n                              autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                                autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ →\n                                  (∀ (a b : α), a * b = b * a) →\n                                    (∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0) → CanonicallyOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_1} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instNatCastInt",
   "instOfNatInt",
   "Int.negSucc",
   "Unit",
   "Int.neg_neg.match_1",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "rfl",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.natAbs_neg",
  "constType": "∀ (a : ℤ), Int.natAbs (-a) = Int.natAbs a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_3",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_1",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_2",
   "LinearOrderedCommSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toOrd",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommRing",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_4"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u} → [d : LinearOrderedCommRing α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "IntCast.intCast",
   "Eq"],
  "name": "AddGroupWithOne.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["IntCast.mk", "Int.negSucc", "Nat", "Int", "rfl", "IntCast.intCast", "Eq"],
  "name": "Int.instCommRingInt.proof_9",
  "constType":
  "∀ (x : ℕ), IntCast.intCast (Int.negSucc x) = IntCast.intCast (Int.negSucc x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "IsRightCancelMulZero",
   "Mul",
   "Eq"],
  "name": "IsRightCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀],\n  (∀ {a b c : M₀}, b ≠ 0 → a * b = c * b → a = c) → IsRightCancelMulZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Ne",
   "Nat.ne_of_gt",
   "OfNat.ofNat",
   "Iff",
   "Nat.pos_of_ne_zero",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat"],
  "name": "Nat.pos_iff_ne_zero",
  "constType": "∀ {n : ℕ}, 0 < n ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instMulInt",
   "instHDiv",
   "instOfNatInt",
   "Dvd.dvd",
   "Exists.intro",
   "Eq",
   "Int.instModInt_1",
   "instHMul",
   "instHMod",
   "HMod.hMod",
   "HMul.hMul",
   "Int.instDivInt_1",
   "Int.mul_ediv_cancel_of_emod_eq_zero",
   "HDiv.hDiv",
   "Eq.symm",
   "Int",
   "Int.instDvdInt"],
  "name": "Int.dvd_of_emod_eq_zero",
  "constType": "∀ {a b : ℤ}, b % a = 0 → a ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Nat.rawCast",
   "Semiring.toMonoidWithZero",
   "One.toOfNat1",
   "one_pow",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "congr",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.one_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (b : ℕ), Nat.rawCast 1 ^ b = Nat.rawCast 1",
  "constCategory": "Theorem"},
 {"references": ["Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.natAbs",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Int.instMulInt",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instOfNatInt",
   "Unit",
   "PUnit",
   "Int.negOfNat.match_1",
   "HMul.hMul",
   "Nat",
   "Nat.succ",
   "Int"],
  "name": "Int.pow",
  "constType": "ℤ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.natAbs_negOfNat",
   "Int.casesOn",
   "Int.ofNat",
   "eq_self",
   "Int.instMulInt",
   "Int.negOfNat",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "Int.negSucc",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "Int",
   "congrFun",
   "Int.natAbs",
   "id"],
  "name": "Int.natAbs_mul",
  "constType": "∀ (a b : ℤ), Int.natAbs (a * b) = Int.natAbs a * Int.natAbs b",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivInvMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT.lt", "LT", "lt_of_eq_of_lt", "Eq"],
  "name": "Eq.trans_lt",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a = b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero.mk",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → GroupWithZero G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α] (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Distrib",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instAddNat",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "Eq",
   "AddGroupWithOne.intCast_negSucc",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Int.cast",
   "Int.negSucc",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat"],
  "name": "Int.cast_negSucc",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑(Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.546",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.toLattice",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "inf_le_of_right_le",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_le_of_left_le",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "instDistribLattice.match_1",
   "LE.le",
   "Preorder.toLE",
   "le_total",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "le_inf",
   "le_refl",
   "sup_le_sup_left",
   "inferInstanceAs",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "instDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (x b c : α), (x ⊔ b) ⊓ (x ⊔ c) ≤ x ⊔ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Left.neg_pos_iff",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_pos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0",
  "constCategory": "Theorem"},
 {"references": ["AddGroupWithOne", "IntCast"],
  "name": "AddGroupWithOne.toIntCast",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → IntCast R",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["lt_of_le_not_le",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "dite",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.lt_or_eq_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.succ_add",
   "Nat.add_comm",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "True",
   "Eq",
   "Int.instAddInt",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "Int.subNatNat_add_negSucc",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int",
   "Nat.succ",
   "Int.subNatNat",
   "id"],
  "name": "Int.add_assoc.aux2",
  "constType":
  "∀ (m n k : ℕ), Int.negSucc m + Int.negSucc n + ↑k = Int.negSucc m + (Int.negSucc n + ↑k)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "Option.none",
   "List",
   "PUnit",
   "Option.some",
   "Nat",
   "List.get!.match_1",
   "Option"],
  "name": "List.get?",
  "constType": "{α : Type u_1} → List α → ℕ → Option α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["Units.mul_left_inj",
   "instHDiv",
   "MulOneClass.toMul",
   "IsUnit.inv",
   "div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "DivInvOneMonoid.toInvOneClass",
   "IsUnit.unit'",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "congrArg",
   "congrFun",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "IsUnit.div_left_inj",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit c → (a / c = b / c ↔ a = b)",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_7",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "MonoidWithZero",
   "id",
   "HPow.hPow",
   "mul_eq_zero",
   "Or",
   "instAddNat",
   "instHAdd",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "Or.casesOn",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "pow_zero",
   "NoZeroDivisors",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "Eq.mp",
   "HMul.hMul",
   "pow_succ",
   "mul_one",
   "MonoidWithZero.toZero"],
  "name": "pow_eq_zero",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] [inst_1 : NoZeroDivisors M] {x : M} {n : ℕ}, x ^ n = 0 → x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoidWithZero",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "Int",
   "Inv.inv"],
  "name": "CommGroupWithZero.mk",
  "constType":
  "{G₀ : Type u_4} →\n  [toCommMonoidWithZero : CommMonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → CommGroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_7",
  "constType": "∀ (a : ℕ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{α : Type u} → [self : Sub α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references": ["Int.decLe", "maxOfLe", "Max", "Int", "Int.instLEInt"],
  "name": "Int.instMaxInt",
  "constType": "Max ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Distrib.toAdd",
   "instHMul",
   "CommSemiring.toSemiring",
   "Exists",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "IsCoprime",
  "constType": "{R : Type u} → [inst : CommSemiring R] → R → R → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LT.lt.ne'",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Int.natAbs_pos",
   "Int.linearOrderedCommRing",
   "instLTNat",
   "Int.instLTInt",
   "Iff.mpr",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Int",
   "Int.natAbs"],
  "name":
  "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.int_natAbs_pos",
  "constType": "∀ {n : ℤ}, 0 < n → 0 < Int.natAbs n",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "CancelMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "CanonicallyOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Or",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedRing.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_2",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_9",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "congr",
   "congrArg",
   "add_zero",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ c₁ b₂ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references": ["Monoid", "Semigroup"],
  "name": "Monoid.toSemigroup",
  "constType": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Option",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubNegMonoid.mk",
   "SubNegMonoid.zsmul_zero'",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Decidable",
   "Not",
   "not_not_intro",
   "Decidable.of_not_not"],
  "name": "Decidable.not_not",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬¬p ↔ p",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "StrictOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "Int.zero_ne_one.match_1",
   "OfNat.ofNat",
   "False",
   "instOfNatInt",
   "Int",
   "Eq"],
  "name": "Int.zero_ne_one",
  "constType": "0 ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "mul_lt_mul_of_pos_left",
   "congrArg",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
   "AddCommMonoid.mk",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalCommSemiring.mk",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [s : NonUnitalCommRing α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Eq.refl",
   "congrArg₂",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Eq",
   "Eq.mpr",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "Eq.trans",
   "id",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "HMul.hMul"],
  "name": "two_mul",
  "constType":
  "∀ {α : Type u} [inst : NonAssocSemiring α] (n : α), 2 * n = n + n",
  "constCategory": "Theorem"},
 {"references":
  ["DivInvOneMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.mk",
  "constType":
  "{G : Type u_2} → [toDivInvMonoid : DivInvMonoid G] → 1⁻¹ = 1 → DivInvOneMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} → [inst : AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IntCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictMono.compares",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Function.Injective",
   "Ordering.Compares",
   "Preorder.toLT",
   "Ordering.eq",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Eq"],
  "name": "StrictMono.injective",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Iff",
   "Nat.cast_injective",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Nat",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "Nat.cast_inj",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "Int.linearOrderedCommRing",
   "abs_of_nonneg",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "SemilatticeSup.toSup",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Int.instNegInt",
   "Int.instLinearOrderInt",
   "le_of_lt",
   "Nat",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Int.abs_eq_natAbs.match_1",
   "instDistribLattice",
   "SubNegZeroMonoid.toNegZeroClass",
   "abs_of_nonpos",
   "DistribLattice.toLattice",
   "Int.instAddGroupInt",
   "instNatCastInt",
   "Int.negSucc",
   "Int.negSucc_lt_zero",
   "Int.ofNat_zero_le",
   "NegZeroClass.toZero",
   "Int",
   "Int.natAbs"],
  "name": "Int.abs_eq_natAbs",
  "constType": "∀ (a : ℤ), |a| = ↑(Int.natAbs a)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "pow_succ",
   "Nat",
   "Eq.trans",
   "Commute.self_pow"],
  "name": "pow_succ'",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a ^ n * a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{α : Type u_1} → [toLattice : Lattice α] → (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) → DistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["AddCommMagma.add_comm",
   "AddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Ring.one_pow",
   "FermatLastTheoremFor",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Mathlib.Tactic.Ring.pow_zero",
   "Eq",
   "Zero.toOfNat0",
   "FermatLastTheoremWith",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Mathlib.Tactic.Ring.pow_add",
   "Mathlib.Tactic.Ring.pow_congr",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "Int.instMonoidInt",
   "id",
   "HPow.hPow",
   "Ne",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "not_fermat_42",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Mathlib.Tactic.Ring.mul_pow",
   "instHAdd",
   "Nat.rawCast",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "Int.instCommSemiringInt",
   "Mathlib.Tactic.Ring.single_pow",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.instAddInt",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.of_eq",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "fermatLastTheoremFor_iff_int",
   "Int.instSemiringInt",
   "HMul.hMul",
   "Mathlib.Tactic.Ring.add_mul",
   "MonoidWithZero.toZero",
   "Mathlib.Tactic.Ring.atom_pf",
   "Int",
   "Nat.semiring"],
  "name": "fermatLastTheoremFour",
  "constType": "FermatLastTheoremFor 4",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Inv"],
  "name": "GroupWithZero.toInv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Inv G₀",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "instAddNat",
   "Int.negSucc",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.subNatNat",
   "Int.add.match_1"],
  "name": "Int.add",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.inv_one",
  "constType": "∀ {G : Type u_2} [self : DivInvOneMonoid G], 1⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHMul",
   "Int.instMulInt",
   "Eq.ndrec",
   "Nat.zero",
   "Int.negOfNat",
   "Int.negSucc",
   "Eq.refl",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Int",
   "Nat.casesOn",
   "Eq"],
  "name": "Int.negSucc_mul_negOfNat",
  "constType":
  "∀ (m n : ℕ), Int.negSucc m * Int.negOfNat n = Int.ofNat (Nat.succ m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Nat.commSemiring", "inferInstance", "CommSemiring", "Nat"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Int.instCommSemiringInt",
   "Int"],
  "name": "Int.instSemiringInt",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableIff.proof_4",
   "instDecidableIff.proof_2",
   "Iff",
   "Decidable.isFalse",
   "instDecidableIff.proof_1",
   "instDecidableIff.proof_3",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite"],
  "name": "instDecidableIff",
  "constType":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], Nontrivial α",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "Semigroup",
   "Eq"],
  "name": "CommSemigroup.mk",
  "constType":
  "{G : Type u} → [toSemigroup : Semigroup G] → (∀ (a b : G), a * b = b * a) → CommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["Monoid", "CommMonoid"],
  "name": "CommMonoid.toMonoid",
  "constType": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Int"],
  "name": "DivisionSemiring.zpow",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} → [self : Ring R] → Sub R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_1",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub", "Int.instSubInt", "HSub.hSub", "Int", "Int.NonNeg"],
  "name": "Int.le",
  "constType": "ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["And.right",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = Int.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Nat.rec",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "LinearOrderedRing.toStrictOrderedRing",
   "Int.coe_natAbs",
   "CommRing.toNonUnitalCommRing",
   "Nat.instDvdNat",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Int.linearOrderedCommRing",
   "semigroupDvd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "True",
   "Abs.abs",
   "iff_self",
   "Eq",
   "abs_abs",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "SemilatticeSup.toSup",
   "Int.natAbs_neg",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Int.instSemigroupInt",
   "Int.instNegInt",
   "Int.instLinearOrderInt",
   "Nat",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "Int.instCommRingInt",
   "Int.instDvdInt",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "Or",
   "Int.natAbs_eq",
   "instDistribLattice",
   "Dvd.dvd",
   "Neg.neg",
   "Mathlib.Algebra.Ring.Divisibility.Basic._auxLemma.2",
   "Or.casesOn",
   "SubNegZeroMonoid.toNegZeroClass",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "Int.instAddGroupInt",
   "Mathlib.Data.Int.Dvd.Basic._auxLemma.2",
   "instNatCastInt",
   "of_eq_true",
   "congr",
   "congrArg",
   "NegZeroClass.toNeg",
   "Int",
   "Int.natAbs"],
  "name": "Int.coe_nat_dvd_left",
  "constType": "∀ {n : ℕ} {z : ℤ}, ↑n ∣ z ↔ n ∣ Int.natAbs z",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "AddHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Nat.addMonoid",
   "Finset",
   "Multiset",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "IsCancelMulZero",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "IsDomain.mk",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [toIsCancelMulZero : IsCancelMulZero α] [toNontrivial : Nontrivial α], IsDomain α",
  "constCategory": "Other"},
 {"references": ["mul_comm", "CommMagma", "CommMagma.toMul", "Commute"],
  "name": "Commute.all",
  "constType": "∀ {S : Type u_2} [inst : CommMagma S] (a b : S), Commute a b",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "Int.ofNat_mul_negOfNat",
   "Int.negOfNat",
   "Eq.refl",
   "True",
   "Int.mul_comm",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Int.negOfNat_mul_ofNat",
  "constType": "∀ (m n : ℕ), Int.negOfNat m * ↑n = Int.negOfNat (m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddSemigroup",
   "AddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "CancelMonoidWithZero",
   "OfNat.ofNat",
   "Function.Injective.eq_iff",
   "MulZeroOneClass.toMulZeroClass",
   "CancelMonoidWithZero.toIsCancelMulZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "mul_right_injective₀",
   "IsCancelMulZero.toIsLeftCancelMulZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero"],
  "name": "mul_right_inj'",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, a ≠ 0 → (a * b = a * c ↔ b = c)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Eq.refl",
   "Eq.symm",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "le_rfl",
   "Mathlib.Algebra.Order.Ring.Lemmas._auxLemma.8",
   "CanonicallyOrderedCommSemiring.toOne",
   "Preorder.toLE",
   "Nat.linearOrder",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "Nat.addMonoid",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "Or",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
   "Nat.le_mul_self.match_1",
   "MulOneClass.toOne",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.canonicallyOrderedCommSemiring",
   "or_true",
   "instHMul",
   "Std.Classes.Order._auxLemma.4",
   "Nat.zero",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Nat.orderedSemiring",
   "LT.lt",
   "OrderedSemiring.toPosMulMono",
   "congrArg",
   "OrderedCancelAddCommMonoid.toContravariantClassRight",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "AddZeroClass.toAdd",
   "IsRightCancelAdd.contravariant_swap_add_le_of_contravariant_swap_add_lt",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "Zero.toOfNat0",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "instLENat",
   "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "PosMulStrictMono.toPosMulReflectLE",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.15",
   "NeZero.succ",
   "Nat.linearOrderedCommMonoidWithZero",
   "instAddNat",
   "instHAdd",
   "Unit",
   "One.toOfNat1",
   "LE.le",
   "GT.gt",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.17",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "StrictOrderedSemiring.toPartialOrder",
   "HMul.hMul",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "instMulNat",
   "Nat.semiring"],
  "name": "Nat.le_mul_self",
  "constType": "∀ (n : ℕ), n ≤ n * n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "Ring.toNeg",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "HAdd.hAdd",
   "Ring.toIntCast",
   "Ring",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "Ring.toSemiring",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.mul_comm",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_8",
   "OrderBot",
   "Nat.canonicallyOrderedCommSemiring.proof_12",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.nontrivial",
   "OrderedAddCommMonoid",
   "Nat.eq_zero_of_mul_eq_zero",
   "inferInstance",
   "instLENat",
   "Semiring.npow",
   "Nat.canonicallyOrderedCommSemiring.proof_10",
   "Nat.canonicallyOrderedCommSemiring.proof_3",
   "CommSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Nat",
   "Nat.canonicallyOrderedCommSemiring.proof_7",
   "Nat.linearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.add_le_add_left",
   "Nat.canonicallyOrderedCommSemiring.proof_5",
   "CanonicallyOrderedCommSemiring.mk",
   "Nat.le_add_right",
   "OrderedAddCommMonoid.mk",
   "OrderBot.bot_le",
   "Nat.canonicallyOrderedCommSemiring.proof_11",
   "Nat.canonicallyOrderedCommSemiring.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.canonicallyOrderedCommSemiring.proof_6",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.toOne",
   "Nat.commSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_9",
   "Nat.canonicallyOrderedCommSemiring.proof_1",
   "Nat.orderedSemiring",
   "OrderBot.toBot",
   "Nat.canonicallyOrderedCommSemiring.proof_4",
   "LinearOrderedSemiring",
   "Nontrivial",
   "OrderBot.mk",
   "Nat.orderBot",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Int.instSubInt",
   "instOfNatInt",
   "_private.Init.Data.Int.Basic.0.Int.decNonneg",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable",
   "HSub.hSub",
   "Int",
   "Int.instLTInt",
   "Int.instAddInt"],
  "name": "Int.decLt",
  "constType": "(a b : ℤ) → Decidable (a < b)",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_zero",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.rec",
   "Int.add_comm",
   "Int",
   "Eq",
   "Int.instAddInt"],
  "name": "Int.zero_add",
  "constType": "∀ (a : ℤ), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "propext", "or_self.match_1", "Eq"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["DivisionSemiring", "Nontrivial"],
  "name": "DivisionSemiring.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Nat.Prime",
   "Semiring.toMonoidWithZero",
   "instOfNatNat",
   "Nat",
   "Nat.semiring",
   "Irreducible.ne_zero"],
  "name": "Nat.Prime.ne_zero",
  "constType": "∀ {n : ℕ}, Nat.Prime n → n ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Iff", "Classical.propDecidable", "Not", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Nat.cast",
   "Int.natAbs_eq",
   "instNatCastInt",
   "Int.instNegInt",
   "Neg.neg",
   "Exists.intro",
   "Nat",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.eq_nat_or_neg",
  "constType": "∀ (a : ℤ), ∃ n, a = ↑n ∨ a = -↑n",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegZeroMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "LeftDistribClass.left_distrib",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq"],
  "name": "left_distrib",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "LT.lt", "LT", "Eq"],
  "name": "lt_of_eq_of_lt",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LT α], a = b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["instSubNat",
   "Int.subNatNat_add_add",
   "HAdd.hAdd",
   "GE.ge",
   "Eq.refl",
   "Int.subNatNat_of_lt",
   "instLTNat",
   "True",
   "Eq",
   "Nat.sub_add_cancel",
   "Eq.mpr",
   "Nat.cast",
   "instLENat",
   "Nat.pred",
   "Eq.rec",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "Nat.sub_pos_of_lt",
   "Nat.add_sub_assoc",
   "id",
   "eq_self",
   "instHSub",
   "Or",
   "Or.inr",
   "instAddNat",
   "instHAdd",
   "HSub.hSub",
   "Nat.succ_pred_eq_of_pos",
   "Or.casesOn",
   "Int.instAddInt",
   "Eq.ndrec",
   "Or.inl",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "LT.lt",
   "Nat.le_add_left",
   "Int.subNatNat_of_le",
   "congr",
   "Nat.le_trans",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "congrArg",
   "Int",
   "Int.subNatNat"],
  "name": "Int.subNatNat_add",
  "constType":
  "∀ (m n k : ℕ), Int.subNatNat (m + n) k = ↑m + Int.subNatNat n k",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.instAddInt"],
  "name": "Int.lt",
  "constType": "ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references": ["One", "InvOneClass"],
  "name": "InvOneClass.toOne",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → One G",
  "constCategory": "Definition"},
 {"references": ["Div.mk", "Rat.div", "Rat", "Div"],
  "name": "Rat.instDivRat",
  "constType": "Div ℚ",
  "constCategory": "Definition"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulOneClass",
   "MulOneClass.toOne",
   "HasDistribNeg",
   "Neg.neg",
   "One.toOfNat1",
   "True",
   "Eq",
   "instHMul",
   "one_mul",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "neg_mul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "neg_one_mul",
  "constType":
  "∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Int.instMulInt",
   "instOfNatInt",
   "Eq.refl",
   "Int.instLTInt",
   "Eq",
   "Int.eq_succ_of_zero_lt",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "Int.ofNat_succ_pos",
   "LT.lt",
   "Int.mul_pos.match_1",
   "HMul.hMul",
   "Int.ofNat_mul",
   "instMulNat",
   "Nat",
   "Nat.mul",
   "Eq.symm",
   "Int",
   "Nat.succ",
   "id"],
  "name": "Int.mul_pos",
  "constType": "∀ {a b : ℤ}, 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Abs", "Abs.mk", "Sup", "Neg.neg", "Sup.sup", "Neg"],
  "name": "Neg.toHasAbs",
  "constType": "{α : Type u_1} → [inst : Neg α] → [inst : Sup α] → Abs α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "MonoidWithZero",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "GroupWithZero",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Int",
   "Inv.inv"],
  "name": "GroupWithZero.mk",
  "constType":
  "{G₀ : Type u} →\n  [toMonoidWithZero : MonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → GroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "mul_le_mul_of_nonneg_left",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toPosMulMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x_2 * x ≤ x_2 * x_1",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "One.toOfNat1",
   "Neg.neg",
   "HasDistribNeg",
   "SemiconjBy.neg_one_left",
   "Commute"],
  "name": "Commute.neg_one_left",
  "constType":
  "∀ {R : Type x} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] (a : R), Commute (-1) a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "mul_ne_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedSemiring",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "ne_of_gt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name":
  "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.mul_ne_zero_of_pos_of_ne_zero",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : NoZeroDivisors α] {a b : α}, 0 < a → b ≠ 0 → a * b ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "CommRing.toRing",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "CommRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "CommRing.toNonUnitalCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references": ["CommMonoidWithZero", "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCommMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelCommMonoidWithZero M₀] → CommMonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references": ["lt_asymm", "Preorder.toLT", "LT.lt", "Not", "Preorder"],
  "name": "LT.lt.not_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "LinearOrder.decidableLE",
   "LinearOrder.max_def",
   "Field.toNontrivial",
   "Field.zpow_neg'",
   "Field.zpow",
   "Field.toRatCast",
   "Rat.instLinearOrderedFieldRat.proof_2",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Field.mul_inv_cancel",
   "Field",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Rat.linearOrder",
   "Field.ratCast_mk",
   "LinearOrder",
   "Semiring",
   "StrictOrderedRing.mk",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Field.toInv",
   "Rat.semiring",
   "Rat.field",
   "Rat.instLinearOrderedFieldRat.proof_1",
   "LinearOrder.toOrd",
   "Rat.instLinearOrderedFieldRat.proof_3",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "Field.inv_zero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "Field.qsmul",
   "LinearOrderedRing.mk",
   "Rat.instLinearOrderedFieldRat.proof_4",
   "Field.div_eq_mul_inv"],
  "name": "Rat.instLinearOrderedFieldRat",
  "constType": "LinearOrderedField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "LinearOrderedRing",
   "DecidableEq",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedRing : StrictOrderedRing α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "Nat",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "iff_true_intro", "IsEmpty", "True", "isEmptyElim"],
  "name": "IsEmpty.forall_iff",
  "constType":
  "∀ {α : Sort u_1} [inst : IsEmpty α] {p : α → Prop}, (∀ (a : α), p a) ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ord.compare",
   "Ordering",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toOrd",
   "Preorder.toLT",
   "LinearOrderedCommRing",
   "LinearOrderedRing.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_4",
  "constType":
  "∀ {α : Type u_1} [d : LinearOrderedCommRing α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "mul_neg",
   "HasDistribNeg",
   "Neg.neg",
   "neg_neg",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "sq",
   "of_eq_true",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "congr",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "neg_mul",
   "congrArg",
   "Eq.trans"],
  "name": "neg_sq",
  "constType":
  "∀ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R), (-a) ^ 2 = a ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "MulZeroOneClass.toMulZeroClass",
   "Monoid.toMulOneClass",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "MonoidWithZero.toZero",
   "absurd",
   "zero_pow'.match_1",
   "id",
   "MonoidWithZero"],
  "name": "zero_pow'",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] (n : ℕ), n ≠ 0 → 0 ^ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "instOfNatInt",
   "AddMonoidWithOne.toAddMonoid",
   "Int.linearOrderedCommRing",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "StrictOrderedSemiring.to_charZero",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instNatCastInt",
   "of_eq_true",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.coe_nat_ne_zero",
  "constType": "∀ {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "one_pow",
   "instLTNat",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.pow_lt_pow_of_lt_left",
   "instHPow",
   "LT.lt",
   "Nat.monoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Nat.one_lt_pow",
  "constType": "∀ (n m : ℕ), 0 < n → 1 < m → 1 < m ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.natAbs_mul_self.match_1",
   "OfNat.ofNat",
   "instOfNatInt",
   "Int.negSucc",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "rfl",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "Int.add_zero",
  "constType": "∀ (a : ℤ), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.le_refl",
   "Not.imp",
   "Ne",
   "Eq.refl",
   "Int.lt_iff_le_and_ne",
   "LE.le",
   "Int.lt_iff_le_and_ne.match_1",
   "Int.instLTInt",
   "Eq",
   "Iff.intro",
   "And",
   "Int.le_antisymm",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Not",
   "And.intro",
   "Int.lt_iff_le_not_le.match_1",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.lt_iff_le_not_le",
  "constType": "∀ {a b : ℤ}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Field", "RatCast"],
  "name": "Field.toRatCast",
  "constType": "{K : Type u} → [self : Field K] → RatCast K",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "mul_one",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "pow_one",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mk",
  "constType":
  "{α : Type u} → [toRing : Ring α] → (∀ (a b : α), a * b = b * a) → CommRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instNatPowNat",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "∀ (n : ℕ), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "neg_one_mul",
   "HasDistribNeg",
   "Neg.neg",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Commute.neg_one_left",
   "Eq",
   "instHMul",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "Eq.rec",
   "HasDistribNeg.toInvolutiveNeg",
   "Commute.mul_pow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "Nat"],
  "name": "neg_pow",
  "constType":
  "∀ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R) (n : ℕ), (-a) ^ n = (-1) ^ n * a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{α : Type u} → [inst : NonUnitalNonAssocRing α] → HasDistribNeg α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommGroupWithZero.mk",
   "CommMonoidWithZero.toZero",
   "zpowRec",
   "Monoid.toOne",
   "CommGroupWithZero",
   "Rat.commGroupWithZero.proof_6",
   "Rat",
   "Rat.commGroupWithZero.proof_3",
   "Rat.instDivRat",
   "Rat.commGroupWithZero.proof_4",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Rat.commGroupWithZero.proof_8",
   "Rat.commRing",
   "Rat.commGroupWithZero.proof_2",
   "Rat.commGroupWithZero.proof_7",
   "Rat.instInvRat",
   "Rat.mul_inv_cancel",
   "CommMonoidWithZero.mk",
   "Rat.commGroupWithZero.proof_5",
   "CommSemiring.toCommMonoidWithZero",
   "CommMonoid.toMonoid",
   "Rat.commGroupWithZero.proof_1"],
  "name": "Rat.commGroupWithZero",
  "constType": "CommGroupWithZero ℚ",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "NeZero",
   "OfNat.ofNat",
   "NeZero.ne",
   "OfNat",
   "instOfNatNat",
   "Nat"],
  "name": "two_ne_zero",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : OfNat α 2] [inst_2 : NeZero 2], 2 ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "zero_lt_two",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "eq_true",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "Mathlib.Algebra.Order.Monoid.NatCast._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], (0 < 2) = True",
  "constCategory": "Theorem"},
 {"references":
  ["List.tfae_singleton",
   "List.cons",
   "eq_true",
   "List.nil",
   "True",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.1",
  "constType": "∀ (p : Prop), List.TFAE [p] = True",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_left_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "mul_sub",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), a * (b - c) = a * b - a * c",
  "constCategory": "Theorem"},
 {"references": ["CommSemigroup", "Semigroup"],
  "name": "CommSemigroup.toSemigroup",
  "constType": "{G : Type u} → [self : CommSemigroup G] → Semigroup G",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommRing α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "True",
   "CommMonoid.toCommSemigroup",
   "DivInvMonoid.toInv",
   "Eq",
   "mul_comm",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "DivisionCommMonoid.toDivisionMonoid",
   "DivisionCommMonoid.toCommMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "DivisionCommMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "mul_inv_rev",
   "congrArg",
   "Eq.trans",
   "mul_left_comm",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "mul_div_mul_comm",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b c d : α), a * b / (c * d) = a / c * (b / d)",
  "constCategory": "Theorem"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.out",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "MulZeroOneClass.toMulZeroClass",
   "Monoid.toMulOneClass",
   "instLTNat",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "zero_pow.match_1",
   "instHPow",
   "LT.lt",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "Monoid.toNatPow",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "MonoidWithZero.toZero",
   "id",
   "MonoidWithZero"],
  "name": "zero_pow",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] {n : ℕ}, 0 < n → 0 ^ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Eq.symm",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero_of_right",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] (a : M₀) {b : M₀}, b = 0 → a * b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "CommMonoid.mul_comm",
   "CommMonoidWithZero",
   "CommSemiring.toCommMonoidWithZero.proof_1",
   "CommSemiring.toCommMonoidWithZero.proof_2",
   "CommMonoid",
   "CommSemiring",
   "AddMonoid.toZero",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "CommMonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HMul.hMul →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.mul x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HMul.hMul) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.mul x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HMul.hMul (↑n) (↑n_1) n n_1 (Int.mul n n_1) (_ : HMul.hMul = HMul.hMul)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.mul n n_1 = Int.mul n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_3",
  "constType": "∀ (a b c : ℕ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulPosStrictMono",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toMulPosStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], MulPosStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toSubNegMonoid : SubNegMonoid G] →\n    (∀ (x : G), - -x = x) → (∀ (a b : G), -(a + b) = -b + -a) → (∀ (a b : G), a + b = 0 → -a = b) → SubtractionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.instModInt_1",
   "instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "instHMod",
   "Eq.mpr",
   "Eq.ndrec",
   "instOfNatInt",
   "Eq.refl",
   "HMul.hMul",
   "HMod.hMod",
   "Int",
   "Int.mul_comm",
   "Int.mul_emod_left",
   "id",
   "Eq"],
  "name": "Int.mul_emod_right",
  "constType": "∀ (a b : ℤ), a * b % a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.pos_of_ne_zero",
   "LT.lt",
   "Rat.den_nz",
   "Rat",
   "Rat.den",
   "instOfNatNat",
   "Nat",
   "instLTNat"],
  "name": "Rat.den_pos",
  "constType": "∀ (self : ℚ), 0 < self.den",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "Eq.symm",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero_of_left",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] {a : M₀}, a = 0 → ∀ (b : M₀), a * b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "CommMonoid",
   "LinearOrderedCommMonoid",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "CommMonoid.toMonoid",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toLinearOrder : LinearOrder α] →\n    [toCommMonoid : CommMonoid α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b) → LinearOrderedCommMonoid α",
  "constCategory": "Other"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Chain"],
  "name": "List.Chain.cons",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "Sub",
   "autoParam",
   "AddMonoid",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Int",
   "Neg"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), a * b = 1 → a⁻¹ = b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Distrib",
   "Eq"],
  "name": "Distrib.mk",
  "constType":
  "{R : Type u_1} →\n  [toMul : Mul R] →\n    [toAdd : Add R] →\n      (∀ (a b c : R), a * (b + c) = a * b + a * c) → (∀ (a b c : R), (a + b) * c = a * c + b * c) → Distrib R",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommRing.toCommMonoid",
   "zpowRec",
   "Rat.commRing",
   "Monoid.toOne",
   "Int.negSucc",
   "Rat.instInvRat",
   "Rat",
   "Eq.refl",
   "CommMonoid.toMonoid",
   "Nat",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_6",
  "constType":
  "∀ (n : ℕ) (a : ℚ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat", "Int.negSucc", "Nat", "Int.rec", "Int"],
  "name": "Int.casesOn",
  "constType":
  "{motive : ℤ → Sort u} → (t : ℤ) → ((a : ℕ) → motive (Int.ofNat a)) → ((a : ℕ) → motive (Int.negSucc a)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "instHMul",
   "MulOneClass.toMul",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "mul_inv_rev",
  "constType":
  "∀ {G : Type u_1} [inst : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Rat.linearOrder.proof_2",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Rat.instLERat",
   "PartialOrder.mk",
   "Max.mk",
   "Iff.rfl",
   "Rat.not_le",
   "Eq.refl",
   "Min.mk",
   "Preorder.toLE",
   "ite",
   "Eq",
   "Rat.le_antisymm",
   "inferInstance",
   "Eq.mpr",
   "Rat.le_refl",
   "Iff",
   "Decidable",
   "LinearOrder.mk",
   "compareOfLessAndEq",
   "Eq.symm",
   "Rat.le_trans",
   "id",
   "LinearOrder",
   "Rat.linearOrder.proof_1",
   "Rat.linearOrder.proof_3",
   "Rat",
   "and_iff_right_of_imp",
   "decidableEqOfDecidableLE",
   "LE.le",
   "Preorder.mk",
   "Rat.instLTRat",
   "Or.resolve_left",
   "Rat.linearOrder.proof_4",
   "And",
   "Rat.instDecidableLeRatInstLERat",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "decidableLTOfDecidableLE",
   "Not",
   "Rat.le_total"],
  "name": "Rat.linearOrder",
  "constType": "LinearOrder ℚ",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → HEq a a_1 → Sort u_1} →\n      motive a (_ : HEq a a) → {β : Sort u} → {a_1 : β} → (t : HEq a a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "neg_eq_self_iff",
   "CharZero",
   "propext",
   "NonAssocRing.toNonAssocSemiring",
   "AddCommGroupWithOne.toAddGroupWithOne"],
  "name": "Mathlib.Algebra.CharZero.Lemmas._auxLemma.9",
  "constType":
  "∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : NoZeroDivisors R] [inst_2 : CharZero R] {a : R}, (-a = a) = (a = 0)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Int.decEq", "Int"],
  "name": "Int.instDecidableEqInt",
  "constType": "DecidableEq ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Inhabited",
   "instOfNatNat",
   "Nat",
   "Inhabited.mk",
   "Int"],
  "name": "Int.instInhabitedInt",
  "constType": "Inhabited ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.zero_ne_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.nontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "of_decide_eq_true",
   "Rat",
   "Eq.refl",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Rat.field",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "Rat.instDecidableLeRatInstLERat",
   "Bool.true",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Bool",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Rat.linearOrder",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.instLinearOrderedFieldRat.proof_2",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "Int.cast_add.match_1",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "eq_neg_add_iff_add_eq",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_iff_eq_add",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "instHSub",
   "add_assoc",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Nat.cast_add",
   "Int.instAddInt",
   "Int.cast_ofNat",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "Nat.add_right_comm",
   "SubtractionMonoid.toSubNegMonoid",
   "propext",
   "Int.cast",
   "Int.negSucc",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "NegZeroClass.toNeg",
   "congrArg",
   "Int",
   "neg_add_rev",
   "Int.subNatNat",
   "Int.cast_subNatNat"],
  "name": "Int.cast_add",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.cast",
   "Rat.instIntCastRat",
   "OfNat",
   "Rat",
   "OfNat.mk",
   "Nat",
   "Int"],
  "name": "Rat.instOfNatRat",
  "constType": "{n : ℕ} → OfNat ℚ n",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Dvd.intro",
   "rfl",
   "Semigroup"],
  "name": "dvd_mul_right",
  "constType": "∀ {α : Type u_1} [inst : Semigroup α] (a b : α), a ∣ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "NegZeroClass.neg_zero",
   "Eq"],
  "name": "neg_zero",
  "constType": "∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["lt_of_le_of_ne",
   "Ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Ne.symm",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
  "constType":
  "∀ {A : Type u_1} {a b : A} [inst : PartialOrder A], a ≤ b → b ≠ a → a < b",
  "constCategory": "Theorem"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableFalse",
   "False",
   "instDecidableNot",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "instDecidableIff",
   "instDecidableTrue",
   "instDecidableEqProp",
   "True",
   "Eq"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semifield.zpow_zero'",
   "DivisionSemiring",
   "Semifield.toNontrivial",
   "Semifield.toCommSemiring",
   "DivisionSemiring.mk",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.mul_inv_cancel",
   "Semifield.zpow_neg'",
   "Semifield.zpow",
   "Semifield.toDiv",
   "Semifield.toInv",
   "Semifield",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references": ["DivisionMonoid", "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvMonoid",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.zero_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "lt_add_of_pos_right",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Mathlib.Tactic.LinearCombination.eq_of_add",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.isNat_eq_false",
   "Or.resolve_right",
   "Mathlib.Tactic.Ring.pow_zero",
   "And.left",
   "And.right",
   "Int.Prime.dvd_pow'",
   "le_of_lt",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.prime_two",
   "Nat.strictOrderedSemiring",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.gcd",
   "or_self_iff",
   "Int.coprime_of_sq_sum'",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "Nat.orderedSemiring",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "IsCoprime.add_mul_right_left",
   "And.intro",
   "MonoidWithZero.toZero",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "instOfNatInt",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "right_ne_zero_of_mul",
   "Mathlib.Tactic.Ring.sub_pf",
   "PythagoreanTriple",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Fermat42.coprime_of_minimal",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "absurd",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Int.instMulInt",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Nat.linearOrderedCommMonoidWithZero",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Meta.NormNum.isInt_pow",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "Monoid.toMulOneClass",
   "LE.le",
   "Mathlib.Logic.IsEmpty._auxLemma.1",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.one_mul",
   "not_true_eq_false",
   "Int.instAddMonoidInt",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "IsCoprime.pow_left",
   "neg_zero",
   "HAdd.hAdd",
   "dvd_mul_right",
   "AddGroup.toSubtractionMonoid",
   "IsCoprime",
   "gt_of_gt_of_ge",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "Int.instDecidableEqInt",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Int.instSemigroupInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.LinearCombination.c_mul_pf",
   "And.casesOn",
   "Eq.trans",
   "Int.instDvdInt",
   "StrictOrderedRing.toPartialOrder",
   "pow_eq_zero",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "IsCoprime.of_mul_left_left",
   "MulZeroOneClass.toMulZeroClass",
   "Int.instLTInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "lt_of_le_of_ne",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Eq.mp",
   "Mathlib.Tactic.Ring.mul_one",
   "Int.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "MulZeroClass.zero_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Int.gcd_eq_one_iff_coprime",
   "ne_of_gt",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "Int.mul_emod",
   "instOfNatNat",
   "Int.instLinearOrderInt",
   "Mathlib.Tactic.Ring.pow_congr",
   "CommSemiring.toCommMonoidWithZero",
   "Int.instMonoidInt",
   "zero_pow",
   "id",
   "eq_self",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "False",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "mt",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "Int.instAddCommGroupInt",
   "sq_pos_of_ne_zero",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Bool",
   "Int.natAbs",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "two_ne_zero",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "not_lt",
   "Mathlib.Meta.NormNum.intPow_negOfNat_bit0",
   "PythagoreanTriple.coprime_classification'",
   "Mathlib.Meta.NormNum.isInt_add",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "left_ne_zero_of_mul",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "mul_assoc",
   "Nat.cast",
   "IsDomain.to_noZeroDivisors",
   "sq",
   "Mathlib.Tactic.Ring.neg_congr",
   "Bool.true",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Mathlib.Tactic.Ring.pow_add",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Int.instCommRingInt",
   "zero_le_mul_right",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Tactic.LinearCombination.add_pf",
   "Or",
   "Int.gcd_comm",
   "CommMagma.toMul",
   "Mathlib.Tactic.Ring.neg_zero",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_true",
   "Nat.zero",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "neg_nonpos",
   "Exists",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Int.ofNat_lt",
   "True",
   "AddMonoidWithOne.toNatCast",
   "Fermat42.Minimal",
   "Mathlib.Meta.NormNum.one_natPow",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Or.inr",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "mul_ne_zero",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "ne_zero_pow",
   "pow_ne_zero",
   "Int.instModInt_1",
   "Or.inl",
   "Bool.false",
   "HMod.hMod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Int.le_self_sq",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "zero_lt_two",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "instLTNat",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Classical.not_not",
   "Eq.mpr",
   "instIsEmptyFalse",
   "Nat",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.rawCast",
   "OrderedSemiring.zeroLEOneClass",
   "sq_nonneg",
   "Int.natAbs_le_self_sq",
   "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "mul_right_inj'",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "instHMul",
   "Int.instAddGroupInt",
   "AddCancelMonoid.toIsCancelAdd",
   "Not",
   "congrArg",
   "CancelMonoidWithZero.toMonoidWithZero",
   "Int.instLEInt",
   "IsCoprime.pow",
   "Int.instSubInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "not_le_of_lt",
   "Mathlib.Meta.NormNum.isNat_add",
   "of_decide_eq_true",
   "Int.eq_natAbs_of_zero_le",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Int.linearOrderedCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "mul_comm",
   "Int.instRingInt",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "MulZeroClass.toZero",
   "Int.instNegInt",
   "LinearOrderedRing.isDomain",
   "Eq.symm",
   "NeZero.succ",
   "Fermat42",
   "instHAdd",
   "HSub.hSub",
   "IsDomain.toCancelMonoidWithZero",
   "Int.sq_of_gcd_eq_one",
   "Mathlib.Tactic.Ring.single_pow",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instHMod",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Int.instSemiringInt",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "Fermat42.not_minimal",
  "constType":
  "∀ {a b c : ℤ}, Fermat42.Minimal a b c → a % 2 = 1 → 0 < c → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubtractionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Monoid.toNatPow",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₃ b c : R} (a₁ : R) (a₂ : ℕ), a₃ * b = c → a₁ ^ a₂ * a₃ * b = a₁ ^ a₂ * c",
  "constCategory": "Theorem"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "Int"],
  "name": "LinearOrderedField.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [inst : Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references": ["Rat.inv", "Rat", "Inv", "Inv.mk"],
  "name": "Rat.instInvRat",
  "constType": "Inv ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "one_mul",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "one_pow",
  "constType": "∀ {M : Type u} [inst : Monoid M] (n : ℕ), 1 ^ n = 1",
  "constCategory": "Theorem"},
 {"references": ["Field", "Int"],
  "name": "Field.zpow",
  "constType": "{K : Type u} → [self : Field K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "DivisionSemiring",
   "div_eq_mul_inv",
   "True",
   "Eq",
   "add_mul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "HDiv.hDiv",
   "Eq.trans",
   "id",
   "DivInvMonoid.toDiv",
   "eq_self",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "instHAdd",
   "DivisionSemiring.toDiv",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "Monoid.toMulOneClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "DivInvMonoid.toInv",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "congr",
   "congrArg",
   "Inv.inv",
   "congrFun"],
  "name": "add_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionSemiring α] (a b c : α), (a + b) / c = a / c + b / c",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_1",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Exists",
   "Int.le.dest_sub",
   "OfNat.ofNat",
   "Int.instSubInt",
   "instOfNatInt",
   "HSub.hSub",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Int.sub_zero",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Eq.mp",
   "Nat",
   "Int",
   "Int.instLEInt"],
  "name": "Int.eq_ofNat_of_zero_le",
  "constType": "∀ {a : ℤ}, 0 ≤ a → ∃ n, a = ↑n",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.sub_eq_add_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "autoParam",
   "Semiring.toNatCast",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Ring",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Neg",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Semiring",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "Ring.mk",
  "constType":
  "{R : Type u} →\n  [toSemiring : Semiring R] →\n    [toNeg : Neg R] →\n      [toSub : Sub R] →\n        autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → R → R) →\n            autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  (∀ (a : R), -a + a = 0) →\n                    [toIntCast : IntCast R] →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → Ring R",
  "constCategory": "Other"},
 {"references":
  ["FermatLastTheoremFor",
   "List.cons",
   "OfNat.ofNat",
   "Rat",
   "Eq.refl",
   "Rat.semiring",
   "fermatLastTheoremWith_nat_int_rat_tfae",
   "FermatLastTheoremWith",
   "List.TFAE.out",
   "Iff",
   "Int.instSemiringInt",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.get?",
   "Int",
   "Nat.semiring",
   "Option"],
  "name": "fermatLastTheoremFor_iff_int",
  "constType": "∀ {n : ℕ}, FermatLastTheoremFor n ↔ FermatLastTheoremWith ℤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Contravariant",
   "Subtype.val",
   "MulPosReflectLE",
   "covariant_lt_iff_contravariant_le",
   "MulPosStrictMono",
   "LE.le",
   "Preorder.toLE",
   "CovariantClass.elim",
   "Zero.toOfNat0",
   "instHMul",
   "Covariant",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "Mul",
   "ContravariantClass.mk",
   "Subtype"],
  "name": "MulPosStrictMono.toMulPosReflectLE",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Zero α] [inst_2 : LinearOrder α] [inst_3 : MulPosStrictMono α],\n  MulPosReflectLE α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "Eq.ndrec",
   "NonUnitalNonAssocRing.zero_mul",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Rat.commRing",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CommRing.toNonUnitalCommRing",
   "Rat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_2",
  "constType": "∀ (a : ℚ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "Commute.eq",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "True",
   "Commute",
   "Semigroup",
   "Eq"],
  "name": "Commute.right_comm",
  "constType":
  "∀ {S : Type u_2} [inst : Semigroup S] {b c : S}, Commute b c → ∀ (a : S), a * b * c = a * c * b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["Int.casesOn",
   "Int.ofNat",
   "Int.negSucc",
   "Unit",
   "Unit.unit",
   "Nat",
   "Nat.succ",
   "Int",
   "Nat.casesOn"],
  "name": "Int.neg_neg.match_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ),\n  (Unit → motive (Int.ofNat 0)) →\n    (∀ (n : ℕ), motive (Int.ofNat (Nat.succ n))) → (∀ (a : ℕ), motive (Int.negSucc a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["lt_or_gt_of_ne",
   "Ne",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder"],
  "name": "Ne.lt_or_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x ≠ y → x < y ∨ y < x",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} (motive : Mathlib.Meta.NormNum.IsNat a 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a 0), (∀ (e : a = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat a 0)) → motive x",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_8",
  "constType": "∀ (a : ℕ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"},
 {"references": ["FermatLastTheoremWith", "Nat", "Nat.semiring"],
  "name": "FermatLastTheoremFor",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_3",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "List.cons",
   "List.chain_cons",
   "propext",
   "List",
   "List.Chain",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, List.Chain R a (b :: l) = (R a b ∧ List.Chain R b l)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Dvd",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "two_mul",
   "Int.instSubInt",
   "HEq",
   "instOfNatInt",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Int.mul_emod_right",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Iff.mpr",
   "Eq",
   "SubNegMonoid.toSub",
   "outParam",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Int.emod_eq_emod_iff_emod_sub_eq_zero",
   "instOfNatNat",
   "Int.instNegInt",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "HMod",
   "id",
   "instHSub",
   "Int.instMulInt",
   "instHAdd",
   "eq_of_heq",
   "HSub.hSub",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.instModInt_1",
   "instHMul",
   "instHMod",
   "Int.instAddGroupInt",
   "Eq.ndrec",
   "HEq.refl",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "SubNegMonoid.toAddMonoid",
   "Int.instSemiringInt",
   "instNatAtLeastTwo",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "HMod.hMod",
   "Eq.casesOn",
   "Int"],
  "name": "Int.neg_emod_two",
  "constType": "∀ (i : ℤ), -i % 2 = i % 2",
  "constCategory": "Theorem"},
 {"references": ["Min", "LinearOrderedRing"],
  "name": "LinearOrderedRing.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Exists",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "IsCoprime",
   "One.toOfNat1",
   "Exists.intro",
   "NonUnitalNonAssocSemiring.toMul",
   "Exists.casesOn",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul"],
  "name": "IsCoprime.of_mul_left_left.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {x y z : R} (motive : IsCoprime (x * y) z → Prop) (H : IsCoprime (x * y) z),\n  (∀ (a b : R) (h : a * (x * y) + b * z = 1), motive (_ : ∃ a b, a * (x * y) + b * z = 1)) → motive H",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "CanonicallyOrderedCommSemiring.toOne",
   "Preorder.toLE",
   "Iff.mpr",
   "Zero.toOfNat0",
   "pow_nonneg",
   "LinearOrderedRing.toLinearOrder",
   "Iff",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "not_le",
   "Nat",
   "HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "pow_bit1_neg",
   "instAddNat",
   "bit1",
   "Nat.canonicallyOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Iff.intro",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "MonoidWithZero.toZero"],
  "name": "pow_bit1_neg_iff",
  "constType":
  "∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R} {n : ℕ}, a ^ bit1 n < 0 ↔ a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "NonAssocRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Neg.neg",
   "One.toOfNat1",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "NonAssocRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                [toIntCast : IntCast α] →\n                  autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝² →\n                    autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝³ → NonAssocRing α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mk",
  "constType":
  "{α : Type u} → [toLinearOrderedRing : LinearOrderedRing α] → (∀ (a b : α), a * b = b * a) → LinearOrderedCommRing α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "OrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Even",
   "Exists.intro",
   "Exists.casesOn",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "pow_bit0_nonneg",
   "Zero.toOfNat0",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "congrArg",
   "id"],
  "name": "Even.pow_nonneg",
  "constType":
  "∀ {R : Type u_4} [inst : LinearOrderedRing R] {n : ℕ}, Even n → ∀ (a : R), 0 ≤ a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "HPow.hPow",
   "eq_self",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "add_zero",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.single_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {b : ℕ} {c : R}, a ^ b = c → (a + 0) ^ b = c + 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Ne", "Eq.refl", "Not", "Eq"],
  "name": "_private.Std.Data.Int.Lemmas.0.Ne._eq_1",
  "constType": "∀ {α : Sort u} (a b : α), (a ≠ b) = ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "eq_add_neg_iff_add_eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "NegZeroClass.toNeg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.5",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (a = b + -c) = (a + c = b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "NegZeroClass.toNeg",
   "AddGroup.toSubNegMonoid",
   "add_neg_eq_iff_eq_add",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.2",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (a + -b = c) = (a = c + b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InvolutiveNeg",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Int.zero_mul",
   "OfNat.ofNat",
   "instSubNat",
   "instOfNatInt",
   "GE.ge",
   "Eq.refl",
   "Int.subNatNat_of_lt",
   "instLTNat",
   "True",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "instLENat",
   "Nat.pred",
   "Nat.mul_le_mul_left",
   "Int.instNegInt",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "Nat.sub_pos_of_lt",
   "Nat.succ_pos",
   "id",
   "instHSub",
   "eq_self",
   "Int.neg_ofNat_succ",
   "Int.instMulInt",
   "Or",
   "Or.inr",
   "Nat.mul_sub_left_distrib",
   "Int.negOfNat",
   "HSub.hSub",
   "Int.subNatNat_self",
   "Neg.neg",
   "Nat.succ_pred_eq_of_pos",
   "Or.casesOn",
   "LE.le",
   "instHMul",
   "Or.inl",
   "Eq.ndrec",
   "Nat.zero",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "LT.lt",
   "Nat.zero_mul",
   "Int.subNatNat_of_le",
   "HMul.hMul",
   "congr",
   "Nat.lt_or_ge",
   "instMulNat",
   "Nat.mul_lt_mul_of_pos_left",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "Nat.casesOn"],
  "name": "Int.ofNat_mul_subNatNat",
  "constType":
  "∀ (m n k : ℕ), ↑m * Int.subNatNat n k = Int.subNatNat (m * n) (m * k)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "Semiring",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
   "StrictOrderedRing.toNontrivial",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
   "StrictOrderedRing.zero_le_one",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_1"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedRing α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Eq"],
  "name": "CommMonoid.mul_comm",
  "constType": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "IsCoprime.pow_left",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "IsCoprime.pow_right",
   "CommSemiring",
   "Semiring.toMonoidWithZero",
   "Monoid.toNatPow",
   "IsCoprime",
   "Nat"],
  "name": "IsCoprime.pow",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y : R} {m n : ℕ}, IsCoprime x y → IsCoprime (x ^ m) (y ^ n)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemiring", "Max"],
  "name": "LinearOrderedSemiring.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Int.emod_add_ediv.match_1",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.emod_add_ediv.aux",
   "Int.emod_zero",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Nat.mod_add_div",
   "Int.instDivInt_1",
   "Int.neg_mul_neg",
   "Int.instNegInt",
   "HDiv.hDiv",
   "Nat.instDivNat",
   "Nat",
   "Nat.succ",
   "id",
   "instHDiv",
   "Int.instMulInt",
   "instAddNat",
   "instHAdd",
   "Neg.neg",
   "Int.instAddInt",
   "Int.instModInt_1",
   "instHMul",
   "Nat.instModNat",
   "instHMod",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "HMod.hMod",
   "instMulNat",
   "congrArg",
   "Int",
   "Int.natAbs"],
  "name": "Int.emod_add_ediv",
  "constType": "∀ (a b : ℤ), a % b + b * (a / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "Monotone.reflect_lt",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulPosReflectLT",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "monotone_mul_right_of_nonneg",
   "Preorder.toLE",
   "Subtype.property",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HMul.hMul",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "ContravariantClass.mk",
   "Subtype"],
  "name": "LinearOrderedSemiring.toMulPosReflectLT",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α], MulPosReflectLT α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Ring.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "False",
   "instLENat",
   "Nat.not_le_of_gt",
   "flip",
   "LT.lt",
   "Not",
   "Nat.ge_of_not_lt",
   "Nat",
   "LE.le",
   "instLTNat",
   "Iff.mpr"],
  "name": "Nat.le_lt_asymm",
  "constType": "∀ {a b : ℕ}, b ≤ a → ¬a < b",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommMonoid",
   "inferInstance",
   "CommMonoid",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instCommMonoidInt",
  "constType": "CommMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "HPow.hPow",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "Semiring.toMonoidWithZero",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "pow_bit0_nonneg",
   "Zero.toOfNat0",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat",
   "MonoidWithZero.toZero"],
  "name": "sq_nonneg",
  "constType":
  "∀ {R : Type u_2} [inst : LinearOrderedRing R] (a : R), 0 ≤ a ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Iff.intro",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "Iff",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mul_eq_zero_of_right",
   "Or.elim",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_5",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instDecidableEq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "And.left",
   "MulZeroClass.toMul",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "Iff.mpr",
   "LT.lt.ne",
   "Eq",
   "Zero.toOfNat0",
   "And.right",
   "LinearOrderedRing.toLinearOrder",
   "mul_pos_of_neg_of_neg",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "mul_neg_of_pos_of_neg",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "mul_neg_of_neg_of_pos",
   "StrictOrderedRing.toPartialOrder",
   "lt_or_gt_of_ne",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "False",
   "Or.inr",
   "Ne.symm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "StrictOrderedSemiring.toSemiring",
   "Decidable.or_iff_not_and_not",
   "GT.gt",
   "NoZeroDivisors",
   "instHMul",
   "And",
   "Or.inl",
   "LT.lt",
   "HMul.hMul",
   "Not",
   "LinearOrder.toPartialOrder",
   "mul_pos",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "MonoidWithZero.toZero"],
  "name": "LinearOrderedRing.noZeroDivisors",
  "constType": "∀ {α : Type u} [inst : LinearOrderedRing α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "LinearOrderedSemiring.toMax",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedSemiring.min_def",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrder.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.decidableLT",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["Nat.gcd", "Nat", "rfl", "Int", "Int.natAbs", "Eq", "Int.gcd"],
  "name": "Int.gcd_eq_natAbs",
  "constType":
  "∀ {a b : ℤ}, Int.gcd a b = Nat.gcd (Int.natAbs a) (Int.natAbs b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "Function.Injective",
   "mul_left_cancel₀",
   "HMul.hMul",
   "Mul",
   "IsLeftCancelMulZero"],
  "name": "mul_right_injective₀",
  "constType":
  "∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀] {a : M₀},\n  a ≠ 0 → Function.Injective fun x => a * x",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "instHMul",
   "Int.negOfNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.add.match_1"],
  "name": "Int.mul",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow", "Nat", "Int.pow", "rfl", "Int", "Int.instHPowIntNat", "Eq"],
  "name": "pow_eq",
  "constType": "∀ {m : ℤ} {n : ℕ}, Int.pow m n = m ^ n",
  "constCategory": "Theorem"},
 {"references": ["Monoid"],
  "name": "Units",
  "constType": "(α : Type u) → [inst : Monoid α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Int.instMulInt",
   "Eq.ndrec",
   "Nat.zero",
   "Nat.cast",
   "Int.negOfNat",
   "instNatCastInt",
   "Eq.refl",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Int",
   "Nat.casesOn",
   "Eq"],
  "name": "Int.ofNat_mul_negOfNat",
  "constType": "∀ (m n : ℕ), ↑m * Int.negOfNat n = Int.negOfNat (m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "Int.negSucc",
   "Unit",
   "Int.negOfNat.match_1",
   "Nat",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Nat.commMonoid",
   "Nat.instDvdNat",
   "instOfNatNat",
   "Dvd.dvd",
   "Not",
   "Nat",
   "Irreducible.not_dvd_one"],
  "name": "Nat.Prime.not_dvd_one",
  "constType": "∀ {p : ℕ}, Nat.Prime p → ¬p ∣ 1",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial", "Semifield"],
  "name": "Semifield.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : Semifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Eq.ndrec",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references": ["False", "IsEmpty"],
  "name": "IsEmpty.mk",
  "constType": "∀ {α : Sort u_4}, (α → False) → IsEmpty α",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemifield", "Inv"],
  "name": "LinearOrderedSemifield.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_pos.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ} (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.add_zero",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["Int.zero_mul",
   "OfNat.ofNat",
   "instOfNatInt",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "NonUnitalNonAssocSemiring.mk",
   "Int.mul_comm",
   "Eq",
   "Eq.mpr",
   "Int.add_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Int.one_mul",
   "instOfNatNat",
   "Nat",
   "id",
   "HPow.hPow",
   "Int.instMulInt",
   "instAddNat",
   "AddSemigroup.mk",
   "Int.mul_add",
   "instHAdd",
   "Int.zero_add",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.mk",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "Int.mul_zero",
   "instHMul",
   "Eq.ndrec",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "Int.add_assoc",
   "HMul.hMul",
   "Int.add_mul",
   "Int.mul_assoc",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Int.instCommRingInt.proof_5",
  "constType":
  "∀ (x : ℕ) (x_1 : ℤ), (fun n x => x ^ n) (x + 1) x_1 = x_1 * (fun n x => x ^ n) x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Commute.symm",
   "MulOneClass.toMul",
   "Monoid",
   "instHPow",
   "Monoid.toNatPow",
   "Nat",
   "Monoid.toMulOneClass",
   "Commute.pow_right",
   "Commute"],
  "name": "Commute.pow_left",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] {a b : M}, Commute a b → ∀ (n : ℕ), Commute (a ^ n) b",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toSubtractionMonoid : SubtractionMonoid G] → (∀ (a b : G), a + b = b + a) → SubtractionCommMonoid G",
  "constCategory": "Other"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → CommMonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Nat.cast_nonneg",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "OrderedSemiring.toSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "id"],
  "name": "Mathlib.Meta.Positivity.nonneg_of_isNat",
  "constType":
  "∀ {A : Type u_1} {e : A} {n : ℕ} [inst : OrderedSemiring A], Mathlib.Meta.NormNum.IsNat e n → 0 ≤ e",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "add_lt_of_lt_of_neg",
   "AddZeroClass"],
  "name": "Left.add_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instMulInt",
   "instHDiv",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.mul_comm",
   "Eq",
   "Int.instAddInt",
   "Int.instModInt_1",
   "instHMul",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "HMod.hMod",
   "HMul.hMul",
   "Int.instDivInt_1",
   "HDiv.hDiv",
   "Int",
   "Int.emod_add_ediv",
   "id"],
  "name": "Int.emod_add_ediv'",
  "constType": "∀ (m k : ℤ), m % k + m / k * k = m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "True",
   "pow_add",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Monoid.toNatPow",
   "HMul.hMul",
   "Nat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.pow_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {b₁ : ℕ} {c₁ : R} {b₂ : ℕ} {c₂ d : R},\n  a ^ b₁ = c₁ → a ^ b₂ = c₂ → c₁ * c₂ = d → a ^ (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoid : CommMonoid M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → CommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "Field",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "instHMul",
   "OfNat.ofNat",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mt",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "left_ne_zero_of_mul",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MulZeroClass M₀] {a b : M₀}, a * b ≠ 0 → a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "CharZero",
   "propext",
   "eq_neg_self_iff",
   "NonAssocRing.toNonAssocSemiring",
   "AddCommGroupWithOne.toAddGroupWithOne"],
  "name": "Mathlib.Algebra.CharZero.Lemmas._auxLemma.10",
  "constType":
  "∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : NoZeroDivisors R] [inst_2 : CharZero R] {a : R}, (a = -a) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "OrderedSemiring",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        0 ≤ 1 →\n          (∀ (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b) →\n            (∀ (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c) → OrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.1",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * b + a * c = a * (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "Or",
   "Int.instSubInt",
   "Int.nonneg_or_nonneg_neg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "Int.add_comm",
   "Or.imp_right",
   "LE.le",
   "True",
   "Int.instAddInt",
   "Int.NonNeg",
   "Eq",
   "Eq.ndrec",
   "Int.neg_neg",
   "of_eq_true",
   "Eq.mp",
   "Int.instNegInt",
   "congrArg",
   "Eq.trans",
   "Int",
   "Int.neg_add",
   "Int.instLEInt",
   "congrFun"],
  "name": "Int.le_total",
  "constType": "∀ (a b : ℤ), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "Semiring.toMonoidWithZero",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "pow_bit0_pos",
   "Preorder.toLT",
   "LT.lt",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "MonoidWithZero.toZero",
   "Nat"],
  "name": "sq_pos_of_ne_zero",
  "constType":
  "∀ {R : Type u_2} [inst : LinearOrderedRing R] (a : R), a ≠ 0 → 0 < a ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references": ["Units", "Monoid"],
  "name": "Units.val",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Div"],
  "name": "LinearOrderedSemifield.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "div_eq_mul_inv",
   "True",
   "Eq",
   "mul_pow",
   "DivisionCommMonoid.toDivisionMonoid",
   "instHPow",
   "DivisionCommMonoid.toCommMonoid",
   "Monoid.toNatPow",
   "DivisionCommMonoid",
   "HDiv.hDiv",
   "Nat",
   "CommMonoid.toMonoid",
   "InvOneClass.toInv",
   "Eq.trans",
   "DivInvMonoid.toDiv",
   "HPow.hPow",
   "eq_self",
   "inv_pow",
   "instHDiv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "instHMul",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "congr",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Inv.inv",
   "congrFun"],
  "name": "div_pow",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b : α) (n : ℕ), (a / b) ^ n = a ^ n / b ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_2",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "LinearOrderedRing"],
  "name": "LinearOrderedRing.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "rfl",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt (Int.rawCast n) n",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivisionSemiring",
   "DivisionSemiring.toInv",
   "DivisionSemiring.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.negSucc n) a = (DivisionSemiring.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "Rat.commRing.proof_10",
   "OfNat.ofNat",
   "Rat.instIntCastRat",
   "HAdd.hAdd",
   "npowRec",
   "nsmulRec",
   "Rat.commRing.proof_9",
   "Rat.instOfNatRat",
   "Rat.commRing.proof_1",
   "Rat.add_left_neg",
   "Rat.commRing.proof_8",
   "NatCast.mk",
   "NonUnitalNonAssocSemiring.mk",
   "CommRing",
   "Rat.instAddRat",
   "CommRing.mk",
   "Rat.mul_assoc",
   "zsmulRec",
   "Rat.add_zero",
   "Nat.cast",
   "AddCommMonoid.mk",
   "Rat.add_assoc",
   "Rat.instNegRat",
   "Rat.instMulRat",
   "Nat",
   "Rat.commRing.proof_4",
   "Add.mk",
   "AddSemigroup.mk",
   "instHAdd",
   "Rat.zero_add",
   "Rat",
   "Rat.mul_add",
   "One.mk",
   "Neg.neg",
   "Rat.commRing.proof_3",
   "Rat.commRing.proof_6",
   "Rat.neg",
   "Rat.commRing.proof_11",
   "Rat.sub_eq_add_neg",
   "Rat.commRing.proof_2",
   "AddMonoid.mk",
   "Rat.instSubRat",
   "instHMul",
   "Rat.mul_zero",
   "IntCast.mk",
   "Rat.zero_mul",
   "instNatCastInt",
   "Rat.commRing.proof_5",
   "Int.cast",
   "NonUnitalSemiring.mk",
   "Rat.one_mul",
   "Zero.mk",
   "HMul.hMul",
   "Rat.commRing.proof_7",
   "Ring.mk",
   "Rat.add_mul",
   "Rat.mul_comm",
   "Int",
   "Rat.mul_one",
   "Neg.mk",
   "Rat.add_comm",
   "Mul.mk"],
  "name": "Rat.commRing",
  "constType": "CommRing ℚ",
  "constCategory": "Definition"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Div"],
  "name": "LinearOrderedField.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Div α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semifield",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "Iff.rfl",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "abs_eq_max_neg",
   "Abs.abs",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Iff",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "max_eq_left_iff",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "propext",
   "Max.max",
   "LinearOrder.toMax",
   "neg_le_self_iff",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_eq_self",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a : α}, |a| = a ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_irrefl", "Not", "Preorder"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "NonUnitalRing",
   "HMul.hMul",
   "Eq"],
  "name": "NonUnitalRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalRing α",
  "constCategory": "Other"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {R : Type u_1} {a c b : R}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Int.neg_mul_eq_neg_mul",
   "Int.instMulInt",
   "HMul.hMul",
   "Int.instNegInt",
   "Neg.neg",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "Int.neg_mul",
  "constType": "∀ (a b : ℤ), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instDecidableEqInt",
   "instOfNatInt",
   "Dvd.dvd",
   "Int.mod",
   "Int.decidableDvd.proof_1",
   "Int",
   "Int.instDvdInt",
   "DecidableRel",
   "Eq",
   "decidable_of_decidable_of_iff"],
  "name": "Int.decidableDvd",
  "constType": "DecidableRel fun x x_1 => x ∣ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Rat.mul.proof_1",
   "Int.instMulInt",
   "instHDiv",
   "Int.div",
   "Rat",
   "Rat.num",
   "Rat.mk'",
   "instHMul",
   "Nat.cast",
   "instNatCastInt",
   "Rat.mul.proof_2",
   "Rat.den",
   "HMul.hMul",
   "Nat.gcd",
   "Nat.instDivNat",
   "HDiv.hDiv",
   "Nat",
   "instMulNat",
   "Int",
   "Int.natAbs"],
  "name": "Rat.mul",
  "constType": "ℚ → ℚ → ℚ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "RightDistribClass.right_distrib",
   "Add",
   "Mul",
   "Eq"],
  "name": "right_distrib",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "HasDistribNeg.toInvolutiveNeg",
   "Ring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "Eq",
   "AddGroupWithOne.intCast_ofNat"],
  "name": "Int.cast_ofNat",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "DivInvMonoid",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "GroupWithZero.toDiv",
   "GroupWithZero.toInv"],
  "name": "GroupWithZero.toDivInvMonoid",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → DivInvMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Nat.sub_self",
   "Int.subNatNat_self.match_1",
   "instOfNatInt",
   "instSubNat",
   "Unit",
   "HSub.hSub",
   "Int.ofNat_zero",
   "Eq.refl",
   "rfl",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "instOfNatNat",
   "Nat",
   "Int.subNatNat_of_sub_eq_zero",
   "Int",
   "Nat.succ",
   "Int.subNatNat",
   "id"],
  "name": "Int.subNatNat_self",
  "constType": "∀ (n : ℕ), Int.subNatNat n n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Int",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_zero'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["mul_comm",
   "instHMul",
   "mul_assoc",
   "right_comm",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "Mul.mul",
   "CommSemigroup",
   "Eq",
   "CommSemigroup.toSemigroup"],
  "name": "mul_right_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * b * c = a * c * b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Exists",
   "Int.instMulInt",
   "Dvd.mk",
   "HMul.hMul",
   "Int",
   "Dvd",
   "Eq"],
  "name": "Int.instDvdInt",
  "constType": "Dvd ℤ",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : StrictOrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Int.natAbs",
   "Inv.inv"],
  "name": "LinearOrderedField.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommRing : LinearOrderedCommRing α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toRatCast : RatCast α] →\n                    (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) →\n                      0⁻¹ = 0 →\n                        autoParam\n                            (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                              ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                            _auto✝⁴ →\n                          (qsmul : ℚ → α → α) →\n                            autoParam (∀ (a : ℚ) (x : α), qsmul a x = ↑a * x) _auto✝⁵ → LinearOrderedField α",
  "constCategory": "Other"},
 {"references":
  ["Int.coe_nat_dvd",
   "Int.natAbs_dvd_natAbs",
   "Nat.cast",
   "Iff.mp",
   "instNatCastInt",
   "Nat.instDvdNat",
   "Dvd.dvd",
   "Int.natAbs_dvd",
   "Nat",
   "Nat.dvd_gcd",
   "Int",
   "Iff.mpr",
   "Int.instDvdInt",
   "Int.gcd",
   "Int.natAbs"],
  "name": "Int.dvd_gcd",
  "constType": "∀ {i j k : ℤ}, k ∣ i → k ∣ j → k ∣ ↑(Int.gcd i j)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "neg_add_eq_iff_eq_add",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "NegZeroClass.toNeg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.4",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (-a + b = c) = (b = a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Nat.add_comm",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_assoc.match_1",
   "Eq.refl",
   "Int.add_comm",
   "Nat.add_left_comm",
   "True",
   "Eq",
   "Int.instAddInt",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "Int.add_assoc.aux1",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "Int",
   "Int.add_assoc.aux2",
   "congrFun",
   "id"],
  "name": "Int.add_assoc",
  "constType": "∀ (a b c : ℤ), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "Iff", "False", "Not", "or_imp"],
  "name": "not_or",
  "constType": "∀ {p q : Prop}, ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "constCategory": "Theorem"},
 {"references":
  ["forall_prop_decidable.proof_2",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "dite",
   "forall_prop_decidable.proof_1",
   "decidable_of_decidable_of_iff"],
  "name": "forall_prop_decidable",
  "constType":
  "{p : Prop} → (P : p → Prop) → [inst : Decidable p] → [inst : (h : p) → Decidable (P h)] → Decidable (∀ (h : p), P h)",
  "constCategory": "Definition"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "PProd",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Preorder.toLT",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "zero_lt_one",
   "Nat",
   "pow_nonneg.match_1",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Nat.below",
   "Nat.brecOn",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instAddNat",
   "instHAdd",
   "Unit",
   "OrderedSemiring.zeroLEOneClass",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "StrictOrderedSemiring.toSemiring",
   "pow_zero",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "HMul.hMul",
   "pow_succ",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "mul_pos",
   "MonoidWithZero.toZero"],
  "name": "pow_pos",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α] {a : α}, 0 < a → ∀ (n : ℕ), 0 < a ^ n",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "Rat.inv", "Rat", "HMul.hMul", "Rat.instMulRat"],
  "name": "Rat.div",
  "constType": "ℚ → ℚ → ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "OrderedAddCommGroup.add_le_add_left",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.to_covariantClass_left_le",
  "constType":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references": ["And", "propext", "and_true_iff", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.4",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references": ["GCDMonoid", "CancelCommMonoidWithZero"],
  "name": "GCDMonoid.gcd",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instAddNat",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_add",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Nat.rec",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "congr",
   "mul_one",
   "instMulNat",
   "congrArg",
   "congrFun",
   "Nat.semiring"],
  "name": "Nat.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Rat.commGroupWithZero",
   "GroupWithZero.toCancelMonoidWithZero",
   "Rat.commRing",
   "CommGroupWithZero.toGroupWithZero",
   "IsDomain",
   "Rat",
   "CommRing.toRing",
   "NoZeroDivisors.to_isDomain",
   "CommGroupWithZero.toNontrivial",
   "CancelMonoidWithZero.to_noZeroDivisors"],
  "name": "Rat.isDomain",
  "constType": "IsDomain ℚ",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "NonAssocRing.toIntCast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Int.cast_mul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.mul a' b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references": ["List", "List.Mem", "Membership.mk", "Membership"],
  "name": "List.instMembershipList",
  "constType": "{α : Type u} → Membership α (List α)",
  "constCategory": "Definition"},
 {"references": ["Subtype.property", "Subtype.val", "Subtype"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "min_le_right",
   "max_le",
   "Inf.mk",
   "le_min",
   "le_max_left",
   "Max.max",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "min_le_left",
   "le_max_right"],
  "name": "LinearOrder.toLattice",
  "constType": "{α : Type u} → [o : LinearOrder α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "instSubNat",
   "Int.negSucc",
   "Unit",
   "HSub.hSub",
   "Int.negOfNat.match_1",
   "Nat",
   "Int"],
  "name": "Int.subNatNat",
  "constType": "ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "dite",
   "GroupWithZero.div_eq_mul_inv",
   "mul_inv_cancel_left₀",
   "MulZeroClass.toMul",
   "Inv.mk",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "mul_assoc",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "MulZeroClass.toZero",
   "not_false_eq_true",
   "mul_inv_cancel",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "Eq.trans",
   "GroupWithZero.toInv",
   "eq_self",
   "Monoid.toSemigroup",
   "False",
   "Classical.propDecidable",
   "One.toOfNat1",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toDiv",
   "DivInvMonoid.toInv",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "HMul.hMul",
   "congr",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "Inv.inv"],
  "name": "GroupWithZero.toDivisionMonoid.proof_2",
  "constType":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a b : G₀), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_10",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "SubNegMonoid.zsmul_succ'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["or_self", "Or", "Iff", "Iff.rfl", "Eq.rec", "Eq.symm", "Eq"],
  "name": "or_self_iff",
  "constType": "∀ {a : Prop}, a ∨ a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["List.tfae_cons_cons",
   "And",
   "List.cons",
   "Iff",
   "propext",
   "List",
   "List.TFAE",
   "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.2",
  "constType":
  "∀ {a b : Prop} {l : List Prop}, List.TFAE (a :: b :: l) = ((a ↔ b) ∧ List.TFAE (b :: l))",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Mathlib.Algebra.GroupPower.Basic._auxLemma.1",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "Eq.symm",
   "Nat.cast_add",
   "Eq"],
  "name": "Mathlib.Data.Nat.Cast.Defs._auxLemma.3",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑m + ↑n = ↑(m + n)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemiring.toMax",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "Max.max",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedSemiring.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) →\n          [toNontrivial : Nontrivial α] →\n            0 ≤ 1 →\n              (∀ (a b c : α), a < b → 0 < c → c * a < c * b) →\n                (∀ (a b c : α), a < b → 0 < c → a * c < b * c) → StrictOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Iff",
   "List.get?_mem",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.507",
   "List",
   "Option.some",
   "_auto._@.Mathlib.Data.List.TFAE._hyg.546",
   "List.get?",
   "Nat",
   "autoParam",
   "List.TFAE",
   "Option",
   "Eq"],
  "name": "List.TFAE.out",
  "constType":
  "∀ {l : List Prop},\n  List.TFAE l →\n    ∀ (n₁ n₂ : ℕ) {a b : Prop},\n      autoParam (List.get? l n₁ = some a) _auto✝ → autoParam (List.get? l n₂ = some b) _auto✝¹ → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "HasDistribNeg",
  "constType": "(α : Type u_1) → [inst : Mul α] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "CommSemigroup.mk",
   "NonUnitalCommSemiring.mul_comm",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommSemigroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "NonUnitalCommSemiring.toCommSemigroup",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → CommSemigroup α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List.rec", "List", "List.nil"],
  "name": "List.casesOn",
  "constType":
  "{α : Type u} →\n  {motive : List α → Sort u_1} →\n    (t : List α) → motive [] → ((head : α) → (tail : List α) → motive (head :: tail)) → motive t",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "OrderedAddCommGroup"],
  "name": "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toLinearOrder",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "One.toOfNat1",
   "Int.cast_ofNat",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "Int",
   "Nat.cast_one",
   "id"],
  "name": "Int.cast_one",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Nat"],
  "name": "Nat.semiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive (Nat.succ n)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Int.instMulInt",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "pow_succ'",
   "Monoid.toMulOneClass",
   "Eq",
   "Int.instHPowIntNat",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.zero",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "Int.natAbs_mul",
   "instMulNat",
   "Int.instMonoidInt",
   "Nat",
   "Int",
   "Nat.succ",
   "id",
   "Int.natAbs"],
  "name": "Int.natAbs_pow",
  "constType": "∀ (n : ℤ) (k : ℕ), Int.natAbs (n ^ k) = Int.natAbs n ^ k",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Semifield",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "CommSemiring",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mk",
  "constType":
  "{α : Type u_4} →\n  [toCommSemiring : CommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → Semifield α",
  "constCategory": "Other"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Int.instAddInt",
   "Iff.intro",
   "Eq.mpr",
   "Int.ofNat_le.match_1",
   "Int.le.dest",
   "Iff",
   "Eq.ndrec",
   "Int.ofNat_add",
   "Nat.cast",
   "instLENat",
   "Nat.le.dest",
   "instNatCastInt",
   "Int.ofNat_le.match_2",
   "Nat.le.intro",
   "Int.ofNat.inj",
   "Int.le.intro",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.ofNat_le",
  "constType": "∀ {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedSemifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "instHAdd",
   "AddSemigroup.toAdd",
   "eq_of_heq",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_add.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℕ) →\n          x = HAdd.hAdd →\n            Mathlib.Meta.NormNum.IsNat x_1 x_3 → Mathlib.Meta.NormNum.IsNat x_2 x_4 → Nat.add x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℕ) (x_6 : x = HAdd.hAdd) (x_7 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsNat x_2 x_4) (x_9 : Nat.add x_3 x_4 = x_5),\n  (∀ (n n_1 : ℕ),\n      motive HAdd.hAdd (↑n) (↑n_1) n n_1 (Nat.add n n_1) (_ : HAdd.hAdd = HAdd.hAdd)\n        (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1)\n        (_ : Nat.add n n_1 = Nat.add n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "HasDistribNeg.toInvolutiveNeg",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Neg.neg",
   "HasDistribNeg",
   "Nat",
   "Monoid.toMulOneClass",
   "neg_sq",
   "Eq"],
  "name": "neg_pow_two",
  "constType":
  "∀ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R), (-a) ^ 2 = a ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["IsDomain.toIsCancelMulZero",
   "CancelMonoidWithZero",
   "CancelMonoidWithZero.mk",
   "Semiring",
   "IsDomain",
   "Semiring.toMonoidWithZero"],
  "name": "IsDomain.toCancelMonoidWithZero",
  "constType":
  "{α : Type u_1} → [inst : Semiring α] → [inst : IsDomain α] → CancelMonoidWithZero α",
  "constCategory": "Definition"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.mk",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, a = ↑n → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "IsUnit.div_self",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "InvOneClass.toOne",
   "DivInvOneMonoid.toInvOneClass",
   "GroupWithZero",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "DivisionMonoid.toDivInvOneMonoid"],
  "name": "div_self",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a / a = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.10",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "Ring.toNeg",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "StrictOrderedRing",
   "HasDistribNeg.toInvolutiveNeg",
   "AddGroup.toAddCancelMonoid",
   "neg_mul",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "StrictOrderedRing.toPartialOrder",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "neg_neg_of_pos",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "instHMul",
   "Std.Classes.Order._auxLemma.4",
   "AddCancelMonoid.toIsCancelAdd",
   "neg_of_neg_pos",
   "LT.lt",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x x_3 0) → (∀ (n m k : ℕ), motive n m (Nat.succ k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Ring", "CommRing.toRing", "Int", "Int.instCommRingInt"],
  "name": "Int.instRingInt",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "Nat.cast",
   "instNatCastInt",
   "Int.ofNat.inj",
   "Nat",
   "congrArg",
   "Int",
   "Eq"],
  "name": "Int.ofNat_inj",
  "constType": "∀ {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedField α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "instNatPowNat",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mul_comm",
  "constType": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "LinearOrder",
   "Int.mul_pos",
   "LinearOrder.max_def",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "CommRing.mul_comm",
   "Int.linearOrderedCommRing.proof_2",
   "CommRing",
   "LinearOrder.toOrd",
   "Int.add_le_add_left",
   "Int.linearOrderedCommRing.proof_1",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "CommRing.toRing",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "Int.instLinearOrderInt",
   "Nontrivial",
   "Int.instNontrivialInt",
   "LinearOrderedRing.mk",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "instSubNat",
   "GE.ge",
   "Eq.refl",
   "Int.subNatNat_of_lt",
   "instLTNat",
   "True",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Nat.cast",
   "Nat.pred",
   "Int.instNegInt",
   "Nat",
   "Nat.le_antisymm",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "Nat.sub_pos_of_lt",
   "Nat.succ_pos",
   "id",
   "eq_self",
   "instHSub",
   "Int.instMulInt",
   "Or",
   "Or.inr",
   "Nat.mul_sub_left_distrib",
   "HSub.hSub",
   "Int.subNatNat_self",
   "Neg.neg",
   "Nat.succ_pred_eq_of_pos",
   "Or.casesOn",
   "Int.negSucc_mul_ofNat",
   "GT.gt",
   "Int.mul_zero",
   "instHMul",
   "Or.inl",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "Int.negSucc",
   "LT.lt",
   "HMul.hMul",
   "Int.subNatNat_of_le",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "instMulNat",
   "Nat.mul_lt_mul_of_pos_left",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.negSucc_mul_subNatNat",
  "constType":
  "∀ (m n k : ℕ), Int.negSucc m * Int.subNatNat n k = Int.subNatNat (Nat.succ m * k) (Nat.succ m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instOfNatInt",
   "One.toOfNat1",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Int",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), LinearOrderedSemifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "CommRing.toRing",
   "Int",
   "Int.instCommRingInt",
   "AddGroupWithOne.toAddGroup"],
  "name": "Int.instAddGroupInt",
  "constType": "AddGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff",
   "instOfNatInt",
   "instHAdd",
   "Iff.rfl",
   "HAdd.hAdd",
   "LT.lt",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.instLTInt",
   "Int.instAddInt"],
  "name": "Int.lt_iff_add_one_le",
  "constType": "∀ (a b : ℤ), a < b ↔ a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
   "Int.natAbs_sq",
   "Eq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "instLENat",
   "sq",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "instHPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Int.instMonoidInt",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "HPow.hPow",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.le_mul_self",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Monoid.toMulOneClass",
   "instHMul",
   "StrictOrderedSemiring.to_charZero",
   "Eq.ndrec",
   "instNatCastInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Int.instSemiringInt",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "instMulNat",
   "congrArg",
   "Int",
   "Int.instLEInt",
   "Int.natAbs"],
  "name": "Int.natAbs_le_self_sq",
  "constType": "∀ (a : ℤ), ↑(Int.natAbs a) ≤ a ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "IsCancelMulZero",
   "MonoidWithZero.toZero",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "IsDomain.toIsCancelMulZero",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [self : IsDomain α], IsCancelMulZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Zero.toOfNat0",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "AddGroup.toSubtractionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (x : G), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "CommMagma.toMul", "Eq"],
  "name": "CommMagma.mul_comm",
  "constType": "∀ {G : Type u} [self : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["Rat.mul", "Rat", "Mul", "Mul.mk"],
  "name": "Rat.instMulRat",
  "constType": "Mul ℚ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instNatCastInt",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "Int",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Int.instCommRingInt.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "False",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.ne_of_beq_eq_false.match_1",
   "Nat.zero",
   "Bool.false",
   "Nat.noConfusion",
   "PUnit",
   "Not",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = false → ¬n = m",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "Field",
   "Rat.cast",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Field.qsmul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Field.toRatCast",
   "Eq"],
  "name": "Field.qsmul_eq_mul'",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℚ) (x : K), Field.qsmul a x = ↑a * x",
  "constCategory": "Definition"},
 {"references":
  ["eq_true", "List.Chain.nil", "List.nil", "List.Chain", "True", "Eq"],
  "name": "Mathlib.Data.List.TFAE._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a [] = True",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "Sub"],
  "name": "AddGroupWithOne.toSub",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Sub R",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Field.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "Ring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ring.toNonAssocRing.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Ring.one_pow",
   "two_ne_zero",
   "Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "add_pos",
   "Mathlib.Tactic.Ring.pow_zero",
   "And.left",
   "Eq",
   "Eq.mpr",
   "And.right",
   "Semiring.toNonAssocSemiring",
   "IsDomain.to_noZeroDivisors",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Mathlib.Tactic.Ring.pow_add",
   "HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "Ne",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Nat.rawCast",
   "Int.instCommSemiringInt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "And",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Int.instAddGroupInt",
   "Mathlib.Tactic.Ring.of_eq",
   "AddCancelMonoid.toIsCancelAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "MonoidWithZero.toZero",
   "Int",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Int.linearOrderedCommRing",
   "AddMonoid.toAddZeroClass",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "ne_of_gt",
   "Preorder.toLT",
   "instHPow",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "LinearOrderedRing.isDomain",
   "Int.instMonoidInt",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "id",
   "NeZero.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Fermat42",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Nat.linearOrderedCommMonoidWithZero",
   "instHAdd",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.single_pow",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "ne_zero_pow",
   "pow_ne_zero",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.one_mul",
   "Int.instSemiringInt",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "sq_pos_of_ne_zero",
   "Mathlib.Tactic.Ring.add_mul",
   "Int.instAddMonoidInt",
   "Mathlib.Tactic.Ring.atom_pf",
   "Nat.semiring"],
  "name": "Fermat42.ne_zero",
  "constType": "∀ {a b c : ℤ}, Fermat42 a b c → c ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "pow_one",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "mul_one",
   "add_zero",
   "congrArg",
   "Nat.semiring",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references": ["Units", "Exists", "Monoid", "Units.val", "Eq"],
  "name": "IsUnit",
  "constType": "{M : Type u_1} → [inst : Monoid M] → M → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "PosMulStrictMono",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toPosMulStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], PosMulStrictMono α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Int"],
  "name": "SubNegMonoid.zsmul",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "Int",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), Semifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "Or",
   "instAddNat",
   "Xor'",
   "Even",
   "True",
   "And",
   "eq_true",
   "of_eq_true",
   "congr",
   "Nat.instDecidablePredNatEvenInstAddNat",
   "Not",
   "Mathlib.Data.Nat.Parity._auxLemma.4",
   "Mathlib.Logic.Basic._auxLemma.10",
   "Nat",
   "Odd",
   "congrArg",
   "Eq.trans",
   "and_self",
   "Nat.semiring",
   "congrFun"],
  "name": "Nat.even_xor_odd",
  "constType": "∀ (n : ℕ), Xor' (Even n) (Odd n)",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.add_comm.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ),\n  (∀ (n m : ℕ), motive (Int.ofNat n) (Int.ofNat m)) →\n    (∀ (a a_1 : ℕ), motive (Int.ofNat a) (Int.negSucc a_1)) →\n      (∀ (a a_1 : ℕ), motive (Int.negSucc a) (Int.ofNat a_1)) →\n        (∀ (a a_1 : ℕ), motive (Int.negSucc a) (Int.negSucc a_1)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "pow_eq_zero",
   "mt",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "MonoidWithZero.toZero",
   "Nat",
   "MonoidWithZero"],
  "name": "pow_ne_zero",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] [inst_1 : NoZeroDivisors M] {a : M} (n : ℕ), a ≠ 0 → a ^ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n + 0",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.mul_add.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → ℤ → Prop) (x x_1 x_2 : ℤ),\n  (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.ofNat n) (Int.ofNat k)) →\n    (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.ofNat n) (Int.negSucc k)) →\n      (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.negSucc n) (Int.ofNat k)) →\n        (∀ (m n k : ℕ), motive (Int.ofNat m) (Int.negSucc n) (Int.negSucc k)) →\n          (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.ofNat n) (Int.ofNat k)) →\n            (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.ofNat n) (Int.negSucc k)) →\n              (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.negSucc n) (Int.ofNat k)) →\n                (∀ (m n k : ℕ), motive (Int.negSucc m) (Int.negSucc n) (Int.negSucc k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), LinearOrderedField.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} → [self : Field K] → CommRing K",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivInvMonoid",
   "Nat",
   "Nat.succ",
   "Int",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_neg'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (motive : Mathlib.Meta.NormNum.IsNat (a + b) 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat (a + b) 0),\n  (∀ (h : a + b = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat (a + b) 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Int.negOfNat",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "Int",
   "rfl",
   "Eq"],
  "name": "Int.negOfNat_eq",
  "constType": "∀ {n : ℕ}, Int.negOfNat n = -Int.ofNat n",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "add_neg_cancel_right",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_neg_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a + -b = c ↔ a = c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_right",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Sort u) → Trans Eq r r",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "congr",
   "HMul.hMul",
   "congrArg",
   "CommMagma.toMul",
   "CommSemigroup",
   "Eq.trans",
   "mul_left_comm",
   "True",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "mul_mul_mul_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c d : G), a * b * (c * d) = a * c * (b * d)",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "AddMonoidWithOne",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Bool",
   "Nat.beq",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_false.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α]\n  (motive :\n    (x x_1 : α) →\n      (x_2 x_3 : ℕ) →\n        Mathlib.Meta.NormNum.IsNat x x_2 → Mathlib.Meta.NormNum.IsNat x_1 x_3 → Nat.beq x_2 x_3 = false → Prop)\n  (x x_1 : α) (x_2 x_3 : ℕ) (x_4 : Mathlib.Meta.NormNum.IsNat x x_2) (x_5 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_6 : Nat.beq x_2 x_3 = false),\n  (∀ (n n_1 : ℕ) (h : Nat.beq n n_1 = false),\n      motive (↑n) (↑n_1) n n_1 (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1) h) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Rat.commGroupWithZero",
   "zpowRec",
   "Rat.field.proof_4",
   "instRatCastRat",
   "CommGroupWithZero.mul_inv_cancel",
   "RatCast.mk",
   "Field.mk",
   "CommGroupWithZero.inv_zero",
   "Rat",
   "Rat.field.proof_5",
   "NonUnitalNonAssocSemiring.toMul",
   "Rat.field.proof_6",
   "Ring.toSemiring",
   "Rat.instDivRat",
   "Semiring.toOne",
   "instHMul",
   "Rat.commRing",
   "Rat.field.proof_2",
   "Rat.field.proof_1",
   "Field",
   "Rat.instInvRat",
   "Rat.cast",
   "Rat.field.proof_3",
   "HMul.hMul",
   "CommRing.toRing",
   "Rat.instMulRat",
   "Rat.nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.field",
  "constType": "Field ℚ",
  "constCategory": "Definition"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "HEq.refl",
   "Ring",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsNat x x_1 → Prop) (x : α)\n  (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsNat x x_1),\n  (∀ (n : ℕ), motive (↑n) n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.emod.match_1",
  "constType":
  "(motive : ℤ → ℤ → Sort u_1) →\n  (x x_1 : ℤ) →\n    ((m : ℕ) → (n : ℤ) → motive (Int.ofNat m) n) → ((m : ℕ) → (n : ℤ) → motive (Int.negSucc m) n) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "Int.zero_mul",
   "Int.instSubInt",
   "instOfNatInt",
   "Zero.ofOfNat0",
   "Int.add_comm",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Int.mul_comm",
   "CommRing.mk",
   "Int.instCommRingInt.proof_9",
   "Int.instCommRingInt.proof_1",
   "Int.mul_one",
   "Int.add_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Int.one_mul",
   "Int.instNegInt",
   "Int.instCommRingInt.proof_2",
   "Int.instCommRingInt.proof_4",
   "Nat",
   "Int.sub_eq_add_neg",
   "HPow.hPow",
   "Int.instMulInt",
   "AddSemigroup.mk",
   "Int.mul_add",
   "Int.instCommRingInt.proof_6",
   "One.ofOfNat1",
   "Int.zero_add",
   "AddMonoid.mk",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "Int.mul_zero",
   "Int.instCommRingInt.proof_5",
   "instHMul",
   "IntCast.mk",
   "instNatCastInt",
   "Int.instCommRingInt.proof_7",
   "NonUnitalSemiring.mk",
   "Int.add_assoc",
   "HMul.hMul",
   "Int.instCommRingInt.proof_8",
   "Int.add_mul",
   "Ring.mk",
   "Int.mul_assoc",
   "Int.instCommRingInt.proof_3",
   "Int",
   "Int.add_left_neg"],
  "name": "Int.instCommRingInt",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["le_of_not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.ndrec", "Ring.toNeg", "Ring", "Eq.refl", "Neg.neg", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.toAdd",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_add",
   "Ring.toNonAssocRing",
   "Int.instAddInt",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.add",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.add a' b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "∀ (n : ℕ), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Ring.toSemiring",
   "Int",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "div_eq_mul_inv",
  "constType":
  "∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "abs_eq_self",
   "Abs.abs",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "Nat",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "HPow.hPow",
   "abs_pow",
   "instAddNat",
   "instDistribLattice",
   "Even",
   "Even.pow_nonneg",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "propext",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "Even.pow_abs",
  "constType":
  "∀ {R : Type u_4} [inst : LinearOrderedRing R] {p : ℕ}, Even p → ∀ (a : R), |a| ^ p = a ^ p",
  "constCategory": "Theorem"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Monoid.npow",
   "Eq"],
  "name": "Monoid.npow_zero",
  "constType": "∀ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "CommRing.toRing",
   "Ring.toAddCommGroup",
   "AddCommGroup",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instAddCommGroupInt",
  "constType": "AddCommGroup ℤ",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [self : OrderedCommSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.neg.match_1",
  "constType":
  "(motive : ℤ → Sort u_1) → (n : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((n : ℕ) → motive (Int.negSucc n)) → motive n",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HasDistribNeg",
   "add_pos",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "inferInstance",
   "SemilatticeSup.toSup",
   "HasDistribNeg.toInvolutiveNeg",
   "Rat.den",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Rat.nontrivial",
   "Mathlib.Data.Nat.Cast.Defs._auxLemma.3",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Nat.strictOrderedSemiring",
   "Ne.lt_or_lt",
   "Odd.pow_neg",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instDistribLattice",
   "Rat.num",
   "PartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "propext",
   "congr",
   "LinearOrder.toPartialOrder",
   "MonoidWithZero.toZero",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "instOfNatInt",
   "add_div",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "LinearOrderedRing",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "List.nil",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "List.TFAE",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "List.cons",
   "Int.instMulInt",
   "Nat.linearOrderedCommMonoidWithZero",
   "pow_pos",
   "Neg.neg",
   "Monoid.toMulOneClass",
   "GroupWithZero.toDiv",
   "Mathlib.Algebra.GroupPower.Lemmas._auxLemma.10",
   "Distrib.leftDistribClass",
   "Eq.ndrec",
   "List.tfae_of_cycle",
   "instNatCastInt",
   "Int.cast_injective",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "Int.instNontrivialInt",
   "NegZeroClass.toNeg",
   "Int.instAddMonoidInt",
   "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.4",
   "MulOneClass.toMul",
   "Int.cast_pow",
   "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.int_natAbs_pos",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "add_neg",
   "Rat.instOfNatRat",
   "Int.cast_add",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.3",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Ring.toIntCast",
   "Int.cast_mul",
   "zero_le",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.instLTInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "List.Chain.cons",
   "Int.cast_ofNat",
   "cast",
   "of_eq_true",
   "Int.cast",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.mp",
   "List.Chain.nil",
   "Rat.den_pos",
   "mul_one",
   "mul_pos",
   "Int.instDistribInt",
   "StrictOrderedRing.toRing",
   "LinearOrderedSemifield.toSemifield",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "GroupWithZero.toDivisionMonoid",
   "Rat.instOrderedSemiringRat",
   "LinearOrderedRing.toLinearOrder",
   "ne_of_gt",
   "Rat.monoid",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Int.instLinearOrderInt",
   "Int.instMonoidInt",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instAddNat",
   "Eq.trans_lt",
   "abs_of_neg",
   "mul_div_mul_comm",
   "AddMonoidWithOne.toAddMonoid",
   "Ring.toSemiring",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Int.coe_nat_inj'",
   "OrderedSemiring.toPartialOrder",
   "Int.natAbs",
   "Distrib.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "Even.pow_abs",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "Rat.commGroupWithZero",
   "LT.lt.ne'",
   "Nat.cast_pos",
   "Rat.num_div_den",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.1",
   "neg_pow",
   "Rat.num_ne_zero",
   "Iff.mpr",
   "Nat.cast_zero",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "IsDomain.to_noZeroDivisors",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HDiv.hDiv",
   "Int.instCommRingInt",
   "HPow.hPow",
   "Or",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Nat.cast_add",
   "eq_true",
   "LT.lt",
   "div_left_inj'",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Nat.cast_pow",
   "DivisionMonoid.toDivInvOneMonoid",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "LT.lt.not_lt",
   "Rat.instIntCastRat",
   "Semiring.toMonoidWithZero",
   "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.mul_ne_zero_of_pos_of_ne_zero",
   "AddMonoid.toAddZeroClass",
   "True",
   "Abs.abs",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toAddSemigroup",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Odd.neg_pow",
   "One.toOfNat1",
   "Even",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Rat.instDivRat",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "InvOneClass.toOne",
   "Rat.divisionRing",
   "Nat.even_or_odd",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Monoid.toOne",
   "Int.coe_natAbs",
   "MulZeroOneClass.toMulOneClass",
   "Int.natAbs_pos",
   "Rat.instLinearOrderedSemiringRat",
   "instLTNat",
   "implies_congr",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "DivisionCommMonoid.toDivisionMonoid",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.6",
   "Rat.instMulRat",
   "Odd",
   "Nat",
   "Ne",
   "Monoid",
   "DivisionSemiring.toGroupWithZero",
   "Nat.canonicallyOrderedCommSemiring",
   "DivisionSemiring.toDiv",
   "Or.casesOn",
   "Rat.semiring",
   "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.mul_ne_zero_of_ne_zero_of_pos",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "DistribLattice.toLattice",
   "instHMul",
   "Rat.instPartialOrderRat",
   "NonAssocRing.toIntCast",
   "Int.instAddGroupInt",
   "AddCancelMonoid.toIsCancelAdd",
   "Not",
   "congrArg",
   "Zero",
   "DivisionRing.toRing",
   "Int.linearOrderedCommRing",
   "Ring.toNonAssocRing",
   "FermatLastTheoremWith",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.2",
   "one_mul",
   "Preorder.toLT",
   "instHPow",
   "Nat.monoid",
   "Int.instNegInt",
   "Mathlib.NumberTheory.FLT.Basic._auxLemma.5",
   "div_self",
   "LinearOrderedRing.isDomain",
   "Eq.symm",
   "lt_of_le_of_lt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Rat",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "Int.instSemiringInt",
   "SubNegMonoid.toAddMonoid",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "abs_of_pos",
   "Nat.semiring"],
  "name": "fermatLastTheoremWith_nat_int_rat_tfae",
  "constType":
  "∀ (n : ℕ), List.TFAE [FermatLastTheoremWith ℕ n, FermatLastTheoremWith ℤ n, FermatLastTheoremWith ℚ n]",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_8",
  "constType": "∀ {α : Type u_1} [inst : Ring α], NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Rat.commRing",
   "CommSemiring",
   "Rat"],
  "name": "Rat.commSemiring",
  "constType": "CommSemiring ℚ",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instMonoidInt",
  "constType": "Monoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.instSubInt",
   "AddGroupWithOne.toSub",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "Iff.rfl",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "AddGroupWithOne",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "HSub.hSub",
   "Int.cast_eq_zero",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "Int.instAddGroupInt",
   "CharZero",
   "Int.cast",
   "propext",
   "sub_eq_zero",
   "NegZeroClass.toZero",
   "Int"],
  "name": "Int.cast_inj",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroupWithOne α] [inst_1 : CharZero α] {m n : ℤ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.natAbs_mul_self.match_1",
   "Int.ofNat",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.one_mul",
   "Int.negSucc",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Int",
   "id"],
  "name": "Int.one_mul",
  "constType": "∀ (a : ℤ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Rat",
   "Rat.semiring"],
  "name": "Rat.monoid",
  "constType": "Monoid ℚ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedField",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "DivInvMonoid",
   "HMul.hMul",
   "Nat",
   "DivInvMonoid.toMonoid",
   "Nat.succ",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_succ'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Eq.rec",
   "ne_eq",
   "Not",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.PushNeg.not_ne_eq",
  "constType": "∀ {α : Sort u_1} (x y : α), (¬x ≠ y) = (x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.mul_zero",
   "instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "instOfNatInt",
   "Eq.rec",
   "HMul.hMul",
   "Int",
   "Int.mul_comm",
   "Eq"],
  "name": "Int.zero_mul",
  "constType": "∀ (a : ℤ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "Finset.card",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Multiset.map_const",
   "Eq",
   "Nat.addMonoid",
   "instHPow",
   "Multiset",
   "Finset",
   "Finset.val",
   "Monoid.toNatPow",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "CommMonoid.toMonoid",
   "Eq.trans",
   "HPow.hPow",
   "Multiset.prod_replicate",
   "congr_arg",
   "AddHomClass.toFunLike",
   "Function.const",
   "FunLike.coe",
   "Multiset.replicate",
   "Multiset.map",
   "CommMonoid",
   "Multiset.prod",
   "Finset.prod",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.prod_const",
  "constType":
  "∀ {β : Type u} {α : Type v} {s : Finset α} [inst : CommMonoid β] (b : β),\n  (Finset.prod s fun _x => b) = b ^ Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "Int.instNegInt",
   "Neg.neg",
   "Int",
   "Int.instAddInt"],
  "name": "Int.sub",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Rat.commRing",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CommRing.toNonUnitalCommRing",
   "Rat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.zero_mul",
   "MulZeroClass.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_1",
  "constType": "∀ (a : ℚ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalNonAssocRing",
   "InvolutiveNeg.toNeg",
   "Neg.neg",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubtractionMonoid.toInvolutiveNeg",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a : α), - -a = a",
  "constCategory": "Theorem"},
 {"references": ["by_contra", "Not"],
  "name": "Mathlib.Tactic.Contrapose.mtr",
  "constType": "∀ {p q : Prop}, (¬q → ¬p) → p → q",
  "constCategory": "Theorem"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [inst : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "CommSemiring",
   "AddMonoid.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instModNat",
  "constType": "Mod ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "le_antisymm",
   "mt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Nat.cast_zero",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "AddGroupWithOne.intCast_ofNat",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "NegZeroClass.toZero",
   "Eq.trans",
   "Int",
   "IntCast.intCast",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Int.cast_zero",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Int.instAddInt",
   "Int.le_trans.match_1",
   "Int.le.dest",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.add_assoc",
   "Nat",
   "Int.le.intro",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.add_le_add_left",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references": ["Int.lt", "LT", "LT.mk", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "instHPow",
   "Monoid.toNatPow",
   "Monoid.npow_zero",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "pow_zero",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Exists",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "NonUnitalCommSemiring.toCommSemigroup",
   "Eq.refl",
   "IsCoprime",
   "Exists.intro",
   "CommSemiring.toNonUnitalCommSemiring",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_assoc",
   "CommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "id",
   "mul_right_comm",
   "instHAdd",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IsCoprime.of_mul_left_left.match_1"],
  "name": "IsCoprime.of_mul_left_left",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime (x * y) z → IsCoprime x z",
  "constCategory": "Theorem"},
 {"references": ["NatPow.pow", "NatPow", "Pow.mk", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "{α : Type u_1} → [inst : NatPow α] → Pow α ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "Mul",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocRing α",
  "constCategory": "Other"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.one_mul",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "Left.add_nonneg",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "LE.le",
   "AddZeroClass",
   "Preorder.toLE"],
  "name": "add_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegZeroMonoid.toSubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.neg_zero",
  "constType": "∀ {G : Type u_2} [self : SubNegZeroMonoid G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedSemiring.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "eq_neg_add_iff_add_eq",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "NegZeroClass.toNeg",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Mathlib.NumberTheory.FLT.Basic._auxLemma.3",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (a = -b + c) = (b + a = c)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": ["One", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toOne",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemiring", "Ord"],
  "name": "LinearOrderedSemiring.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.foldl_eq_foldr.match_1",
   "eq_self",
   "List.cons",
   "Or",
   "Or.inr",
   "List.brecOn",
   "List.below",
   "List.instMembershipList",
   "List.mem_cons",
   "Eq.refl",
   "Std.Data.List.Lemmas._auxLemma.3",
   "True",
   "Eq",
   "PProd",
   "PProd.fst",
   "Eq.mpr",
   "Eq.ndrec",
   "List.rec",
   "List.ilast'",
   "of_eq_true",
   "propext",
   "List",
   "PUnit",
   "List.nil",
   "Eq.trans",
   "id"],
  "name": "List.ilast'_mem",
  "constType": "∀ {α : Type u} (a : α) (l : List α), List.ilast' a l ∈ a :: l",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "List.cons",
   "PUnit.unit",
   "List.rec",
   "List.below",
   "List",
   "PUnit",
   "List.nil",
   "PProd.mk"],
  "name": "List.brecOn",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → (t : List α) → ((t : List α) → List.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_one",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Ring.toNonAssocRing",
   "Eq",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Ring.toIntCast",
   "Ring",
   "Monoid.toNatPow",
   "Int.cast_mul",
   "instOfNatNat",
   "Nat",
   "Int.instMonoidInt",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "instHAdd",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "pow_zero",
   "Int.instHPowIntNat",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "pow_succ",
   "Int"],
  "name": "Int.cast_pow",
  "constType":
  "∀ {R : Type u₁} [inst : Ring R] (n : ℤ) (m : ℕ), ↑(n ^ m) = ↑n ^ m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Units",
   "Exists",
   "MulOneClass.toMul",
   "Monoid",
   "Units.val",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Associated",
  "constType": "{α : Type u_1} → [inst : Monoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "Inv"],
  "name": "LinearOrderedField.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Inv α",
  "constCategory": "Definition"},
 {"references": ["Field", "Rat"],
  "name": "Field.qsmul",
  "constType": "{K : Type u} → [self : Field K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "Preorder.toLT",
   "HAdd.hAdd",
   "LT.lt",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "instIsTransLtToLT",
   "instOfNatNat",
   "Nat",
   "Preorder",
   "Nat.rel_of_forall_rel_succ_of_lt"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "AddZeroClass",
   "lt_add_of_lt_of_pos"],
  "name": "Left.add_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "inferInstance",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.linearOrderedSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_9",
  "constType": "NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "instNatPowNat",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Int", "Semifield"],
  "name": "Semifield.zpow",
  "constType": "{α : Type u_4} → [self : Semifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "autoParam",
   "Inv",
   "Eq",
   "instHMul",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "HMul.hMul",
   "Div",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv"],
  "name": "DivInvMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toMonoid : Monoid G] →\n    [toInv : Inv G] →\n      [toDiv : Div G] →\n        autoParam (∀ (a b : G), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G → G) →\n            autoParam (∀ (a : G), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  DivInvMonoid G",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Classical.propDecidable",
   "left_inv_eq_right_inv",
   "dite",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "True",
   "Inv.mk",
   "Eq",
   "DivInvMonoid.toInv",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "inv_mul_cancel",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero",
   "GroupWithZero.zpow_zero'",
   "congr",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "inv_ne_zero",
   "Eq.trans",
   "Inv.inv",
   "GroupWithZero.toInv",
   "GroupWithZero.zpow",
   "GroupWithZero.zpow_neg'"],
  "name": "GroupWithZero.toDivisionMonoid.proof_1",
  "constType":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toRing : Ring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        [toNontrivial : Nontrivial α] → 0 ≤ 1 → (∀ (a b : α), 0 < a → 0 < b → 0 < a * b) → StrictOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "mul_pow",
   "instHMul",
   "pow_mul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "of_eq_true",
   "instHPow",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "HMul.hMul",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {ea₁ b c₁ : ℕ} {a₂ c₂ xa₁ : R},\n  ea₁ * b = c₁ → a₂ ^ b = c₂ → (xa₁ ^ ea₁ * a₂) ^ b = xa₁ ^ c₁ * c₂",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.toLinearOrderedSemifield.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Lattice.toSemilatticeInf",
   "Rat.instLatticeRat",
   "Rat",
   "SemilatticeInf"],
  "name": "Rat.instSemilatticeInfRat",
  "constType": "SemilatticeInf ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Neg",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "Field.toInv",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Field.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Field.toCommRing",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Field",
   "Rat.cast",
   "CommRing.toRing",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "Field.ratCast_mk",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMod",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Distrib",
   "Distrib.toMul",
   "Eq"],
  "name": "Distrib.left_distrib",
  "constType":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "dite",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MulZeroClass.toMul",
   "Ring.toNonAssocRing",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Ring",
   "MulZeroClass.toZero",
   "sub_zero",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instHSub",
   "IsRightCancelMulZero.mul_right_cancel_of_ne_zero",
   "Or",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Or.inr",
   "sub_mul",
   "Classical.propDecidable",
   "HSub.hSub",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "NoZeroDivisors",
   "instHMul",
   "SubNegZeroMonoid.toSubNegMonoid",
   "Or.inl",
   "Eq.ndrec",
   "Eq.mp",
   "HMul.hMul",
   "Ring.toAddCommGroup",
   "Not",
   "IsRightCancelMulZero",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero"],
  "name": "IsRightCancelMulZero.to_noZeroDivisors",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] [inst_1 : IsRightCancelMulZero α], NoZeroDivisors α",
  "constCategory": "Theorem"},
 {"references":
  ["Int.natAbs_mul_self.match_1",
   "eq_self",
   "Nat.add_assoc",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "True",
   "Eq",
   "Int.instAddInt",
   "Nat.cast",
   "instNatCastInt",
   "of_eq_true",
   "Int.subNatNat_add",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.add_assoc.aux1",
  "constType": "∀ (m n : ℕ) (c : ℤ), ↑m + ↑n + c = ↑m + (↑n + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Nontrivial.exists_pair_ne",
   "Nontrivial",
   "Nontrivial.mk",
   "Int.instNontrivialInt",
   "Int"],
  "name": "Int.linearOrderedCommRing.proof_1",
  "constType": "Nontrivial ℤ",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Int"],
  "name": "DivInvMonoid.zpow",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{α : Type u} → (α → α) → Inv α",
  "constCategory": "Other"},
 {"references": ["And", "Or", "Xor'", "Not", "And.left", "Or.imp"],
  "name": "Xor'.or",
  "constType": "∀ {a b : Prop}, Xor' a b → a ∨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "SubNegMonoid.toNeg",
   "Mathlib.Tactic.Ring.pow_zero",
   "And.left",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Mathlib.Tactic.Ring.pow_one",
   "Mathlib.Tactic.Ring.pow_bit0",
   "And.right",
   "Iff",
   "Mathlib.Tactic.Ring.neg_congr",
   "sq",
   "PythagoreanTriple.eq",
   "Mathlib.Tactic.Ring.pow_add",
   "Int.instCommRingInt",
   "HPow.hPow",
   "instHSub",
   "Or",
   "PythagoreanTriple.IsPrimitiveClassified",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.gcd_comm",
   "Int.gcd",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "And.intro",
   "Int",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "CommMonoidWithZero.toZero",
   "instOfNatInt",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Mathlib.Tactic.Ring.sub_pf",
   "PythagoreanTriple",
   "Monoid.toNatPow",
   "PythagoreanTriple.isPrimitiveClassified_of_coprime",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Or.inr",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "Mathlib.Tactic.Ring.neg_add",
   "Monoid.toMulOneClass",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Int.instModInt_1",
   "Or.inl",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Tactic.Ring.one_mul",
   "HMod.hMod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "Mathlib.Tactic.Ring.pow_one_cast",
   "Exists.casesOn",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.pow_nat",
   "Nat",
   "LinearOrderedRing.noZeroDivisors",
   "And.casesOn",
   "eq_or_eq_neg_of_sq_eq_sq",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.rawCast",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
   "Mathlib.Tactic.Ring.coeff_one",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Iff.intro",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Eq.mp",
   "congrArg",
   "Mathlib.Tactic.Ring.mul_one",
   "Int.ofNat",
   "Int.instSubInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Meta.NormNum.isNat_add",
   "_private.Mathlib.NumberTheory.PythagoreanTriples.0.coprime_sq_sub_mul",
   "Int.linearOrderedCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "instHPow",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.instMonoidInt",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "Eq.symm",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "instHAdd",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.single_pow",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instHMod",
   "SubtractionMonoid.toSubNegMonoid",
   "Int.instAddCommGroupInt",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "neg_add_rev",
   "Nat.semiring"],
  "name": "PythagoreanTriple.coprime_classification",
  "constType":
  "∀ {x y z : ℤ},\n  PythagoreanTriple x y z ∧ Int.gcd x y = 1 ↔\n    ∃ m n,\n      (x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∨ x = 2 * m * n ∧ y = m ^ 2 - n ^ 2) ∧\n        (z = m ^ 2 + n ^ 2 ∨ z = -(m ^ 2 + n ^ 2)) ∧ Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_5",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "Exists",
   "isUnit_one",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instOfNatInt",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "Exists.intro",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Nat.cast",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Int.instNegInt",
   "Int.instMonoidInt",
   "neg_mul",
   "Eq.symm",
   "Eq.trans",
   "Int.instCommRingInt",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Or",
   "Or.inr",
   "Int.natAbs_eq",
   "MulOneClass.toOne",
   "Neg.neg",
   "One.toOfNat1",
   "Or.casesOn",
   "instHMul",
   "neg_eq_iff_eq_neg",
   "Or.inl",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "IsUnit.neg",
   "Int.instSemiringInt",
   "HMul.hMul",
   "IsUnit",
   "congrArg",
   "Int",
   "Int.natAbs"],
  "name": "Int.exists_unit_of_abs",
  "constType": "∀ (a : ℤ), ∃ u, ∃ (_ : IsUnit u), ↑(Int.natAbs a) = u * a",
  "constCategory": "Theorem"},
 {"references": ["Div", "Semifield"],
  "name": "Semifield.toDiv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.mk",
   "AddCommGroupWithOne.toIntCast",
   "AddCommGroupWithOne.natCast_succ",
   "SubNegMonoid.toNeg",
   "AddCommGroupWithOne.toAddCommGroup",
   "SubNegMonoid.zsmul_neg'",
   "AddCommGroupWithOne",
   "AddCommGroupWithOne.intCast_ofNat",
   "AddCommGroupWithOne.toNatCast",
   "SubNegMonoid.sub_eq_add_neg",
   "AddCommGroupWithOne.toOne",
   "AddGroup.toSubNegMonoid",
   "AddGroup.add_left_neg",
   "SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "AddCommGroupWithOne.intCast_negSucc",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddGroupWithOne",
   "AddCommGroup.toAddGroup",
   "AddCommGroupWithOne.natCast_zero",
   "AddMonoidWithOne.mk",
   "SubNegMonoid.zsmul_zero'"],
  "name": "AddCommGroupWithOne.toAddGroupWithOne",
  "constType":
  "{R : Type u} → [self : AddCommGroupWithOne R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "lt_trans", "lt_irrefl", "Not", "Preorder"],
  "name": "lt_asymm",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.Tactic.Ring.one_pow",
   "Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.LinearCombination.eq_of_add",
   "CommSemiring.toSemiring",
   "Mathlib.Tactic.Ring.mul_congr",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Mathlib.Tactic.Ring.pow_zero",
   "And.left",
   "MulZeroClass.toMul",
   "Mathlib.Meta.NormNum.isInt_add",
   "Eq",
   "SubNegMonoid.toSub",
   "And.right",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "IsDomain.to_noZeroDivisors",
   "Iff",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Mathlib.Tactic.LinearCombination.c_mul_pf",
   "Mathlib.Tactic.Ring.pow_add",
   "Nat",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Ne",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Nat.rawCast",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "mul_right_inj'",
   "MulZeroOneClass.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Iff.intro",
   "MonoidWithZero.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Int.instAddGroupInt",
   "Mathlib.Tactic.Ring.of_eq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "And.intro",
   "CancelMonoidWithZero.toMonoidWithZero",
   "Int",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "instOfNatInt",
   "CommRing.toNonUnitalCommRing",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.rawCast",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Int.linearOrderedCommRing",
   "Mathlib.Tactic.Ring.sub_congr",
   "right_ne_zero_of_mul",
   "Ring.toNonAssocRing",
   "Mathlib.Tactic.Ring.sub_pf",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "LinearOrderedRing.isDomain",
   "CommSemiring.toCommMonoidWithZero",
   "Int.instMonoidInt",
   "Mathlib.Tactic.Ring.pow_congr",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Fermat42",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.mul_pow",
   "instHAdd",
   "IsDomain.toCancelMonoidWithZero",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "HSub.hSub",
   "mul_ne_zero",
   "Mathlib.Tactic.Ring.single_pow",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Tactic.Ring.neg_add",
   "AddGroup.toSubNegMonoid",
   "pow_ne_zero",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.zero_mul",
   "Int.instSemiringInt",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "Fermat42.mul",
  "constType":
  "∀ {a b c k : ℤ}, k ≠ 0 → (Fermat42 a b c ↔ Fermat42 (k * a) (k * b) (k ^ 2 * c))",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "PUnit",
   "List.ilast'.match_1",
   "List.nil"],
  "name": "List.ilast'",
  "constType": "{α : Type u_1} → α → List α → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "HPow.hPow",
   "MulOneClass.toMul",
   "Monoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_succ'",
   "Monoid.toMulOneClass",
   "pow_zero",
   "Nat.mul_zero",
   "pow_add",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "pow_mul",
  "constType":
  "∀ {M : Type u} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m * n) = (a ^ m) ^ n",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Max.max",
   "LinearOrderedRing.toMax",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "pow_zero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "add_zero",
   "congrArg",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.pow_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a ^ 0 = Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "propext",
   "Eq.mp",
   "sub_eq_zero",
   "NegZeroClass.toZero",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "Mathlib.Tactic.LinearCombination.eq_of_add",
  "constType":
  "∀ {α : Type u_1} {a b a' b' : α} [inst : AddGroup α], a = b → a' - b' - (a - b) = 0 → a' = b'",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ≠ a + c ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "LT.lt.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Abs.abs",
   "abs_of_nonneg",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "AddGroup",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_of_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 < a → |a| = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalCommRing.mk",
  "constType":
  "{α : Type u} → [toNonUnitalRing : NonUnitalRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommRing α",
  "constCategory": "Other"},
 {"references":
  ["InvolutiveNeg",
   "neg_inj",
   "InvolutiveNeg.toNeg",
   "propext",
   "Neg.neg",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Basic._auxLemma.14",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Units.instGroupUnits",
   "Units",
   "CommGroup.mk",
   "CommMonoid",
   "CommGroup",
   "CommMonoid.toMonoid",
   "Units.instCommGroupUnits.proof_1"],
  "name": "Units.instCommGroupUnits",
  "constType": "{α : Type u_1} → [inst : CommMonoid α] → CommGroup αˣ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "HMul.hMul",
   "Mul",
   "IsLeftCancelMulZero",
   "Eq"],
  "name": "IsLeftCancelMulZero.mk",
  "constType":
  "∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀],\n  (∀ {a b c : M₀}, a ≠ 0 → a * b = a * c → b = c) → IsLeftCancelMulZero M₀",
  "constCategory": "Other"},
 {"references":
  ["le_self_add",
   "AddZeroClass.toAdd",
   "Exists",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "LE.le",
   "ExistsAddOfLE.exists_add_of_le",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.ndrec",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "le_iff_exists_add",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b ↔ ∃ c, b = a + c",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "Preorder",
   "add_lt_add_right",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "instTransEq_1",
   "Function.swap",
   "AddZeroClass.toZero",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "instTransLtToLTLeToLE",
   "AddZeroClass"],
  "name": "add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["bit0",
   "StrictOrderedRing.toPartialOrder",
   "HPow.hPow",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "instAddNat",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Monoid.toMulOneClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "pow_bit0",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "mul_self_nonneg",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "LinearOrderedRing",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "id"],
  "name": "pow_bit0_nonneg",
  "constType":
  "∀ {R : Type u_2} [inst : LinearOrderedRing R] (a : R) (n : ℕ), 0 ≤ a ^ bit0 n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.one_mul",
   "HMul.hMul",
   "Int.add_mul",
   "Nat",
   "Int",
   "id"],
  "name": "Int.instCommRingInt.proof_1",
  "constType": "∀ (n : ℕ) (x : ℤ), (↑n + 1) * x = x + ↑n * x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "Eq"],
  "name": "NegZeroClass.neg_zero",
  "constType": "∀ {G : Type u_2} [self : NegZeroClass G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.casesOn",
   "Int.ofNat",
   "Int.instMulInt",
   "Int.negOfNat",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.ndrec",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.mul_comm",
  "constType": "∀ (a b : ℤ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Int.eq_ofNat_of_zero_le",
   "OfNat.ofNat",
   "instOfNatInt",
   "Eq.refl",
   "LE.le",
   "Int.mul_nonneg.match_1",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Nat",
   "Int",
   "Int.instLEInt",
   "Int.natAbs",
   "id"],
  "name": "Int.eq_natAbs_of_zero_le",
  "constType": "∀ {a : ℤ}, 0 ≤ a → a = ↑(Int.natAbs a)",
  "constCategory": "Theorem"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instSubNat",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "Nat.lt_of_sub_eq_succ",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddGroupWithOne.toAddGroup",
   "True",
   "Eq",
   "Nat.linearOrder",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instLENat",
   "AddGroupWithOne",
   "instOfNatNat",
   "le_of_lt",
   "Int.cast_negSucc",
   "Nat",
   "Eq.symm",
   "Nat.le_of_sub_eq_zero",
   "Nat.succ",
   "Eq.trans",
   "Nat.add_one",
   "id",
   "eq_self",
   "instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "LE.le",
   "Int.cast_ofNat",
   "eq_true",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Nat.cast_sub",
   "SubtractionMonoid.toSubNegMonoid",
   "Int.cast",
   "Int.negSucc",
   "Int.negOfNat.match_1",
   "LinearOrder.toPartialOrder",
   "congrArg",
   "neg_sub",
   "Int",
   "Nat.casesOn",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.cast_subNatNat",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℕ), ↑(Int.subNatNat m n) = ↑m - ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Rat.num",
   "Rat",
   "Rat.den",
   "Rat.divInt_self",
   "Int",
   "Rat.divInt",
   "Eq"],
  "name": "Rat.num_den",
  "constType": "∀ {a : ℚ}, Rat.divInt a.num ↑a.den = a",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.mk",
   "Int.instDecidableEqInt",
   "Int.decLt",
   "compareOfLessAndEq",
   "Int",
   "Int.instLTInt",
   "Ord"],
  "name": "instOrdInt",
  "constType": "Ord ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_4",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["bit0",
   "OfNat.ofNat",
   "One",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Add"],
  "name": "bit1",
  "constType": "{α : Type u} → [inst : One α] → [inst : Add α] → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "IsDomain", "Nontrivial"],
  "name": "IsDomain.toNontrivial",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [self : IsDomain α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "instHMul",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedCommSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "OrderedCommSemiring.mk",
  "constType":
  "{α : Type u} → [toOrderedSemiring : OrderedSemiring α] → (∀ (a b : α), a * b = b * a) → OrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["Div.mk", "Div", "Int.ediv", "Int"],
  "name": "Int.instDivInt_1",
  "constType": "Div ℤ",
  "constCategory": "Definition"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CancelMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "IsCancelMulZero",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero"],
  "name": "CancelMonoidWithZero.toIsCancelMulZero",
  "constType":
  "∀ {M₀ : Type u_4} [self : CancelMonoidWithZero M₀], IsCancelMulZero M₀",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Option.some.injEq",
   "Exists",
   "False",
   "HEq",
   "List.get?_len_le",
   "Eq.refl",
   "Option.noConfusion",
   "Exists.intro",
   "List.length",
   "List.get?_eq_get",
   "List.get?_eq_some.match_1",
   "LE.le",
   "instLTNat",
   "Eq",
   "Iff.intro",
   "Iff",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Option.none",
   "List",
   "Eq.rec",
   "LT.lt",
   "Eq.mp",
   "Option.some",
   "Eq.casesOn",
   "Nat.lt_of_not_le",
   "Nat",
   "List.get?",
   "List.get",
   "Fin.mk",
   "Option"],
  "name": "List.get?_eq_some",
  "constType":
  "∀ {α : Type u_1} {a : α} {l : List α} {n : ℕ},\n  List.get? l n = some a ↔ ∃ (h : n < List.length l), List.get l { val := n, isLt := h } = a",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_le_add_iff_left",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "add_right_neg",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "AddMonoid.toZero",
   "LE",
   "Eq.symm",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "congr",
   "add_zero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Left.neg_nonpos_iff",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance", "DivisionRing", "Rat", "Rat.field", "Field.toDivisionRing"],
  "name": "Rat.divisionRing",
  "constType": "DivisionRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "mul_neg",
   "HAdd.hAdd",
   "HasDistribNeg",
   "Exists.casesOn",
   "True",
   "pow_one",
   "Odd.proof_1",
   "Eq",
   "Semiring.toNatCast",
   "pow_mul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Odd",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "instOfNat",
   "neg_sq",
   "id",
   "eq_self",
   "HPow.hPow",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "One.toOfNat1",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "pow_add",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "instMulNat",
   "congrArg",
   "congrFun",
   "Nat.semiring"],
  "name": "Odd.neg_pow",
  "constType":
  "∀ {α : Type u_2} [inst : Monoid α] [inst_1 : HasDistribNeg α] {n : ℕ}, Odd n → ∀ (a : α), (-a) ^ n = -a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "Units.instInv",
   "MulOneClass.toMul",
   "Monoid",
   "InvolutiveNeg.toNeg",
   "Units.val",
   "HasDistribNeg.toInvolutiveNeg",
   "Neg.neg",
   "HasDistribNeg",
   "Units.instNegUnits.proof_2",
   "Units.instNegUnits.proof_1",
   "Units.mk",
   "Monoid.toMulOneClass",
   "Neg",
   "Neg.mk",
   "Inv.inv"],
  "name": "Units.instNegUnits",
  "constType":
  "{α : Type u} → [inst : Monoid α] → [inst_1 : HasDistribNeg α] → Neg αˣ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq"],
  "name": "LeftDistribClass.left_distrib",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.zero_mul",
   "CommMonoidWithZero.toZero",
   "MonoidWithZero.mk",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "MonoidWithZero"],
  "name": "CommMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Fermat42", "And", "instLENat", "Nat", "LE.le", "Int", "Int.natAbs"],
  "name": "Fermat42.Minimal",
  "constType": "ℤ → ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": ["SemiconjBy", "Mul"],
  "name": "Commute",
  "constType": "{S : Type u_2} → [inst : Mul S] → S → S → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.ofNat_succ",
   "instOfNatInt",
   "Iff.rfl",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "LE.le",
   "Int.instLTInt",
   "Eq",
   "Int.instAddInt",
   "Int.lt_iff_add_one_le",
   "Eq.mpr",
   "instLENat",
   "Eq.ndrec",
   "Iff",
   "Nat.cast",
   "instNatCastInt",
   "Int.ofNat_le",
   "propext",
   "LT.lt",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.ofNat_lt",
  "constType": "∀ {n m : ℕ}, ↑n < ↑m ↔ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "Eq.ndrec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "id"],
  "name": "NeZero.one",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Int.instSubInt",
   "_private.Init.Data.Int.Basic.0.Int.decNonneg",
   "Decidable",
   "HSub.hSub",
   "LE.le",
   "Int",
   "Int.instLEInt"],
  "name": "Int.decLe",
  "constType": "(a b : ℤ) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "GroupWithZero",
   "Nat",
   "Nat.succ",
   "Int",
   "GroupWithZero.toInv",
   "Inv.inv",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_neg'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.negSucc n) a = (GroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_neg",
  "constType": "∀ {G : Type u} [self : SubtractionMonoid G] (x : G), - -x = x",
  "constCategory": "Definition"},
 {"references": ["Ne", "OfNat.ofNat", "Rat", "Rat.den", "instOfNatNat", "Nat"],
  "name": "Rat.den_nz",
  "constType": "∀ (self : ℚ), self.den ≠ 0",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.one_mul",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toSemiring",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "of_eq_true",
   "Ring",
   "Ring.toAddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_1} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Prime.one_lt",
   "Nat.gcd_dvd_right",
   "Exists",
   "Nat.gcd_dvd_left",
   "Nat.not_coprime_of_dvd_of_dvd",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Exists.intro",
   "Nat.minFac",
   "And.left",
   "Exists.casesOn",
   "Eq",
   "Iff.intro",
   "And",
   "And.right",
   "Nat.Prime",
   "Nat.semigroup",
   "Iff",
   "Nat.Coprime",
   "Not",
   "Nat.gcd",
   "Nat.minFac_prime",
   "Nat.minFac_dvd",
   "And.intro",
   "Nat",
   "Dvd.dvd.trans"],
  "name": "Nat.Prime.not_coprime_iff_dvd",
  "constType":
  "∀ {m n : ℕ}, ¬Nat.Coprime m n ↔ ∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n",
  "constCategory": "Theorem"},
 {"references": ["CommMonoid", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toCommMonoid",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → CommMonoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommRing.toCommMonoid",
   "zpowRec",
   "Rat.commRing",
   "Monoid.toOne",
   "Rat.instInvRat",
   "Rat",
   "Eq.refl",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Rat.commGroupWithZero.proof_5",
  "constType":
  "∀ (n : ℕ) (a : ℚ), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrder.mk",
   "LinearOrderedAddCommGroup.min_def",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd"],
  "name": "LinearOrderedAddCommGroup.toLinearOrder",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.nodup_range", "Multiset.range", "Finset", "Finset.mk", "Nat"],
  "name": "Finset.range",
  "constType": "ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, a = ↑n → Mathlib.Meta.NormNum.IsInt a n",
  "constCategory": "Other"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["Ord.compare", "Ordering", "instOrdInt", "Eq.refl", "Int", "Eq"],
  "name": "Int.instLinearOrderInt.proof_3",
  "constType": "∀ (a b : ℤ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Nat.cast",
   "instNatCastInt",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Int",
   "Eq"],
  "name": "Int.mul_nonneg.match_1",
  "constType":
  "∀ {a : ℤ} (motive : (∃ n, a = ↑n) → Prop) (x : ∃ n, a = ↑n),\n  (∀ (n : ℕ) (hn : a = ↑n), motive (_ : ∃ n, a = ↑n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Iff",
   "instOfNatInt",
   "Rat.num",
   "Rat",
   "Rat.instOfNatRat",
   "Int",
   "Iff.not",
   "Rat.num_eq_zero",
   "Eq"],
  "name": "Rat.num_ne_zero",
  "constType": "∀ {q : ℚ}, q.num ≠ 0 ↔ q ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "not_lt",
   "PartialOrder.toPreorder",
   "And.left",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "Iff.mpr",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "And.right",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "mul_assoc",
   "le_of_not_gt",
   "Int.natAbs_neg",
   "Mathlib.Tactic.Ring.neg_congr",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Int.instCommRingInt",
   "neg_sq",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Or",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Int.gcd",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "eq_true",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Nat.gcd",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Int",
   "neg_nonpos",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "CommMonoidWithZero.toZero",
   "PythagoreanTriple.coprime_classification",
   "instOfNatInt",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "PythagoreanTriple",
   "zero_ne_one",
   "Int.add_one_le_iff",
   "AddMonoid.toAddSemigroup",
   "InvolutiveNeg.toNeg",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "zero_lt_one",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Or.inr",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Monoid.toMulOneClass",
   "Int.instModInt_1",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Or.inl",
   "Bool.false",
   "HMod.hMod",
   "Mathlib.Tactic.Ring.add_mul",
   "NegZeroClass.toNeg",
   "Int.instAddMonoidInt",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "add_nonneg",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Int.instSemigroupInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "And.casesOn",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_neg_of_pos",
   "OrderedSemiring.zeroLEOneClass",
   "sq_nonneg",
   "Nat.rawCast",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Int.instAddGroupInt",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "Not",
   "Mathlib.Tactic.Ring.mul_one",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Int.instSubInt",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "imp_false",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Int.mul_emod_right",
   "Int.linearOrderedCommRing",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Preorder.toLT",
   "instHPow",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Linarith.mul_neg",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.instLinearOrderInt",
   "add_lt_of_neg_of_le",
   "Int.instMonoidInt",
   "CommSemiring.toCommMonoidWithZero",
   "NeZero.charZero_one",
   "Eq.symm",
   "id",
   "le_or_lt",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "GT.gt",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instHMod",
   "StrictOrderedSemiring.to_charZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "Int.instSemiringInt",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Bool",
   "NegZeroClass.toZero",
   "Int.neg_emod_two",
   "Int.natAbs"],
  "name": "PythagoreanTriple.coprime_classification'",
  "constType":
  "∀ {x y z : ℤ},\n  PythagoreanTriple x y z →\n    Int.gcd x y = 1 →\n      x % 2 = 1 →\n        0 < z →\n          ∃ m n,\n            x = m ^ 2 - n ^ 2 ∧\n              y = 2 * m * n ∧\n                z = m ^ 2 + n ^ 2 ∧ Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_zero",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_pos'",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "instLTNat",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Nat",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_pos",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Preorder.toLT", "LT.lt", "Ne.symm", "Preorder", "LT.lt.ne"],
  "name": "LT.lt.ne'",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "Function.swap",
   "PartialOrder.toPreorder",
   "covariant_swap_add_of_covariant_add",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassRight",
  "constType":
  "∀ (M : Type u_3) [inst : OrderedAddCommMonoid M],\n  CovariantClass M M (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast", "Iff", "instNatCastInt", "Nat", "Int", "Int.ofNat_inj", "Eq"],
  "name": "Int.coe_nat_inj'",
  "constType": "∀ {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": ["Semigroup.toMul", "instHMul", "HMul.hMul", "Semigroup", "Eq"],
  "name": "Semigroup.mul_assoc",
  "constType":
  "∀ {G : Type u} [self : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "mul_neg",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "IsCoprime",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "CommRing",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Ring.toNeg",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "IsCoprime.of_add_mul_left_left",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CommRing.toCommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "CommRing.toRing",
   "congrArg",
   "congrFun"],
  "name": "IsCoprime.add_mul_left_left",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {x y : R}, IsCoprime x y → ∀ (z : R), IsCoprime (x + y * z) y",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "CommMonoid", "Multiset.prod", "Finset", "Finset.val"],
  "name": "Finset.prod",
  "constType":
  "{β : Type u} → {α : Type v} → [inst : CommMonoid β] → Finset α → (α → β) → β",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Nat.succ",
   "id",
   "IsCancelAdd.toIsLeftCancelAdd",
   "lt_add_one",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "strictMono_nat_of_lt_succ",
   "StrictMono.injective"],
  "name": "StrictOrderedSemiring.to_charZero",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedSemiring α], CharZero α",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((a : ℕ) → motive a Nat.zero) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_zero'",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), Ring.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "OrderedSemiring.toSemiring",
   "Nat",
   "Nat.cast_nonneg'",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_nonneg",
  "constType": "∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Eq.refl",
   "IsCoprime",
   "isCoprime_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "CommSemiring",
   "Eq.mp",
   "HMul.hMul",
   "IsCoprime.mul_left",
   "id"],
  "name": "IsCoprime.mul_right",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime x y → IsCoprime x z → IsCoprime x (y * z)",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "LT.lt.le",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "abs_of_nonpos",
   "DistribLattice.toLattice",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_of_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, a < 0 → |a| = -a",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_inv",
  "constType": "∀ {G : Type u} [self : DivisionMonoid G] (x : G), x⁻¹⁻¹ = x",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x ≤ x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x ≤ x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a ≤ _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "Mul", "Eq"],
  "name": "CommMagma.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b : G), a * b = b * a) → CommMagma G",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["lt_or_le",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Or.symm",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_or_lt",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "instNatCastInt", "Nat", "Int", "rfl", "Eq", "Int.natAbs"],
  "name": "Int.natAbs_ofNat",
  "constType": "∀ (n : ℕ), Int.natAbs ↑n = n",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.ble",
   "Iff.mp",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "Bool",
   "Nat",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → Nat.ble b' a' = false → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "Int.instMulInt",
   "Int.add_mul_emod_self_left",
   "Int.mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_mul_emod_self",
   "Eq.refl",
   "Eq",
   "Int.instAddInt",
   "Int.instModInt_1",
   "instHMul",
   "Eq.mpr",
   "instHMod",
   "Eq.ndrec",
   "Eq.rec",
   "Int.instDivInt_1",
   "HMod.hMod",
   "HMul.hMul",
   "Int.add_mul",
   "HDiv.hDiv",
   "Int.mul_assoc",
   "Eq.symm",
   "Int.emod_add_ediv'",
   "Int",
   "Eq.trans",
   "Int.emod_add_ediv",
   "id"],
  "name": "Int.mul_emod",
  "constType": "∀ (a b n : ℤ), a * b % n = a % n * (b % n) % n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instOfNatInt",
   "instNatCastInt",
   "instOfNatNat",
   "Nat",
   "Int",
   "rfl",
   "Eq"],
  "name": "Int.ofNat_one",
  "constType": "↑1 = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "LinearOrder.mk",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLT"],
  "name": "LinearOrderedRing.toLinearOrder",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedCommSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedCommSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemigroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → Prop) (x : _a ≤ _b ∧ ¬_b ≤ _a),\n  (∀ (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive (_ : _a ≤ _b ∧ ¬_b ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "IsCoprime",
   "Exists.casesOn",
   "Iff.mpr",
   "instDecidableEqNat",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_assoc",
   "Nat.Prime",
   "Iff",
   "Nat.cast",
   "Iff.mp",
   "Int.instSemigroupInt",
   "Dvd.dvd.mul_left",
   "Nat",
   "And.casesOn",
   "Int.instDvdInt",
   "Int.instCommRingInt",
   "Int.instCommSemiringInt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Nat.Prime.not_coprime_iff_dvd",
   "CommMagma.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.gcd",
   "Int.instAddInt",
   "Iff.intro",
   "instHMul",
   "And",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "dvd_add",
   "Nat.gcd",
   "Not",
   "Int",
   "Int.instDistribInt",
   "Int.exists_unit_of_abs",
   "Int.coe_nat_dvd_left",
   "Exists",
   "instOfNatInt",
   "CommRing.toNonUnitalCommRing",
   "Nat.instDvdNat",
   "Eq.refl",
   "Exists.intro",
   "mul_comm",
   "Nat.gcd_eq_gcd_ab",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "Int.ofNat_one",
   "Nat.Prime.not_dvd_one",
   "instOfNatNat",
   "Int.instMonoidInt",
   "Eq.symm",
   "Decidable.byContradiction",
   "id",
   "Int.coe_nat_dvd",
   "Nat.gcdB",
   "Int.instMulInt",
   "False",
   "Int.instCommSemigroupInt",
   "instHAdd",
   "One.toOfNat1",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.gcdA",
   "Distrib.leftDistribClass",
   "Semiring.toOne",
   "Eq.ndrec",
   "instNatCastInt",
   "HMul.hMul",
   "Nat.Coprime",
   "IsUnit",
   "Int.gcd_eq_natAbs",
   "Int.natAbs"],
  "name": "Int.gcd_eq_one_iff_coprime",
  "constType": "∀ {a b : ℤ}, Int.gcd a b = 1 ↔ IsCoprime a b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "abs_of_nonneg",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "SemilatticeSup.toSup",
   "Int.noConfusion",
   "Nat.cast",
   "Int.instDecidableEqInt",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Bool.true",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "Int.emod_lt",
   "Ne",
   "Or",
   "instDistribLattice",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Nat.cast_add",
   "Int.instLTInt",
   "DistribLattice.toLattice",
   "False.elim",
   "Int.instAddGroupInt",
   "HEq.refl",
   "AddCancelMonoid.toIsCancelAdd",
   "Int.negSucc",
   "LT.lt",
   "Int.emod_nonneg",
   "Int",
   "Int.instLEInt",
   "OrderedCancelAddCommMonoid.toContravariantClassRight",
   "Int.decLe",
   "Int.ofNat",
   "AddZeroClass.toAdd",
   "IsRightCancelAdd.contravariant_swap_add_le_of_contravariant_swap_add_lt",
   "HEq",
   "Int.instSubInt",
   "Int.NonNeg.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "of_decide_eq_true",
   "Eq.refl",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Int.linearOrderedCommRing",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "IsCancelAdd.toIsRightCancelAdd",
   "Abs.abs",
   "le_add_iff_nonneg_left",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "AddMonoidWithOne.toNatCast",
   "instDecidableNot",
   "AddMonoid.toAddSemigroup",
   "Eq.rec",
   "AddGroup.toAddCancelMonoid",
   "Int.emod_two_eq_zero_or_one.match_1",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "Int.instLinearOrderInt",
   "Int.NonNeg.casesOn",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "Or.inr",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "LT.lt.not_le",
   "LE.le",
   "Int.NonNeg",
   "Int.instModInt_1",
   "instHMod",
   "Or.inl",
   "Eq.ndrec",
   "instNatCastInt",
   "OrderedCommSemiring.toOrderedSemiring",
   "HMod.hMod",
   "Bool",
   "NegZeroClass.toNeg",
   "Int.instAddMonoidInt"],
  "name": "Int.emod_two_eq_zero_or_one",
  "constType": "∀ (n : ℤ), n % 2 = 0 ∨ n % 2 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Dvd",
   "Eq"],
  "name": "Nat.instDvdNat",
  "constType": "Dvd ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toCommRing",
   "instHMul",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Rat.field",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.instLinearOrderedFieldRat.proof_4",
  "constType": "∀ (a b : ℚ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "Preorder",
   "MulZeroClass.toMul",
   "Left.mul_pos"],
  "name": "mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "instHPow",
   "HAdd.hAdd",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Monoid.npow_succ",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "pow_succ",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a * a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "True",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Int.neg_mul",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "HMul.hMul",
   "Int.instNegInt",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.instCommRingInt.proof_7",
  "constType": "∀ (m : ℕ) (n : ℤ), -(↑m + 1) * n = -((↑m + 1) * n)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "Nat",
   "GroupWithZero.toMonoidWithZero",
   "Nat.succ",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_succ'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * GroupWithZero.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_self",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "left_neg_eq_right_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {a b : G}, a + b = 0 → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "SubNegMonoid.toNeg",
   "neg_zero",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_add",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Eq",
   "Int.instInhabitedInt",
   "Int.eq_nat_or_neg",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Int.cast_neg",
   "HasDistribNeg.toInvolutiveNeg",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "Eq.trans",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Std.Logic._auxLemma.32",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.cast_zero",
   "instHMul",
   "Nat.rec",
   "NonAssocRing.toIntCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "congr",
   "congrArg",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "forall_congr",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.instNegInt",
   "neg_mul",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "Mathlib.Algebra.Group.Basic._auxLemma.14",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Ring.toAddCommGroup",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "Int.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocRing α] (m n : ℤ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "Eq.rec", "HMul.hMul", "Mul", "rfl", "Eq"],
  "name": "Mathlib.Tactic.LinearCombination.c_mul_pf",
  "constType":
  "∀ {α : Type u_1} {b c : α} [inst : Mul α], b = c → ∀ (a : α), a * b = a * c",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toInv",
   "Inv.inv",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "GroupWithZero.div_eq_mul_inv",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a b : G₀), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "Iff.rfl",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "Eq.ndrec",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "add_neg_eq_iff_eq_add",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a - b = c ↔ a = c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Max.max", "Eq.refl", "Int.instMaxInt", "Int", "Eq"],
  "name": "Int.instLinearOrderInt.proof_2",
  "constType": "∀ (a b : ℤ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "AddMonoid.toZero",
   "add_neg_self",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "add_lt_add_iff_left",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "add_zero"],
  "name": "Left.neg_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "CommRing.toRing",
   "Int",
   "Int.instCommRingInt",
   "AddMonoid"],
  "name": "Int.instAddMonoidInt",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "constCategory": "Other"},
 {"references":
  ["Int.cast_injective.match_1",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Iff.mp",
   "Function.Injective",
   "CharZero",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "Int.cast_inj",
   "AddGroupWithOne",
   "Int",
   "Eq"],
  "name": "Int.cast_injective",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroupWithOne α] [inst_1 : CharZero α], Function.Injective Int.cast",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "List.ilast'_mem",
   "Function.comp",
   "Eq.refl",
   "Mathlib.Data.List.TFAE._auxLemma.2",
   "implies_congr",
   "True",
   "Eq",
   "Iff.intro",
   "Mathlib.Data.List.TFAE._auxLemma.6",
   "And",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "List.rec",
   "List.ilast'",
   "forall_congr",
   "List",
   "Eq.mp",
   "List.Mem.head",
   "Mathlib.Data.List.TFAE._auxLemma.1",
   "Mathlib.Data.List.TFAE._auxLemma.4",
   "And.intro",
   "List.nil",
   "And.casesOn",
   "List.Chain",
   "congrArg",
   "Eq.trans",
   "List.TFAE",
   "id",
   "Mathlib.Data.List.TFAE._auxLemma.5"],
  "name": "List.tfae_of_cycle",
  "constType":
  "∀ {a b : Prop} {l : List Prop},\n  List.Chain (fun x x_1 => x → x_1) a (b :: l) → (List.ilast' b l → a) → List.TFAE (a :: b :: l)",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_mul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Mathlib.Meta.NormNum.isNat_mul.match_1",
   "Nat.mul",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.mul a' b' = c → Mathlib.Meta.NormNum.IsNat (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "LeftDistribClass.mk",
   "LeftDistribClass",
   "Distrib.left_distrib",
   "Distrib",
   "Distrib.toMul"],
  "name": "Distrib.leftDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], LeftDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Nat.add_assoc",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Eq.mpr",
   "mul_assoc",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Nat.add_zero",
   "Eq.symm",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Monoid.toSemigroup",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "pow_succ'",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "HMul.hMul",
   "mul_one"],
  "name": "pow_add",
  "constType":
  "∀ {M : Type u} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m + n) = a ^ m * a ^ n",
  "constCategory": "Theorem"},
 {"references": ["propext", "IsEmpty.forall_iff", "IsEmpty", "True", "Eq"],
  "name": "Mathlib.Logic.IsEmpty._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} [inst : IsEmpty α] {p : α → Prop}, (∀ (a : α), p a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.negSucc_mul_subNatNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "True",
   "Eq",
   "Nat.right_distrib",
   "Int.ofNat_mul_subNatNat",
   "Eq.mpr",
   "Nat.cast",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.left_distrib",
   "Nat.succ",
   "id",
   "Nat.succ_add",
   "eq_self",
   "Int.instMulInt",
   "Int.mul_add.match_1",
   "instAddNat",
   "Int.negOfNat",
   "instHAdd",
   "Int.instAddInt",
   "Nat.mul_comm",
   "Int.negOfNat_add",
   "instHMul",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "Int.negSucc",
   "Int.negOfNat_eq_subNatNat_zero",
   "Int.subNatNat_add",
   "HMul.hMul",
   "congr",
   "instMulNat",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.mul_add",
  "constType": "∀ (a b c : ℤ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Int.coe_nat_dvd_left",
   "Nat.Prime.dvd_of_dvd_pow",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Eq",
   "Int.instHPowIntNat",
   "Nat.Prime",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "propext",
   "instHPow",
   "Eq.mp",
   "Nat.monoid",
   "Monoid.toNatPow",
   "Int.natAbs_pow",
   "Nat",
   "Int",
   "Int.instDvdInt",
   "Int.natAbs"],
  "name": "Int.Prime.dvd_pow",
  "constType":
  "∀ {n : ℤ} {k p : ℕ}, Nat.Prime p → ↑p ∣ n ^ k → p ∣ Int.natAbs n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "left_distrib",
   "Eq"],
  "name": "mul_add",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrder.mk",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Monoid.toMulOneClass",
   "pow_one",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "pow_two",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "PartialOrder.toPreorder",
   "Mathlib.Tactic.Ring.pow_zero",
   "And.left",
   "instDecidableEqNat",
   "Iff.mpr",
   "Int.pow_dvd_pow_iff",
   "And.right",
   "Nat.Prime",
   "Nat.one_lt_pow",
   "Nat.cast",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Int.coe_nat_ne_zero",
   "Mathlib.Tactic.Ring.pow_add",
   "instOfNat",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Nat.pos_of_ne_zero",
   "MulOneClass.toOne",
   "Nat.Prime.not_coprime_iff_dvd",
   "Fermat42.mul",
   "Int.gcd",
   "And",
   "Nat.zero",
   "propext",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "instNatAtLeastTwo",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Exists",
   "CommMonoidWithZero.toZero",
   "instOfNatInt",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "Dvd.intro",
   "AddMonoidWithOne.toNatCast",
   "Monoid.toNatPow",
   "Fermat42.Minimal",
   "Decidable.byContradiction",
   "Nat.linearOrderedSemiring",
   "Int.instMulInt",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Nat.linearOrderedCommMonoidWithZero",
   "Mathlib.Tactic.Ring.mul_pow",
   "lt_mul_iff_one_lt_left",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "One.toOfNat1",
   "LE.le",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Int.natAbs_ne_zero",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Fermat42.ne_zero",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "zero_lt_two",
   "HAdd.hAdd",
   "IsCoprime",
   "Exists.casesOn",
   "instLTNat",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "Int.instSemigroupInt",
   "Nat.Prime.ne_zero",
   "Nat",
   "And.casesOn",
   "Int.instDvdInt",
   "Ne",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Int.instCommSemiringInt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Nat.le_lt_asymm",
   "Not",
   "LinearOrderedSemiring.toMulPosReflectLT",
   "Int.coe_nat_dvd_left",
   "Nat.instDvdNat",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Int.gcd_eq_one_iff_coprime",
   "Zero.toOfNat0",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Nat.monoid",
   "instOfNatNat",
   "Int.instMonoidInt",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "Eq.symm",
   "Int.natAbs_ofNat",
   "id",
   "NeZero.succ",
   "Nat.Prime.one_lt",
   "Fermat42",
   "False",
   "instHAdd",
   "Dvd.dvd",
   "Mathlib.Tactic.Ring.single_pow",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "StrictOrderedSemiring.toPartialOrder",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Nat.Coprime",
   "HMul.hMul",
   "Int.natAbs_pow",
   "Int.natAbs_mul",
   "instMulNat",
   "Nat.semiring",
   "Int.natAbs"],
  "name": "Fermat42.coprime_of_minimal",
  "constType": "∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.le_refl",
   "Or",
   "OfNat.ofNat",
   "instOfNatInt",
   "Eq.refl",
   "Int.eq_natAbs_of_zero_le",
   "Int.le_natAbs.match_1",
   "LE.le",
   "Int.le_trans",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.le_total",
   "Int.ofNat_zero_le",
   "Int",
   "Int.instLEInt",
   "Int.natAbs",
   "id"],
  "name": "Int.le_natAbs",
  "constType": "∀ {a : ℤ}, a ≤ ↑(Int.natAbs a)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.cons",
   "instAddNat",
   "List.brecOn",
   "List.below",
   "instHAdd",
   "List.instMembershipList",
   "HAdd.hAdd",
   "List.Mem.tail",
   "List.get_mem.match_1",
   "List.length",
   "instLTNat",
   "List.get.proof_2",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "List.rec",
   "List",
   "LT.lt",
   "PUnit",
   "List.Mem.head",
   "instOfNatNat",
   "Nat",
   "List.get",
   "Fin.mk"],
  "name": "List.get_mem",
  "constType":
  "∀ {α : Type u_1} (l : List α) (n : ℕ) (h : n < List.length l), List.get l { val := n, isLt := h } ∈ l",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Iff",
   "instOfNatInt",
   "instHAdd",
   "Iff.rfl",
   "LT.lt",
   "HAdd.hAdd",
   "LE.le",
   "Int",
   "Int.instLTInt",
   "Int.instLEInt",
   "Int.instAddInt"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "One",
   "NeZero.ne'",
   "One.toOfNat1"],
  "name": "zero_ne_one",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 0 ≠ 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instOfNatInt",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Nat.xgcd",
   "MulZeroClass.toZero",
   "_private.Mathlib.Data.Int.GCD.0.Nat.P",
   "Nat",
   "Eq.trans",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Int.instMulInt",
   "Nat.gcdB",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "instHAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Nat.xgcdAux_P",
   "One.toOfNat1",
   "Nat.xgcdAux",
   "Nat.gcdA",
   "Int.instAddInt",
   "Nat.xgcd_val",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Prod.mk",
   "Eq.mp",
   "Int.instSemiringInt",
   "congr",
   "HMul.hMul",
   "mul_one",
   "Nat.gcd",
   "Prod",
   "Int.instAddMonoidInt",
   "add_zero",
   "congrArg",
   "Int",
   "Nat.xgcdAux_val"],
  "name": "Nat.gcd_eq_gcd_ab",
  "constType":
  "∀ (x y : ℕ), ↑(Nat.gcd x y) = ↑x * Nat.gcdA x y + ↑y * Nat.gcdB x y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SubNegMonoid.toSub",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toSub",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_3",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "Eq",
   "instHMul",
   "One",
   "HMul.hMul",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            autoParam (∀ (x : M), npow 0 x = 1) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), npow (n + 1) x = x * npow n x) _auto✝¹ → Monoid M",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_6",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "neg_add_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, -a + b = c ↔ b = a + c",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Max.max",
   "LinearOrderedCommRing",
   "LinearOrderedRing.toMax",
   "LE.le",
   "LinearOrderedRing.max_def",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_3",
  "constType":
  "∀ {α : Type u_1} [d : LinearOrderedCommRing α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toNeg",
   "add_left_neg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "Eq"],
  "name": "AddGroup.toSubtractionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "One", "One.mk", "OfNat"],
  "name": "One.ofOfNat1",
  "constType": "{α : Type u_1} → [inst : OfNat α 1] → One α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ c₁ a₂ b₂ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_succ",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "DivInvMonoid.div_eq_mul_inv",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "Semiring.npow",
   "CommMonoid",
   "CommSemiring",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommSemiring.toCommMonoid",
  "constType": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedSemiring.toMax",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedSemifield",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedField.toLinearOrderedSemifield.proof_1",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedField.inv_zero",
   "LinearOrderedField.toDiv",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedSemifield.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedField.zpow_neg'",
   "LinearOrderedField.zpow",
   "LinearOrderedField.toInv",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedField.toLinearOrderedSemifield",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LinearOrderedSemifield α",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "Eq.mpr",
   "Eq.ndrec",
   "instOfNatInt",
   "Int.one_mul",
   "Eq.refl",
   "HMul.hMul",
   "Int",
   "Int.mul_comm",
   "id",
   "Eq"],
  "name": "Int.mul_one",
  "constType": "∀ (a : ℤ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Field", "Nontrivial"],
  "name": "Field.toNontrivial",
  "constType": "∀ {K : Type u} [self : Field K], Nontrivial K",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedAddCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "IntCast.mk",
   "instNatCastInt",
   "Nat",
   "Int",
   "rfl",
   "IntCast.intCast",
   "Eq"],
  "name": "Int.instCommRingInt.proof_8",
  "constType": "∀ (x : ℕ), IntCast.intCast ↑x = IntCast.intCast ↑x",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "CommMagma",
   "CommMagma.mk",
   "CommSemigroup.mul_comm",
   "CommSemigroup",
   "CommSemigroup.toSemigroup"],
  "name": "CommSemigroup.toCommMagma",
  "constType": "{G : Type u} → [self : CommSemigroup G] → CommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "LinearOrderedCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "LinearOrderedCommMonoid.toCommMonoid",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "HMul.hMul",
   "LinearOrderedCommMonoid.toLinearOrder",
   "LinearOrder.toPartialOrder",
   "CommMonoid.toMonoid"],
  "name": "LinearOrderedCommMonoidWithZero.mk",
  "constType":
  "{α : Type u_1} →\n  [toLinearOrderedCommMonoid : LinearOrderedCommMonoid α] →\n    [toZero : Zero α] → (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → 0 ≤ 1 → LinearOrderedCommMonoidWithZero α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Eq.refl",
   "instPowNat",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.zero",
   "instHPow",
   "instNatPowNat",
   "HMul.hMul",
   "Nat.mul_one",
   "Nat.pow_succ",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.one_pow",
  "constType": "∀ (n : ℕ), 1 ^ n = 1",
  "constCategory": "Theorem"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [inst : Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "add_le_add_left",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "instTransEq_1",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "zero_le_one",
   "AddMonoid.toZero",
   "CovariantClass",
   "instTransEq",
   "instNatAtLeastTwo",
   "LE",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "Eq.symm",
   "instOfNat"],
  "name": "one_le_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : LE α] [inst_2 : ZeroLEOneClass α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 1 ≤ 2",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_2",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.cast_add.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ),\n  (∀ (m n : ℕ), motive (Int.ofNat m) (Int.ofNat n)) →\n    (∀ (m n : ℕ), motive (Int.ofNat m) (Int.negSucc n)) →\n      (∀ (m n : ℕ), motive (Int.negSucc m) (Int.ofNat n)) →\n        (∀ (m n : ℕ), motive (Int.negSucc m) (Int.negSucc n)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocRing.toIntCast",
   "NonAssocRing",
   "NonAssocRing.intCast_negSucc",
   "AddCommGroupWithOne.mk",
   "NonAssocRing.natCast_succ",
   "NonAssocRing.intCast_ofNat",
   "AddCommGroupWithOne",
   "NonAssocRing.toNatCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.natCast_zero",
   "NonAssocRing.toOne",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.toAddCommGroupWithOne",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → AddCommGroupWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "AddCommSemigroup",
   "Int.instAddCommMonoidInt",
   "AddCommMonoid.toAddCommSemigroup",
   "Int"],
  "name": "Int.instAddCommSemigroupInt",
  "constType": "AddCommSemigroup ℤ",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "RightDistribClass.mk",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R], (∀ (a b c : R), (a + b) * c = a * c + b * c) → RightDistribClass R",
  "constCategory": "Other"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references": ["NonAssocRing", "IntCast"],
  "name": "NonAssocRing.toIntCast",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → IntCast α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "mul_ne_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedSemiring",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "ne_of_gt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name":
  "_private.Mathlib.Tactic.Positivity.Basic.0.Mathlib.Meta.Positivity.mul_ne_zero_of_ne_zero_of_pos",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : NoZeroDivisors α] {a b : α}, a ≠ 0 → 0 < b → a * b ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Int.decEq.proof_2",
   "Int.decEq.proof_4",
   "Int.decEq.match_1",
   "Decidable.isTrue",
   "Int.decEq.match_2",
   "Int.decEq.proof_3",
   "decEq",
   "instDecidableEqNat",
   "Eq",
   "Decidable.isFalse",
   "Int.negSucc",
   "Int.decEq.proof_6",
   "Decidable",
   "Int.decEq.proof_5",
   "Not",
   "Nat",
   "Int",
   "Int.decEq.proof_1"],
  "name": "Int.decEq",
  "constType": "(a b : ℤ) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Rat.commSemiring",
   "Semiring",
   "Rat"],
  "name": "Rat.semiring",
  "constType": "Semiring ℚ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_1",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["Add", "Mul"],
  "name": "LeftDistribClass",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → GroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.toInv",
   "DivisionSemiring.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegZeroMonoid",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.mk",
  "constType":
  "{G : Type u_2} → [toSubNegMonoid : SubNegMonoid G] → -0 = 0 → SubNegZeroMonoid G",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "HEq",
   "instHAdd",
   "eq_of_heq",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int.add",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HAdd.hAdd →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.add x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HAdd.hAdd) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.add x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HAdd.hAdd (↑n) (↑n_1) n n_1 (Int.add n n_1) (_ : HAdd.hAdd = HAdd.hAdd)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.add n n_1 = Int.add n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "HPow.hPow",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "Int.linearOrderedCommRing",
   "Int.natAbs_le_self_sq",
   "LE.le",
   "Nat.cast",
   "instNatCastInt",
   "instHPow",
   "Monoid.toNatPow",
   "le_trans",
   "instOfNatNat",
   "Int.le_natAbs",
   "Nat",
   "Int.instMonoidInt",
   "Int",
   "Int.instLEInt",
   "Int.natAbs"],
  "name": "Int.le_self_sq",
  "constType": "∀ (b : ℤ), b ≤ b ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u_1} → [inst : Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.head",
  "constType": "∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "congr_arg", "Function.Injective", "Eq"],
  "name": "Function.Injective.eq_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α}, f a = f b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "Int.rawCast",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Ring.toNeg",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Nat.addMonoid",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "neg_mul",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "Int.negOfNat",
   "MulOneClass.toOne",
   "instHAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.negSucc",
   "Int.cast",
   "HMul.hMul",
   "congrArg",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b : R}, Int.rawCast (Int.negOfNat 1) * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Div"],
  "name": "DivInvMonoid.toDiv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Decidable.isFalse",
   "propext",
   "instDecidableEqProp.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqProp.proof_1",
   "Eq"],
  "name": "instDecidableEqProp",
  "constType": "{p q : Prop} → [d : Decidable (p ↔ q)] → Decidable (p = q)",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty",
  "constType": "∀ {α : Sort u} [inst : Inhabited α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references": ["LinearOrderedRing", "Ord"],
  "name": "LinearOrderedRing.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["Abs"],
  "name": "Abs.abs",
  "constType": "{α : Type u_1} → [self : Abs α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "Add.add",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.toAdd",
   "left_comm",
   "Eq"],
  "name": "add_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + (b + c) = b + (a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Dvd.intro",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["inv_div",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "one_div",
   "One.toOfNat1",
   "inv_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "Eq",
   "DivInvMonoid.toInv",
   "DivInvMonoid.zpow",
   "DivInvMonoid.zpow_neg'",
   "DivisionMonoid",
   "Eq.mp",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "congrArg",
   "Eq.trans",
   "id",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "DivisionMonoid.toDivInvOneMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : DivisionMonoid α], 1⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["PProd", "List.rec", "List", "PUnit"],
  "name": "List.below",
  "constType":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max 1 u_1)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.List.TFAE._hyg.507",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "MulPosMono",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toMulPosMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], MulPosMono α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "pow_eq_zero_iff",
   "MulZeroOneClass.toMulZeroClass",
   "instLTNat",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "NoZeroDivisors",
   "MonoidWithZero.toMulZeroOneClass",
   "MonoidWithZero.toMonoid",
   "propext",
   "instHPow",
   "LT.lt",
   "Monoid.toNatPow",
   "instOfNatNat",
   "MonoidWithZero.toZero",
   "Nat",
   "MonoidWithZero"],
  "name": "Mathlib.Algebra.GroupPower.Ring._auxLemma.1",
  "constType":
  "∀ {M : Type u_3} [inst : MonoidWithZero M] [inst_1 : NoZeroDivisors M] {a : M} {n : ℕ}, 0 < n → (a ^ n = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "instHDiv",
   "Ne.isUnit",
   "OfNat.ofNat",
   "Iff",
   "GroupWithZero.toDivisionMonoid",
   "GroupWithZero",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "IsUnit.div_left_inj",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "div_left_inj'",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, c ≠ 0 → (a / c = b / c ↔ a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddGroup",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (n : ℕ) (x : G), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "CommRing",
   "Semiring.toOne",
   "CommMonoid",
   "Semiring.npow",
   "CommRing.toRing",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommRing.toCommMonoid",
  "constType": "{α : Type u} → [self : CommRing α] → CommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommMonoidWithZero",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Or.resolve_left",
   "Ne",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Nat.eq_zero_or_pos",
   "GT.gt",
   "Eq"],
  "name": "Nat.pos_of_ne_zero",
  "constType": "∀ {n : ℕ}, n ≠ 0 → 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references": ["DivInvOneMonoid", "DivInvMonoid"],
  "name": "DivInvOneMonoid.toDivInvMonoid",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Mathlib.Meta.NormNum.IsNat.rec",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.casesOn",
  "constType":
  "{α : Type u_1} →\n  [inst : AddMonoidWithOne α] →\n    {a : α} →\n      {n : ℕ} →\n        {motive : Mathlib.Meta.NormNum.IsNat a n → Sort u} →\n          (t : Mathlib.Meta.NormNum.IsNat a n) →\n            ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "neg_zero",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "neg_neg",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Nat.add",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.cast_negSucc",
   "Nat",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Int.cast_ofNat",
   "Int.cast_zero",
   "Int.cast_neg.match_1",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.negSucc",
   "Int.cast",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Int.cast_neg",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℤ), ↑(-n) = -↑n",
  "constCategory": "Theorem"},
 {"references": ["Irreducible", "Nat.monoid", "Nat"],
  "name": "Nat.Prime",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Int.natAbs_dvd_natAbs",
   "OfNat.ofNat",
   "Nat.pow_dvd_pow_iff",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Int.instCommMonoidInt",
   "instLTNat",
   "Int.instHPowIntNat",
   "Eq",
   "pow_dvd_pow_of_dvd",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "instHPow",
   "propext",
   "LT.lt",
   "Nat.monoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Int.natAbs_pow",
   "Nat",
   "Eq.symm",
   "Int",
   "Int.instDvdInt",
   "Int.natAbs",
   "id"],
  "name": "Int.pow_dvd_pow_iff",
  "constType": "∀ {m n : ℤ} {k : ℕ}, 0 < k → (m ^ k ∣ n ^ k ↔ m ∣ n)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "DivisionSemiring.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionSemiring.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "eq_neg_add_iff_add_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a = -b + c ↔ b + a = c",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "instHDiv",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Rat.instIntCastRat",
   "Rat",
   "Rat.num",
   "Eq.refl",
   "Rat.semiring",
   "Rat.divInt",
   "Rat.divInt_eq_div",
   "Int.cast_ofNat",
   "Eq",
   "Rat.instDivRat",
   "Semiring.toNatCast",
   "Eq.mpr",
   "Rat.commRing",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "Int.cast",
   "Rat.den",
   "CommRing.toRing",
   "HDiv.hDiv",
   "Rat.num_den",
   "Eq.symm",
   "Int",
   "id"],
  "name": "Rat.num_div_den",
  "constType": "∀ (r : ℚ), ↑r.num / ↑r.den = r",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "rfl"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat (Nat.rawCast n) n",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "not_lt_of_ge",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_of_not_gt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Eq.ndrec",
   "Nat.zero",
   "Int.negOfNat",
   "Eq.refl",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Int",
   "Int.subNatNat",
   "Nat.casesOn",
   "Eq"],
  "name": "Int.negOfNat_eq_subNatNat_zero",
  "constType": "∀ (n : ℕ), Int.negOfNat n = Int.subNatNat 0 n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "OfNat.ofNat",
   "Nat.le",
   "HEq",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "instLTNat",
   "Eq",
   "Nat.zero",
   "HEq.refl",
   "Nat.noConfusion",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.casesOn"],
  "name": "zero_pow.match_1",
  "constType":
  "∀ (motive : (x : ℕ) → 0 < x → Prop) (x : ℕ) (x_1 : 0 < x),\n  (∀ (n : ℕ) (x : 0 < n + 1), motive (Nat.succ n) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["Dvd"],
  "name": "Dvd.dvd",
  "constType": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Rat.zero_ne_one",
   "Rat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Rat.instOfNatRat"],
  "name": "Rat.commGroupWithZero.proof_7",
  "constType": "Nontrivial ℚ",
  "constCategory": "Theorem"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → CommMagma α",
  "constCategory": "Definition"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "eq_self",
   "Nat.add_comm",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Int.add_comm.match_1",
   "Eq",
   "Int.instAddInt",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans"],
  "name": "Int.add_comm",
  "constType": "∀ (a b : ℤ), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Or",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedCommRing",
   "LinearOrderedRing.le_total",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [d : LinearOrderedCommRing α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "OrderedSemiring",
   "inferInstance",
   "OrderedCommSemiring.toOrderedSemiring",
   "Rat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Rat.instLinearOrderedFieldRat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Rat.instOrderedSemiringRat",
  "constType": "OrderedSemiring ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["Iff", "False", "Iff.rfl", "Not"],
  "name": "imp_false",
  "constType": "∀ {a : Prop}, a → False ↔ ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield.zpow_neg'",
   "LinearOrderedSemifield.mul_inv_cancel",
   "CommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Semifield",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.div_eq_mul_inv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedSemifield.inv_zero",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toNontrivial",
   "Semifield.mk",
   "LinearOrderedSemifield.zpow_succ'",
   "LinearOrderedSemifield.zpow_zero'",
   "StrictOrderedCommSemiring.mul_comm"],
  "name": "LinearOrderedSemifield.toSemifield",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → Semifield α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "inferInstance",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int",
   "Distrib",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "Int.instDistribInt",
  "constType": "Distrib ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "mul_one",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_one",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * Nat.rawCast 1 = a",
  "constCategory": "Theorem"},
 {"references": ["List.nil", "List.Chain"],
  "name": "List.Chain.nil",
  "constType": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "constCategory": "Other"},
 {"references":
  ["InvOneClass.mk",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid.inv_one",
   "InvOneClass",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "IsUnit.mul_inv_cancel",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Eq",
   "DivisionMonoid",
   "InvOneClass.toOne",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "id",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "IsUnit.div_self",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a : α}, IsUnit a → a / a = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalCommRing", "NonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalRing",
  "constType": "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_neg'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "StrictOrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm",
   "instHMul",
   "mul_assoc",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "Mul.mul",
   "CommSemigroup",
   "left_comm",
   "Eq",
   "CommSemigroup.toSemigroup"],
  "name": "mul_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * (b * c) = b * (a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "MulOneClass.toMul",
   "Monoid",
   "instHPow",
   "Monoid.toNatPow",
   "Nat",
   "Monoid.toMulOneClass",
   "Commute.refl",
   "Commute",
   "Commute.pow_right"],
  "name": "Commute.self_pow",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), Commute a (a ^ n)",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Chain",
  "constType": "{α : Type u_1} → (α → α → Prop) → α → List α → Prop",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommMonoid",
   "Exists",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderBot",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_1} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    [toOrderBot : OrderBot α] →\n      (∀ {a b : α}, a ≤ b → ∃ c, b = a + c) → (∀ (a b : α), a ≤ a + b) → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CommSemiring",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Mathlib.Meta.NormNum.IsNat.out",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "add_add_add_comm"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ a₂ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Int",
   "Int.instCommRingInt",
   "Semigroup"],
  "name": "Int.instSemigroupInt",
  "constType": "Semigroup ℤ",
  "constCategory": "Definition"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} → [self : Ring R] → IntCast R",
  "constCategory": "Definition"},
 {"references": ["Semifield", "Inv"],
  "name": "Semifield.toInv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["lt_of_le_of_lt",
   "Preorder.toLT",
   "GE.ge",
   "Preorder",
   "Preorder.toLE",
   "GT.gt"],
  "name": "gt_of_gt_of_ge",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a > b → b ≥ c → a > c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "Ring.toNonAssocRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Other"},
 {"references": ["Monoid", "Nat"],
  "name": "Monoid.npow",
  "constType": "{M : Type u} → [self : Monoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "Nat"],
  "name": "Mathlib.Meta.NormNum.IsNat",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → α → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "Nat.monoid",
   "Monoid.toNatPow",
   "Nat.cast_pow",
   "Nat",
   "Eq.symm",
   "Eq",
   "Semiring.toNatCast"],
  "name": "Mathlib.Algebra.GroupPower.Lemmas._auxLemma.10",
  "constType":
  "∀ {R : Type u₁} [inst : Semiring R] (n m : ℕ), ↑n ^ m = ↑(n ^ m)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulOneClass",
   "Iff.rfl",
   "MulPosReflectLT",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "Preorder",
   "MulPosStrictMono",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Eq.mpr",
   "one_mul",
   "Eq.ndrec",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Iff.trans",
   "mul_lt_mul_right",
   "id"],
  "name": "lt_mul_iff_one_lt_left",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α]\n  [inst_4 : MulPosReflectLT α], 0 < a → (a < b * a ↔ 1 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.negSucc n) a = (LinearOrderedSemifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Prod.snd", "Nat.xgcd", "Nat", "Int"],
  "name": "Nat.gcdB",
  "constType": "ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedCommRing α] → LinearOrderedRing α",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Iff", "List.instMembershipList", "List"],
  "name": "List.TFAE",
  "constType": "List Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "rfl",
   "Eq",
   "Iff.intro",
   "Iff",
   "Int.negSucc",
   "Eq.rec",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Int.natAbs_eq_zero.match_1",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Int",
   "absurd",
   "Int.natAbs"],
  "name": "Int.natAbs_eq_zero",
  "constType": "∀ {a : ℤ}, Int.natAbs a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "Semigroup",
   "Dvd",
   "Eq"],
  "name": "semigroupDvd",
  "constType": "{α : Type u_1} → [inst : Semigroup α] → Dvd α",
  "constCategory": "Definition"},
 {"references": ["Int.cast", "Ring.toIntCast", "Ring", "Int"],
  "name": "Int.rawCast",
  "constType": "{α : Type u_1} → [inst : Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionSemiring",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0", "Zero", "Ne", "OfNat.ofNat", "NeZero", "NeZero.out"],
  "name": "NeZero.ne",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], n ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "Nat",
   "Nat.decLe",
   "Nat.strictOrderedSemiring"],
  "name": "Nat.orderedSemiring",
  "constType": "OrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Subtype.val",
   "rel_iff_cov",
   "MulPosReflectLE",
   "MulPosMono.to_covariantClass_pos_mul_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Mul",
   "Subtype.mk",
   "MulPosMono",
   "Subtype"],
  "name": "mul_le_mul_right",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α]\n  [inst_4 : MulPosReflectLE α], 0 < a → (b * a ≤ c * a ↔ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.mk",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Exists.imp",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid",
   "inferInstance",
   "Nat.le.dest",
   "AddMonoid.toAddSemigroup",
   "Nat.orderedSemiring",
   "Nat",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_1",
  "constType": "∀ {x x_1 : ℕ}, x ≤ x_1 → ∃ a, x_1 = x + a",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_5",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalNonAssocCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_2",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLattice.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice.mk",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left"],
  "name": "instDistribLattice",
  "constType": "{α : Type u} → [inst : LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "LE.le",
   "PProd",
   "Nat.le_succ_of_le",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Int.coe_nat_dvd_left",
   "Int.Prime.dvd_pow",
   "Nat.instDvdNat",
   "Eq.refl",
   "Dvd.dvd",
   "Int.instHPowIntNat",
   "Eq",
   "Nat.Prime",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "propext",
   "Nat",
   "Int",
   "Int.instDvdInt",
   "Int.natAbs",
   "id"],
  "name": "Int.Prime.dvd_pow'",
  "constType": "∀ {n : ℤ} {k p : ℕ}, Nat.Prime p → ↑p ∣ n ^ k → ↑p ∣ n",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHDiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedField.toDiv",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "Nat.cast_le",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"}]