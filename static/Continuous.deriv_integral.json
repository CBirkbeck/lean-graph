[{"references":
  ["NontriviallyNormedField",
   "NontriviallyNormedField.mk",
   "DenselyNormedField",
   "DenselyNormedField.toNormedField",
   "DenselyNormedField.toNontriviallyNormedField.proof_1"],
  "name": "DenselyNormedField.toNontriviallyNormedField",
  "constType":
  "{α : Type u_1} → [inst : DenselyNormedField α] → NontriviallyNormedField α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Ord.compare",
   "Ordering",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedRing.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "Eq"],
  "name": "LinearOrderedRing.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1375",
   "SubNegMonoid.toSub",
   "MetricSpace",
   "Norm",
   "PseudoMetricSpace.toDist",
   "AddGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedAddGroup",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddGroup.mk",
  "constType":
  "{E : Type u_9} →\n  [toNorm : Norm E] →\n    [toAddGroup : AddGroup E] →\n      [toMetricSpace : MetricSpace E] → autoParam (∀ (x y : E), dist x y = ‖x - y‖) _auto✝ → NormedAddGroup E",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "∀ {α : Type u_1} (a : Set α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "Nontrivial"],
  "name": "StrictOrderedSemiring.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references": ["Norm", "NonUnitalNormedRing"],
  "name": "NonUnitalNormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NonUnitalNormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Ring.zsmul",
  "constType": "{R : Type u} → [self : Ring R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real.instLinearOrderedFieldReal",
   "Real.instLinearOrderedRingReal",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "CauSeq.IsComplete.mk",
   "Real",
   "CauSeq.IsComplete",
   "Real.instSupReal",
   "Real.instRingReal",
   "Abs.abs",
   "Real.cauSeq_converges",
   "Real.instNegReal"],
  "name":
  "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
  "constType": "CauSeq.IsComplete ℝ abs",
  "constCategory": "Definition"},
 {"references":
  ["SecondCountableTopologyEither",
   "SecondCountableTopology",
   "Or",
   "TopologicalSpace"],
  "name": "SecondCountableTopologyEither.mk",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  SecondCountableTopology α ∨ SecondCountableTopology β → SecondCountableTopologyEither α β",
  "constCategory": "Other"},
 {"references":
  ["MeasurableSpace.instLEMeasurableSpace",
   "OpensMeasurableSpace",
   "borel",
   "TopologicalSpace",
   "LE.le",
   "MeasurableSpace"],
  "name": "OpensMeasurableSpace.mk",
  "constType":
  "∀ {α : Type u_6} [inst : TopologicalSpace α] [h : MeasurableSpace α], borel α ≤ h → OpensMeasurableSpace α",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LinearOrderedRing.toMin",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Inf.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Semiring",
   "Submodule.instInfSetSubmodule.proof_2",
   "SemilatticeSup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_8",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)), 0 ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i",
  "constCategory": "Theorem"},
 {"references":
  ["DistribMulActionHom",
   "AddCommSemigroup.toAddCommMagma",
   "Module.toDistribMulAction",
   "Semiring",
   "AddHom.mk",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.mk",
   "LinearMap.id.proof_2",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "DistribMulActionHom.id",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "MulActionHom.toFun",
   "LinearMap.id.proof_1",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "Module",
   "LinearMap",
   "DistribMulActionHom.toMulActionHom",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid"],
  "name": "LinearMap.id",
  "constType":
  "{R : Type u_1} → {M : Type u_9} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → M →ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHomClass.toNonUnitalRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "Algebra.cast",
  "constType":
  "{R : Type u_1} → {A : Type u_2} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst : Algebra R A] → R → A",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "HMul.hMul",
   "HasDistribNeg",
   "Neg.neg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mk",
  "constType":
  "{α : Type u_1} →\n  [inst : Mul α] →\n    [toInvolutiveNeg : InvolutiveNeg α] →\n      (∀ (x y : α), -x * y = -(x * y)) → (∀ (x y : α), x * -y = -(x * y)) → HasDistribNeg α",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Continuous.tendsto.match_1",
   "Exists",
   "Filter.HasBasis.tendsto_iff",
   "Set.preimage",
   "nhds",
   "Set",
   "Exists.intro",
   "Set.Subset.rfl",
   "Iff.mpr",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "And",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "And.intro",
   "IsOpen.preimage",
   "IsOpen"],
  "name": "Continuous.tendsto",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ (x : α), Filter.Tendsto f (nhds x) (nhds (f x))",
  "constCategory": "Theorem"},
 {"references":
  ["MulAction.one_smul",
   "DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "inferInstance",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "Module",
   "MulAction",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_1",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (b : M), 1 • b = b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.inv_zero",
  "constType": "∀ {K : Type u} [self : DivisionRing K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "OfNat.ofNat",
   "NontriviallyNormedField.toNormedField",
   "Real.instLEReal",
   "Real.instMulReal",
   "AddCommGroup.toAddCommMonoid",
   "Asymptotics.IsLittleO",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "tendsto_const_nhds",
   "Iff.mp",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "NormedAddCommGroup.toNorm",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "Filter.Tendsto.prod_mk_nhds",
   "instHSub",
   "setOf",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "PseudoMetricSpace.toUniformSpace",
   "Filter.Eventually",
   "Prod.fst",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "HasStrictFDerivAt",
   "instHMul",
   "ContinuousLinearMap",
   "propext",
   "LT.lt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Norm.norm",
   "NormedSpace.toModule",
   "Asymptotics.isLittleO_iff",
   "NormedAddCommGroup.toAddCommGroup",
   "Filter.tendsto_id",
   "Real",
   "Eq.refl",
   "NormedSpace",
   "RingHom.id",
   "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAtFilter._eq_1",
   "NormedField.toField",
   "Zero.toOfNat0",
   "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAt._eq_1",
   "NormedAddGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "id",
   "NontriviallyNormedField",
   "Real.instLTReal",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "FunLike.coe",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Prod.mk",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNormedAddGroup",
   "Prod",
   "ContinuousMapClass.toFunLike"],
  "name": "HasStrictFDerivAt.hasFDerivAt",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E}, HasStrictFDerivAt f f' x → HasFDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass",
   "Neg",
   "Eq"],
  "name": "NegZeroClass.mk",
  "constType":
  "{G : Type u_2} → [toZero : Zero G] → [toNeg : Neg G] → -0 = 0 → NegZeroClass G",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.npow",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_succ",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (n : ℕ) (x : α),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = x * CanonicallyOrderedCommSemiring.npow n x",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "Exists.intro",
   "UniformSpace.toTopologicalSpace",
   "Exists.casesOn",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace.match_1",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] (motive : (∃ m, UniformSpace.toTopologicalSpace = inst) → Prop)\n  (x : ∃ m, UniformSpace.toTopologicalSpace = inst),\n  (∀ (m : MetricSpace X) (hm : UniformSpace.toTopologicalSpace = inst),\n      motive (_ : ∃ m, UniformSpace.toTopologicalSpace = inst)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{α : Type u} →\n  [toCompleteLattice : CompleteLattice α] →\n    (∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)) →\n      CompletelyDistribLattice α",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Neg.toHasAbs",
   "SemilatticeSup.toSup",
   "LinearOrder",
   "instDistribLattice",
   "LinearOrder.toMax",
   "Max.max",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "rfl",
   "Abs.abs",
   "Neg",
   "Eq"],
  "name": "abs_eq_max_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] {a : α}, |a| = max a (-a)",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "Preorder"],
  "name": "OrderClosedTopology",
  "constType":
  "(α : Type u_1) → [inst : TopologicalSpace α] → [inst : Preorder α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{K : Type u} → [self : DivisionRing K] → Ring K",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Module",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_5",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), ↑x ∩ ↑x_1 ⊆ ↑x_1",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1571"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribMulAction.toMulAction",
   "MulOneClass.toMul",
   "Module.toDistribMulAction",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "MulAction.mul_smul",
   "Monoid.toMulOneClass",
   "Eq",
   "inferInstance",
   "instHMul",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "Module",
   "MulAction",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_2",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x y : R) (b : M),\n  (x * y) • b = x • y • b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "setOf",
   "Preorder.toLT",
   "Set",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Set.Ioc",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Semiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mk",
  "constType":
  "{α : Type u_4} →\n  [toSemiring : Semiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → DivisionSemiring α",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyLinearOrderedSemifield",
   "Real.instLinearOrderedFieldReal",
   "Real",
   "Nonneg.canonicallyLinearOrderedSemifield",
   "NNReal"],
  "name": "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
  "constType": "CanonicallyLinearOrderedSemifield NNReal",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (r : α → β → Sort u) → Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "AddMonoidHom.id",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_4",
  "constType":
  "∀ (f : ℝ), (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f) = (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Eq.symm", "Eq"],
  "name": "eq_comm",
  "constType": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "SemilatticeSup.toSup",
   "sup_eq_maxDefault",
   "IsTotal",
   "Max.max",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "LinearOrderedRing.toStrictOrderedRing",
   "instNatCastInt",
   "LinearOrderedRing",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing",
   "Module.Finite",
   "AddCommGroup.toAddCommMonoid",
   "Module",
   "AddCommGroup"],
  "name": "FiniteDimensional",
  "constType":
  "(K : Type u_1) → (V : Type u_2) → [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst : Module K V] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Real.linearOrderedCommRing",
   "Real",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "Real.instLinearOrderedSemiringReal",
  "constType": "LinearOrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["SecondCountableTopologyEither",
   "SecondCountableTopology",
   "Or",
   "TopologicalSpace"],
  "name": "SecondCountableTopologyEither.out",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [self : SecondCountableTopologyEither α β], SecondCountableTopology α ∨ SecondCountableTopology β",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivAt",
  "constType":
  "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → (E →L[𝕜] F) → E → Prop",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "Div"],
  "name": "CommGroupWithZero.toDiv",
  "constType": "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} → [self : Ring R] → Neg R",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "SeminormedCommRing"],
  "name": "SeminormedCommRing.toSeminormedRing",
  "constType":
  "{α : Type u_5} → [self : SeminormedCommRing α] → SeminormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_1",
  "constType":
  "∀ (M : Type u_1) [inst : AddZeroClass M], (fun x => x) 0 = (fun x => x) 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingEquiv.map_add'",
   "RingEquiv.map_mul'",
   "Equiv.toFun",
   "Equiv.invFun",
   "RingEquivClass",
   "RingEquiv.instRingEquivClassRingEquiv.proof_2",
   "RingEquiv",
   "Add",
   "Mul",
   "MulEquivClass.mk",
   "RingEquivClass.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_3",
   "RingEquiv.toEquiv",
   "EquivLike.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_1"],
  "name": "RingEquiv.instRingEquivClassRingEquiv",
  "constType":
  "{R : Type u_4} →\n  {S : Type u_5} →\n    [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → RingEquivClass (R ≃+* S) R S",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.4539"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.lt",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Eq.rec",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "max_comm",
   "LE.le",
   "Preorder.toLE",
   "max_eq_left",
   "Eq"],
  "name": "max_eq_right",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → max a b = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["two_ne_zero",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "two_mul",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "Semifield.toCommGroupWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "Eq",
   "Semiring.toNatCast",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "CommGroupWithZero.toDiv",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "mul_div_cancel_left",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "instHDiv",
   "CommGroupWithZero.toGroupWithZero",
   "LinearOrderedSemifield",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "div_add_div_same",
   "NonUnitalNonAssocSemiring.toDistrib",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "ZeroLEOneClass.neZero.two",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "add_halves",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] (a : α), a / 2 + a / 2 = a",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "Subtype.val",
   "MeasureTheory.StronglyMeasurable.isSeparable_range",
   "Set",
   "BorelSpace.opensMeasurable",
   "Set.range",
   "Iff",
   "MeasureTheory.StronglyMeasurable",
   "Set.Elem",
   "TopologicalSpace.PseudoMetrizableSpace.subtype",
   "TopologicalSpace",
   "Measurable",
   "Set.rangeFactorization",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Set.mem_range_self",
   "Subtype",
   "Membership.mem",
   "BorelSpace",
   "continuous_subtype_val",
   "Subtype.instMeasurableSpace",
   "stronglyMeasurable_iff_measurable_separable.match_1",
   "Measurable.stronglyMeasurable",
   "Measurable.subtype_mk",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "TopologicalSpace.IsSeparable.secondCountableTopology",
   "SecondCountableTopology",
   "Subtype.opensMeasurableSpace",
   "instTopologicalSpaceSubtype",
   "And.intro",
   "MeasureTheory.StronglyMeasurable.measurable",
   "MeasurableSpace",
   "Subtype.mk",
   "Continuous.comp_stronglyMeasurable"],
  "name": "stronglyMeasurable_iff_measurable_separable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [inst : TopologicalSpace β]\n  [inst_1 : TopologicalSpace.PseudoMetrizableSpace β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β],\n  MeasureTheory.StronglyMeasurable f ↔ Measurable f ∧ TopologicalSpace.IsSeparable (Set.range f)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalNonAssocSemiring",
   "TopologicalSemiring",
   "TopologicalSpace",
   "ContinuousAdd",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "TopologicalSemiring.toContinuousAdd",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonUnitalNonAssocSemiring α] [self : TopologicalSemiring α],\n  ContinuousAdd α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "True",
   "Preorder.toLE",
   "max_def",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_left",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.MetrizableSpace.exists_metric",
   "MetricSpace",
   "Exists",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace.match_1",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "Exists.intro",
   "TopologicalSpace.PseudoMetrizableSpace.mk",
   "TopologicalSpace.PseudoMetrizableSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
  "constType":
  "∀ {X : Type u_2} [inst : TopologicalSpace X] [h : TopologicalSpace.MetrizableSpace X],\n  TopologicalSpace.PseudoMetrizableSpace X",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Set", "MeasurableSet", "LE", "MeasurableSpace"],
  "name": "MeasurableSpace.instLEMeasurableSpace",
  "constType": "{α : Type u_1} → LE (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Filter.mem_iInf_of_mem",
   "HAdd.hAdd",
   "Set",
   "Filter.mem_of_superset",
   "compRel",
   "AddCommMonoid.toAddMonoid",
   "Filter.mem_lift'",
   "Iff.mpr",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Filter.mem_principal_self",
   "setOf",
   "Prod.snd",
   "instHAdd",
   "Prod.fst",
   "AddCommMagma.toAdd",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le.trans_lt",
   "UniformSpace.ofFun.match_2",
   "Set.instMembershipSet",
   "GT.gt",
   "le_iInf₂",
   "And",
   "Filter.le_principal_iff",
   "iInf",
   "CompleteLattice.toInfSet",
   "Prod.mk",
   "LT.lt",
   "Filter.instPartialOrderFilter",
   "UniformSpace.ofFun.match_1",
   "Filter.lift'",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "UniformSpace.ofFun.match_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedAddCommMonoid β] (d : α → α → β),\n  (∀ (x y z : α), d x z ≤ d x y + d y z) →\n    (∀ ε > 0, ∃ δ > 0, ∀ x < δ, ∀ y < δ, x + y < ε) →\n      (Filter.lift' (⨅ r, ⨅ (_ : r > 0), Filter.principal {x | d x.1 x.2 < r}) fun s => compRel s s) ≤\n        ⨅ i, ⨅ (_ : i > 0), Filter.principal {x | d x.1 x.2 < i}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M →+ N),\n  (fun f => f.toFun) f = (fun f => f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "CommRing.toNonUnitalCommRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "instNontrivial",
   "Real.instRingReal",
   "Nontrivial"],
  "name": "Real.nontrivial",
  "constType": "Nontrivial ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.mk",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : MonoidWithZero R] →\n      [inst_1 : Zero M] →\n        [toMulAction : MulAction R M] → (∀ (r : R), r • 0 = 0) → (∀ (m : M), 0 • m = 0) → MulActionWithZero R M",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "Max.max",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid.toMax",
   "LinearOrderedCancelAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.max_def",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.equiv",
   "Setoid.r",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "Real.casesOn",
   "CauSeq.Completion.Cauchy",
   "Quot.induction_on",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ind_mk",
  "constType":
  "∀ {C : ℝ → Prop} (x : ℝ), (∀ (y : CauSeq ℚ abs), C (Real.mk y)) → C x",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["UniformSpace", "TopologicalSpace"],
  "name": "UniformSpace.toTopologicalSpace",
  "constType": "{α : Type u} → [self : UniformSpace α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "instHAdd",
   "Real",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Set",
   "LE.le",
   "Bornology.ofDist.proof_1",
   "Eq",
   "Set.instMembershipSet",
   "Bornology.ofDist.proof_2",
   "Bornology.ofDist.proof_4",
   "Bornology.ofBounded",
   "Bornology.ofDist.proof_3",
   "Bornology"],
  "name": "Bornology.ofDist",
  "constType":
  "{α : Type u_3} →\n  (dist : α → α → ℝ) →\n    (∀ (x y : α), dist x y = dist y x) → (∀ (x y z : α), dist x z ≤ dist x y + dist y z) → Bornology α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "wrapped._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
   "NormedAddCommGroup",
   "BorelSpace",
   "Basis",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "MeasureTheory.Measure",
   "Fintype",
   "Real.semiring",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace.toModule",
   "MeasurableSpace"],
  "name": "Basis.addHaar",
  "constType":
  "{ι : Type u_5} →\n  {E : Type u_6} →\n    [inst : Fintype ι] →\n      [inst : NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [inst_2 : MeasurableSpace E] → [inst_3 : BorelSpace E] → Basis ι ℝ E → MeasureTheory.Measure E",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MetricSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["BorelSpace", "borel", "TopologicalSpace", "MeasurableSpace", "Eq"],
  "name": "BorelSpace.measurable_eq",
  "constType":
  "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α], inst_1 = borel α",
  "constCategory": "Definition"},
 {"references":
  ["OpensMeasurableSpace",
   "BorelSpace",
   "borel",
   "PartialOrder.toPreorder",
   "TopologicalSpace",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "ge_of_eq",
   "OpensMeasurableSpace.mk",
   "MeasurableSpace",
   "BorelSpace.measurable_eq"],
  "name": "BorelSpace.opensMeasurable",
  "constType":
  "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  OpensMeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedAddCommGroup.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommGroup α",
  "constCategory": "Other"},
 {"references":
  ["RingHom.id.proof_1",
   "RingHom",
   "RingHom.id.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "OneHom.mk",
   "MonoidHom.mk",
   "RingHom.id.proof_4",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.id.proof_2",
   "NonAssocSemiring",
   "id"],
  "name": "RingHom.id",
  "constType": "(α : Type u_5) → [inst : NonAssocSemiring α] → α →+* α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield",
   "Semifield.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Semiring.mk",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "zero_le",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "Field",
   "CommRing.toRing",
   "One.toOfNat1",
   "Field.zpow",
   "Ring.toSemiring",
   "Int",
   "Eq"],
  "name": "Field.zpow_zero'",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "Sub",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Neg",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddGroupWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toIntCast : IntCast R] →\n    [toAddMonoidWithOne : AddMonoidWithOne R] →\n      [toNeg : Neg R] →\n        [toSub : Sub R] →\n          autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n            (zsmul : ℤ → R → R) →\n              autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                  autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                    (∀ (a : R), -a + a = 0) →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → AddGroupWithOne R",
  "constCategory": "Other"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne.toSub",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.sub_eq_add_neg",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "TopologicalSpace",
   "ContinuousWithinAt",
   "Set.instMembershipSet"],
  "name": "ContinuousOn",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PosMulMono",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toPosMulMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], PosMulMono α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b : G), a + b = b + a) → AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "RingHom",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "Zero.mk",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "ContinuousLinearMap.zero.proof_1",
   "LinearMap.instZeroLinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.zero",
  "constType":
  "{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {M₁ : Type u_4} →\n            [inst_2 : TopologicalSpace M₁] →\n              [inst_3 : AddCommMonoid M₁] →\n                {M₂ : Type u_6} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R₁ M₁] → [inst_7 : Module R₂ M₂] → Zero (M₁ →SL[σ₁₂] M₂)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["Field", "Div"],
  "name": "Field.toDiv",
  "constType": "{K : Type u} → [self : Field K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "CommRing.toNonUnitalCommRing",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "hasFDerivAt_iff_hasDerivAt",
   "Iff.mp",
   "HasFDerivAt",
   "NormedField.toNormedSpace",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "One.toOfNat1",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousMapClass.toFunLike"],
  "name": "HasFDerivAt.hasDerivAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : 𝕜 →L[𝕜] F}, HasFDerivAt f f' x → HasDerivAt f (f' 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "eq_comm",
   "LE.le.le_iff_eq",
   "le_top",
   "OrderTop",
   "Iff.trans",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "top_le_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a ↔ a = ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "NormedAddCommGroup",
   "NontriviallyNormedField",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "PseudoMetricSpace.toUniformSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "SeminormedRing.toPseudoMetricSpace",
   "HasDerivAtFilter",
   "NormedField.toNormedCommRing",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace"],
  "name": "HasDerivAt",
  "constType":
  "{𝕜 : Type u} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {F : Type v} → [inst_1 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (𝕜 → F) → F → 𝕜 → Prop",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat"],
  "name": "EuclideanSpace.proof_1",
  "constType": "Nat.AtLeastTwo (0 + 2)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)) (t : Set α), (∀ b ∈ s, b ≤ t) → ∀ a ∈ sSup s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "SetLike.instMembership",
   "SMulZeroClass.toSMul",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "AddMonoid.toZero",
   "Submodule.smul_mem'",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.smul_mem",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M} (p : Submodule R M)\n  {x : M} (r : R), x ∈ p → r • x ∈ p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.OuterMeasure.coe_fn_injective",
   "MeasureTheory.OuterMeasure.instAdd",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Set",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_4",
   "AddMonoid.toNatSMul",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Pi.addCommMonoid",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.OuterMeasure.instSMul",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_3",
   "Function.Injective.addCommMonoid",
   "MeasureTheory.OuterMeasure.instZero",
   "Nat",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_1",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.addCommMonoid.proof_2",
   "AddCommMonoid"],
  "name": "MeasureTheory.OuterMeasure.addCommMonoid",
  "constType": "{α : Type u_1} → AddCommMonoid (MeasureTheory.OuterMeasure α)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1771",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Dist.dist",
   "Norm",
   "MetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "AddCommGroup"],
  "name": "NormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} →\n  [toNorm : Norm E] →\n    [toAddCommGroup : AddCommGroup E] →\n      [toMetricSpace : MetricSpace E] → autoParam (∀ (x y : E), dist x y = ‖x - y‖) _auto✝ → NormedAddCommGroup E",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "Zero.mk",
   "instZeroAddMonoidHom.proof_1",
   "instZeroAddMonoidHom.proof_2",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom"],
  "name": "instZeroAddMonoidHom",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → Zero (M →+ N)",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "Real.strictOrderedCommSemiring",
   "Real",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring"],
  "name": "Real.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Inter.inter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mk",
  "constType":
  "{α : Type u_1} →\n  (sets : Set (Set α)) →\n    Set.univ ∈ sets →\n      (∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets) → (∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) → Filter α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderHom",
   "Nat",
   "Preorder",
   "Nat.strictOrderedSemiring"],
  "name": "OmegaCompletePartialOrder.Chain",
  "constType": "(α : Type u) → [inst : Preorder α] → Type u",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "LinearOrderedSemiring.toMin",
   "Eq"],
  "name": "LinearOrderedSemiring.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "left_distrib",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Real", "Real.toNNReal", "ENNReal.ofNNReal"],
  "name": "ENNReal.ofReal",
  "constType": "ℝ → ENNReal",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toMin",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.min_def",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.6260", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.sup",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Set",
   "Real",
   "Real.measurableSpace",
   "StieltjesFunction.measure",
   "Real.volume_eq_stieltjes_id",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real.measureSpace",
   "StieltjesFunction.id",
   "MeasureTheory.OuterMeasure",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.volume_val",
  "constType":
  "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = ↑↑(StieltjesFunction.measure StieltjesFunction.id) s",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike", "Function.Injective", "FunLike.coe", "FunLike.coe_injective'"],
  "name": "FunLike.coe_injective",
  "constType":
  "∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : FunLike F α β], Function.Injective fun f => ⇑f",
  "constCategory": "Theorem"},
 {"references": ["Field", "Inv"],
  "name": "Field.toInv",
  "constType": "{K : Type u} → [self : Field K] → Inv K",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "eq_max",
   "le_refl",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "max_eq_left",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b ≤ a → max a b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommSemiring : LinearOrderedCommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → LinearOrderedSemifield α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "Module",
   "AddCommMonoid"],
  "name": "SemilinearMapClass",
  "constType":
  "Type u_17 →\n  {R : outParam (Type u_18)} →\n    {S : outParam (Type u_19)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          outParam (R →+* S) →\n            (M : outParam (Type u_20)) →\n              (M₂ : outParam (Type u_21)) →\n                [inst_2 : AddCommMonoid M] →\n                  [inst_3 : AddCommMonoid M₂] →\n                    [inst : Module R M] → [inst : Module S M₂] → Type (max (max u_17 u_20) u_21)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedCommRing.toSeminormedRing",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "NormedField.toNormedSpace",
   "HasFDerivAt",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "Module.toMulActionWithZero",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "HasDerivAt",
   "SMulZeroClass.toSMul",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "NormedSpace.toModule",
   "BoundedSMul.continuousSMul",
   "NegZeroClass.toZero",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.hasFDerivAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : F},\n  HasDerivAt f f' x → HasFDerivAt f (ContinuousLinearMap.smulRight 1 f') x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "compl_compl",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Set.compl_univ",
   "BooleanAlgebra.toHasCompl",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Set.compl_inter",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Filter.mk",
   "Filter",
   "Eq.symm",
   "Set.compl_subset_compl",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "setOf",
   "Union.union",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.univ",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Filter.le_cofinite_iff_compl_singleton_mem",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "propext",
   "Filter.cofinite",
   "Filter.instPartialOrderFilter",
   "Eq.mp",
   "Singleton.singleton",
   "congrArg",
   "Set.instUnionSet",
   "congrFun",
   "Set.instInterSet"],
  "name": "Bornology.ofBounded.proof_4",
  "constType":
  "∀ {α : Type u_1} (B : Set (Set α)) (empty_mem : ∅ ∈ B) (subset_mem : ∀ s₁ ∈ B, ∀ s₂ ⊆ s₁, s₂ ∈ B)\n  (union_mem : ∀ s₁ ∈ B, ∀ s₂ ∈ B, s₁ ∪ s₂ ∈ B),\n  (∀ (x : α), {x} ∈ B) →\n    { sets := {s | sᶜ ∈ B}, univ_sets := (_ : Set.univᶜ ∈ B),\n        sets_of_superset := (_ : ∀ {x y : Set α}, x ∈ {s | sᶜ ∈ B} → x ⊆ y → yᶜ ∈ B),\n        inter_sets := (_ : ∀ {x y : Set α}, x ∈ {s | sᶜ ∈ B} → y ∈ {s | sᶜ ∈ B} → x ∩ y ∈ {s | sᶜ ∈ B}) } ≤\n      Filter.cofinite",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : OrderedCancelAddCommMonoid α] → AddCancelCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Exists",
   "Filter.EventuallyEq",
   "MeasureTheory.StronglyMeasurable",
   "TopologicalSpace",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace"],
  "name": "MeasureTheory.AEStronglyMeasurable",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : TopologicalSpace β] → {x : MeasurableSpace α} → (α → β) → MeasureTheory.Measure α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "MeasureTheory.Integrable",
   "Set",
   "MeasureTheory.Measure.restrict",
   "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.689",
   "autoParam",
   "MeasurableSpace"],
  "name": "MeasureTheory.IntegrableOn",
  "constType":
  "{α : Type u_1} →\n  {E : Type u_3} →\n    [inst : MeasurableSpace α] →\n      [inst_1 : NormedAddCommGroup E] → (α → E) → Set α → autoParam (MeasureTheory.Measure α) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommGroupWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Add",
   "AddSubsemigroup",
   "Set.instMembershipSet"],
  "name": "AddSubsemigroup.mk",
  "constType":
  "{M : Type u_4} →\n  [inst : Add M] → (carrier : Set M) → (∀ {a b : M}, a ∈ carrier → b ∈ carrier → a + b ∈ carrier) → AddSubsemigroup M",
  "constCategory": "Other"},
 {"references": ["CanonicallyOrderedCommSemiring", "Mul"],
  "name": "CanonicallyOrderedCommSemiring.toMul",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.toLinearMap",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_3} →\n            [inst_2 : TopologicalSpace M] →\n              [inst_3 : AddCommMonoid M] →\n                {M₂ : Type u_4} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R M] → [inst_7 : Module S M₂] → (M →SL[σ] M₂) → M →ₛₗ[σ] M₂",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toNormedDivisionRing.proof_7",
   "DivisionRing.mk",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "NormedField.toNormedDivisionRing.proof_5",
   "NormedField.norm_mul'",
   "Field.toInv",
   "Field.zpow",
   "NormedField.toNormedDivisionRing.proof_8",
   "NormedField.toNorm",
   "NormedField.toNormedDivisionRing.proof_2",
   "Field.toRatCast",
   "NormedField.toNormedDivisionRing.proof_9",
   "Field.toCommRing",
   "NormedField.toField",
   "NormedField.toNormedDivisionRing.proof_1",
   "NormedField.toNormedDivisionRing.proof_6",
   "NormedField.toNormedDivisionRing.proof_3",
   "CommRing.toRing",
   "Field.toDiv",
   "NormedDivisionRing",
   "Field.qsmul",
   "NormedField.toNormedDivisionRing.proof_4",
   "NormedDivisionRing.mk"],
  "name": "NormedField.toNormedDivisionRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedDivisionRing α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CommMonoidWithZero.toZero",
   "instHDiv",
   "OfNat.ofNat",
   "Ne.isUnit",
   "CommGroupWithZero.toGroupWithZero",
   "CommGroupWithZero",
   "IsUnit.mul_div_cancel'",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "CommGroupWithZero.toDiv",
   "HMul.hMul",
   "HDiv.hDiv",
   "CommGroupWithZero.toDivisionCommMonoid"],
  "name": "mul_div_cancel'",
  "constType":
  "∀ {G₀ : Type u_3} [inst : CommGroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → b * (a / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3986",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4028",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["ENNReal",
   "Semiring",
   "WithLp",
   "AddCommGroup.toAddCommMonoid",
   "WithLp.instAddCommGroup",
   "Module",
   "AddCommGroup"],
  "name": "WithLp.instModule",
  "constType":
  "(p : ENNReal) →\n  (K : Type uK) →\n    (V : Type uV) → [inst : Semiring K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → Module K (WithLp p V)",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "Eq.symm", "rfl", "Eq"],
  "name": "forall_eq",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.symm",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "one_add_one_eq_two",
  "constType": "∀ {α : Type u_1} [inst : AddMonoidWithOne α], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{α : Type u_1} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "instHSub",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "Ring.toNeg",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Module.add_smul",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "add_smul",
  "constType":
  "∀ {R : Type u_2} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (r s : R) (x : M),\n  (r + s) • x = r • x + s • x",
  "constCategory": "Theorem"},
 {"references": ["Top", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toTop : Top α] → (∀ (a : α), a ≤ ⊤) → OrderTop α",
  "constCategory": "Other"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "Eq.refl",
   "One.toOfNat1",
   "OneHom.mk",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "id"],
  "name": "RingHom.id.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : NonAssocSemiring α] (x y : α),\n  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n    OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["continuous_id",
   "instHMul",
   "ContinuousMul",
   "Continuous.mul",
   "Continuous",
   "continuous_const",
   "HMul.hMul",
   "TopologicalSpace",
   "Mul"],
  "name": "continuous_mul_left",
  "constType":
  "∀ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Mul M] [inst_2 : ContinuousMul M] (a : M),\n  Continuous fun b => a * b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHom.toMonoidHom",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →* β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddLeftCancelMonoid.mk",
   "Eq.symm",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_1",
   "AddCommMonoid.mk",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_2",
   "SubNegMonoid.toAddMonoid",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "AddCommGroup.toAddGroup",
   "OrderedAddCommGroup.add_le_add_left",
   "AddGroup.toSubNegMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [inst : OrderedAddCommGroup α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "And",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "DenselyNormedField",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "NormedField",
   "Norm.norm",
   "LE.le",
   "NormedField.toNorm"],
  "name": "DenselyNormedField.mk",
  "constType":
  "{α : Type u_5} →\n  [toNormedField : NormedField α] → (∀ (x y : ℝ), 0 ≤ x → x < y → ∃ a, x < ‖a‖ ∧ ‖a‖ < y) → DenselyNormedField α",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "PartialOrder"],
  "name": "OrderedAddCommGroup.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHSMul",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddCommMagma.toAdd",
   "DistribMulAction",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "Module.mk",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [toDistribMulAction : DistribMulAction R M] →\n          (∀ (r s : R) (x : M), (r + s) • x = r • x + s • x) → (∀ (x : M), 0 • x = 0) → Module R M",
  "constCategory": "Other"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{α : Type u_1} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.toInv",
   "Field.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.div_eq_mul_inv",
  "constType": "∀ {K : Type u} [self : Field K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_zero'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a : G), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.principal",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "Filter.NeBot",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "IsCompact",
  "constType": "{X : Type u} → [inst : TopologicalSpace X] → Set X → Prop",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing",
   "Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "NormedRing.toRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (n : ℕ) (a : α), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedRing.toNorm",
   "NormedCommRing.toSeminormedCommRing.proof_2",
   "NormedCommRing",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "SeminormedCommRing",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toSeminormedCommRing.proof_1",
   "SeminormedRing.mk",
   "NormedRing.toRing",
   "SeminormedCommRing.mk"],
  "name": "NormedCommRing.toSeminormedCommRing",
  "constType": "{α : Type u_1} → [β : NormedCommRing α] → SeminormedCommRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.instHasSubsetSet",
   "setOf",
   "Bornology.ofDist.match_1",
   "Real.instLEReal",
   "Set",
   "Real",
   "HasSubset.Subset",
   "Exists.intro",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_2",
  "constType":
  "∀ {α : Type u_1} (dist : α → α → ℝ),\n  ∀ s ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C},\n    ∀ t ⊆ s, t ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C}",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Set.Icc",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup"],
  "name": "Set.uIcc",
  "constType": "{α : Type u_1} → [inst : Lattice α] → α → α → Set α",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Real", "LT", "LT.mk", "_private.Mathlib.Data.Real.Basic.0.Real.lt"],
  "name": "Real.instLTReal",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Real.linearOrderedCommRing",
   "Real"],
  "name": "Real.instLinearOrderedRingReal",
  "constType": "LinearOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure", "TopologicalSpace", "MeasurableSpace"],
  "name": "MeasureTheory.IsLocallyFiniteMeasure",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → [inst : TopologicalSpace α] → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "CompleteSpace",
   "OfNat.ofNat",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "Classical.propDecidable",
   "MeasureTheory.Integrable",
   "PseudoMetricSpace.toUniformSpace",
   "dite",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NormedSpace",
   "MeasureTheory.Integrable.toL1",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "MeasureTheory.L1.integral",
   "Not",
   "NegZeroClass.toZero",
   "MeasurableSpace",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name":
  "MeasureTheory.definition._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
  "constType":
  "{α : Type u_1} →\n  {G : Type u_5} →\n    [inst : NormedAddCommGroup G] →\n      [inst : NormedSpace ℝ G] → {x : MeasurableSpace α} → MeasureTheory.Measure α → (α → G) → G",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["wrapped._@.Mathlib.LinearAlgebra.Dimension._hyg.100",
   "Semiring",
   "Cardinal",
   "Module",
   "AddCommMonoid"],
  "name": "Module.rank",
  "constType":
  "(K : Type u_2) →\n  (V : Type u_3) → [inst : Semiring K] → [inst_1 : AddCommMonoid V] → [inst : Module K V] → Cardinal.{u_3}",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "TopologicalSpace.PseudoMetrizableSpace",
  "constType": "(X : Type u_5) → [t : TopologicalSpace X] → Prop",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "Continuous.add",
   "instHAdd",
   "HAdd.hAdd",
   "Continuous",
   "continuous_const",
   "TopologicalSpace",
   "ContinuousAdd",
   "Add",
   "id"],
  "name": "continuous_add_right",
  "constType":
  "∀ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M] (a : M),\n  Continuous fun b => b + a",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "Real",
   "GE.ge",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "Preorder.toLE",
   "Nonempty",
   "Filter.HasBasis.cauchySeq_iff'",
   "GT.gt",
   "Dist.dist",
   "SemilatticeSup",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "Iff",
   "LT.lt",
   "Prod",
   "Metric.uniformity_basis_dist",
   "SemilatticeSup.toPartialOrder",
   "PseudoMetricSpace"],
  "name": "Metric.cauchySeq_iff'",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, dist (u n) (u N) < ε",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "Function.leftLim",
   "StieltjesFunction.measure_Ioo",
   "Set.Ioo",
   "Real.measurableSpace",
   "Real",
   "Real.instSubReal",
   "PseudoMetricSpace.toUniformSpace",
   "ENNReal.ofReal",
   "HSub.hSub",
   "StieltjesFunction.measure",
   "Real.pseudoMetricSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Real.volume_val",
   "True",
   "Eq",
   "Real.linearOrder",
   "ENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "StieltjesFunction.toFun",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "StieltjesFunction.id_leftLim",
   "Real.instPreorderReal",
   "Real.measureSpace",
   "StieltjesFunction.id",
   "UniformSpace.toTopologicalSpace",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.volume_Ioo",
  "constType":
  "∀ {a b : ℝ}, ↑↑MeasureTheory.volume (Set.Ioo a b) = ENNReal.ofReal (b - a)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedSemifield.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "Nontrivial"],
  "name": "StrictOrderedRing.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.instAdd",
   "MeasureTheory.Measure.toOuterMeasure",
   "instHAdd",
   "HAdd.hAdd",
   "MeasureTheory.Measure.instAdd",
   "MeasureTheory.OuterMeasure",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.Measure.add_toOuterMeasure",
  "constType":
  "∀ {α : Type u_1} {_m : MeasurableSpace α} (μ₁ μ₂ : MeasureTheory.Measure α), ↑(μ₁ + μ₂) = ↑μ₁ + ↑μ₂",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "BorelSpace",
   "Basis",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "Eq",
   "MeasureTheory.Measure",
   "Fintype",
   "Real.semiring",
   "definition._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "NormedSpace.toModule",
   "MeasurableSpace",
   "Subtype"],
  "name": "wrapped._@.Mathlib.MeasureTheory.Measure.Haar.OfBasis._hyg.2506",
  "constType": "Subtype (Eq @definition✝)",
  "constCategory": "Other"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.Regular",
   "MeasureTheory.Measure",
   "TopologicalSpace",
   "MeasureTheory.IsFiniteMeasureOnCompacts",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.Regular.toIsFiniteMeasureOnCompacts",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [self : MeasureTheory.Measure.Regular μ], MeasureTheory.IsFiniteMeasureOnCompacts μ",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet"],
  "name": "Set.subset_univ",
  "constType": "∀ {α : Type u} (s : Set α), s ⊆ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["Nat.gcd.proof_1",
   "measure",
   "WellFoundedRelation.rel",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
   "Nat",
   "WellFounded.fix",
   "id"],
  "name": "Nat.gcd",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Norm", "Real"],
  "name": "Norm.norm",
  "constType": "{E : Type u_9} → [self : Norm E] → E → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring.proof_1",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "ContinuousLinearMap.toLinearMap",
   "AddHom.toFun",
   "Semiring",
   "continuous_const",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Continuous.smul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Continuous",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "ContinuousSMul",
   "Module",
   "MonoidWithZero.toZero",
   "ContinuousLinearMap.cont",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.smulRight.proof_2",
  "constType":
  "∀ {M₁ : Type u_2} [inst : TopologicalSpace M₁] [inst_1 : AddCommMonoid M₁] {M₂ : Type u_1}\n  [inst_2 : TopologicalSpace M₂] [inst_3 : AddCommMonoid M₂] {R : Type u_4} {S : Type u_3} [inst_4 : Semiring R]\n  [inst_5 : Semiring S] [inst_6 : Module R M₁] [inst_7 : Module R S] [inst_8 : Module S M₂]\n  [inst_9 : TopologicalSpace S] [inst_10 : ContinuousSMul S M₂] (c : M₁ →L[R] S) (f : M₂),\n  Continuous fun x => AddHom.toFun c.toAddHom x • f",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "∀ {α : Type u_1} (x y z : Set α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "Continuous",
   "ContinuousMapClass",
   "TopologicalSpace",
   "FunLike.coe"],
  "name": "ContinuousMapClass.mk",
  "constType":
  "{F : Type u_1} →\n  {α : outParam (Type u_2)} →\n    {β : outParam (Type u_3)} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] →\n          [toFunLike : FunLike F α fun x => β] → (∀ (f : F), Continuous ⇑f) → ContinuousMapClass F α β",
  "constCategory": "Other"},
 {"references": ["nhds", "TopologicalSpace", "Filter.Tendsto"],
  "name": "ContinuousAt",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MulActionWithZero.toMulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.smul_zero",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (r : R),\n  r • 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "CommRing",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "Nat.cast",
   "Field",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "CommRing.toRing",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.natAbs",
   "Inv.inv"],
  "name": "Field.mk",
  "constType":
  "{K : Type u} →\n  [toCommRing : CommRing K] →\n    [toInv : Inv K] →\n      [toDiv : Div K] →\n        autoParam (∀ (a b : K), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → K → K) →\n            autoParam (∀ (a : K), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : K), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial K] →\n                    [toRatCast : RatCast K] →\n                      (∀ (a : K), a ≠ 0 → a * a⁻¹ = 1) →\n                        0⁻¹ = 0 →\n                          autoParam\n                              (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                              _auto✝⁴ →\n                            (qsmul : ℚ → K → K) → autoParam (∀ (a : ℚ) (x : K), qsmul a x = ↑a * x) _auto✝⁵ → Field K",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Inf.inf",
   "Set",
   "Filter.generate",
   "Inter.inter",
   "Preorder.le_trans",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.inter_mem",
   "Preorder.toLT",
   "Eq.rec",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.match_1",
   "Filter.sets",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "OrderDual.completeLattice",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "PartialOrder.le_antisymm",
   "Filter.giGenerate",
   "Preorder.lt_iff_le_not_le",
   "Set.instInterSet"],
  "name": "Filter.instCompleteLatticeFilter.proof_8",
  "constType":
  "∀ {α : Type u_1} (x x_1 x_2 : Filter α), x ≤ x_1 → x ≤ x_2 → ∀ _s ∈ x_1 ⊓ x_2, _s ∈ x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "True",
   "Eq",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "neg_add",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b : α), -(a + b) = -a + -b",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N], (fun x => 0) 0 = (fun x => 0) 0",
  "constCategory": "Theorem"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{α : Type u} → [self : Div α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulHomClass",
   "HMul.hMul",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulHomClass.map_mul",
   "Mul",
   "Eq"],
  "name": "map_mul",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Mul M] [inst_1 : Mul N] [inst_2 : MulHomClass F M N] (f : F)\n  (x y : M), f (x * y) = f x * f y",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "abs_of_nonneg",
   "True",
   "Abs.abs",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Iff",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "LinearOrderedAddCommGroup",
   "Neg.toHasAbs",
   "Or",
   "instDistribLattice",
   "eq_or_eq_neg_of_abs_eq",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Or.casesOn",
   "LE.le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "of_eq_true",
   "abs_neg",
   "congrArg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrFun",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_eq",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, 0 ≤ b → (|a| = b ↔ a = b ∨ a = -b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Set", "Set.instSupSetSet", "iSup"],
  "name": "Set.iUnion",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Semiring",
   "ContinuousLinearMap.ext_ring_iff",
   "One.toOfNat1",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "RingHom.id",
   "Eq",
   "Semiring.toOne",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "Semiring.toModule",
   "AddCommMonoid",
   "ContinuousMapClass.toFunLike",
   "ContinuousSemilinearMapClass.toContinuousMapClass"],
  "name": "Mathlib.Topology.Algebra.Module.Basic._auxLemma.20",
  "constType":
  "∀ {R₁ : Type u_1} [inst : Semiring R₁] {M₁ : Type u_4} [inst_1 : TopologicalSpace M₁] [inst_2 : AddCommMonoid M₁]\n  [inst_3 : Module R₁ M₁] [inst_4 : TopologicalSpace R₁] {f g : R₁ →L[R₁] M₁}, (f = g) = (f 1 = g 1)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_trans",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : MeasurableSpace α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{α : Type u_1} → [inst : SupSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references": ["Eq.ge", "GE.ge", "Preorder", "Preorder.toLE", "Eq"],
  "name": "ge_of_eq",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≥ b",
  "constCategory": "Theorem"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_9} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "instTransEq",
   "add_lt_add_left",
   "add_zero",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "lt_add_of_pos_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["starMulOfComm",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "starRingOfComm.proof_2",
   "starRingOfComm.proof_1",
   "StarMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "StarRing.mk",
   "StarMul.toInvolutiveStar",
   "StarMul.mk"],
  "name": "starRingOfComm",
  "constType": "{R : Type u_1} → [inst : CommSemiring R] → StarRing R",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg.neg", "Neg", "Eq"],
  "name": "InvolutiveNeg.mk",
  "constType":
  "{A : Type u_2} → [toNeg : Neg A] → (∀ (x : A), - -x = x) → InvolutiveNeg A",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "zero_add",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass N], M → M → 0 = 0 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "ContinuousSMul",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Module.toMulActionWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "BoundedSMul.continuousSMul"],
  "name": "HasStrictDerivAt.proof_2",
  "constType":
  "∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F], ContinuousSMul 𝕜 F",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.toMeasurableSpace",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LinearOrderedCancelAddCommMonoid.decidableEq",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "compareOfLessAndEq",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLT",
   "Eq"],
  "name": "LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Continuous", "ContinuousAt", "TopologicalSpace", "Continuous.tendsto"],
  "name": "Continuous.continuousAt",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {x : α},\n  Continuous f → ContinuousAt f x",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.zsmul (Int.negSucc n) a = -AddGroupWithOne.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ConditionallyCompleteLattice",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Norm.norm",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule"],
  "name": "NormedSpace.norm_smul_le",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NormedField α] [inst_1 : SeminormedAddCommGroup β] [self : NormedSpace α β]\n  (a : α) (b : β), ‖a • b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.cofinite",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Bornology",
   "Preorder.toLE"],
  "name": "Bornology.mk",
  "constType":
  "{α : Type u_4} → (cobounded' : Filter α) → cobounded' ≤ Filter.cofinite → Bornology α",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddZeroClass.toZero",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "congrFun"],
  "name": "Real.isROrC.proof_12",
  "constType": "ℝ → 0 * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "TopologicalSpace",
   "Filter.Tendsto",
   "MeasureTheory.SimpleFunc",
   "Nat",
   "Filter.atTop",
   "MeasurableSpace",
   "MeasureTheory.SimpleFunc.toFun",
   "Nat.strictOrderedSemiring"],
  "name": "MeasureTheory.StronglyMeasurable",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace β] → [inst : MeasurableSpace α] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{α : Type u} → [self : Lattice α] → Inf α",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.neg", "Real", "Neg", "Neg.mk"],
  "name": "Real.instNegReal",
  "constType": "Neg ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Classical.choose_spec",
   "Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "Classical.choose",
   "PartialOrder.toPreorder",
   "not_lt",
   "le_iInf",
   "not_le_of_lt",
   "GE.ge",
   "dite",
   "CompleteLinearOrder",
   "iSup",
   "le_iSup",
   "Mathlib.Init.Order.Defs._auxLemma.2",
   "Exists.casesOn",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.5",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Iff.mp",
   "forall_congr",
   "Preorder.toLT",
   "lt_irrefl",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.3",
   "le_trans",
   "lt_of_not_le",
   "le_of_lt",
   "iInf_le",
   "And.casesOn",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.2",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "id",
   "lt_iSup_iff",
   "Or",
   "le_of_not_lt",
   "False",
   "CompleteLinearOrder.toLinearOrder",
   "lt_of_lt_of_le",
   "Classical.propDecidable",
   "LE.le",
   "Or.resolve_left",
   "And",
   "iInf",
   "CompleteLinearOrder.toCompletelyDistribLattice.match_1",
   "CompleteLattice.toInfSet",
   "LT.lt",
   "Eq.mp",
   "CompleteLinearOrder.toCompleteLattice",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "le_iInf_iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "le_antisymm"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLinearOrder α] {α_1 : Type u_1} {β : α_1 → Type u_1} (g : (a : α_1) → β a → α),\n  ⨅ a, ⨆ b, g a b = ⨆ g_1, ⨅ a, g a (g_1 a)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Abs.abs",
   "neg_le_abs_self",
   "le_total",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "Or.elim",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "le_abs_self",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "LinearOrder.toPartialOrder",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), 0 ≤ |a|",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "inferInstance",
   "Real",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Real.orderedSemiring"],
  "name": "Real.orderedAddCommMonoid",
  "constType": "OrderedAddCommMonoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "Eq",
   "Iff.of_eq",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "OrderTopology",
   "Filter",
   "Metric.ball",
   "Eq.trans",
   "PseudoMetricSpace",
   "iInf_congr_Prop",
   "instHSub",
   "setOf",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "DistribLattice.toLattice",
   "orderTopology_of_nhds_abs",
   "of_eq_true",
   "iInf",
   "LT.lt",
   "Real.instAddGroupReal",
   "congrArg",
   "abs_sub_comm",
   "OrderedAddCommGroup.toAddCommGroup",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.eq_biInf",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Metric.nhds_basis_ball",
   "Abs.abs",
   "True",
   "Zero.toOfNat0",
   "Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddCommGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Filter.instCompleteLatticeFilter",
   "Neg.toHasAbs",
   "eq_self",
   "funext",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "ConditionallyCompleteLattice.toInfSet",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "CompleteLattice.toInfSet",
   "Real.instPreorderReal",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name":
  "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
  "constType": "OrderTopology ℝ",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "Real.partialOrder.proof_4",
   "Real.partialOrder.proof_2",
   "LT.mk",
   "Real.partialOrder.proof_1",
   "LE.le",
   "PartialOrder",
   "Real.partialOrder.proof_3",
   "Preorder.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "Set",
   "MeasurableSpace.generateFrom",
   "TopologicalSpace",
   "MeasurableSpace",
   "IsOpen"],
  "name": "borel",
  "constType": "(α : Type u) → [inst : TopologicalSpace α] → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["UniformSpace",
   "UniformSpace.Core.toTopologicalSpace",
   "UniformSpace.ofCore.proof_1",
   "UniformSpace.mk",
   "UniformSpace.Core"],
  "name": "UniformSpace.ofCore",
  "constType": "{α : Type u} → UniformSpace.Core α → UniformSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "NormedRing",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HSub.hSub",
   "zero_sub",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegMonoid.sub_eq_add_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "congr",
   "Eq.symm",
   "congrArg",
   "neg_sub",
   "Eq.trans",
   "SubNegMonoid.zsmul_zero'",
   "id"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : SubtractionMonoid α], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NormedCommRing",
   "NormedCommRing.toNormedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : NormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mul_smul",
  "constType":
  "∀ {α : Type u_10} {β : Type u_11} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), (x * y) • b = x • y • b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module",
   "DistribMulAction",
   "AddCommMonoid"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} →\n  {M : Type v} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [self : Module R M] → DistribMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "inferInstance",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Real",
   "Real.strictOrderedRing"],
  "name": "Real.orderedAddCommGroup",
  "constType": "OrderedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["ENNReal", "WithTop.some", "NNReal"],
  "name": "ENNReal.ofNNReal",
  "constType": "NNReal → ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.1166",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1166",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "PartialOrder.toPreorder",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "HAdd.hAdd",
   "Set",
   "Inf.inf",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Preorder.toLE",
   "Inf.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "instHAdd",
   "Semiring",
   "SemilatticeSup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Submodule.instInfSetSubmodule.proof_1",
   "And",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_7",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (a a_1 : M),\n  a ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i →\n    a_1 ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i → a + a_1 ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_6",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{α : Type u_1} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OrderDual.toDual",
   "TopologicalSpace.generateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "TopologicalSpace.instPartialOrderTopologicalSpace",
   "Set",
   "Function.comp",
   "Set.Set.completeAtomicBooleanAlgebra",
   "FunLike.coe",
   "GaloisCoinsertion.liftCompleteLattice",
   "Equiv.instFunLikeEquiv",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "OrderDual.ofDual",
   "CompleteLattice",
   "OrderDual.completeLattice",
   "TopologicalSpace",
   "OrderDual",
   "TopologicalSpace.gciGenerateFrom",
   "IsOpen"],
  "name": "TopologicalSpace.instCompleteLatticeTopologicalSpace",
  "constType": "{α : Type u} → CompleteLattice (TopologicalSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PseudoMetricSpace.toUniformSpace",
   "TopologicalSpace",
   "TopologicalSpace.PseudoMetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "Eq"],
  "name": "TopologicalSpace.PseudoMetrizableSpace.mk",
  "constType":
  "∀ {X : Type u_5} [t : TopologicalSpace X],\n  (∃ m, UniformSpace.toTopologicalSpace = t) → TopologicalSpace.PseudoMetrizableSpace X",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Nontrivial"],
  "name": "DivisionRing.toNontrivial",
  "constType": "∀ {K : Type u} [self : DivisionRing K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "AddHom",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "LinearMap.toAddHom",
  "constType":
  "{R : Type u_17} →\n  {S : Type u_18} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_19} →\n            {M₂ : Type u_20} →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] →\n                  [inst_4 : Module R M] → [inst_5 : Module S M₂] → (M →ₛₗ[σ] M₂) → AddHom M M₂",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "DenselyOrdered", "LT.lt", "LT"],
  "name": "DenselyOrdered.dense",
  "constType":
  "∀ {α : Type u} [inst : LT α] [self : DenselyOrdered α] (a₁ a₂ : α), a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Homeomorph.symm",
   "HAdd.hAdd",
   "Set.Nonempty",
   "AddGroup.toSubtractionMonoid",
   "Homeomorph.instEquivLikeHomeomorph",
   "Inter.inter",
   "TopologicalSpace.exists_dense_seq",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "Set.iUnion",
   "Homeomorph",
   "EquivLike.toEmbeddingLike",
   "Homeomorph.addLeft",
   "Filter",
   "Nat",
   "And.casesOn",
   "TopologicalAddGroup.toContinuousAdd",
   "Dense.inter_nhds_nonempty",
   "Homeomorph.apply_symm_apply",
   "Homeomorph.addRight",
   "Homeomorph.isCompact_preimage",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "And",
   "Classical.indefiniteDescription",
   "DenseRange",
   "Eq.mp",
   "And.intro",
   "TopologicalSpace.denseSeq",
   "AddZeroClass.toAdd",
   "TopologicalSpace.denseRange_denseSeq",
   "Exists",
   "EmbeddingLike.toFunLike",
   "WeaklyLocallyCompactSpace.exists_compact_mem_nhds",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Zero.toOfNat0",
   "Set.range",
   "AddGroup",
   "TopologicalSpace",
   "TopologicalSpace.SeparableSpace",
   "Eq.symm",
   "SigmaCompactSpace.mk",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instMembershipSetFilter",
   "Membership.mem",
   "WeaklyLocallyCompactSpace",
   "Set.preimage",
   "instHAdd",
   "nhds",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.univ",
   "AddGroup.toSubNegMonoid",
   "Continuous.continuousAt",
   "Zero.nonempty",
   "Eq.ndrec",
   "SigmaCompactSpace",
   "Homeomorph.continuous",
   "SubNegMonoid.toAddMonoid",
   "IsCompact",
   "NegZeroClass.toZero",
   "TopologicalAddGroup",
   "Set.instInterSet"],
  "name": "SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace",
  "constType":
  "∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : TopologicalSpace.SeparableSpace G] [inst_4 : WeaklyLocallyCompactSpace G], SigmaCompactSpace G",
  "constCategory": "Definition"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} → [self : InvolutiveNeg A] → Neg A",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.FiniteAtFilter",
   "nhds",
   "TopologicalSpace",
   "MeasurableSpace",
   "MeasureTheory.IsLocallyFiniteMeasure"],
  "name": "MeasureTheory.IsLocallyFiniteMeasure.mk",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α},\n  (∀ (x : α), MeasureTheory.Measure.FiniteAtFilter μ (nhds x)) → MeasureTheory.IsLocallyFiniteMeasure μ",
  "constCategory": "Other"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → (coe : A → Set B) → Function.Injective coe → SetLike A B",
  "constCategory": "Other"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "∀ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "LinearOrderedCommRing"],
  "name": "LinearOrderedField.toLinearOrderedCommRing",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedField α] → LinearOrderedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references":
  ["BorelSpace", "borel", "TopologicalSpace", "MeasurableSpace", "Eq"],
  "name": "BorelSpace.mk",
  "constType":
  "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α], inst_1 = borel α → BorelSpace α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Semifield.toCommSemiring",
   "Real",
   "Real.instLEReal",
   "Field.toSemifield",
   "Ring.toSemiring",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Norm.norm",
   "NormedAlgebra",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.mk",
  "constType":
  "{𝕜 : Type u_5} →\n  {𝕜' : Type u_6} →\n    [inst : NormedField 𝕜] →\n      [inst_1 : SeminormedRing 𝕜'] →\n        [toAlgebra : Algebra 𝕜 𝕜'] → (∀ (r : 𝕜) (x : 𝕜'), ‖r • x‖ ≤ ‖r‖ * ‖x‖) → NormedAlgebra 𝕜 𝕜'",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Left.neg_nonpos_iff",
   "LE",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonpos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, -a ≤ 0 ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["WithTop.instCompleteLinearOrderWithTop.proof_7",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "WithTop.le",
   "Inf.inf",
   "CompleteLattice.mk",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop.proof_13",
   "OrderBot",
   "Lattice.mk",
   "Sup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_11",
   "Preorder.toLE",
   "WithTop.instCompleteLinearOrderWithTop.proof_2",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "WithTop.orderBot",
   "ConditionallyCompleteLattice.toSupSet",
   "WithTop",
   "instLinearOrder",
   "WithTop.semilatticeSup",
   "LinearOrder.decidableEq",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrderBot",
   "WithTop.linearOrder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "CompleteLinearOrder.mk",
   "WithTop.instInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_5",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "SemilatticeSup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_12",
   "ConditionallyCompleteLattice.toInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_8",
   "WithTop.orderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_9",
   "WithTop.instCompleteLinearOrderWithTop.proof_1",
   "WithTop.instCompleteLinearOrderWithTop.proof_6",
   "WithTop.instCompleteLinearOrderWithTop.proof_3",
   "ConditionallyCompleteLinearOrderBot.toOrderBot",
   "WithTop.lattice",
   "LinearOrder.decidableLT",
   "OrderBot.toBot",
   "OrderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_10",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "WithTop.instCompleteLinearOrderWithTop.proof_4",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "WithTop.instSupSet"],
  "name": "WithTop.instCompleteLinearOrderWithTop",
  "constType":
  "{α : Type u_1} → [inst : ConditionallyCompleteLinearOrderBot α] → CompleteLinearOrder (WithTop α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["continuous_id",
   "DistribLattice.toLattice",
   "isOpen_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "continuous_const",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Set.Iio",
   "IsOpen"],
  "name": "isOpen_Iio",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] {a : α},\n  IsOpen (Set.Iio a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSMul",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.Measure.instSMul",
   "Module.toMulActionWithZero",
   "MeasureTheory.Measure.smul_toOuterMeasure",
   "IsScalarTower",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "SMulZeroClass.toSMul",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "HSMul.hSMul",
   "OrderedSemiring.toSemiring",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Algebra.id",
   "Module",
   "MonoidWithZero.toZero",
   "MeasureTheory.OuterMeasure",
   "Algebra.toSMul",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.instModule.proof_1",
  "constType":
  "∀ {α : Type u_1} {R : Type u_2} [inst : Semiring R] [inst_1 : Module R ENNReal]\n  [inst_2 : IsScalarTower R ENNReal ENNReal] [inst_3 : MeasurableSpace α] (c : R) (μ : MeasureTheory.Measure α),\n  ↑(c • μ) = c • ↑μ",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toLinearOrder.proof_4",
   "Lattice.toLinearOrder.proof_2",
   "Min.mk",
   "Lattice.toLinearOrder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "IsTotal",
   "LinearOrder.mk",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Lattice.toLinearOrder.proof_3",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder",
  "constType":
  "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Abs",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["tangentConeAt",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Set",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "ContinuousLinearMap.ext_on",
   "Eq",
   "MetricSpace.toMetrizableSpace",
   "NormedAddCommGroup.toMetricSpace",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "UniqueDiffWithinAt",
   "Semifield.toDivisionSemiring",
   "HasFDerivWithinAt.unique_on",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "UniqueDiffWithinAt.dense_tangentCone",
   "HasFDerivWithinAt"],
  "name": "UniqueDiffWithinAt.eq",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' f₁' : E →L[𝕜] F} {x : E} {s : Set E},\n  UniqueDiffWithinAt 𝕜 s x → HasFDerivWithinAt f f' s x → HasFDerivWithinAt f f₁' s x → f' = f₁'",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "le_max_left",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), a ≤ |a|",
  "constCategory": "Theorem"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Module.toDistribMulAction",
   "OfNat.ofNat",
   "instHSMul",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "smul_zero",
   "Eq",
   "SMulZeroClass.toSMul",
   "Zero.toOfNat0",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero.proof_3",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (a : R), a • 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Inf", "SemilatticeInf"],
  "name": "SemilatticeInf.toInf",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → Inf α",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "NormedField"],
  "name": "NormedField.toMetricSpace",
  "constType": "{α : Type u_5} → [self : NormedField α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.add_left_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NormedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toNormedRing : NormedRing α] → (∀ (x y : α), x * y = y * x) → NormedCommRing α",
  "constCategory": "Other"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_two",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "sq",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α], 0 ≤ 1 → ZeroLEOneClass α",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Module",
   "Submodule.span",
   "Submodule.setLike",
   "SetLike.instMembership",
   "Iff.mpr",
   "Submodule.mem_span",
   "SetLike.coe",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.subset_span",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M},\n  s ⊆ ↑(Submodule.span R s)",
  "constCategory": "Theorem"},
 {"references": ["NormedField", "DenselyNormedField"],
  "name": "DenselyNormedField.toNormedField",
  "constType": "{α : Type u_5} → [self : DenselyNormedField α] → NormedField α",
  "constCategory": "Definition"},
 {"references":
  ["borel",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace"],
  "name": "Real.measurableSpace",
  "constType": "MeasurableSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "Set.Countable",
   "And",
   "Exists",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace"],
  "name": "TopologicalSpace.IsSeparable",
  "constType": "{α : Type u} → [t : TopologicalSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "One",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.id",
   "One.mk",
   "TopologicalSpace",
   "Module",
   "RingHom.id",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.one",
  "constType":
  "{R₁ : Type u_1} →\n  [inst : Semiring R₁] →\n    {M₁ : Type u_4} →\n      [inst_1 : TopologicalSpace M₁] → [inst_2 : AddCommMonoid M₁] → [inst_3 : Module R₁ M₁] → One (M₁ →L[R₁] M₁)",
  "constCategory": "Definition"},
 {"references":
  ["definition._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
   "NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "OrthonormalBasis",
   "Eq",
   "NormedField.toField",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "NormedDivisionRing.toDivisionRing",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NormedField.toNormedDivisionRing",
   "Subtype",
   "FiniteDimensional",
   "Fin"],
  "name": "wrapped._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
  "constType": "Subtype (Eq definition✝)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "RatCast"],
  "name": "LinearOrderedField.toRatCast",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → RatCast α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet"],
  "name": "Set.Subset.trans",
  "constType": "∀ {α : Type u} {a b c : Set α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "Ring.toSemiring",
   "LinearOrderedRing.max_def",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "LinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "LatticeOrderedGroup.neg_eq_zero_iff",
   "NormedLatticeAddCommGroup.toLattice",
   "AddGroup.toSubtractionMonoid",
   "IsClosed.preimage",
   "Eq.refl",
   "NormedLatticeAddCommGroup",
   "T3Space.t25Space",
   "continuous_neg'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "NegPart.neg",
   "True",
   "Preorder.toLE",
   "iff_self",
   "isClosed_singleton",
   "Eq",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.3",
   "Set.ext",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff",
   "NormedAddGroup.toAddGroup",
   "T2Space.t1Space",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "separated_t3",
   "T25Space.t2Space",
   "setOf",
   "Lattice.toSemilatticeInf",
   "Set.preimage",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.4",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Set.instMembershipSet",
   "NormedAddCommGroup.toMetricSpace",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "LatticeOrderedGroup.hasZeroLatticeHasNegPart",
   "NormedAddCommGroup.toNormedAddGroup",
   "Singleton.singleton",
   "IsClosed",
   "congrArg",
   "NegZeroClass.toZero",
   "MetricSpace.to_separated"],
  "name": "isClosed_nonneg",
  "constType":
  "∀ {E : Type u_2} [inst : NormedLatticeAddCommGroup E], IsClosed {x | 0 ≤ x}",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHSMul",
   "SMulWithZero",
   "HSMul.hSMul",
   "SMulZeroClass",
   "SMulZeroClass.toSMul",
   "Eq"],
  "name": "SMulWithZero.mk",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Zero R] →\n      [inst_1 : Zero M] → [toSMulZeroClass : SMulZeroClass R M] → (∀ (m : M), 0 • m = 0) → SMulWithZero R M",
  "constCategory": "Other"},
 {"references":
  ["Norm",
   "Filter",
   "Subtype",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Eq"],
  "name":
  "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
  "constType": "Subtype (Eq @Asymptotics.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedCancelAddCommMonoid α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "NormedAddCommGroup",
   "Real.measurableSpace",
   "Real",
   "Real.instPreorderReal",
   "Set.Ioc",
   "MeasureTheory.IntegrableOn"],
  "name": "IntervalIntegrable",
  "constType":
  "{E : Type u_3} → [inst : NormedAddCommGroup E] → (ℝ → E) → MeasureTheory.Measure ℝ → ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "∀ {M : Type u_1} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.toCompleteLattice",
   "CompletelyDistribLattice",
   "CompleteLinearOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice.proof_1"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [inst : CompleteLinearOrder α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "Algebra.commutes'",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Algebra.id"],
  "name": "NormedAlgebra.id.proof_1",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (r x : 𝕜), Algebra.toRingHom r * x = x * Algebra.toRingHom r",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Filter.map.proof_2",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "Filter.map.proof_1",
   "Filter",
   "Filter.univ_mem"],
  "name": "Filter.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references": ["CanonicallyLinearOrderedSemifield", "Nontrivial"],
  "name": "CanonicallyLinearOrderedSemifield.toNontrivial",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyLinearOrderedSemifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Field.toInv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Field.mul_inv_cancel",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass",
  "constType":
  "Type u_1 →\n  {R : outParam (Type u_2)} →\n    {S : outParam (Type u_3)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          outParam (R →+* S) →\n            (M : outParam (Type u_4)) →\n              [inst_2 : TopologicalSpace M] →\n                [inst_3 : AddCommMonoid M] →\n                  (M₂ : outParam (Type u_5)) →\n                    [inst_4 : TopologicalSpace M₂] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst : Module R M] → [inst : Module S M₂] → Type (max (max u_1 u_4) u_5)",
  "constCategory": "Other"},
 {"references": ["Prod", "Filter", "UniformSpace.Core"],
  "name": "UniformSpace.Core.uniformity",
  "constType": "{α : Type u} → UniformSpace.Core α → Filter (α × α)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "HSMul.hSMul",
   "SMulZeroClass",
   "Eq"],
  "name": "SMulZeroClass.mk",
  "constType":
  "{M : Type u_10} → {A : Type u_11} → [inst : Zero A] → [toSMul : SMul M A] → (∀ (a : M), a • 0 = 0) → SMulZeroClass M A",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace"],
  "name": "MeasureTheory.MeasureSpace.volume",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "∀ {α : Type u_1} (x : Set α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "BorelSpace",
   "IsROrC.toDenselyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "MeasureTheory.MeasureSpace.mk",
   "Real.isROrC",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "NormedField.toField",
   "Real.instDivisionRingReal",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace.toNormedSpace",
   "stdOrthonormalBasis",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "MeasureTheory.MeasureSpace",
   "OrthonormalBasis.toBasis",
   "Basis.addHaar",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace",
   "Fin",
   "FiniteDimensional"],
  "name": "measureSpaceOfInnerProductSpace",
  "constType":
  "{E : Type u_3} →\n  [inst : NormedAddCommGroup E] →\n    [inst_1 : InnerProductSpace ℝ E] →\n      [inst_2 : FiniteDimensional ℝ E] →\n        [inst_3 : MeasurableSpace E] → [inst : BorelSpace E] → MeasureTheory.MeasureSpace E",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.restrictₗ",
   "Set",
   "LinearMap.instFunLike",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.restrict.proof_1",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasurableSpace",
   "LinearMap",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.restrict",
  "constType":
  "{α : Type u_2} → {_m0 : MeasurableSpace α} → MeasureTheory.Measure α → Set α → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.insert",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.ndinsert.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.ndinsert",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → α → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "PseudoMetricSpace"],
  "name": "SeminormedRing.toPseudoMetricSpace",
  "constType":
  "{α : Type u_5} → [self : SeminormedRing α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instNNRealSemiring",
   "NNReal",
   "AddCommMonoidWithOne",
   "WithTop.addCommMonoidWithOne"],
  "name": "instENNRealAddCommMonoidWithOne",
  "constType": "AddCommMonoidWithOne ENNReal",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "neg_neg",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "neg_sub",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "Finset.instSingletonFinset"],
  "name": "Finset.coe_singleton",
  "constType": "∀ {α : Type u_1} (a : α), ↑{a} = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "RingHom.instRingHomClass",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "IsROrC.toStarRing",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "map_mul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.trans",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "EuclideanDomain.toCommRing",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "of_eq_true",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "congrArg",
   "congrFun"],
  "name": "IsROrC.innerProductSpace.proof_4",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (x y z : 𝕜),\n  (starRingEnd 𝕜) (z * x) * y = (starRingEnd 𝕜) z * ((starRingEnd 𝕜) x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["closure",
   "MeasureTheory.SimpleFunc.tendsto_approxOn",
   "PartialOrder.toPreorder",
   "Nontrivial.to_nonempty",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "MeasureTheory.SimpleFunc",
   "MeasureTheory.SimpleFunc.toFun",
   "Eq",
   "PseudoEMetricSpace.toUniformSpace",
   "Eq.mpr",
   "MeasureTheory.StronglyMeasurable",
   "Subsingleton",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Measurable",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim",
   "separableSpace_univ",
   "id",
   "Nat.strictOrderedSemiring",
   "PseudoMetricSpace.toPseudoEMetricSpace",
   "Membership.mem",
   "OpensMeasurableSpace",
   "Lean.Elab.Tactic.nonempty_to_inhabited",
   "nhds",
   "MeasureTheory.SimpleFunc.approxOn",
   "TopologicalSpace.pseudoMetrizableSpacePseudoMetric",
   "Set.univ",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "Inhabited.default",
   "Set.instMembershipSet",
   "SecondCountableTopology",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "StrictOrderedSemiring.toPartialOrder",
   "Nontrivial",
   "Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic._auxLemma.2",
   "Filter.atTop",
   "MeasurableSpace",
   "Set.mem_univ",
   "closure_univ"],
  "name": "Measurable.stronglyMeasurable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β] [inst_3 : SecondCountableTopology β]\n  [inst_4 : OpensMeasurableSpace β], Measurable f → MeasureTheory.StronglyMeasurable f",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "OfNat.ofNat",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulZeroOneClass.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Zero.toOfNat0",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass.toMonoidWithZeroHomClass",
   "map_zero",
   "MonoidWithZeroHomClass.toZeroHomClass"],
  "name": "RingHom.map_zero",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), f 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemifield",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instSubReal",
   "Real",
   "Real.instMulReal",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Real.instAddCommGroupReal",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "sub_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.isROrC.proof_6",
  "constType": "∀ (z w : ℝ), z * w = z * w - 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedField.toField",
   "Real",
   "Field"],
  "name": "Real.field",
  "constType": "Field ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "NonUnitalSeminormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "NonUnitalSeminormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalSeminormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "Max"],
  "name": "LinearOrderedRing.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Max α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NegZeroClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semifield.toCommSemiring",
   "Real",
   "DenselyNormedField.toNormedField",
   "NonUnitalRingHomClass.toMulHomClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "Eq.trans",
   "Real.denselyNormedField",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "Neg.neg",
   "RingHom.map_zero",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroOneClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.isROrC.proof_10",
  "constType": "(starRingEnd ℝ) 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "sub_self",
   "DivisionRing.toRing",
   "AddGroup.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "AddGroupWithOne.toAddGroup",
   "True",
   "MulZeroClass.toMul",
   "mul_div_cancel",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "Field",
   "Ring.toSub",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Ne",
   "instHDiv",
   "False",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "HSub.hSub",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "congr",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "and_self",
   "congrFun"],
  "name": "Field.toEuclideanDomain.proof_4",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b ≠ 0 → a - a * b / b = 0 ∧ ¬b = 0",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.map_mono",
   "PartialOrder.toPreorder",
   "Filter.map",
   "LE.le.trans",
   "Filter.instPartialOrderFilter",
   "Filter.Tendsto",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto.mono_left",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {x y : Filter α} {z : Filter β},\n  Filter.Tendsto f x z → y ≤ x → Filter.Tendsto f y z",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomInvPair",
   "RingHom",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "LinearEquiv",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "LinearIsometryEquiv",
   "Module"],
  "name": "LinearIsometryEquiv.toLinearEquiv",
  "constType":
  "{R : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R →+* R₂} →\n          {σ₂₁ : R₂ →+* R} →\n            [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n              [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                {E : Type u_11} →\n                  {E₂ : Type u_12} →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → (E ≃ₛₗᵢ[σ₁₂] E₂) → E ≃ₛₗ[σ₁₂] E₂",
  "constCategory": "Definition"},
 {"references": ["Bot", "CompleteLattice"],
  "name": "CompleteLattice.toBot",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Bot α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "List.finRange.proof_1",
   "List.Nodup",
   "LT.lt",
   "List.finRange",
   "List.Pairwise.pmap",
   "Fin.ne_of_vne",
   "List.nodup_range",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.nodup_finRange",
  "constType": "∀ (n : ℕ), List.Nodup (List.finRange n)",
  "constCategory": "Theorem"},
 {"references": ["semiOutParam"],
  "name": "IsROrC",
  "constType": "semiOutParam (Type u_1) → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_coe",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.6",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "AddHom.toFun",
   "Semiring",
   "Continuous",
   "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
   "TopologicalSpace",
   "Module",
   "AddCommMagma.toAdd",
   "autoParam",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.mk",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_3} →\n            [inst_2 : TopologicalSpace M] →\n              [inst_3 : AddCommMonoid M] →\n                {M₂ : Type u_4} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R M] →\n                        [inst_7 : Module S M₂] →\n                          (toLinearMap : M →ₛₗ[σ] M₂) → autoParam (Continuous toLinearMap.toFun) _auto✝ → M →SL[σ] M₂",
  "constCategory": "Other"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "lt_add_of_pos_right",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NeZero.one",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddZeroClass.toZero",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "one_pos",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NoMaxOrder.mk",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "NoMaxOrder"],
  "name": "StrictOrderedSemiring.toNoMaxOrder",
  "constType": "∀ {α : Type u} [inst : StrictOrderedSemiring α], NoMaxOrder α",
  "constCategory": "Definition"},
 {"references": ["Abs"],
  "name": "Abs.mk",
  "constType": "{α : Type u_1} → (α → α) → Abs α",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toNormedCommRing.proof_2",
   "NormedField.toField",
   "Field.toCommRing",
   "NormedCommRing",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "CommRing.toRing",
   "NormedRing.mk",
   "NormedCommRing.mk",
   "NormedField.toNormedCommRing.proof_1",
   "NormedField.toNorm"],
  "name": "NormedField.toNormedCommRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_2",
   "Mathlib.Order.OmegaCompletePartialOrder._auxLemma.14",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "RelHomClass.toFunLike",
   "OrderHom.mk",
   "Eq.mpr",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (s : α),\n  (∀ (i : ℕ), x i ≤ s) → (fun c => ⨆ i, c i) x ≤ s",
  "constCategory": "Theorem"},
 {"references":
  ["Algebra.toRingHom",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "algebraMap",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyLinearOrderedAddCommMonoid.decidableLE",
   "OrderedAddCommMonoid.add_le_add_left",
   "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.max_def",
   "CanonicallyLinearOrderedAddCommMonoid.le_total",
   "CanonicallyLinearOrderedAddCommMonoid.min_def",
   "CanonicallyLinearOrderedAddCommMonoid.toMin",
   "CanonicallyLinearOrderedAddCommMonoid.toOrd",
   "CanonicallyLinearOrderedAddCommMonoid.decidableLT",
   "CanonicallyLinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq",
   "CanonicallyLinearOrderedAddCommMonoid.toMax",
   "LinearOrder.mk",
   "CanonicallyLinearOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.decidableEq",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedAddCommMonoid α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "lt_add_of_pos_right",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder",
   "AddZeroClass.toZero",
   "NeZero",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "zero_lt_one",
   "AddZeroClass"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] [inst_5 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references":
  ["OpensMeasurableSpace",
   "CompactIccSpace.isCompact_Icc",
   "NormedAddCommGroup",
   "Set.Icc",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "ContinuousOn.integrableOn_compact",
   "PseudoMetricSpace.toUniformSpace",
   "CompactIccSpace",
   "MeasureTheory.IntegrableOn",
   "Preorder",
   "MeasureTheory.IsFiniteMeasureOnCompacts",
   "MeasureTheory.Measure",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "TopologicalSpace",
   "T2Space",
   "UniformSpace.toTopologicalSpace",
   "ContinuousOn",
   "MeasurableSpace"],
  "name": "ContinuousOn.integrableOn_Icc",
  "constType":
  "∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X] {a b : X}\n  [inst_4 : MeasureTheory.IsFiniteMeasureOnCompacts μ] [inst_5 : Preorder X] [inst_6 : CompactIccSpace X]\n  [inst_7 : T2Space X], ContinuousOn f (Set.Icc a b) → MeasureTheory.IntegrableOn f (Set.Icc a b)",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "instTopologicalSpaceProd",
   "ContinuousAt",
   "continuous_snd",
   "TopologicalSpace",
   "Prod",
   "Continuous.continuousAt"],
  "name": "continuousAt_snd",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α × β},\n  ContinuousAt Prod.snd p",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Function.Injective",
   "Nat"],
  "name": "CharZero.mk",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R], Function.Injective Nat.cast → CharZero R",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] →\n        [inst_1 : AddZeroClass N] → [toAddHomClass : AddHomClass F M N] → (∀ (f : F), f 0 = 0) → AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references": ["OfNat.ofNat", "One", "One.toOfNat1", "OneHom", "Eq"],
  "name": "OneHom.mk",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : One M] → [inst_1 : One N] → (toFun : M → N) → toFun 1 = 1 → OneHom M N",
  "constCategory": "Other"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Set", "MeasurableSpace.MeasurableSet'", "MeasurableSpace"],
  "name": "MeasurableSet",
  "constType": "{α : Type u_1} → [inst : MeasurableSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.mk",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLE",
   "Ring.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Ring.toSub",
   "LinearOrderedAddCommGroup.mk",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
   "AddCommGroup.mk",
   "LinearOrderedAddCommGroup",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
   "AddGroup.mk",
   "LinearOrderedRing.decidableEq",
   "Ring.toSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.min_def",
   "SubNegMonoid.mk",
   "Ring.zsmul",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OrderHom",
   "inferInstanceAs",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Nat",
   "Preorder",
   "Preorder.toLE",
   "OrderHomClass",
   "Nat.strictOrderedSemiring"],
  "name":
  "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
  "constType":
  "{α : Type u} → [inst : Preorder α] → OrderHomClass (OmegaCompletePartialOrder.Chain α) ℕ α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "NatCast.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Nat",
   "CauSeq.instNatCast",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instNatCastCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → NatCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Prod.pseudoMetricSpaceMax",
   "PseudoMetricSpace.toDist",
   "Prod.casesOn",
   "Real.instLTReal",
   "Prod.mk",
   "LT.lt",
   "Real",
   "Prod",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "BoundedSMul.continuousSMul.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] (a : α) (b : β) (δ : ℝ)\n  (motive : (x : α × β) → dist x (a, b) < δ → Prop) (x : α × β) (hab' : dist x (a, b) < δ),\n  (∀ (a' : α) (b' : β) (hab' : dist (a', b') (a, b) < δ), motive (a', b') hab') → motive x hab'",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "OfNat.ofNat",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "Classical.choose",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "RingHom.id",
   "Zero.toOfNat0",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Not",
   "Semifield.toDivisionSemiring",
   "ContinuousLinearMap.zero",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
  "constType":
  "(𝕜 : Type u_1) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} → [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → E → E →L[𝕜] F",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toInv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.inv_zero",
  "constType": "∀ {α : Type u_4} [self : Semifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} → [self : Field K] → DivisionRing K",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "Continuous.isOpen_preimage",
   "TopologicalSpace",
   "IsOpen"],
  "name": "IsOpen.preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ {s : Set β}, IsOpen s → IsOpen (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "SeminormedAddCommGroup.mk",
   "NormedAddCommGroup",
   "SeminormedAddCommGroup",
   "MetricSpace.toPseudoMetricSpace",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm"],
  "name": "NormedAddCommGroup.toSeminormedAddCommGroup",
  "constType":
  "{E : Type u_6} → [inst : NormedAddCommGroup E] → SeminormedAddCommGroup E",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toMulPosMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x * x_2 ≤ x_1 * x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Real.instLEReal",
   "Set",
   "Real",
   "Exists.intro",
   "Exists.casesOn",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.match_1",
  "constType":
  "∀ {α : Type u_1} (dist : α → α → ℝ) (s : Set α)\n  (motive : s ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C} → Prop)\n  (x : s ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C}),\n  (∀ (c : ℝ) (hc : ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ c),\n      motive (_ : ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → [self : RingHomClass F α β] → MonoidHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "Classical.choose_spec",
   "instHasEquiv",
   "CauSeq.lim",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.equiv_lim",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] (s : CauSeq β abv),\n  s ≈ CauSeq.const abv (CauSeq.lim s)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Lattice._auxLemma.27",
   "Set",
   "Set.univ",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "iff_self",
   "Iff",
   "Set.iUnion",
   "of_eq_true",
   "forall_congr",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.iUnion_eq_univ_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → Set α}, ⋃ i, f i = Set.univ ↔ ∀ (x : α), ∃ i, x ∈ f i",
  "constCategory": "Theorem"},
 {"references": ["Zero", "SMul", "SMulZeroClass"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_10} → {A : Type u_11} → [inst : Zero A] → [self : SMulZeroClass M A] → SMul M A",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Zero M] → [inst : Zero N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "IsROrC.I",
   "NormedField.toField",
   "Field.toCommRing",
   "IsROrC.re_add_im_ax",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "EuclideanDomain.toCommRing",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "IsROrC.ofReal",
   "instHMul",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.re_add_im",
  "constType":
  "∀ {K : Type u_1} [inst : IsROrC K] (z : K), ↑(IsROrC.re z) + ↑(IsROrC.im z) * IsROrC.I = z",
  "constCategory": "Theorem"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1166"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.neg",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "NormedRing",
   "instHMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedRing.norm_mul",
  "constType":
  "∀ {α : Type u_5} [self : NormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{α : Type u_1} → α → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{α : Type u_1} → [inst : Mul α] → [self : HasDistribNeg α] → InvolutiveNeg α",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{α : Type u} → (α → α → α) → Div α",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "NormedRing",
   "PseudoMetricSpace.toDist",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddMonoidHom.map_zero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "congrArg",
   "Eq.trans",
   "AddMonoidHom",
   "AddMonoidHom.id",
   "congrFun"],
  "name": "Real.isROrC.proof_1",
  "constType": "(AddMonoidHom.id ℝ) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Preorder.toLT",
   "Real.lattice",
   "LT.lt",
   "Classical.propDecidable",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "Real.instIsTotalRealLeInstLEReal",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Real.linearOrder",
  "constType": "LinearOrder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "inferInstance",
   "instDecidableEq",
   "Real",
   "Decidable",
   "Eq"],
  "name": "Real.decidableEq",
  "constType": "(a b : ℝ) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["One", "Real", "One.mk", "_private.Mathlib.Data.Real.Basic.0.Real.one"],
  "name": "Real.instOneReal",
  "constType": "One ℝ",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_7",
  "constType":
  "∀ {α : Type u_1} (a b c : (Filter α)ᵒᵈᵒᵈ), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Submodule.FG",
   "Top.top",
   "Semiring",
   "Module.Finite",
   "Module",
   "Submodule.instTopSubmodule",
   "AddCommMonoid"],
  "name": "Module.Finite.mk",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Submodule.FG ⊤ → Module.Finite R M",
  "constCategory": "Other"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "Real",
   "Real.instAddMonoidReal",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam",
   "AddMonoidHom"],
  "name": "IsROrC.re",
  "constType": "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K →+ ℝ",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "MetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NonUnitalNormedRing",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toNonUnitalRing : NonUnitalRing α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NonUnitalNormedRing α",
  "constCategory": "Other"},
 {"references": ["UniformSpace", "UniformSpace.Core"],
  "name": "UniformSpace.toCore",
  "constType": "{α : Type u} → [self : UniformSpace α] → UniformSpace.Core α",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.lift.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "Preorder",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : PartialOrder β] → (f : α → β) → Function.Injective f → PartialOrder α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "AddSubsemigroup.carrier",
   "AddCommMonoid"],
  "name": "Submodule.mk",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          (toAddSubmonoid : AddSubmonoid M) →\n            (∀ (c : R) {x : M}, x ∈ toAddSubmonoid.carrier → c • x ∈ toAddSubmonoid.carrier) → Submodule R M",
  "constCategory": "Other"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "Membership.mem",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "setOf",
   "Submodule",
   "PartialOrder.toPreorder",
   "Semiring",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Inf.mk",
   "And",
   "Set.subset_inter",
   "And.intro",
   "Set.inter_subset_left",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_10",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)), ∀ x_1 ∈ x, x_1 ≤ sInf fun x_2 => ∀ b ∈ x, b ≤ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_one",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.toNormedAlgebra",
   "NormedField.toField",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "NormedAlgebra.toAlgebra",
   "IsROrC.toDenselyNormedField",
   "Real.instCommSemiringReal",
   "Real.normedField",
   "Real",
   "Algebra.cast",
   "Field.toSemifield",
   "DenselyNormedField.toNormedField",
   "Semifield.toDivisionSemiring",
   "IsROrC",
   "NormedField.toNormedCommRing"],
  "name": "IsROrC.ofReal",
  "constType": "{K : Type u_1} → [inst : IsROrC K] → ℝ → K",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "max_eq_right",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_of_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, a ≤ 0 → |a| = -a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "HasDerivAtFilter.proof_2",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "NormedField.toNormedSpace",
   "HasFDerivAt.differentiableAt",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "HasDerivAtFilter.proof_1",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DifferentiableAt",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.differentiableAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasDerivAt f f' x → DifferentiableAt 𝕜 f x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SMul",
   "Module.toDistribMulAction",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "DistribMulAction",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "Function.Injective.distribMulAction",
   "HSMul.hSMul",
   "Module",
   "Function.Injective.module.proof_1",
   "AddCommMonoid",
   "DistribMulAction.toMulAction",
   "DistribMulAction.mk",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "Function.Injective.module.proof_3",
   "MulActionWithZero.toSMulWithZero",
   "Function.Injective",
   "Function.Injective.module.proof_4",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "MonoidWithZero.toZero",
   "Function.Injective.module.proof_2",
   "AddMonoidHom",
   "Module.mk"],
  "name": "Function.Injective.module",
  "constType":
  "(R : Type u_2) →\n  {M : Type u_5} →\n    {M₂ : Type u_6} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : Module R M] →\n            [inst_3 : AddCommMonoid M₂] →\n              [inst_4 : SMul R M₂] →\n                (f : M₂ →+ M) → Function.Injective ⇑f → (∀ (c : R) (x : M₂), f (c • x) = c • f x) → Module R M₂",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.mk",
  "constType": "{K : Type u} → (ℚ → K) → RatCast K",
  "constCategory": "Other"},
 {"references":
  ["Quot.liftOn", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedRing"],
  "name": "Real.strictOrderedRing",
  "constType": "StrictOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references": ["SMul", "TopologicalSpace"],
  "name": "ContinuousSMul",
  "constType":
  "(M : Type u_1) → (X : Type u_2) → [inst : SMul M X] → [inst : TopologicalSpace M] → [inst : TopologicalSpace X] → Prop",
  "constCategory": "Other"},
 {"references": ["DecidableEq", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableEq",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.instAdd.proof_1",
   "MeasureTheory.OuterMeasure.instAdd",
   "MeasureTheory.Measure.toOuterMeasure",
   "instHAdd",
   "HAdd.hAdd",
   "MeasureTheory.Measure.mk",
   "Add",
   "MeasureTheory.Measure.instAdd.proof_2",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "Add.mk"],
  "name": "MeasureTheory.Measure.instAdd",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → Add (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "add_right_neg",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["starRingAut",
   "Distrib.toAdd",
   "RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "RingAut",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "RingHomClass.toRingHom",
   "NonUnitalNonAssocSemiring.toMul",
   "RingEquivClass.toRingHomClass",
   "RingEquiv.instRingEquivClassRingEquiv",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "starRingEnd",
  "constType":
  "(R : Type u) → [inst : CommSemiring R] → [inst_1 : StarRing R] → R →+* R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "Set.subset_univ",
   "Set.instMembershipSet"],
  "name": "Filter.principal",
  "constType": "{α : Type u} → Set α → Filter α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inner",
  "constType": "Type u_4 → Type u_5 → Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{α : Type u_1} → Singleton α (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "or_true", "iff_of_eq", "True"],
  "name": "or_true_iff",
  "constType": "∀ (p : Prop), p ∨ True ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["Function.swap",
   "add_lt_add_of_lt_of_lt",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "Add"],
  "name": "add_lt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : α},\n  a < b → c < d → a + c < b + d",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Preorder.le_trans",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : (Filter α)ᵒᵈᵒᵈ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "Left.mul_nonneg",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul"],
  "name": "mul_nonneg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "Real",
   "Real.instAddMonoidReal",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam",
   "AddMonoidHom"],
  "name": "IsROrC.im",
  "constType": "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K →+ ℝ",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.intCast",
  "constType": "{R : Type u} → [self : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "SMul",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul"],
  "name": "Algebra.mk",
  "constType":
  "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : Semiring A] →\n        [toSMul : SMul R A] →\n          (toRingHom : R →+* A) →\n            (∀ (r : R) (x : A), toRingHom r * x = x * toRingHom r) →\n              (∀ (r : R) (x : A), r • x = toRingHom r * x) → Algebra R A",
  "constCategory": "Other"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "And",
   "setOf",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "InfSet.sInf",
   "And.intro",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_3",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 x_2 : Submodule R M), x ≤ x_2 → x_1 ≤ x_2 → sInf {x_3 | x ≤ x_3 ∧ x_1 ≤ x_3} ≤ x_2",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulOneClass.toOne", "MonoidHom", "OneHom"],
  "name": "MonoidHom.toOneHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (M →* N) → OneHom M N",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "OrderedAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Continuous.sub",
   "IsClosed.preimage",
   "Eq.refl",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Eq",
   "Set.ext",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "ContinuousSub",
   "continuous_snd",
   "TopologicalSpace",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "instHSub",
   "funext",
   "setOf",
   "Prod.snd",
   "Set.preimage",
   "instTopologicalSpaceProd",
   "HSub.hSub",
   "Prod.fst",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Mathlib.Analysis.Normed.Order.Lattice._auxLemma.5",
   "Set.instMembershipSet",
   "continuous_fst",
   "Eq.ndrec",
   "of_eq_true",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "Prod",
   "IsClosed",
   "congrArg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "isClosed_le_of_isClosed_nonneg",
  "constType":
  "∀ {G : Type u_2} [inst : OrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousSub G],\n  IsClosed {x | 0 ≤ x} → IsClosed {p | p.1 ≤ p.2}",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "Eq"],
  "name": "SubNegMonoid.sub_eq_add_neg",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Definition"},
 {"references": ["Real", "Dist"],
  "name": "Dist.mk",
  "constType": "{α : Type u_3} → (α → α → ℝ) → Dist α",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommSemiring",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring",
   "Real.instStrictOrderedCommRingReal",
   "Real"],
  "name": "Real.strictOrderedCommSemiring",
  "constType": "StrictOrderedCommSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OrderDual.instPreorder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "inferInstanceAs",
   "OrderDual",
   "OrderDual.instPartialOrder.proof_3",
   "OrderDual.instPartialOrder.proof_1",
   "Preorder",
   "le_antisymm",
   "LE.le",
   "OrderDual.instPartialOrder.proof_2",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "OrderDual.instPartialOrder",
  "constType": "(α : Type u_3) → [inst : PartialOrder α] → PartialOrder αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.inv'", "Real", "Inv", "Inv.mk"],
  "name": "Real.instInvReal",
  "constType": "Inv ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "instHSub",
   "OfNat.ofNat",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegZeroMonoid",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegZeroMonoid.toSubNegMonoid",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "sub_zero",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedAddCommGroup", "Min"],
  "name": "LinearOrderedAddCommGroup.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Min α",
  "constCategory": "Definition"},
 {"references": ["WithTop", "NNReal"],
  "name": "ENNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "max_eq_left",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "neg_nonpos"],
  "name": "abs_of_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ a → |a| = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "semiOutParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Filter.join.proof_2",
   "Membership.mem",
   "setOf",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.join.proof_3",
   "Filter.join.proof_1",
   "instMembershipSetFilter"],
  "name": "Filter.join",
  "constType": "{α : Type u} → Filter (Filter α) → Filter α",
  "constCategory": "Definition"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule",
   "setOf",
   "PartialOrder.toPreorder",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_2",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), x_1 ≤ sInf {x_2 | x ≤ x_2 ∧ x_1 ≤ x_2}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "True",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_1",
  "constType": "∀ (a : ℝ), |a - a| = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Neg.neg",
   "Sub",
   "Real.instNegReal",
   "Sub.mk"],
  "name": "Real.instSubReal",
  "constType": "Sub ℝ",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "one_le_two",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "zero_lt_one",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "zero_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "NormedAlgebra.toAlgebra",
   "NormedAlgebra.toNormedSpace.proof_2",
   "Algebra.toModule",
   "NormedSpace.mk",
   "NormedField",
   "Semifield.toCommSemiring",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "NormedSpace",
   "NormedAlgebra.norm_smul_le",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "SeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "SeminormedRing.toRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDivisionSemiring",
   "NormedAlgebra.toNormedSpace.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedAlgebra",
   "Module",
   "SeminormedRing.toNonUnitalSeminormedRing",
   "Module.mk"],
  "name": "NormedAlgebra.toNormedSpace",
  "constType":
  "{𝕜 : Type u_5} →\n  (𝕜' : Type u_6) →\n    [inst : NormedField 𝕜] → [inst_1 : SeminormedRing 𝕜'] → [inst_2 : NormedAlgebra 𝕜 𝕜'] → NormedSpace 𝕜 𝕜'",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], α → b ↔ b",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Ring",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u_1} → Set α",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "instHasEquiv",
   "Classical.choose",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.lim",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] →\n        {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → [inst_3 : CauSeq.IsComplete β abv] → CauSeq β abv → β",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocRing α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "tangentConeAt",
   "closure",
   "Mathlib.Topology.Basic._auxLemma.26",
   "NormedAddCommGroup",
   "Submodule",
   "NontriviallyNormedField.toNormedField",
   "Set",
   "uniqueDiffWithinAt_iff",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "Dense",
   "NormedSpace",
   "Submodule.span",
   "True",
   "Submodule.instTopSubmodule",
   "Eq",
   "NormedField.toField",
   "Eq.mpr",
   "UniqueDiffWithinAt",
   "UniformSpace.toTopologicalSpace",
   "Submodule.span_univ",
   "Eq.trans",
   "id",
   "Membership.mem",
   "NontriviallyNormedField",
   "Top.top",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "tangentCone_univ",
   "Set.univ",
   "Set.instMembershipSet",
   "And",
   "DivisionSemiring.toSemiring",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "congr",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "congrArg",
   "and_self",
   "Submodule.setLike",
   "closure_univ",
   "SetLike.coe"],
  "name": "uniqueDiffWithinAt_univ",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {x : E}, UniqueDiffWithinAt 𝕜 Set.univ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "∀ {α : Type u_1} (x : Set α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "CommRing.toNonUnitalCommRing",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "HasFDerivAt",
   "NormedField.toNormedSpace",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "NontriviallyNormedField",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "One.toOfNat1",
   "FunLike.coe",
   "hasFDerivAtFilter_iff_hasDerivAtFilter",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousMapClass.toFunLike"],
  "name": "hasFDerivAt_iff_hasDerivAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {f' : 𝕜 →L[𝕜] F}, HasFDerivAt f f' x ↔ HasDerivAt f (f' 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "OfNat.ofNat",
   "Field",
   "Field.toSemifield",
   "And.intro",
   "Semifield.toCommGroupWithZero",
   "And.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.match_1",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (b c : K) (motive : c = 0 ∧ b ≠ 0 → Prop) (x : c = 0 ∧ b ≠ 0),\n  (∀ (left : c = 0) (hnb : b ≠ 0), motive (_ : c = 0 ∧ b ≠ 0)) → motive x",
  "constCategory": "Definition"},
 {"references": ["SeminormedAddCommGroup", "AddCommGroup"],
  "name": "SeminormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} → [self : SeminormedAddCommGroup E] → AddCommGroup E",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Field",
   "Field.toInv",
   "Field.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "Field.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["continuous_fst",
   "instTopologicalSpaceProd",
   "ContinuousAt",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "Continuous.continuousAt"],
  "name": "continuousAt_fst",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α × β},\n  ContinuousAt Prod.fst p",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_eq_of_add",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), a + b = 0 → -a = b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_9} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "HSub.hSub",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GT.gt",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "LT.lt",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat"],
  "name": "IsCauSeq",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → {β : Type u_2} → [inst : Ring β] → (β → α) → (ℕ → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.instPartialOrderFilter",
   "le_refl",
   "Filter.Tendsto",
   "Filter",
   "id"],
  "name": "Filter.tendsto_id",
  "constType": "∀ {α : Type u} {x : Filter α}, Filter.Tendsto id x x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Submodule",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Type v",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "SeminormedAddCommGroup.to_uniformAddGroup",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "UniformAddGroup.to_topologicalAddGroup",
   "PseudoMetricSpace.toUniformSpace",
   "SeminormedAddCommGroup",
   "UniformSpace.toTopologicalSpace",
   "SeminormedAddCommGroup.toSeminormedAddGroup",
   "SeminormedAddGroup.toAddGroup",
   "TopologicalAddGroup"],
  "name": "SeminormedAddCommGroup.toTopologicalAddGroup",
  "constType":
  "∀ {E : Type u_6} [inst : SeminormedAddCommGroup E], TopologicalAddGroup E",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedCancelAddCommMonoid", "Ord"],
  "name": "LinearOrderedCancelAddCommMonoid.toOrd",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references":
  ["max_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_max_left",
   "eq_max",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "le_max_right",
   "Preorder.toLE",
   "Eq"],
  "name": "max_comm",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), max a b = max b a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "Nat.succ",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_8",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "NormedField",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "SeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Module",
   "NormedSpace"],
  "name": "NormedSpace.toModule",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} → [inst : NormedField α] → [inst_1 : SeminormedAddCommGroup β] → [self : NormedSpace α β] → Module α β",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Field",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toInv",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.inv_zero",
  "constType": "∀ {K : Type u} [self : Field K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.intro",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.subset_inter",
  "constType": "∀ {α : Type u} {s t r : Set α}, r ⊆ s → r ⊆ t → r ⊆ s ∩ t",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "StrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDecidableEq",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → DecidableEq K",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "HasStrictFDerivAt.hasFDerivAt",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "HasStrictDerivAt",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "HasStrictDerivAt.proof_1",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "HasStrictDerivAt.proof_2",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasStrictDerivAt.hasDerivAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasStrictDerivAt f f' x → HasDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["MetricSpace", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toMetricSpace",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → MetricSpace E",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "DecidableEq"],
  "name": "LinearOrderedAddCommGroup.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "InvolutiveNeg.mk"],
  "name": "SubtractionMonoid.toInvolutiveNeg",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → InvolutiveNeg G",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mul_pos",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "BoundedSMul.dist_smul_pair'",
   "LE.le",
   "Dist.dist",
   "Zero.toOfNat0",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "HSMul.hSMul",
   "HMul.hMul",
   "PseudoMetricSpace",
   "BoundedSMul"],
  "name": "dist_smul_pair",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero α]\n  [inst_3 : Zero β] [inst_4 : SMul α β] [inst_5 : BoundedSMul α β] (x : α) (y₁ y₂ : β),\n  dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "And",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "Filter",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace",
   "instMembershipSetFilter"],
  "name": "MeasureTheory.Measure.FiniteAtFilter",
  "constType":
  "{α : Type u_1} → {_m0 : MeasurableSpace α} → MeasureTheory.Measure α → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references": ["Monoid"],
  "name": "MulAction",
  "constType":
  "(α : Type u_10) → Type u_11 → [inst : Monoid α] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_1} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.liftLinear.proof_3",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "LinearMap.instFunLike",
   "RingHom.id",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.instModule",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "Semiring.toModule",
   "MeasureTheory.Measure.liftLinear.proof_1",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "AddHom.mk",
   "LinearMap.mk",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddCommMagma.toAdd",
   "MeasureTheory.Measure.liftLinear.proof_2",
   "LE.le",
   "MeasurableSpace.instLEMeasurableSpace",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.toMeasure",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.caratheodory"],
  "name": "MeasureTheory.Measure.liftLinear",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MeasurableSpace β] →\n      {m0 : MeasurableSpace α} →\n        (f : MeasureTheory.OuterMeasure α →ₗ[ENNReal] MeasureTheory.OuterMeasure β) →\n          (∀ (μ : MeasureTheory.Measure α), inst ≤ MeasureTheory.OuterMeasure.caratheodory (f ↑μ)) →\n            MeasureTheory.Measure α →ₗ[ENNReal] MeasureTheory.Measure β",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "ContinuousMul",
   "Prod.mk",
   "Continuous",
   "Continuous.prod_mk",
   "HMul.hMul",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "continuous_mul",
   "Mul",
   "Continuous.comp"],
  "name": "Continuous.mul",
  "constType":
  "∀ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Mul M]\n  [inst_3 : ContinuousMul M] {f g : X → M}, Continuous f → Continuous g → Continuous fun x => f x * g x",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Set", "MeasureTheory.OuterMeasure"],
  "name": "MeasureTheory.OuterMeasure.measureOf",
  "constType":
  "{α : Type u_1} → MeasureTheory.OuterMeasure α → Set α → ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["continuous_add",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Continuous",
   "Continuous.prod_mk",
   "TopologicalSpace",
   "Prod",
   "ContinuousAdd",
   "Prod.fst",
   "Add",
   "Continuous.comp"],
  "name": "Continuous.add",
  "constType":
  "∀ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Add M]\n  [inst_3 : ContinuousAdd M] {f g : X → M}, Continuous f → Continuous g → Continuous fun x => f x + g x",
  "constCategory": "Theorem"},
 {"references":
  ["add_lt_iff_neg_left",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "propext",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "AddZeroClass",
   "ContravariantClass",
   "Eq"],
  "name": "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.27",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, (a + b < a) = (b < 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Real",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "AddMonoid.toAddSemigroup",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instZeroAddMonoidHom",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "congrFun"],
  "name": "Real.isROrC.proof_3",
  "constType": "∀ (z : ℝ), z + 0 z * 0 = z",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "TopologicalSpace.MetrizableSpace",
  "constType": "(X : Type u_5) → [t : TopologicalSpace X] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {b c : α},\n  b ≤ c → ∀ (a : α), b + a ≤ c + a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "Semifield.toCommSemiring",
   "NormedField",
   "Algebra",
   "Field.toSemifield",
   "NormedAlgebra",
   "Ring.toSemiring"],
  "name": "NormedAlgebra.toAlgebra",
  "constType":
  "{𝕜 : Type u_5} →\n  {𝕜' : Type u_6} → [inst : NormedField 𝕜] → [inst_1 : SeminormedRing 𝕜'] → [self : NormedAlgebra 𝕜 𝕜'] → Algebra 𝕜 𝕜'",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.const.proof_1",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "IsCauSeq",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Nat",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Subtype.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.const",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → (abv : β → α) → [inst_2 : IsAbsoluteValue abv] → β → CauSeq β abv",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Set",
   "Continuous",
   "TopologicalSpace",
   "IsOpen",
   "Iff.mpr",
   "continuous_def",
   "id"],
  "name": "continuous_id",
  "constType": "∀ {α : Type u_1} [inst : TopologicalSpace α], Continuous id",
  "constCategory": "Theorem"},
 {"references": ["Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.natAbs",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "SubNegMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MeasureTheory.OuterMeasure",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "EmptyCollection.emptyCollection",
   "setOf",
   "Set",
   "Union.union",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Bornology.ofBounded.proof_1",
   "Set.instMembershipSet",
   "Bornology.ofBounded.proof_2",
   "Bornology.ofBounded.proof_4",
   "Set.instHasSubsetSet",
   "Set.instSingletonSet",
   "Filter.mk",
   "Singleton.singleton",
   "Bornology.ofBounded.proof_3",
   "Bornology",
   "Set.instUnionSet",
   "Bornology.mk"],
  "name": "Bornology.ofBounded",
  "constType":
  "{α : Type u_4} →\n  (B : Set (Set α)) →\n    ∅ ∈ B → (∀ s₁ ∈ B, ∀ s₂ ⊆ s₁, s₂ ∈ B) → (∀ s₁ ∈ B, ∀ s₂ ∈ B, s₁ ∪ s₂ ∈ B) → (∀ (x : α), {x} ∈ B) → Bornology α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Max"],
  "name": "LinearOrderedAddCommGroup.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.instSingletonSet",
   "forall_eq",
   "Real.instLEReal",
   "Set",
   "Real",
   "Real.instPreorderReal",
   "Singleton.singleton",
   "le_rfl",
   "Exists.intro",
   "LE.le",
   "Iff.mpr",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_4",
  "constType":
  "∀ {α : Type u_1} (dist : α → α → ℝ) (z : α), ∃ C, ∀ ⦃x : α⦄, x ∈ {z} → ∀ ⦃y : α⦄, y ∈ {z} → dist x y ≤ C",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.83",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZeroHom.toZeroHom",
   "MulOneClass.toMul",
   "ZeroHom.toFun",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZeroHomClass",
   "FunLike.mk",
   "MonoidWithZeroHom.map_one'",
   "MonoidWithZeroHom.monoidWithZeroHomClass.proof_2",
   "MonoidWithZeroHom.map_mul'",
   "MulZeroOneClass.toZero",
   "MonoidWithZeroHom",
   "MonoidWithZeroHomClass.mk",
   "MonoidWithZeroHom.monoidWithZeroHomClass.proof_1",
   "MulHomClass.mk",
   "MonoidHomClass.mk",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHom.monoidWithZeroHomClass",
  "constType":
  "{M : Type u_3} →\n  {N : Type u_4} → [inst : MulZeroOneClass M] → [inst_1 : MulZeroOneClass N] → MonoidWithZeroHomClass (M →*₀ N) M N",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero.mk",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → GroupWithZero G₀",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.add_le_add_left",
   "LinearOrderedCancelAddCommMonoid.toOrd",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toMax",
   "LinearOrderedCancelAddCommMonoid.decidableLT",
   "LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq",
   "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrder.mk",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableEq",
   "LinearOrderedCancelAddCommMonoid.toMin",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid.le_total",
   "LinearOrderedCancelAddCommMonoid.min_def",
   "LinearOrderedCancelAddCommMonoid.max_def",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_5",
  "constType": "∀ {α : Type u_1} [β : NormedRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real.borelSpace",
   "NormedAddCommGroup",
   "CompleteSpace",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real.measurableSpace",
   "Real",
   "Real.normedField",
   "intervalIntegral.integral_hasStrictDerivAt_right",
   "HasStrictDerivAt",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Real.locallyFinite_volume",
   "Continuous.continuousAt",
   "MetricSpace.toMetrizableSpace",
   "BorelSpace.opensMeasurable",
   "NormedAddCommGroup.toMetricSpace",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
   "Continuous.stronglyMeasurableAtFilter",
   "Continuous",
   "Continuous.intervalIntegrable",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.measureSpace",
   "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
   "secondCountableTopologyEither_of_left",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "Real.denselyNormedField",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "Continuous.integral_hasStrictDerivAt",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E},\n  Continuous f → ∀ (a b : ℝ), HasStrictDerivAt (fun u => ∫ (x : ℝ) in a..u, f x) (f b) b",
  "constCategory": "Theorem"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (x : α), (∀ (y : α), r y x → Acc r y) → Acc r x",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_10",
  "constType": "∀ {α : Type u_1} [β : NormedRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Eq"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
  "constType":
  "∀ {α : Type u_1} (a b : MeasurableSpace α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "_auto._@.Std.Data.Rat.Basic._hyg.33",
   "Rat",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "Int",
   "_auto._@.Std.Data.Rat.Basic._hyg.4",
   "Int.natAbs"],
  "name": "Rat.mk'",
  "constType":
  "(num : ℤ) → (den : ℕ) → autoParam (den ≠ 0) _auto✝ → autoParam (Nat.Coprime (Int.natAbs num) den) _auto✝¹ → ℚ",
  "constCategory": "Other"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Min.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "inf_eq_minDefault",
   "Lattice.toInf",
   "IsTotal",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedLatticeAddCommGroup",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toLattice",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "inf_le_of_right_le",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_le_of_left_le",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "instDistribLattice.match_1",
   "LE.le",
   "Preorder.toLE",
   "le_total",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "le_inf",
   "le_refl",
   "sup_le_sup_left",
   "inferInstanceAs",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "instDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (x b c : α), (x ⊔ b) ⊓ (x ⊔ c) ≤ x ⊔ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["nhds",
   "Eq.rec",
   "Continuous",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Continuous.tendsto",
   "Eq"],
  "name": "Continuous.tendsto'",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → ∀ (x : α) (y : β), f x = y → Filter.Tendsto f (nhds x) (nhds y)",
  "constCategory": "Theorem"},
 {"references": ["SMul", "instHSMul", "HSMul.hSMul", "IsScalarTower", "Eq"],
  "name": "IsScalarTower.mk",
  "constType":
  "∀ {M : Type u_10} {N : Type u_11} {α : Type u_12} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α],\n  (∀ (x : M) (y : N) (z : α), (x • y) • z = x • y • z) → IsScalarTower M N α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "And",
   "Exists",
   "Set",
   "TopologicalSpace",
   "MeasureTheory.Measure.restrict",
   "Filter",
   "_auto._@.Mathlib.MeasureTheory.Integral.IntegrableOn._hyg.83",
   "autoParam",
   "MeasurableSpace",
   "MeasureTheory.AEStronglyMeasurable",
   "instMembershipSetFilter"],
  "name": "StronglyMeasurableAtFilter",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MeasurableSpace α] →\n      [inst_1 : TopologicalSpace β] → (α → β) → Filter α → autoParam (MeasureTheory.Measure α) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SMul",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "PseudoEMetricSpace.toPseudoMetricSpaceOfDist",
   "Real",
   "PseudoMetricSpace.replaceBornology",
   "Real.instSupReal",
   "Prod.fst",
   "PseudoMetricSpace.toBornology",
   "Dist.dist",
   "PseudoMetricSpace.toDist",
   "Prod.pseudoEMetricSpaceMax",
   "Prod.pseudoMetricSpaceMax.proof_3",
   "Prod",
   "Sup.sup",
   "Prod.pseudoMetricSpaceMax.proof_1",
   "Prod.instBornology",
   "Prod.pseudoMetricSpaceMax.proof_2",
   "PseudoMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name": "Prod.pseudoMetricSpaceMax",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : PseudoMetricSpace α] → [inst : PseudoMetricSpace β] → PseudoMetricSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Trans",
   "lt_of_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLeToLELtToLT",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LT.lt LT.lt",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "True",
   "max_def",
   "Eq",
   "ite",
   "le_of_not_le",
   "Eq.mpr",
   "if_pos",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_right",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), b ≤ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "ContinuousLinearMap.toLinearMap",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalRingHomClass.toMulHomClass",
   "RingHom.id",
   "LinearMap.smulRight",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid",
   "LinearMap.map_smul'",
   "AddHom.toFun",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "IsScalarTower",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "ContinuousLinearMap.smulRight.proof_1",
  "constType":
  "∀ {M₁ : Type u_2} [inst : TopologicalSpace M₁] [inst_1 : AddCommMonoid M₁] {M₂ : Type u_1} [inst_2 : AddCommMonoid M₂]\n  {R : Type u_3} {S : Type u_4} [inst_3 : Semiring R] [inst_4 : Semiring S] [inst_5 : Module R M₁]\n  [inst_6 : Module R M₂] [inst_7 : Module R S] [inst_8 : Module S M₂] [inst_9 : IsScalarTower R S M₂]\n  [inst_10 : TopologicalSpace S] (c : M₁ →L[R] S) (f : M₂) (r : R) (x : M₁),\n  AddHom.toFun (LinearMap.smulRight (↑c) f).toAddHom (r • x) =\n    (RingHom.id R) r • AddHom.toFun (LinearMap.smulRight (↑c) f).toAddHom x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{α : Type u_1} → InfSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.mk",
   "CauSeq",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.mk",
  "constType": "CauSeq ℚ abs → ℝ",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "add_le_add",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "Iff.mpr",
   "neg_le_abs_self",
   "Eq",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "Eq.rec",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "neg_add",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "instHAdd",
   "instDistribLattice",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "LE.le",
   "le_abs_self",
   "abs_le",
   "DistribLattice.toLattice",
   "neg_le",
   "And",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "And.intro",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_add",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] (a b : α), |a + b| ≤ |a| + |b|",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "AddCommGroup.toAddCommMonoid",
   "Dist.dist",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "SMulWithZero.toSMulZeroClass",
   "DistribSMul.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "sub_zero",
   "Eq.trans",
   "BoundedSMul.mk",
   "SeminormedRing.toNonUnitalSeminormedRing",
   "DistribMulAction.toDistribSMul",
   "instHSub",
   "SeminormedAddGroup.toPseudoMetricSpace",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "instHMul",
   "SubNegZeroMonoid.toSubNegMonoid",
   "MulActionWithZero.toSMulWithZero",
   "Eq.mp",
   "congr",
   "Norm.norm",
   "MonoidWithZero.toZero",
   "SeminormedAddCommGroup.toSeminormedAddGroup",
   "congrArg",
   "BoundedSMul",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "SeminormedAddCommGroup",
   "SeminormedAddGroup.toNorm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SeminormedAddGroup.toAddGroup",
   "Zero.toOfNat0",
   "SeminormedAddCommGroup.toAddCommGroup",
   "SeminormedRing.toNorm",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "Ring.toSub",
   "AddGroup.toAddCancelMonoid",
   "SeminormedAddCommGroup.toNorm",
   "AddCommGroup.toAddGroup",
   "Module",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "AddRightCancelMonoid.toZero",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "dist_eq_norm",
   "sub_smul",
   "Ring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "SeminormedRing",
   "PseudoMetricSpace.toDist",
   "SeminormedRing.toRing",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "smul_sub",
   "NegZeroClass.toZero"],
  "name": "BoundedSMul.of_norm_smul_le",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SeminormedRing α] [inst_1 : SeminormedAddCommGroup β] [inst_2 : Module α β],\n  (∀ (r : α) (x : β), ‖r • x‖ ≤ ‖r‖ * ‖x‖) → BoundedSMul α β",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Not",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_3",
  "constType":
  "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_7",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["OmegaCompletePartialOrder.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
   "iSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "CompleteLattice",
   "instLENat",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "(α : Type u) → [inst : CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Filter",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.univ_mem'",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (∀ (a : α), a ∈ s) → s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoidWithZero",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "Nontrivial",
   "Int",
   "Inv.inv"],
  "name": "CommGroupWithZero.mk",
  "constType":
  "{G₀ : Type u_4} →\n  [toCommMonoidWithZero : CommMonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → CommGroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["Metric.closedBall",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace",
   "UniformSpace.toTopologicalSpace",
   "IsCompact",
   "PseudoMetricSpace"],
  "name": "ProperSpace.mk",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α], (∀ (x : α) (r : ℝ), IsCompact (Metric.closedBall x r)) → ProperSpace α",
  "constCategory": "Other"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["MulZeroOneClass"],
  "name": "MonoidWithZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : MulZeroOneClass M] → [inst : MulZeroOneClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{α : Type u} → [self : Sub α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["continuous_id",
   "DistribLattice.toLattice",
   "isOpen_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "continuous_const",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Set.Ioi",
   "IsOpen"],
  "name": "isOpen_Ioi",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] {a : α},\n  IsOpen (Set.Ioi a)",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "DivisionSemiring.toSemiring",
   "NormedSpace.mk",
   "NormedField",
   "NormedField.toNormedSpace.proof_1",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "Semifield.toDivisionSemiring",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "Semiring.toModule",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup"],
  "name": "NormedField.toNormedSpace",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedSpace α α",
  "constCategory": "Definition"},
 {"references":
  ["Pi.partialOrder.proof_2",
   "Pi.partialOrder.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Pi.partialOrder.proof_3",
   "Preorder.toLT",
   "Pi.preorder",
   "Pi.partialOrder.proof_1",
   "Preorder",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder",
  "constType":
  "{ι : Type u_1} → {π : ι → Type u_2} → [inst : (i : ι) → PartialOrder (π i)] → PartialOrder ((i : ι) → π i)",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_refl",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
  "constType": "∀ {α : Type u_1} (a : MeasurableSpace α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Semiring.toModule.proof_1",
  "constType": "∀ {R : Type u_1} [inst : Semiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "inferInstance",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Submodule",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "Semiring",
   "OrderBot.toBot",
   "OrderBot.bot_le",
   "OrderBot",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_13",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (a : Submodule R M), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Filter",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "UniformSpace.ofDist",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "uniformity",
   "of_eq_true",
   "Real.instAddGroupReal",
   "Prod",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_4",
  "constType": "uniformity ℝ = uniformity ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Real.instLTReal",
   "Subtype.val",
   "Real",
   "Subtype.ext",
   "Eq.refl",
   "Asymptotics.IsBigOWith",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Asymptotics.IsLittleO",
   "rfl",
   "Eq",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427",
   "Subtype.property",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Norm",
   "Eq.mpr",
   "Eq.ndrec",
   "LT.lt",
   "Filter",
   "Eq.symm",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "Asymptotics.IsLittleO_def",
  "constType":
  "∀ {α : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (l : Filter α) (f : α → E)\n  (g : α → F), f =o[l] g = ∀ ⦃c : ℝ⦄, 0 < c → Asymptotics.IsBigOWith c l f g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedAddGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "sub_add_cancel",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id",
   "add_sub_assoc"],
  "name": "sub_add_sub_cancel",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - b + (b - c) = a - c",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "SMulZeroClass",
  "constType":
  "Type u_10 → (A : Type u_11) → [inst : Zero A] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "PseudoMetricSpace.toDist",
   "dist_triangle",
   "dist_comm",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instLEReal",
   "Real",
   "dist_self",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "dist_nonneg",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α}, 0 ≤ dist x y",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.mem_top",
   "Membership.mem",
   "Iff.mp",
   "Filter.instTopFilter",
   "Top.top",
   "Eq.rec",
   "Set",
   "Filter",
   "Eq.symm",
   "Set.univ",
   "Top.mk",
   "Filter.univ_mem",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instCompleteLatticeFilter.proof_11",
  "constType": "∀ {α : Type u_1} (x : Filter α), ∀ _s ∈ ⊤, _s ∈ x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_10",
  "constType":
  "∀ {α : Type u_1} (s : Set (Filter α)ᵒᵈᵒᵈ) (a : (Filter α)ᵒᵈᵒᵈ), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_insert_iff",
   "Membership.mem",
   "Or",
   "propext",
   "Set",
   "Insert.insert",
   "Eq",
   "Set.instInsertSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.63",
  "constType":
  "∀ {α : Type u} {x a : α} {s : Set α}, (x ∈ insert a s) = (x = a ∨ x ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.dist_eq",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.toNormedAddCommGroup",
  "constType":
  "{α : Type u_1} → [β : NonUnitalNormedRing α] → NormedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "Monoid.mk",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Semiring.npow_succ",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "HDiv.hDiv",
   "Real.strictOrderedRing",
   "Semigroup.mk",
   "StrictOrderedRing.toPartialOrder",
   "instHDiv",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "DivInvMonoid.div'",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_6",
  "constType": "∀ (a b : ℝ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "Real.normedField",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedSpace",
   "MeasurableSpace",
   "MeasureTheory.definition._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
   "Subtype",
   "Eq"],
  "name":
  "MeasureTheory.wrapped._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
  "constType": "Subtype (Eq @MeasureTheory.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.zero_le_one",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "SigmaCompactSpace",
  "constType": "(X : Type u_4) → [inst : TopologicalSpace X] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{α : Type u} → BooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.commRing",
   "Eq",
   "Real.instOneReal",
   "Eq.mpr",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "Eq.trans",
   "Ne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.ofCauchy.injEq",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "CommMagma.toMul",
   "CauSeq.Completion.inv_mul_cancel",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Mathlib.Data.Real.Basic._auxLemma.18",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Not",
   "LinearOrderedCommRing.mul_comm",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "Abs.abs",
   "Inv.mk",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "mul_comm",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "CauSeq.Completion.instMulCauchy",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Eq.ndrec",
   "Mathlib.Data.Real.Basic._auxLemma.3",
   "Rat.divisionRing",
   "LinearOrderedCommRing.mk",
   "Real.linearOrderedCommRing",
   "Real.casesOn",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Real.instLinearOrderedFieldReal.proof_10",
  "constType": "∀ (a : ℝ), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toNatCast",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "LinearOrderedField.toRatCast",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Int.natAbs"],
  "name": "LinearOrderedField.ratCast_mk",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Real.field",
   "inferInstance",
   "DivisionRing",
   "Real",
   "Field.toDivisionRing"],
  "name": "Real.instDivisionRingReal",
  "constType": "DivisionRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "NormedRing.dist_eq",
   "NormedCommRing",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_2",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Or",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedRing.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_9",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.Icc",
   "IntervalIntegrable",
   "Real.lattice",
   "Real",
   "Real.measurableSpace",
   "HasSubset.Subset.trans",
   "Set",
   "Set.uIcc",
   "MeasureTheory.IntegrableOn",
   "Set.Icc_subset_uIcc",
   "MeasureTheory.Measure",
   "Set.instHasSubsetSet",
   "Set.Icc_subset_uIcc'",
   "Real.instPreorderReal",
   "Set.Ioc_subset_Icc_self",
   "And.intro",
   "Set.Ioc",
   "MeasureTheory.IntegrableOn.mono_set"],
  "name": "MeasureTheory.IntegrableOn.intervalIntegrable",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ℝ → E} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  MeasureTheory.IntegrableOn f (Set.uIcc a b) → IntervalIntegrable f μ a b",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubNegMonoid.mk",
   "SubNegMonoid.zsmul_zero'",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.innerProductSpace",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "PiLp.seminormedAddCommGroup",
   "DenselyNormedField.toNormedField",
   "OrthonormalBasis",
   "IsROrC",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "ENNReal",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Semiring.toNonAssocSemiring",
   "Fintype",
   "LinearIsometryEquiv",
   "fact_one_le_two_ennreal",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "RingHomInvPair.ids",
   "IsROrC.toDenselyNormedField",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "EuclideanSpace.proof_1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace.toNormedSpace",
   "EuclideanSpace",
   "Field.toEuclideanDomain",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "WithLp.instModule",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "Pi.module",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "OrthonormalBasis.repr",
  "constType":
  "{ι : Type u_1} →\n  {𝕜 : Type u_3} →\n    [inst : IsROrC 𝕜] →\n      {E : Type u_4} →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] → [inst_3 : Fintype ι] → OrthonormalBasis ι 𝕜 E → E ≃ₗᵢ[𝕜] EuclideanSpace 𝕜 ι",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction.mul_smul",
   "Eq.symm",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "smul_smul",
  "constType":
  "∀ {M : Type u_1} {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α] (a₁ a₂ : M) (b : α),\n  a₁ • a₂ • b = (a₁ * a₂) • b",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_exists_eq_and", "Eq"],
  "name": "Mathlib.Logic.Basic._auxLemma.33",
  "constType":
  "∀ {α : Sort u_3} {β : Sort u_2} {f : α → β} {p : β → Prop}, (∃ b, (∃ a, f a = b) ∧ p b) = ∃ a, p (f a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And", "and_iff_left_of_imp", "Iff"],
  "name": "and_iff_left",
  "constType": "∀ {b a : Prop}, b → (a ∧ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "SMul",
   "Monoid",
   "Monoid.toOne",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "One.toOfNat1",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mk",
  "constType":
  "{α : Type u_10} →\n  {β : Type u_11} →\n    [inst : Monoid α] →\n      [toSMul : SMul α β] → (∀ (b : β), 1 • b = b) → (∀ (x y : α) (b : β), (x * y) • b = x • y • b) → MulAction α β",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "nhds",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Eq.refl",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAt._eq_1",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  (f' : E →L[𝕜] F) (x : E), HasFDerivAt f f' x = HasFDerivAtFilter f f' x (nhds x)",
  "constCategory": "Theorem"},
 {"references": ["Field", "NormedField"],
  "name": "NormedField.toField",
  "constType": "{α : Type u_5} → [self : NormedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "setOf",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "Set.compl_subset_compl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet"],
  "name": "Bornology.ofBounded.proof_2",
  "constType":
  "∀ {α : Type u_1} (B : Set (Set α)), (∀ s₁ ∈ B, ∀ s₂ ⊆ s₁, s₂ ∈ B) → ∀ {x y : Set α}, x ∈ {s | sᶜ ∈ B} → x ⊆ y → yᶜ ∈ B",
  "constCategory": "Theorem"},
 {"references": ["Max", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toMax",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → Max α",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Int"],
  "name": "DivisionRing.zpow",
  "constType": "{K : Type u} → [self : DivisionRing K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZeroHomClass",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] → [self : MonoidWithZeroHomClass F M N] → MonoidHomClass F M N",
  "constCategory": "Definition"},
 {"references": ["CanonicallyOrderedCommSemiring", "Nat"],
  "name": "CanonicallyOrderedCommSemiring.npow",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Eq.refl",
   "congrArg₂",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Eq",
   "Eq.mpr",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "Eq.trans",
   "id",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "HMul.hMul"],
  "name": "two_mul",
  "constType":
  "∀ {α : Type u} [inst : NonAssocSemiring α] (n : α), 2 * n = n + n",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
   "AddCommMonoid.mk",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalCommSemiring.mk",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [s : NonUnitalCommRing α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} → [inst : AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1375",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IntCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "MeasurableSpace",
  "constType": "Type u_7 → Type u_7",
  "constCategory": "Other"},
 {"references":
  ["StrictMono.compares",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Function.Injective",
   "Ordering.Compares",
   "Preorder.toLT",
   "Ordering.eq",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Eq"],
  "name": "StrictMono.injective",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "instHAdd",
   "HAdd.hAdd",
   "Function.Injective.addMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddCommSemigroup.add_comm",
   "AddMonoid.mk",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq",
   "Zero.toOfNat0",
   "Function.Injective.addCommSemigroup",
   "AddMonoid.nsmul_zero",
   "AddCommMonoid.mk",
   "Function.Injective",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "AddCommSemigroup",
   "HSMul.hSMul",
   "AddMonoid.zero_add",
   "AddCommSemigroup.toAddSemigroup",
   "Add",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "Function.Injective.addCommMonoid",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddCommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCommMonoid M₁",
  "constCategory": "Definition"},
 {"references": ["One", "OneHom"],
  "name": "OneHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : One M] → [inst_1 : One N] → OneHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "CompactIccSpace.isCompact_Icc",
   "Set.Icc",
   "Metric.closedBall",
   "instHAdd",
   "Set",
   "Real",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Eq.refl",
   "Real.pseudoMetricSpace",
   "ConditionallyCompleteLinearOrder.toCompactIccSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Real.instPreorderReal",
   "ProperSpace",
   "UniformSpace.toTopologicalSpace",
   "IsCompact",
   "Real.closedBall_eq_Icc",
   "ProperSpace.mk",
   "id"],
  "name": "instProperSpaceRealPseudoMetricSpace",
  "constType": "ProperSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "SetLike.instPartialOrder",
   "inferInstance",
   "PartialOrder.toPreorder",
   "Submodule",
   "Top.top",
   "Semiring",
   "OrderTop.le_top",
   "OrderTop",
   "Module",
   "LE.le",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_12",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (a : Submodule R M), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.toReal",
   "Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real.instLEReal",
   "Real",
   "ENNReal.ofReal",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "ENNReal.coe_nnreal_eq",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "Subtype.mk",
   "ENNReal.ofNNReal",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_3",
  "constType":
  "∀ (x y : ℝ),\n  ↑{ val := |x - y|, property := (_ : 0 ≤ |x - y|) } = ENNReal.ofReal ↑{ val := |x - y|, property := (_ : 0 ≤ |x - y|) }",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "Or",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedAddCommGroup.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "not_congr",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Nat.cast_ne_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{α : Type u_1} → [toLattice : Lattice α] → (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) → DistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd", "AddSubmonoid", "AddZeroClass", "AddSubsemigroup"],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_4} → [inst : AddZeroClass M] → AddSubmonoid M → AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "NatCast.natCast",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "instHMul",
   "AddZeroClass.toZero",
   "MonoidHom.toOneHom",
   "HMul.hMul",
   "OneHom.mk",
   "MonoidHom.mk",
   "id"],
  "name": "RingHom.id.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : NonAssocSemiring α],\n  OneHom.toFun\n      (↑{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ∀ (x y : α),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      0 =\n    OneHom.toFun\n      (↑{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ∀ (x y : α),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "NormedRing",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_1",
  "constType": "∀ {α : Type u_1} [β : NormedRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "lt_add_of_pos_right",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "ENNReal.ofReal",
   "Real.instAddMonoidReal",
   "NormedLatticeAddCommGroup.orderClosedTopology",
   "AddGroup.toSubtractionMonoid",
   "Real.instOneReal",
   "AddZeroClass.toZero",
   "ENNReal",
   "Real.linearOrder",
   "MeasureTheory.OuterMeasure.measureOf",
   "Real.measureSpace",
   "Filter",
   "Eq.trans",
   "instHSub",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.Ioo",
   "Real.partialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "sub_lt_self",
   "OrderedSemiring.zeroLEOneClass",
   "PseudoMetricSpace.toUniformSpace",
   "Real.orderedSemiring",
   "And",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "Real.instAddGroupReal",
   "And.intro",
   "congrArg",
   "Real.normedLatticeAddCommGroup",
   "congrFun",
   "AddZeroClass.toAdd",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Real",
   "Set",
   "IsOpen.mem_nhds",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "Real.volume_Ioo",
   "MeasureTheory.IsLocallyFiniteMeasure.mk",
   "Preorder.toLT",
   "AddGroup.toAddCancelMonoid",
   "zero_lt_one",
   "isOpen_Ioo",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "instMembershipSetFilter",
   "Membership.mem",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Top.top",
   "nhds",
   "instHAdd",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Real.instPreorderReal",
   "CompleteLattice.toTop",
   "SubNegMonoid.toAddMonoid",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.1",
   "NegZeroClass.toZero"],
  "name": "Real.locallyFinite_volume",
  "constType": "MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.volume",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalAddGroup.to_continuousSub",
   "SeminormedAddCommGroup.toTopologicalAddGroup",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "OrderClosedTopology.mk",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NormedLatticeAddCommGroup",
   "OrderClosedTopology",
   "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "isClosed_nonneg",
   "isClosed_le_of_isClosed_nonneg",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedAddCommGroup.toNormedAddGroup",
   "UniformSpace.toTopologicalSpace"],
  "name": "NormedLatticeAddCommGroup.orderClosedTopology",
  "constType":
  "∀ {E : Type u_2} [inst : NormedLatticeAddCommGroup E], OrderClosedTopology E",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "LE.le.trans",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mul_le_mul_of_nonneg_right",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulPosMono",
   "MulZeroClass.toMul"],
  "name": "mul_le_mul",
  "constType":
  "∀ {α : Type u_1} {a b c d : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α]\n  [inst_3 : MulPosMono α], a ≤ b → c ≤ d → 0 ≤ c → 0 ≤ b → a * c ≤ b * d",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "NormedSpace.boundedSMul",
   "AddMonoid.toZero",
   "ContinuousSMul",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Module.toMulActionWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "MulActionWithZero.toSMulWithZero",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "BoundedSMul.continuousSMul"],
  "name": "HasDerivAtFilter.proof_2",
  "constType":
  "∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F], ContinuousSMul 𝕜 F",
  "constCategory": "Theorem"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Preorder.le_refl",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_1",
  "constType": "∀ {α : Type u_1} (a : (Filter α)ᵒᵈᵒᵈ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Field.mk",
   "LinearOrderedField.qsmul",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedRing.toNontrivial",
   "LinearOrderedField.inv_zero",
   "CommRing.mk",
   "LinearOrderedField.toDiv",
   "LinearOrderedField.ratCast_mk",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "Field",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedField.toRatCast",
   "LinearOrderedField.qsmul_eq_mul'",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "LinearOrderedField.zpow_neg'"],
  "name": "LinearOrderedField.toField",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "Left.nonneg_neg_iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonneg",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Add M] →\n        [inst_1 : Add N] →\n          [toFunLike : FunLike F M fun x => N] → (∀ (f : F) (x y : M), f (x + y) = f x + f y) → AddHomClass F M N",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Real.instDistribLatticeReal.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Inf.inf",
   "Real",
   "Real.instLEReal",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "Real.instSupReal",
   "Lattice.mk",
   "Real.instDistribLatticeReal.proof_5",
   "Real.instDistribLatticeReal.proof_6",
   "Sup.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "Inf.mk",
   "DistribLattice",
   "Real.instDistribLatticeReal.proof_8",
   "Real.instDistribLatticeReal.proof_2",
   "Real.instDistribLatticeReal.proof_10",
   "Real.instDistribLatticeReal.proof_9",
   "Preorder.toLT",
   "Real.instDistribLatticeReal.proof_1",
   "Real.instDistribLatticeReal.proof_3",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.instDistribLatticeReal.proof_7"],
  "name": "Real.instDistribLatticeReal",
  "constType": "DistribLattice ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["wrapped._@.Mathlib.Topology.Basic._hyg.10659",
   "TopologicalSpace",
   "Filter"],
  "name": "nhds",
  "constType": "{α : Type u_1} → [inst : TopologicalSpace α] → α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], Nontrivial α",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace"],
  "name": "SecondCountableTopologyEither",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → Prop",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace", "MeasurableSpace"],
  "name": "OpensMeasurableSpace",
  "constType":
  "(α : Type u_6) → [inst : TopologicalSpace α] → [h : MeasurableSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalNormedRing.toNonUnitalRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq",
   "Dist.dist",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalNormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Div"],
  "name": "DivisionRing.toDiv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} → [self : Ring R] → Sub R",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring"],
  "name": "StarRing",
  "constType": "(R : Type u) → [inst : NonUnitalNonAssocSemiring R] → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "Real.commRing",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "AddMonoid.toAddZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "AddMonoidHom.id",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "eq_self",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_7",
  "constType":
  "∀ (z w : ℝ), 0 = (AddMonoidHom.id ℝ) z * 0 + 0 * (AddMonoidHom.id ℝ) w",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "zero_lt_two",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "two_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{α : Type u_1} → {ι : Sort u_4} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "RingHom",
   "MulOneClass.toMul",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "MonoidHom.map_mul'",
   "HMul.hMul",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (x_2 y : α),\n  OneHom.toFun (↑↑f) (x_2 * y) = OneHom.toFun (↑↑f) x_2 * OneHom.toFun (↑↑f) y",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Semiring",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddSubmonoid",
   "AddCommMonoid"],
  "name": "Submodule.toAddSubmonoid",
  "constType":
  "{R : Type u} →\n  {M : Type v} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Submodule R M → AddSubmonoid M",
  "constCategory": "Definition"},
 {"references":
  ["BorelSpace",
   "BorelSpace.mk",
   "Real.measurableSpace",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "MeasurableSpace",
   "rfl"],
  "name": "Real.borelSpace",
  "constType": "BorelSpace ℝ",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["SecondCountableTopologyEither",
   "inferInstance",
   "SecondCountableTopology",
   "Or.inl",
   "TopologicalSpace",
   "SecondCountableTopologyEither.mk"],
  "name": "secondCountableTopologyEither_of_left",
  "constType":
  "∀ (α : Type u_6) (β : Type u_7) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : SecondCountableTopology α], SecondCountableTopologyEither α β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "StrictOrderedRing.toNontrivial",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "HMul.hMul",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_1",
  "constType": "∀ (a b c : ℝ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "mem_interior_iff_mem_nhds",
   "WeaklyLocallyCompactSpace",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "Exists.intro",
   "Set.univ",
   "isOpen_univ",
   "Set.instMembershipSet",
   "LocallyCompactSpace",
   "And",
   "Set.instHasSubsetSet",
   "Iff.mp",
   "exists_compact_subset",
   "WeaklyLocallyCompactSpace.mk",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsCompact",
   "Set.mem_univ",
   "instWeaklyLocallyCompactSpace_1.match_1",
   "interior",
   "instMembershipSetFilter"],
  "name": "instWeaklyLocallyCompactSpace_1",
  "constType":
  "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X], WeaklyLocallyCompactSpace X",
  "constCategory": "Definition"},
 {"references": ["SMul", "Monoid", "MulAction"],
  "name": "MulAction.toSMul",
  "constType":
  "{α : Type u_10} → {β : Type u_11} → [inst : Monoid α] → [self : MulAction α β] → SMul α β",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "AddHomClass",
   "SemilinearMapClass",
   "Semiring",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "SemilinearMapClass.toAddHomClass",
  "constType":
  "{F : Type u_17} →\n  {R : outParam (Type u_18)} →\n    {S : outParam (Type u_19)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          {σ : outParam (R →+* S)} →\n            {M : outParam (Type u_20)} →\n              {M₂ : outParam (Type u_21)} →\n                [inst_2 : AddCommMonoid M] →\n                  [inst_3 : AddCommMonoid M₂] →\n                    [inst_4 : Module R M] →\n                      [inst_5 : Module S M₂] → [self : SemilinearMapClass F σ M M₂] → AddHomClass F M M₂",
  "constCategory": "Definition"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "constCategory": "Other"},
 {"references": ["AddZeroClass"],
  "name": "AddSubmonoid",
  "constType": "(M : Type u_4) → [inst : AddZeroClass M] → Type u_4",
  "constCategory": "Other"},
 {"references": ["SMul"],
  "name": "IsScalarTower",
  "constType":
  "(M : Type u_10) → (N : Type u_11) → (α : Type u_12) → [inst : SMul M N] → [inst : SMul N α] → [inst : SMul M α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Filter", "instMembershipSetFilter"],
  "name": "Filter.Eventually",
  "constType": "{α : Type u} → (α → Prop) → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "Ring.toNeg",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "HAdd.hAdd",
   "Ring.toIntCast",
   "Ring",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "Ring.toSemiring",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra.smul_def'",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = (algebraMap R A) r * x",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "TopologicalSpace.induced"],
  "name": "instTopologicalSpaceProd",
  "constType":
  "{α : Type u} → {β : Type v} → [t₁ : TopologicalSpace α] → [t₂ : TopologicalSpace β] → TopologicalSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Real.instAddCommGroupReal",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "Real.metricSpace",
   "Real",
   "Real.normedAddCommGroup.proof_1",
   "Real.norm"],
  "name": "Real.normedAddCommGroup",
  "constType": "NormedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.add_left_neg",
  "constType": "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.765",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "∀ {α : Type u_1} (a : Set α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubNegZeroMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "HAdd.hAdd",
   "Set",
   "Set.inter_comm",
   "LinearMap.instFunLike",
   "Inter.inter",
   "RingHom.id",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Mathlib.MeasureTheory.Measure.Restrict._auxLemma.1",
   "MeasurableSet",
   "Eq.trans",
   "LinearMap",
   "Semiring.toModule",
   "id",
   "Mathlib.MeasureTheory.Measure.Restrict._auxLemma.2",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "instHAdd",
   "MeasureTheory.le_toOuterMeasure_caratheodory",
   "Set.instSDiffSet",
   "MeasureTheory.OuterMeasure.restrict_apply",
   "SDiff.sdiff",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "congr",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "congrArg",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.restrict",
   "MeasurableSpace",
   "Set.instInterSet"],
  "name": "MeasureTheory.Measure.restrictₗ.proof_1",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (s : Set α) (μ : MeasureTheory.Measure α) (s' : Set α),\n  MeasurableSet s' →\n    ∀ (t : Set α),\n      ↑((MeasureTheory.OuterMeasure.restrict s) ↑μ) t =\n        ↑((MeasureTheory.OuterMeasure.restrict s) ↑μ) (t ∩ s') + ↑((MeasureTheory.OuterMeasure.restrict s) ↑μ) (t \\ s')",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup",
   "CompleteSpace",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Real",
   "Real.normedField",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "deriv",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Eq",
   "HasDerivAt.deriv",
   "HasStrictDerivAt.hasDerivAt",
   "Continuous",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.measureSpace",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "Continuous.integral_hasStrictDerivAt",
   "DenselyNormedField.toNontriviallyNormedField",
   "Real.denselyNormedField"],
  "name": "Continuous.deriv_integral",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] (f : ℝ → E),\n  Continuous f → ∀ (a b : ℝ), deriv (fun u => ∫ (x : ℝ) in a..u, f x) b = f b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "IsROrC.toDenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedField.toNormedCommRing",
   "NormedAlgebra",
   "semiOutParam"],
  "name": "IsROrC.toNormedAlgebra",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → NormedAlgebra ℝ K",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "OrderedCommMonoid.toCovariantClassLeft",
   "Zero.toOfNat0",
   "mul_le_mul_left'",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder"],
  "name": "Real.instPreorderReal",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Neg.toHasAbs",
   "instHSub",
   "Set",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Eq.refl",
   "Bornology.cobounded",
   "Real.instSupReal",
   "abs_sub_le",
   "Real.instLinearOrderedAddCommGroupReal",
   "Abs.abs",
   "Eq",
   "Real.instNegReal",
   "Real.linearOrder",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "abs_sub_comm"],
  "name": "Real.pseudoMetricSpace.proof_5",
  "constType": "(Bornology.cobounded ℝ).sets = (Bornology.cobounded ℝ).sets",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references": ["NormedAddCommGroup", "IsROrC"],
  "name": "InnerProductSpace",
  "constType":
  "(𝕜 : Type u_4) → (E : Type u_5) → [inst : IsROrC 𝕜] → [inst : NormedAddCommGroup E] → Type (max u_4 u_5)",
  "constCategory": "Other"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.6260",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.6260",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "Module.toMulActionWithZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsScalarTower",
   "NormedSpace",
   "NormedField.toField",
   "Monoid.toMulAction",
   "DivisionSemiring.toSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "HasStrictDerivAt.proof_1",
  "constType":
  "∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F], IsScalarTower 𝕜 𝕜 F",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule",
   "Semiring",
   "Set.insert_eq",
   "Union.union",
   "Set",
   "Eq.refl",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.completeLattice",
   "Submodule.span",
   "Insert.insert",
   "Submodule.span_union",
   "Eq",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Eq.ndrec",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Sup.sup",
   "Singleton.singleton",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.instUnionSet",
   "id",
   "AddCommMonoid",
   "Set.instInsertSet"],
  "name": "Submodule.span_insert",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x : M)\n  (s : Set M), Submodule.span R (insert x s) = Submodule.span R {x} ⊔ Submodule.span R s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "LT.lt.not_le",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "GT.gt",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "le_of_not_gt",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "mul_neg_of_pos_of_neg",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "MonoidWithZero.toZero"],
  "name": "nonneg_of_mul_nonneg_right",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α] {a b : α}, 0 ≤ a * b → 0 < a → 0 ≤ b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Add M] → [inst_1 : Add N] → [self : AddHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["StronglyMeasurableAtFilter",
   "CompleteSpace",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Real.measurableSpace",
   "Real.normedField",
   "Real",
   "Inf.inf",
   "continuousAt_fst",
   "NormedSpace",
   "intervalIntegral.FTCFilter.nhds",
   "MeasureTheory.MeasureSpace.volume",
   "NormedRing.toNonUnitalNormedRing",
   "Filter.Tendsto",
   "Real.measureSpace",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "MeasureTheory.Measure.ae",
   "continuousAt_snd",
   "Real.denselyNormedField",
   "IntervalIntegrable",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HasStrictDerivAt",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Prod.fst",
   "NormedField.toNormedCommRing",
   "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Prod.mk",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Filter.instInfFilter",
   "Prod",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_right",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E} {c : E}\n  {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b →\n    StronglyMeasurableAtFilter f (nhds b) →\n      Filter.Tendsto f (nhds b ⊓ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) →\n        HasStrictDerivAt (fun u => ∫ (x : ℝ) in a..u, f x) c b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra.smul_def'",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.id",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.id.proof_2",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (r x : 𝕜), r • x = Algebra.toRingHom r * x",
  "constCategory": "Theorem"},
 {"references": ["DenselyNormedField", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDenselyNormedField",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → DenselyNormedField K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Abs", "Abs.mk", "Sup", "Neg.neg", "Sup.sup", "Neg"],
  "name": "Neg.toHasAbs",
  "constType": "{α : Type u_1} → [inst : Neg α] → [inst : Sup α] → Abs α",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "Subtype"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instHSMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Submodule.subset_span",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "one_smul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "AddCommMonoid",
   "add_smul",
   "Submodule.smul_mem",
   "Semiring",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Iff.intro",
   "instHMul",
   "MulActionWithZero.toSMulWithZero",
   "MulAction.toSMul",
   "of_eq_true",
   "HEq.refl",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Singleton.singleton",
   "MonoidWithZero.toZero",
   "congrArg",
   "Submodule.setLike",
   "congrFun",
   "zero_smul",
   "Exists",
   "HEq",
   "Submodule",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "Submodule.span",
   "True",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "AddMonoid.toZero",
   "Module",
   "smul_smul",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "Membership.mem",
   "eq_self",
   "instHAdd",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Eq.ndrec",
   "Submodule.span_induction",
   "HMul.hMul",
   "Eq.casesOn"],
  "name": "Submodule.mem_span_singleton",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x y : M},\n  x ∈ Submodule.span R {y} ↔ ∃ a, a • y = x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddZeroClass M] (x x_1 : M),\n  ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1) =\n    ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "mul_le_mul_of_nonneg_left",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toPosMulMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x_2 * x ≤ x_2 * x_1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : SProd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_add_one",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddMonoidWithOne",
   "Eq.mpr",
   "NeZero",
   "one_add_one_eq_two",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "LT.lt",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "id"],
  "name": "one_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], 1 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "False.elim",
   "EmptyCollection.emptyCollection",
   "Real.instLEReal",
   "Set",
   "Real",
   "Set.instEmptyCollectionSet",
   "Exists.intro",
   "LE.le",
   "Set.instMembershipSet"],
  "name": "Bornology.ofDist.proof_1",
  "constType":
  "∀ {α : Type u_1} (dist : α → α → ℝ), ∃ C, ∀ ⦃x : α⦄, x ∈ ∅ → ∀ ⦃y : α⦄, y ∈ ∅ → dist x y ≤ C",
  "constCategory": "Theorem"},
 {"references":
  ["Real.borelSpace",
   "pure_le_nhds",
   "tendstoIocClassNhds",
   "PartialOrder.toPreorder",
   "nhds",
   "Real",
   "Real.measurableSpace",
   "intervalIntegral.FTCFilter.mk",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "le_rfl",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "BorelSpace.opensMeasurable",
   "outParam",
   "intervalIntegral.FTCFilter",
   "Real.instPreorderReal",
   "Filter.instPartialOrderFilter",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "nhds_isMeasurablyGenerated"],
  "name": "intervalIntegral.FTCFilter.nhds",
  "constType": "∀ (a : ℝ), intervalIntegral.FTCFilter a (nhds a) (nhds a)",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "Set.instHasSubsetSet",
   "setOf",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "HasSubset.Subset",
   "Module",
   "Submodule.setLike",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) →\n  {M : Type u_4} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Set M → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nhds",
   "Set",
   "ContinuousAt",
   "Set.univ",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Logic.Basic._auxLemma.43",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Continuous",
   "TopologicalSpace",
   "congr",
   "Filter",
   "Filter.Tendsto",
   "nhdsWithin",
   "ContinuousOn",
   "congrArg",
   "Eq.trans",
   "Mathlib.Topology.ContinuousOn._auxLemma.29",
   "nhdsWithin_univ",
   "congrFun"],
  "name": "continuous_iff_continuousOn_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f ↔ ContinuousOn f Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "InvolutiveNeg.neg_neg",
   "Neg.neg",
   "Eq"],
  "name": "neg_neg",
  "constType": "∀ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "And",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "DenselyNormedField",
   "DenselyNormedField.toNormedField",
   "Norm.norm",
   "LE.le",
   "NormedField.toNorm"],
  "name": "DenselyNormedField.lt_norm_lt",
  "constType":
  "∀ {α : Type u_5} [self : DenselyNormedField α] (x y : ℝ), 0 ≤ x → x < y → ∃ a, x < ‖a‖ ∧ ‖a‖ < y",
  "constCategory": "Definition"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "CommRing.toRing",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "CommRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "CommRing.toNonUnitalCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "LinearOrder.decidableLE",
   "LinearOrder.max_def",
   "Field.toNontrivial",
   "Field.zpow_neg'",
   "Field.zpow",
   "Field.toRatCast",
   "Rat.instLinearOrderedFieldRat.proof_2",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Field.mul_inv_cancel",
   "Field",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Rat.linearOrder",
   "Field.ratCast_mk",
   "LinearOrder",
   "Semiring",
   "StrictOrderedRing.mk",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Field.toInv",
   "Rat.semiring",
   "Rat.field",
   "Rat.instLinearOrderedFieldRat.proof_1",
   "LinearOrder.toOrd",
   "Rat.instLinearOrderedFieldRat.proof_3",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "Field.inv_zero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "Field.qsmul",
   "LinearOrderedRing.mk",
   "Rat.instLinearOrderedFieldRat.proof_4",
   "Field.div_eq_mul_inv"],
  "name": "Rat.instLinearOrderedFieldRat",
  "constType": "LinearOrderedField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "LinearOrderedRing",
   "DecidableEq",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedRing : StrictOrderedRing α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "SemilatticeSup.le_sup_right",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_6",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1339", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.mul",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Not",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
  "constType":
  "∀ {α : Type u_1} (a b : MeasurableSpace α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.le_sSup",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "CompleteLattice.sInf_le",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "Preorder.toLE",
   "OrderTop.toTop",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "OrderDual.completeLattice.proof_4",
   "CompleteLattice.sSup_le",
   "OrderDual.completeLattice.proof_1",
   "Lattice.toSemilatticeSup",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "OrderDual.completeLattice.proof_2",
   "OrderDual.infSet",
   "InfSet",
   "OrderDual.completeLattice.proof_5",
   "SupSet.sSup",
   "OrderDual.instLEOrderDual",
   "OrderDual.supSet",
   "OrderDual.boundedOrder",
   "SupSet",
   "InfSet.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice.proof_3",
   "OrderBot.toBot",
   "OrderDual",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "OrderDual.lattice"],
  "name": "OrderDual.completeLattice",
  "constType":
  "(α : Type u_1) → [inst : CompleteLattice α] → CompleteLattice αᵒᵈ",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "NontriviallyNormedField",
   "NontriviallyNormedField.toNormedField",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "HasDerivAt.differentiableAt",
   "deriv",
   "DifferentiableAt.hasDerivAt",
   "NormedSpace",
   "HasDerivAt",
   "Eq",
   "HasDerivAt.unique"],
  "name": "HasDerivAt.deriv",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasDerivAt f f' x → deriv f x = f'",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "Real.measurableSpace",
   "Real",
   "StieltjesFunction",
   "StieltjesFunction.wrapped._@.Mathlib.MeasureTheory.Measure.Stieltjes._hyg.3510"],
  "name": "StieltjesFunction.measure",
  "constType": "StieltjesFunction → MeasureTheory.Measure ℝ",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "SMulWithZero",
  "constType":
  "(R : Type u_1) → (M : Type u_3) → [inst : Zero R] → [inst : Zero M] → Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references": ["Filter", "Bornology"],
  "name": "Bornology.cobounded'",
  "constType": "{α : Type u_4} → [self : Bornology α] → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "EmptyCollection.emptyCollection",
   "false_or_iff",
   "Union.union",
   "Set",
   "Set.instEmptyCollectionSet",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.empty_union",
  "constType": "∀ {α : Type u} (a : Set α), ∅ ∪ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Bot.bot",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.bot_le",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteLattice.toBot",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_12",
  "constType": "∀ {α : Type u_1} (x : (Filter α)ᵒᵈᵒᵈ), ⊥ ≤ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PseudoMetricSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "ENNReal.covariantClass_add_le",
   "OrderedSemiring.zeroLEOneClass",
   "instENNRealAddCommMonoidWithOne",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "one_le_two",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "Preorder.toLE",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Fact.mk",
   "OrderedCommSemiring.toOrderedSemiring",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Fact",
   "instOfNat"],
  "name": "fact_one_le_two_ennreal",
  "constType": "Fact (1 ≤ 2)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{α : Type u_1} → SupSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.re",
   "Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC.conj_re",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "IsROrC.ext",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Mathlib.Tactic.Ring.neg_congr",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "IsROrC.mul_re",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.sub_pf",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "Monoid.toNatPow",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Ring.toAddGroupWithOne",
   "IsROrC.toDenselyNormedField",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "AddHomClass.toFunLike",
   "MonoidHomClass.toMulHomClass",
   "Mathlib.Tactic.Ring.mul_add",
   "Field.toSemifield",
   "Neg.neg",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "AddMonoidHom",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Real.instSubReal",
   "Semifield.toCommSemiring",
   "Real.instAddReal",
   "Real.commRing",
   "MulZeroClass.mul_zero",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "IsROrC.ofReal_re",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "IsROrC.conj_im",
   "MonoidWithZeroHom",
   "Nat",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.rawCast",
   "IsROrC.normSq",
   "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "EuclideanDomain.toCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Field.toEuclideanDomain",
   "CommRing.toRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.im",
   "Int.ofNat",
   "IsROrC.ofReal_im",
   "RingHom",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "CommRing.toNonUnitalCommRing",
   "IsROrC.toStarRing",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoid.toAddMonoid",
   "IsROrC.ofReal_add",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "starRingEnd",
   "instHPow",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "instHAdd",
   "HSub.hSub",
   "map_add",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "IsROrC.ofReal_mul",
   "IsROrC.ofReal",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "AddMonoidHom.addMonoidHomClass",
   "IsROrC.mul_im"],
  "name": "IsROrC.mul_conj",
  "constType":
  "∀ {K : Type u_1} [inst : IsROrC K] (z : K), z * (starRingEnd K) z = ↑(IsROrC.normSq z)",
  "constCategory": "Theorem"},
 {"references": ["Field", "RatCast"],
  "name": "Field.toRatCast",
  "constType": "{K : Type u} → [self : Field K] → RatCast K",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mk",
  "constType":
  "{α : Type u} → [toRing : Ring α] → (∀ (a b : α), a * b = b * a) → CommRing α",
  "constCategory": "Other"},
 {"references": ["NormedAddCommGroup", "NormedLatticeAddCommGroup"],
  "name": "NormedLatticeAddCommGroup.toNormedAddCommGroup",
  "constType":
  "{α : Type u_1} → [self : NormedLatticeAddCommGroup α] → NormedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "CommGroupWithZero",
   "Semifield.toCommSemiring",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "Semifield.mul_inv_cancel",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semifield",
   "Semifield.toInv",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Semifield.toNontrivial",
   "CommMonoidWithZero.mk",
   "CommMonoid.mk",
   "Semigroup.mk",
   "CommGroupWithZero.mk",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "Semifield.zpow_zero'",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references": ["le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_rfl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "AddZeroClass.toAdd",
   "Submodule.completeLattice.proof_5",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "AddSubsemigroup.mk",
   "PartialOrder.toPreorder",
   "Submodule",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SupSet.mk",
   "AddCommMonoid.toAddMonoid",
   "Submodule.completeLattice.proof_11",
   "Lattice.mk",
   "OrderBot",
   "Submodule.completeLattice.proof_2",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Submodule.completeLattice.proof_6",
   "Submodule.completeLattice.proof_13",
   "Preorder.toLE",
   "OrderTop.toTop",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "inferInstance",
   "Inf.mk",
   "Submodule.completeLattice.proof_9",
   "Submodule.completeLattice.proof_1",
   "Submodule.completeLattice.proof_4",
   "AddSubmonoid.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "Semiring",
   "SemilatticeSup.mk",
   "Submodule.completeLattice.proof_8",
   "LE.le",
   "Submodule.completeLattice.proof_12",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "CompleteLattice",
   "Submodule.completeLattice.proof_10",
   "Submodule.completeLattice.proof_3",
   "OrderBot.toBot",
   "Submodule.mk",
   "Set.iInter",
   "OrderTop",
   "Submodule.completeLattice.proof_7",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → CompleteLattice (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u_1} → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Decidable", "LinearOrder.decidableEq", "Eq"],
  "name": "instDecidableEq",
  "constType":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set.compl_subset_compl",
   "MeasurableSpace",
   "MeasureTheory.measure_mono_null"],
  "name": "MeasureTheory.Measure.ae.proof_2",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) {x y : Set α},\n  x ∈ {s | ↑↑μ sᶜ = 0} → x ⊆ y → ↑↑μ yᶜ = 0",
  "constCategory": "Theorem"},
 {"references": ["UniformSpace"],
  "name": "CompleteSpace",
  "constType": "(α : Type u) → [inst : UniformSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{α : Type u} → [inst : NonUnitalNonAssocRing α] → HasDistribNeg α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Set",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAtFilter",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "nhdsWithin",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivWithinAt",
  "constType":
  "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → (E →L[𝕜] F) → Set E → E → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "Metric.closedBall",
   "Real.instLEReal",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSupReal",
   "abs_sub_le_iff",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "instHSub",
   "instDistribLattice",
   "Set.mem_Icc",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "propext",
   "OrderedAddCommGroup.toAddCommGroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Set.Icc",
   "sub_le_iff_le_add'",
   "Real.dist_eq",
   "dist_comm",
   "Iff.rfl",
   "Real",
   "Set",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Metric.mem_closedBall",
   "Abs.abs",
   "Real.instNegReal",
   "Set.ext",
   "Real.instAddCommGroupReal",
   "sub_le_comm",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "Membership.mem",
   "instHAdd",
   "HSub.hSub",
   "Real.pseudoMetricSpace",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "PseudoMetricSpace.toDist",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg"],
  "name": "Real.closedBall_eq_Icc",
  "constType": "∀ {x r : ℝ}, Metric.closedBall x r = Set.Icc (x - r) (x + r)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{α : Type u_4} → (val : Multiset α) → Multiset.Nodup val → Finset α",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.OuterMeasure.addCommMonoid",
   "MeasureTheory.Measure.zero_toOuterMeasure",
   "MeasureTheory.Measure.add_toOuterMeasure",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MeasureTheory.Measure.instAddCommMonoid.proof_2",
   "AddMonoid.toNatSMul",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "MeasureTheory.Measure.instAdd",
   "MeasureTheory.Measure.instAddCommMonoid.proof_1",
   "Function.Injective.addCommMonoid",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "AddCommMonoid"],
  "name": "MeasureTheory.Measure.instAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → AddCommMonoid (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Submodule",
   "Semiring",
   "Finset.toSet",
   "Finset",
   "Module",
   "Submodule.span",
   "Eq",
   "AddCommMonoid"],
  "name": "Submodule.FG",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Submodule R M → Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Ord"],
  "name": "LinearOrderedAddCommGroup.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommRing α",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "HasStrictFDerivAt",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "HasStrictDerivAt.proof_1",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "HasStrictDerivAt.proof_2",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasStrictDerivAt",
  "constType":
  "{𝕜 : Type u} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {F : Type v} → [inst_1 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (𝕜 → F) → F → 𝕜 → Prop",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Norm", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup",
   "Real",
   "Real.normedField",
   "Real.measurableSpace",
   "HSub.hSub",
   "MeasureTheory.Measure.restrict",
   "NormedSpace",
   "AddGroup.toSubNegMonoid",
   "MeasureTheory.integral",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.instPreorderReal",
   "NormedAddCommGroup.toNormedAddGroup",
   "Set.Ioc"],
  "name": "intervalIntegral",
  "constType":
  "{E : Type u_3} →\n  [inst : NormedAddCommGroup E] → [inst : NormedSpace ℝ E] → (ℝ → E) → ℝ → ℝ → MeasureTheory.Measure ℝ → E",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references": ["continuous_id", "Continuous", "TopologicalSpace"],
  "name": "continuous_id'",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α], Continuous fun x => x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "NormedField",
   "Real.instMulReal",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Dist.dist",
   "Field.toCommRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Field",
   "Ring.toSub",
   "CommRing.toRing",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedField.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toField : Field α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ = ‖a‖ * ‖b‖) → NormedField α",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8834",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8800",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toCompletelyDistribLattice : CompletelyDistribLattice α] →\n    (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) →\n      [toHasCompl : HasCompl α] →\n        [toSDiff : SDiff α] →\n          [toHImp : HImp α] →\n            (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n              (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                  autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ →\n                    (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) →\n                      (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteAtomicBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toSubNegMonoid : SubNegMonoid G] →\n    (∀ (x : G), - -x = x) → (∀ (a b : G), -(a + b) = -b + -a) → (∀ (a b : G), a + b = 0 → -a = b) → SubtractionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "NormedSpace",
   "Asymptotics.IsLittleO",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "NormedAddGroup.toAddGroup",
   "HasFDerivAtFilter",
   "Filter",
   "NormedAddCommGroup.toNorm",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "instHSub",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNormedAddGroup",
   "NormedSpace.toModule",
   "ContinuousMapClass.toFunLike"],
  "name":
  "_private.Mathlib.Analysis.Calculus.FDeriv.Basic.0.HasFDerivAtFilter._eq_1",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  (f' : E →L[𝕜] F) (x : E) (L : Filter E),\n  HasFDerivAtFilter f f' x L = (fun x' => f x' - f x - f' (x' - x)) =o[L] fun x' => x' - x",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["And", "Exists", "DenselyOrdered", "LT.lt", "LT", "DenselyOrdered.dense"],
  "name": "exists_between",
  "constType":
  "∀ {α : Type u} [inst : LT α] [inst_1 : DenselyOrdered α] {a₁ a₂ : α}, a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "MeasureTheory.Measure",
   "OfNat.ofNat",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "MeasureTheory.OuterMeasure.instZero",
   "MeasureTheory.OuterMeasure",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.Measure.zero_toOuterMeasure",
  "constType": "∀ {α : Type u_1} {_m : MeasurableSpace α}, ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "Module",
   "LE.le",
   "Preorder.toLE",
   "Submodule.setLike",
   "Set.biInter_subset_of_mem",
   "Set.instMembershipSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name":
  "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {S : Set (Submodule R M)} {p : Submodule R M}, p ∈ S → sInf S ≤ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "Ring",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "DivisionRing",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.natAbs",
   "Inv.inv"],
  "name": "DivisionRing.mk",
  "constType":
  "{K : Type u} →\n  [toRing : Ring K] →\n    [toInv : Inv K] →\n      [toDiv : Div K] →\n        autoParam (∀ (a b : K), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → K → K) →\n            autoParam (∀ (a : K), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : K), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial K] →\n                    [toRatCast : RatCast K] →\n                      (∀ (a : K), a ≠ 0 → a * a⁻¹ = 1) →\n                        0⁻¹ = 0 →\n                          autoParam\n                              (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                              _auto✝⁴ →\n                            (qsmul : ℚ → K → K) →\n                              autoParam (∀ (a : ℚ) (x : K), qsmul a x = ↑a * x) _auto✝⁵ → DivisionRing K",
  "constCategory": "Other"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Classical.choose",
   "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.Tendsto.eventually",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "dist_triangle",
   "mul_le_mul",
   "Real.instAddMonoidReal",
   "add_le_add_right",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "Dist.dist",
   "Real.linearOrder",
   "Continuous.add",
   "Continuous.mul",
   "Real.strictOrderedSemiring",
   "HSMul.hSMul",
   "LinearOrderedField.toTopologicalDivisionRing",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Prod.snd",
   "TopologicalSemiring.toContinuousMul",
   "dist_smul_pair",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "And",
   "Prod.casesOn",
   "propext",
   "LT.lt",
   "congr",
   "LinearOrderedSemiField.toDenselyOrdered",
   "And.intro",
   "OrderedSemiring.toMulPosMono",
   "OrderedSemiring.toPosMulMono",
   "congrFun",
   "BoundedSMul.continuousSMul.match_1",
   "AddZeroClass.toAdd",
   "Exists",
   "Real",
   "Eq.refl",
   "dist_pair_smul",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "zero_add",
   "continuous_add_right",
   "UniformSpace.toTopologicalSpace",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Metric.continuous_iff",
   "Real.instLTReal",
   "LE.le.trans",
   "instTransLeToLE",
   "LE.le",
   "Real.instDivisionRingReal",
   "Eq.ndrec",
   "Prod.mk",
   "Real.instPreorderReal",
   "TopologicalSemiring.toContinuousAdd",
   "Prod",
   "max_lt_iff",
   "Real.orderedAddCommGroup",
   "StrictOrderedSemiring.toNoMaxOrder",
   "Filter.Eventually.exists_gt",
   "instHSMul",
   "gt_mem_nhds",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real.commRing",
   "add_le_add",
   "dist_nonneg",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff.mp",
   "Continuous",
   "And.casesOn",
   "Eq.trans",
   "continuous_mul_left",
   "instTopologicalSpaceProd",
   "Lattice.toSemilatticeInf",
   "Prod.fst",
   "Real.orderedSemiring",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "DistribLattice.toLattice",
   "instHMul",
   "of_eq_true",
   "Real.orderedAddCommMonoid",
   "LinearOrder.toMax",
   "nhdsWithin_Ioi_self_neBot",
   "congrArg",
   "add_zero",
   "BoundedSMul",
   "instTransLeToLELtToLT",
   "Zero",
   "Real.instLinearOrderedFieldReal",
   "SMul",
   "Prod.pseudoMetricSpaceMax",
   "Continuous.tendsto'",
   "CommRing.toNonUnitalCommRing",
   "MulZeroClass.zero_mul",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "TopologicalRing.toTopologicalSemiring",
   "MulZeroClass.toZero",
   "continuous_id'",
   "ContinuousSMul",
   "id",
   "eq_self",
   "LT.lt.le",
   "nhds",
   "instHAdd",
   "Real.pseudoMetricSpace",
   "SemilatticeInf.toPartialOrder",
   "ContinuousSMul.mk",
   "GT.gt",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "Max.max",
   "le_refl",
   "HMul.hMul",
   "TopologicalDivisionRing.toTopologicalRing"],
  "name": "BoundedSMul.continuousSMul",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero α]\n  [inst_3 : Zero β] [inst_4 : SMul α β] [inst_5 : BoundedSMul α β], ContinuousSMul α β",
  "constCategory": "Definition"},
 {"references":
  ["NormedLatticeAddCommGroup.mk",
   "instHasSolidNormRealNormedAddCommGroupLattice",
   "Real.normedLatticeAddCommGroup.proof_1",
   "Real.lattice",
   "Real",
   "NormedLatticeAddCommGroup",
   "Real.normedAddCommGroup"],
  "name": "Real.normedLatticeAddCommGroup",
  "constType": "NormedLatticeAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "Real",
   "Real.instRingReal",
   "AddGroupWithOne.toAddGroup"],
  "name": "Real.instAddGroupReal",
  "constType": "AddGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "AddSubmonoid.instTopAddSubmonoid",
   "OfNat.ofNat",
   "Top.top",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule.proof_2",
  "constType": "∀ {M : Type u_1} [inst : AddCommMonoid M], 0 ∈ ⊤.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "SMulWithZero.toSMulZeroClass",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "MulActionWithZero.toMulAction",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace.toUniformSpace",
   "NormedCommRing.toNormedRing",
   "HasFDerivAt.unique",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Module.toMulActionWithZero",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "HasDerivAt",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "ContinuousLinearMap.smulRight_one_eq_iff",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "BoundedSMul.continuousSMul",
   "NormedAddCommGroup.toAddCommGroup",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommRing.toNonUnitalCommRing",
   "Semiring.toMonoidWithZero",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "HasDerivAt.hasFDerivAt",
   "IsScalarTower.left",
   "AddMonoid.toZero",
   "NormedSpace.boundedSMul",
   "ContinuousLinearMap.smulRight",
   "UniformSpace.toTopologicalSpace",
   "Semiring.toModule",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAt.unique",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f₀' f₁' : F} {x : 𝕜}, HasDerivAt f f₀' x → HasDerivAt f f₁' x → f₀' = f₁'",
  "constCategory": "Theorem"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5401",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
   "Sub",
   "autoParam",
   "AddMonoid",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5479",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5440",
   "Nat",
   "Nat.succ",
   "Int",
   "Neg"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "UniformSpace",
   "UniformSpace.ofDist.proof_1",
   "Real.orderedAddCommMonoid",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "UniformSpace.ofFun",
   "LE.le",
   "Eq"],
  "name": "UniformSpace.ofDist",
  "constType":
  "{α : Type u} →\n  (dist : α → α → ℝ) →\n    (∀ (x : α), dist x x = 0) →\n      (∀ (x y : α), dist x y = dist y x) → (∀ (x y z : α), dist x z ≤ dist x y + dist y z) → UniformSpace α",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.re",
   "Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "ZeroHom.mk",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "IsROrC.normSq.proof_1",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZeroHom",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Field.toSemifield",
   "FunLike.coe",
   "IsROrC.normSq.proof_3",
   "MulZeroOneClass.toZero",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Real.semiring",
   "HMul.hMul",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.normSq.proof_2",
   "IsROrC.im",
   "MonoidWithZeroHom.mk"],
  "name": "IsROrC.normSq",
  "constType": "{K : Type u_1} → [inst : IsROrC K] → K →*₀ ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["RingEquiv", "Add", "Mul"],
  "name": "RingAut",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Type u_1",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references": ["NormedRing", "Ring"],
  "name": "NormedRing.toRing",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "propext",
   "Continuous",
   "Set",
   "Eq.mp",
   "Eq.refl",
   "TopologicalSpace",
   "continuous_iff_continuousOn_univ",
   "ContinuousOn.mono",
   "ContinuousOn",
   "Set.univ",
   "Set.subset_univ",
   "Eq"],
  "name": "Continuous.continuousOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α},\n  Continuous f → ContinuousOn f s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "SemilinearMapClass",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.toSemilinearMapClass",
  "constType":
  "{F : Type u_1} →\n  {R : outParam (Type u_2)} →\n    {S : outParam (Type u_3)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          {σ : outParam (R →+* S)} →\n            {M : outParam (Type u_4)} →\n              [inst_2 : TopologicalSpace M] →\n                [inst_3 : AddCommMonoid M] →\n                  {M₂ : outParam (Type u_5)} →\n                    [inst_4 : TopologicalSpace M₂] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : Module R M] →\n                          [inst_7 : Module S M₂] →\n                            [self : ContinuousSemilinearMapClass F σ M M₂] → SemilinearMapClass F σ M M₂",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "Exists.intro",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DifferentiableAt",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "HasFDerivAt.differentiableAt",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E}, HasFDerivAt f f' x → DifferentiableAt 𝕜 f x",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Real",
   "CommSemiring",
   "Real.commRing"],
  "name": "Real.instCommSemiringReal",
  "constType": "CommSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.5206",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5206",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{α : Type u} → (α → α → α) → Inf α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.45",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop} (t : Nonempty α), (∀ (val : α), motive (_ : Nonempty α)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Norm",
   "Filter",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.4427"],
  "name": "Asymptotics.IsLittleO",
  "constType":
  "{α : Type u_17} →\n  {E : Type u_18} → {F : Type u_19} → [inst : Norm E] → [inst : Norm F] → Filter α → (α → E) → (α → F) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "Eq.refl",
   "div_eq_mul_one_div",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "DivInvMonoid.toDiv",
   "id",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "One.toOfNat1",
   "CommGroupWithZero.toCommMonoidWithZero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "one_div_pos",
   "mul_lt_mul_of_pos_right",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "div_lt_div_of_lt",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → a < b → a / c < b / c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.isROrC.proof_5",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Real.decidableEq",
   "Field.toCommRing",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.isROrC.proof_3",
   "Real.isROrC.proof_1",
   "Real.isROrC.proof_9",
   "Real.isROrC.proof_7",
   "Real.isROrC.proof_12",
   "Real.isROrC.proof_10",
   "Real.isROrC.proof_11",
   "Real.isROrC.proof_2",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "Real.isROrC.proof_6",
   "Real.partialOrder",
   "Ring.toSemiring",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Real.isROrC.proof_4",
   "Real.instZeroReal",
   "Real.isROrC.proof_13",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC.mk",
   "Real.isROrC.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC",
  "constType": "IsROrC ℝ",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5206", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.le",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "NegZeroClass.neg_zero",
   "Eq"],
  "name": "neg_zero",
  "constType": "∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["HSMul", "HSMul.mk", "SMul", "SMul.smul"],
  "name": "instHSMul",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Iff.rfl",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff",
   "HasFDerivAtFilter",
   "HasFDerivAt",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "nhdsWithin",
   "id",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "Set.univ",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "congrArg",
   "HasFDerivWithinAt",
   "nhdsWithin_univ",
   "congrFun"],
  "name": "hasFDerivWithinAt_univ",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E}, HasFDerivWithinAt f f' Set.univ x ↔ HasFDerivAt f f' x",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_zero",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.dist_eq",
   "NonUnitalNormedRing.norm_mul",
   "NonUnitalNormedRing.toNorm",
   "NonUnitalNormedRing",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNormedRing.toMetricSpace",
   "NonUnitalSeminormedRing",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalSeminormedRing.mk"],
  "name": "NonUnitalNormedRing.toNonUnitalSeminormedRing",
  "constType":
  "{α : Type u_1} → [β : NonUnitalNormedRing α] → NonUnitalSeminormedRing α",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.4",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → ({a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) → Trans r s t",
  "constCategory": "Other"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Int.negSucc",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_9",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semifield.zpow_zero'",
   "DivisionSemiring",
   "Semifield.toNontrivial",
   "Semifield.toCommSemiring",
   "DivisionSemiring.mk",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.mul_inv_cancel",
   "Semifield.zpow_neg'",
   "Semifield.zpow",
   "Semifield.toDiv",
   "Semifield.toInv",
   "Semifield",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "CommSemiring.mk",
   "Field.toSemifield.proof_1",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Ring.toSemiring",
   "Semifield",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Semifield.mk",
   "Field.toDiv",
   "Field.div_eq_mul_inv"],
  "name": "Field.toSemifield",
  "constType": "{K : Type u_3} → [inst : Field K] → Semifield K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.zsmul (Int.ofNat (Nat.succ n)) a = a + AddGroupWithOne.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Membership.mk",
   "Membership",
   "Set.instMembershipSet"],
  "name": "instMembershipSetFilter",
  "constType": "{α : Type u_1} → Membership (Set α) (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["DenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.mk",
   "Real.denselyNormedField.proof_1"],
  "name": "Real.denselyNormedField",
  "constType": "DenselyNormedField ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (toZeroHom : ZeroHom M N) →\n          (∀ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n            M →+ N",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Int"],
  "name": "LinearOrderedField.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["ContinuousLinearMap.toLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "Semiring.toMonoidWithZero",
   "LinearMap.mk",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "RingHom.id",
   "LinearMap.smulRight",
   "ContinuousLinearMap.smulRight.proof_2",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "TopologicalSpace",
   "ContinuousLinearMap.smulRight.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "ContinuousSMul",
   "Module",
   "MonoidWithZero.toZero",
   "LinearMap.toAddHom",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.smulRight",
  "constType":
  "{M₁ : Type u_4} →\n  [inst : TopologicalSpace M₁] →\n    [inst_1 : AddCommMonoid M₁] →\n      {M₂ : Type u_6} →\n        [inst_2 : TopologicalSpace M₂] →\n          [inst_3 : AddCommMonoid M₂] →\n            {R : Type u_10} →\n              {S : Type u_11} →\n                [inst_4 : Semiring R] →\n                  [inst_5 : Semiring S] →\n                    [inst_6 : Module R M₁] →\n                      [inst_7 : Module R M₂] →\n                        [inst_8 : Module R S] →\n                          [inst_9 : Module S M₂] →\n                            [inst_10 : IsScalarTower R S M₂] →\n                              [inst_11 : TopologicalSpace S] →\n                                [inst_12 : ContinuousSMul S M₂] → (M₁ →L[R] S) → M₂ → M₁ →L[R] M₂",
  "constCategory": "Definition"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [inst : Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.inter_subset_left",
   "Module",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_4",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), ↑x ∩ ↑x_1 ⊆ ↑x",
  "constCategory": "Theorem"},
 {"references": ["MeasurableSpace"],
  "name": "MeasureTheory.Measure",
  "constType": "(α : Type u_6) → [inst : MeasurableSpace α] → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["RingHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.mk",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass",
   "RingHomClass.map_add",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_zero",
   "NonAssocSemiring",
   "NonUnitalRingHomClass"],
  "name": "RingHomClass.toNonUnitalRingHomClass",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → NonUnitalRingHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedCancelAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableLT",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Field", "Int"],
  "name": "Field.zpow",
  "constType": "{K : Type u} → [self : Field K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.mk",
  "constType": "{α : Type u_9} → (Set α → α) → SupSet α",
  "constCategory": "Other"},
 {"references":
  ["OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_2",
   "Eq",
   "MeasureTheory.Measure",
   "BooleanAlgebra.toBiheytingAlgebra",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "ENNReal.instTopologicalSpaceENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.iUnion",
   "Pairwise",
   "Eq.rec",
   "MeasurableSet",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_1",
   "Nat",
   "Function.onFun",
   "CompletelyDistribLattice.toCompleteLattice",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Disjoint",
   "MeasureTheory.Measure.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "tsum",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Function.Injective",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim"],
  "name": "MeasureTheory.Measure.toOuterMeasure_injective",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α], Function.Injective MeasureTheory.Measure.toOuterMeasure",
  "constCategory": "Theorem"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_6",
  "constType": "∀ {α : Type u_1} [β : NormedRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "congr_arg",
   "LinearOrder",
   "Trans.trans",
   "SubNegMonoid.toNeg",
   "instDistribLattice",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "SubNegMonoid.toSub",
   "AddGroup",
   "SemilatticeSup.toSup",
   "SubtractionMonoid.toSubNegMonoid",
   "abs_neg",
   "instTransEq",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_sub",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_sub_comm",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] (a b : α), |a - b| = |b - a|",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.zero_mul",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.sub_eq_add_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "instZeroAddMonoidHom",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "Iff.symm",
   "And",
   "Iff",
   "and_iff_left",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_13",
  "constType": "∀ {z w : ℝ}, z ≤ w ↔ z ≤ w ∧ 0 z = 0 z",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.901"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.add",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "Eq.ndrec",
   "NonUnitalNonAssocRing.zero_mul",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.right_distrib",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "NormedCommRing"],
  "name": "NormedCommRing.toNormedRing",
  "constType": "{α : Type u_5} → [self : NormedCommRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNonUnitalNormedRing",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NormedRing",
   "inferInstance",
   "NormedRing.toSeminormedRing",
   "NormedField",
   "NormedAlgebra",
   "NormedSpace",
   "NormedAlgebra.toNormedSpace",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup"],
  "name": "NormedAlgebra.toNormedSpace'",
  "constType":
  "{𝕜 : Type u_5} →\n  [inst : NormedField 𝕜] → {𝕜' : Type u_7} → [inst_1 : NormedRing 𝕜'] → [inst_2 : NormedAlgebra 𝕜 𝕜'] → NormedSpace 𝕜 𝕜'",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "Semiring",
   "AddHomClass.toFunLike",
   "ContinuousSemilinearMapClass.map_continuous",
   "ContinuousMapClass",
   "ContinuousMapClass.mk",
   "AddCommMagma.toAdd",
   "outParam",
   "SemilinearMapClass.toAddHomClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "ContinuousSemilinearMapClass.toSemilinearMapClass",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.toContinuousMapClass",
  "constType":
  "{F : Type u_1} →\n  {R : outParam (Type u_2)} →\n    {S : outParam (Type u_3)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          (σ : outParam (R →+* S)) →\n            {M : outParam (Type u_4)} →\n              [inst_2 : TopologicalSpace M] →\n                [inst_3 : AddCommMonoid M] →\n                  {M₂ : outParam (Type u_5)} →\n                    [inst_4 : TopologicalSpace M₂] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : Module R M] →\n                          [inst_7 : Module S M₂] →\n                            [self : ContinuousSemilinearMapClass F σ M M₂] → ContinuousMapClass F M M₂",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{α : Type u} →\n  [toInf : Inf α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ⊓ b ≤ a) →\n        (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → SemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Union.union",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "Set.compl_inter",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "congrArg",
   "Set.instUnionSet",
   "Set.instInterSet",
   "id",
   "congrFun"],
  "name": "Bornology.ofBounded.proof_3",
  "constType":
  "∀ {α : Type u_1} (B : Set (Set α)),\n  (∀ s₁ ∈ B, ∀ s₂ ∈ B, s₁ ∪ s₂ ∈ B) → ∀ {x y : Set α}, x ∈ {s | sᶜ ∈ B} → y ∈ {s | sᶜ ∈ B} → x ∩ y ∈ {s | sᶜ ∈ B}",
  "constCategory": "Theorem"},
 {"references":
  ["StieltjesFunction.id.proof_2",
   "Real",
   "StieltjesFunction",
   "StieltjesFunction.mk",
   "StieltjesFunction.id.proof_1",
   "id"],
  "name": "StieltjesFunction.id",
  "constType": "StieltjesFunction",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace.proof_1",
   "PseudoMetricSpace.toUniformSpace",
   "T0Space",
   "UniformSpace.toTopologicalSpace",
   "MetricSpace.mk",
   "PseudoMetricSpace"],
  "name": "MetricSpace.ofT0PseudoMetricSpace",
  "constType":
  "(α : Type u_3) → [inst : PseudoMetricSpace α] → [inst : T0Space α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "Asymptotics.IsLittleO",
   "NormedSpace",
   "AddGroup.toSubNegMonoid",
   "RingHom.id",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedAddCommGroup.toNormedAddGroup",
   "Filter",
   "Semifield.toDivisionSemiring",
   "NormedAddCommGroup.toNorm",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "ContinuousMapClass.toFunLike"],
  "name": "HasFDerivAtFilter",
  "constType":
  "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → (E →L[𝕜] F) → E → Filter E → Prop",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "NormedDivisionRing"],
  "name": "NormedDivisionRing.toDivisionRing",
  "constType":
  "{α : Type u_5} → [self : NormedDivisionRing α] → DivisionRing α",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule",
   "setOf",
   "PartialOrder.toPreorder",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "LE.le",
   "Preorder.toLE",
   "Submodule.completeLattice.match_1",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_1",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 : Submodule R M), x ≤ sInf {x_2 | x ≤ x_2 ∧ x_1 ≤ x_2}",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "starMulAut",
   "NonUnitalCommSemiring.toCommSemigroup",
   "MulAut",
   "CommSemiring.toNonUnitalCommSemiring",
   "Semiring.toNonAssocSemiring",
   "starRingAut.proof_3",
   "InvolutiveStar.toStar",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "AddEquiv.toEquiv",
   "StarRing",
   "starRingAut.proof_2",
   "StarRing.toStarMul",
   "starRingAut.proof_1",
   "RingAut",
   "Star.star",
   "AddSemigroup.toAdd",
   "RingEquiv.mk",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddEquiv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "starAddEquiv",
   "StarRing.toStarAddMonoid",
   "Equiv.invFun",
   "starRingAut.proof_4",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Equiv.mk",
   "StarAddMonoid.toInvolutiveStar"],
  "name": "starRingAut",
  "constType":
  "{R : Type u} → [inst : CommSemiring R] → [inst_1 : StarRing R] → RingAut R",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNormedRing", "NonUnitalRing"],
  "name": "NonUnitalNormedRing.toNonUnitalRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalNormedRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "DivInvMonoid.toInv",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "id",
   "Inv.inv"],
  "name": "div_zero",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (a : G₀), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Module.Finite",
  "constType":
  "(R : Type u_1) → (M : Type u_4) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_3",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Filter.Tendsto", "Filter", "Filter.Eventually"],
  "name": "Filter.Tendsto.eventually",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop},\n  Filter.Tendsto f l₁ l₂ → (∀ᶠ (y : β) in l₂, p y) → ∀ᶠ (x : α) in l₁, p (f x)",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Filter.principal",
   "And",
   "setOf",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Set",
   "TopologicalSpace",
   "Filter",
   "IsOpen",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "definition._@.Mathlib.Topology.Basic._hyg.10659",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → α → Filter α",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedRing"],
  "name": "LinearOrderedRing.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "NonAssocRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.306",
   "One",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Neg.neg",
   "One.toOfNat1",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.72",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.261",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.117",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "NonAssocRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                [toIntCast : IntCast α] →\n                  autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝² →\n                    autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝³ → NonAssocRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [β : NormedRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def'",
  "constType":
  "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [self : Algebra R A] (r : R) (x : A),\n  r • x = Algebra.toRingHom r * x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mk",
  "constType":
  "{α : Type u} → [toLinearOrderedRing : LinearOrderedRing α] → (∀ (a b : α), a * b = b * a) → LinearOrderedCommRing α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsTotal",
   "SemilatticeInf.toPartialOrder",
   "total_of",
   "Lattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "Lattice.toLinearOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["SProd", "SProd.mk", "Filter.prod", "Prod", "Filter"],
  "name": "Filter.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Filter α) (Filter β) (Filter (α × β))",
  "constCategory": "Definition"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_9} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddHom",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "LinearMap.mk",
  "constType":
  "{R : Type u_17} →\n  {S : Type u_18} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        {σ : R →+* S} →\n          {M : Type u_19} →\n            {M₂ : Type u_20} →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] →\n                  [inst_4 : Module R M] →\n                    [inst_5 : Module S M₂] →\n                      (toAddHom : AddHom M M₂) →\n                        (∀ (r : R) (x : M), AddHom.toFun toAddHom (r • x) = σ r • AddHom.toFun toAddHom x) → M →ₛₗ[σ] M₂",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "UniformSpace",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "UniformSpace.ofCore",
   "Filter",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "Filter.instCompleteLatticeFilter",
   "setOf",
   "Prod.snd",
   "instHAdd",
   "Prod.fst",
   "AddCommMagma.toAdd",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "GT.gt",
   "UniformSpace.ofFun.proof_3",
   "And",
   "UniformSpace.ofFun.proof_1",
   "iInf",
   "LT.lt",
   "Prod",
   "UniformSpace.ofFun.proof_2",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "UniformSpace.Core.mk"],
  "name": "UniformSpace.ofFun",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    [inst : OrderedAddCommMonoid β] →\n      (d : α → α → β) →\n        (∀ (x : α), d x x = 0) →\n          (∀ (x y : α), d x y = d y x) →\n            (∀ (x y z : α), d x z ≤ d x y + d y z) → (∀ ε > 0, ∃ δ > 0, ∀ x < δ, ∀ y < δ, x + y < ε) → UniformSpace α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "LinearMap.map_smul'",
  "constType":
  "∀ {R : Type u_17} {S : Type u_18} [inst : Semiring R] [inst_1 : Semiring S] {σ : R →+* S} {M : Type u_19}\n  {M₂ : Type u_20} [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module S M₂]\n  (self : M →ₛₗ[σ] M₂) (r : R) (x : M), AddHom.toFun self.toAddHom (r • x) = σ r • AddHom.toFun self.toAddHom x",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "SemilatticeSup.le_sup_left",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Sup.sup",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_5",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.left_distrib",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toMulAction",
   "Monoid",
   "MulAction.toSMul",
   "IsScalarTower.mk",
   "MulAction.mul_smul",
   "IsScalarTower",
   "MulAction"],
  "name": "IsScalarTower.left",
  "constType":
  "∀ (M : Type u_1) {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α], IsScalarTower M M α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvolutiveNeg",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "Semiring",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
   "StrictOrderedRing.toNontrivial",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
   "StrictOrderedRing.zero_le_one",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_1"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedRing α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "setOf",
   "Submodule",
   "PartialOrder.toPreorder",
   "Semiring",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "Inf.mk",
   "And",
   "Set.subset_inter",
   "And.intro",
   "Set.inter_subset_left",
   "Module",
   "Lattice.toSemilatticeSup",
   "Set.inter_subset_right",
   "Submodule.setLike",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_11",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (x_1 : Submodule R M), (∀ b ∈ x, b ≤ x_1) → (sInf fun x_2 => ∀ b ∈ x, b ≤ x_2) ≤ x_1",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "SMul.mk",
   "instHSMul",
   "MeasureTheory.Measure.mk",
   "MeasureTheory.Measure.instSMul.proof_1",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Algebra.id",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.Measure.instSMul.proof_2"],
  "name": "MeasureTheory.Measure.instSMul",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_6} →\n    [inst : SMul R ENNReal] →\n      [inst : IsScalarTower R ENNReal ENNReal] → [inst : MeasurableSpace α] → SMul R (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.preimage",
   "nhds",
   "all_mem_nhds_filter",
   "Filter.map",
   "Set",
   "HasSubset.Subset",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Filter",
   "Set.preimage_mono",
   "IsOpen",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "tendsto_nhds",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] {f : β → α} {l : Filter β} {a : α},\n  Filter.Tendsto f l (nhds a) ↔ ∀ (s : Set α), IsOpen s → a ∈ s → f ⁻¹' s ∈ l",
  "constCategory": "Theorem"},
 {"references": ["NonAssocSemiring"],
  "name": "RingHom",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemiring", "Max"],
  "name": "LinearOrderedSemiring.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Ring.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OneHom.toFun",
   "AddZeroClass.toZero",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_zero'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β),\n  OneHom.toFun (↑↑self) 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CommSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CommSemiring",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toCommSemiring",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Real.instLinearOrderedFieldReal.proof_7",
  "constType": "∀ (a : ℝ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_add_sub_cancel",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "instHSub",
   "instHAdd",
   "instDistribLattice",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "abs_add",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "instTransEq",
   "NegZeroClass.toNeg",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_sub_le",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] (a b c : α), |a - c| ≤ |a - b| + |b - c|",
  "constCategory": "Theorem"},
 {"references": ["outParam", "TopologicalSpace"],
  "name": "ContinuousMapClass",
  "constType":
  "Type u_1 →\n  (α : outParam (Type u_2)) →\n    (β : outParam (Type u_3)) → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → Type (max (max u_1 u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Real.measurableSpace",
   "Real.instAddMonoidReal",
   "ENNReal.ofReal",
   "AddCommGroup.toAddCommMonoid",
   "le_rfl",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.MeasureTheory.Measure.Stieltjes._auxLemma.16",
   "Real.linearOrder",
   "BooleanAlgebra.toBiheytingAlgebra",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "SubNegMonoid.toSub",
   "MeasureTheory.OuterMeasure.measureOf",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "instHSub",
   "Or",
   "add_comm",
   "Set.Ioo",
   "MeasurableSingletonClass.measurableSet_singleton",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "StieltjesFunction.measure",
   "instENNRealZero",
   "AddCommMagma.toAdd",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "LT.lt",
   "Real.instConditionallyCompleteLinearOrderReal",
   "GeneralizedCoheytingAlgebra.toLattice",
   "LinearOrder.toPartialOrder",
   "Int",
   "Mathlib.Data.Real.ENNReal._auxLemma.107",
   "congrFun",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.1",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Mathlib.MeasureTheory.Measure.Stieltjes._auxLemma.9",
   "Set.Ioo_eq_empty",
   "instOfNatInt",
   "Set",
   "Real",
   "StieltjesFunction.measure_singleton",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "BorelSpace.opensMeasurable",
   "Real.instAddCommGroupReal",
   "MeasureTheory.Measure",
   "zero_add",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "StieltjesFunction.mono",
   "Mathlib.Tactic.Abel.unfold_sub",
   "UniformSpace.toTopologicalSpace",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Disjoint",
   "ConditionallyCompleteLattice.toLattice",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Mathlib.Tactic.Abel.term_atomg",
   "ENNReal.ofReal_ne_top",
   "OrderTopology.t5Space",
   "StieltjesFunction.toFun",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "Set.instUnionSet",
   "ENNReal.add_right_inj",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "AddGroup.toHasOrderedSub",
   "neg_zero",
   "Real.instLEReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Mathlib.Algebra.Order.Sub.Defs._auxLemma.1",
   "AddGroup.toSubtractionMonoid",
   "Mathlib.Tactic.Abel.zero_termg",
   "Set.Icc_self",
   "MeasureTheory.measure_empty",
   "Preorder.toLE",
   "Eq",
   "StieltjesFunction.measure_Ioc",
   "Mathlib.Tactic.Abel.const_add_termg",
   "AddZeroClass.toZero",
   "ENNReal",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "ENNReal.ofReal_add",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "not_false_eq_true",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Function.leftLim",
   "CompletelyDistribLattice.toCompleteLattice",
   "Lattice.toSemilatticeInf",
   "Real.partialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Mathlib.Tactic.Abel.termg",
   "Mathlib.Tactic.Abel.term_neg",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Set.instMembershipSet",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Order.Basic._auxLemma.2",
   "DistribLattice.toLattice",
   "Real.orderedAddCommMonoid",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.77",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Real.instAddGroupReal",
   "Not",
   "Singleton.singleton",
   "Monotone.leftLim_le",
   "Set.Ioc",
   "Mathlib.Tactic.Abel.term_add_constg",
   "add_zero",
   "congrArg",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "Int.ofNat",
   "Real.borelSpace",
   "Set.Icc",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Mathlib.Tactic.Abel.term_add_termg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Set.instSingletonSet",
   "and_false",
   "Preorder.toLT",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "Int.instNegInt",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "le_or_lt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "instHAdd",
   "Union.union",
   "HSub.hSub",
   "MeasureTheory.measure_union",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "OpensMeasurableSpace.toMeasurableSingletonClass",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Monotone.le_leftLim",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "T5Space.toT1Space",
   "HeytingAlgebra.toOrderBot",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "SubtractionMonoid.toSubNegMonoid",
   "OrderedCommSemiring.toOrderedSemiring",
   "StieltjesFunction",
   "OrderedSemiring.toSemiring",
   "NegZeroClass.toZero",
   "Set.Ioo_union_Icc_eq_Ioc"],
  "name": "StieltjesFunction.measure_Ioo",
  "constType":
  "∀ (f : StieltjesFunction) {a b : ℝ},\n  ↑↑(StieltjesFunction.measure f) (Set.Ioo a b) = ENNReal.ofReal (Function.leftLim (↑f) b - ↑f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Iff.intro",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "Iff",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mul_eq_zero_of_right",
   "Or.elim",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Continuous.neg",
   "Eq.mpr",
   "AddGroup",
   "Continuous.add",
   "ContinuousSub",
   "Continuous",
   "continuous_snd",
   "TopologicalSpace",
   "id",
   "TopologicalAddGroup.toContinuousAdd",
   "instHSub",
   "funext",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "instHAdd",
   "HSub.hSub",
   "TopologicalAddGroup.toContinuousNeg",
   "Neg.neg",
   "Prod.fst",
   "AddGroup.toSubNegMonoid",
   "continuous_fst",
   "SubNegMonoid.toAddMonoid",
   "Prod",
   "ContinuousSub.mk",
   "congrArg",
   "TopologicalAddGroup"],
  "name": "TopologicalAddGroup.to_continuousSub",
  "constType":
  "∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G], ContinuousSub G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["TopologicalSpace.IsOpen", "Set", "TopologicalSpace"],
  "name": "IsOpen",
  "constType": "{α : Type u} → [inst : TopologicalSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "IsROrC.ofReal",
   "IsROrC.ofReal_re_ax",
   "Field.toCommRing",
   "NormedField.toField",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "IsROrC.ofReal_re",
  "constType": "∀ {K : Type u_1} [inst : IsROrC K] (r : ℝ), IsROrC.re ↑r = r",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toSeminormedRing : SeminormedRing α] → (∀ (x y : α), x * y = y * x) → SeminormedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Exists",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "Real.normedField",
   "Real.instLEReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "Real.instSupReal",
   "Exists.intro",
   "And.left",
   "exists_between",
   "abs_of_nonneg",
   "NormedField.toNorm",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "LT.lt.le",
   "Real.instLTReal",
   "instDistribLattice",
   "LE.le.trans",
   "Real.norm",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "And",
   "Real.norm_eq_abs",
   "Eq.ndrec",
   "Real.denselyNormedField.match_1",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "Norm.norm",
   "LinearOrderedSemiField.toDenselyOrdered",
   "NegZeroClass.toNeg"],
  "name": "Real.denselyNormedField.proof_1",
  "constType": "∀ (x x_1 : ℝ), 0 ≤ x → x < x_1 → ∃ a, x < ‖a‖ ∧ ‖a‖ < x_1",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedField"],
  "name": "NormedField.toNorm",
  "constType": "{α : Type u_5} → [self : NormedField α] → Norm α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "Real",
   "Real.toNNReal",
   "ENNReal.ofReal",
   "Eq.refl",
   "ENNReal.ofNNReal",
   "Eq"],
  "name": "_private.Mathlib.Data.Real.ENNReal.0.ENNReal.ofReal._eq_1",
  "constType": "∀ (r : ℝ), ENNReal.ofReal r = ↑(Real.toNNReal r)",
  "constCategory": "Theorem"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.decidableLT",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "NormedSpace.norm_smul_le",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "AddCommMonoid.toAddMonoid",
   "NormedField.toNormedCommRing",
   "LE.le",
   "NormedField.toNorm",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "NormedSpace.toModule"],
  "name": "NormedAlgebra.id.proof_3",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (a b : 𝕜), ‖a • b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.810",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.commRing.proof_25",
   "Semiring.mk",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "nsmulRec",
   "npowRec",
   "CommRing.mk",
   "Real.instOneReal",
   "Real.commRing.proof_24",
   "zsmulRec",
   "Real.commRing.proof_3",
   "Real.commRing.proof_1",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Real.commRing.proof_20",
   "Rat.instNegRat",
   "Sub.sub",
   "Real.commRing.proof_10",
   "Nat",
   "Real.commRing.proof_11",
   "Add.mk",
   "Real.commRing.proof_6",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.commRing.proof_4",
   "AddMonoid.mk",
   "instHMul",
   "IntCast.mk",
   "Real.commRing.proof_21",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Zero.mk",
   "Real.commRing.proof_13",
   "CauSeq.Completion.Cauchy",
   "Ring.mk",
   "Real.commRing.proof_8",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Neg.mk",
   "Mul.mk",
   "CauSeq.Completion.instIntCastCauchy",
   "Real.commRing.proof_15",
   "Real.commRing.proof_5",
   "DivisionRing.toRing",
   "Real",
   "CauSeq.Completion.instNatCastCauchy",
   "Real.commRing.proof_23",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Abs.abs",
   "Real.commRing.proof_17",
   "Rat.instSupRat",
   "Real.instNegReal",
   "Sub.mk",
   "Zero.toOfNat0",
   "Real.commRing.proof_9",
   "Real.commRing.proof_18",
   "Real.commRing.proof_7",
   "Real.commRing.proof_22",
   "Real.commRing.proof_12",
   "Real.commRing.proof_14",
   "Real.commRing.proof_2",
   "Real.commRing.proof_16",
   "Real.commRing.proof_19",
   "Neg.toHasAbs",
   "AddSemigroup.mk",
   "instHAdd",
   "One.mk",
   "Rat",
   "One.toOfNat1",
   "Neg.neg",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "HMul.hMul"],
  "name": "Real.commRing",
  "constType": "CommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Real.field",
   "NormedAddCommGroup",
   "Field.zpow_zero'",
   "Real.instLinearOrderedRingReal",
   "NormedField",
   "Real",
   "Field.mk",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "NormedAddCommGroup.toMetricSpace",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "abs_mul",
   "Field",
   "NormedField.mk",
   "Field.inv_zero",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Real.normedAddCommGroup",
   "Field.div_eq_mul_inv"],
  "name": "Real.normedField",
  "constType": "NormedField ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.33",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Set",
   "ENNReal.ofReal",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.810",
   "Bornology.cobounded",
   "autoParam",
   "Dist",
   "Dist.dist",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "Filter.principal",
   "UniformSpace",
   "CompleteLattice.toConditionallyCompleteLattice",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.765",
   "Filter",
   "PseudoMetricSpace",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Filter.sets",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "instHAdd",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Prod.fst",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "GT.gt",
   "Real.instZeroReal",
   "uniformity",
   "iInf",
   "LT.lt",
   "Prod",
   "Bornology"],
  "name": "PseudoMetricSpace.mk",
  "constType":
  "{α : Type u} →\n  [toDist : Dist α] →\n    (∀ (x : α), dist x x = 0) →\n      (∀ (x y : α), dist x y = dist y x) →\n        (∀ (x y z : α), dist x z ≤ dist x y + dist y z) →\n          (edist : α → α → ENNReal) →\n            (∀ (x y : α), edist x y = ENNReal.ofReal (dist x y)) →\n              (toUniformSpace : UniformSpace α) →\n                autoParam (uniformity α = ⨅ ε, ⨅ (_ : ε > 0), Filter.principal {p | dist p.1 p.2 < ε}) _auto✝ →\n                  (toBornology : Bornology α) →\n                    autoParam ((Bornology.cobounded α).sets = {s | ∃ C, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C}) _auto✝¹ →\n                      PseudoMetricSpace α",
  "constCategory": "Other"},
 {"references": ["Norm", "Real"],
  "name": "Norm.mk",
  "constType": "{E : Type u_9} → (E → ℝ) → Norm E",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Filter.map",
   "Set",
   "Filter",
   "Filter.mem_map",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.3",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, (t ∈ Filter.map m f) = (m ⁻¹' t ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1573",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "NeZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NeZero.mk",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "one_ne_zero",
   "One.toOfNat1",
   "Real.instRingReal",
   "NeZero.charZero_one",
   "Real.instOneReal"],
  "name": "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
  "constType": "NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "Ne.symm",
   "NeZero.out"],
  "name": "NeZero.ne'",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], 0 ≠ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "OfNat.ofNat",
   "MeasureTheory.Measure.instZero.proof_1",
   "MeasureTheory.Measure.mk",
   "Zero.mk",
   "MeasureTheory.OuterMeasure.instZero",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim_zero"],
  "name": "MeasureTheory.Measure.instZero",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → Zero (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "DivisionRing",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionRing.mul_inv_cancel",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "outParam",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_add",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [self : RingHomClass F α β] (f : F) (x y : α), f (x + y) = f x + f y",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "instHMul",
   "MonoidHom.toOneHom",
   "HMul.hMul",
   "OneHom.mk",
   "MonoidHom.mk",
   "id"],
  "name": "RingHom.id.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : NonAssocSemiring α] (x y : α),\n  OneHom.toFun\n      (↑{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ∀ (x y : α),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      (x + y) =\n    OneHom.toFun\n      (↑{ toOneHom := { toFun := id, map_one' := (_ : id 1 = id 1) },\n          map_mul' :=\n            (_ :\n              ∀ (x y : α),\n                OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y) =\n                  OneHom.toFun { toFun := id, map_one' := (_ : id 1 = id 1) } (x * y)) })\n      (x + y)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.val",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "Subtype.ext",
   "Eq.refl",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "Asymptotics.IsBigOWith",
   "Filter.Eventually",
   "rfl",
   "LE.le",
   "Eq",
   "Subtype.property",
   "Norm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Asymptotics.definition._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "HMul.hMul",
   "Filter",
   "Norm.norm",
   "Eq.symm",
   "Subtype",
   "Subtype.mk",
   "id"],
  "name": "Asymptotics.IsBigOWith_def",
  "constType":
  "∀ {α : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (c : ℝ) (l : Filter α) (f : α → E)\n  (g : α → F), Asymptotics.IsBigOWith c l f g = ∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ContinuousAt",
   "Metric.tendsto_nhds_nhds",
   "continuous_iff_continuousAt",
   "GT.gt",
   "Dist.dist",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "PseudoMetricSpace.toDist",
   "Iff",
   "Continuous",
   "LT.lt",
   "Iff.trans",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "forall_congr'"],
  "name": "Metric.continuous_iff",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  Continuous f ↔ ∀ (b : α), ∀ ε > 0, ∃ δ > 0, ∀ (a : α), dist a b < δ → dist (f a) (f b) < ε",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → γ) → Insert α γ",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "DecidableEq",
   "propext",
   "Finset",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.62",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.toNNReal_coe",
   "NNReal.toReal",
   "ENNReal",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.toNNReal",
   "ENNReal.ofReal",
   "Eq.refl",
   "_private.Mathlib.Data.Real.ENNReal.0.ENNReal.ofReal._eq_1",
   "NNReal",
   "id",
   "ENNReal.ofNNReal",
   "Eq"],
  "name": "ENNReal.coe_nnreal_eq",
  "constType": "∀ (r : NNReal), ↑r = ENNReal.ofReal ↑r",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial", "Semifield"],
  "name": "Semifield.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : Semifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real.natCast",
   "Real",
   "One.toOfNat1",
   "DenselyNormedField.toNormedField",
   "Exists.intro",
   "Exists.casesOn",
   "NormedField.toNorm",
   "Real.instOneReal",
   "And",
   "DenselyNormedField",
   "LT.lt",
   "instNatAtLeastTwo",
   "Norm.norm",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "And.casesOn",
   "instOfNat"],
  "name": "DenselyNormedField.toNontriviallyNormedField.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DenselyNormedField α] (motive : (∃ a, 1 < ‖a‖ ∧ ‖a‖ < 2) → Prop) (x : ∃ a, 1 < ‖a‖ ∧ ‖a‖ < 2),\n  (∀ (a : α) (h : 1 < ‖a‖) (right : ‖a‖ < 2), motive (_ : ∃ a, 1 < ‖a‖ ∧ ‖a‖ < 2)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "instHSMul",
   "PartialOrder.toPreorder",
   "Submodule.instInfSetSubmodule.proof_3",
   "Submodule",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "Set",
   "Inf.inf",
   "Semiring.toMonoidWithZero",
   "InfSet.sInf",
   "Submodule.instInfSubmodule",
   "AddCommMonoid.toAddMonoid",
   "Lattice.mk",
   "Sup.mk",
   "Preorder.toLE",
   "Inf.mk",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Lattice.toSemilatticeSup",
   "Module",
   "Set.inter_subset_right",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "Submodule.instInfSetSubmodule",
   "setOf",
   "Semiring",
   "SemilatticeSup.mk",
   "Module.toMulActionWithZero",
   "LE.le",
   "Submodule.completeLattice.match_1",
   "SMulZeroClass.toSMul",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "And",
   "MulActionWithZero.toSMulWithZero",
   "Set.subset_inter",
   "Set.iInter",
   "And.intro",
   "MonoidWithZero.toZero",
   "Set.inter_subset_left",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice.proof_9",
  "constType":
  "∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Set (Submodule R M)) (a : R),\n  ∀ a_1 ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i, a • a_1 ∈ ⋂ i ∈ fun x_1 => ∀ b ∈ x, b ≤ x_1, ↑i",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "Algebra.toRingHom",
  "constType":
  "{R : Type u} → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [self : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u_1} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), ZeroHom.toFun (↑f) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["MetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "TopologicalSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace.MetrizableSpace",
   "Exists.intro",
   "TopologicalSpace.MetrizableSpace.mk",
   "UniformSpace.toTopologicalSpace",
   "rfl",
   "Eq"],
  "name": "MetricSpace.toMetrizableSpace",
  "constType":
  "∀ {X : Type u_5} [m : MetricSpace X], TopologicalSpace.MetrizableSpace X",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet", "Set", "HasSubset.Subset", "Set.Subset.refl"],
  "name": "Set.Subset.rfl",
  "constType": "∀ {α : Type u} {s : Set α}, s ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MonoidHom.toOneHom"],
  "name": "RingHom.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    [inst : NonAssocSemiring α] →\n      [inst_1 : NonAssocSemiring β] →\n        (toMonoidHom : α →* β) →\n          OneHom.toFun (↑toMonoidHom) 0 = 0 →\n            (∀ (x y : α),\n                OneHom.toFun (↑toMonoidHom) (x + y) = OneHom.toFun (↑toMonoidHom) x + OneHom.toFun (↑toMonoidHom) y) →\n              α →+* β",
  "constCategory": "Other"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "Distrib.toAdd",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "Module.toDistribMulAction",
   "instHSMul",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.instFunLike",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "RingHom.id",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "SMulHomClass.map_smul",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "SemilinearMapClass.distribMulActionHomClass",
   "MonoidWithZero.toMonoid",
   "DistribSMul.toSMulZeroClass",
   "AddMonoid.toZero",
   "SMulHomClass.toFunLike",
   "HSMul.hSMul",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid",
   "id",
   "LinearMap.semilinearMapClass",
   "add_smul",
   "smul_assoc",
   "AddHom.toFun",
   "Semiring",
   "AddHom.mk",
   "instHAdd",
   "DistribMulActionHomClass.toSMulHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "Eq.ndrec",
   "LinearMap.map_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "LinearMap.smulRight.proof_2",
  "constType":
  "∀ {R : Type u_4} {S : Type u_3} {M : Type u_1} {M₁ : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R M] [inst_4 : Module R M₁] [inst_5 : Semiring S] [inst_6 : Module R S]\n  [inst_7 : Module S M] [inst_8 : IsScalarTower R S M] (f : M₁ →ₗ[R] S) (x : M) (b : R) (y : M₁),\n  AddHom.toFun\n      { toFun := fun b => f b • x,\n        map_add' := (_ : ∀ (x_1 y : M₁), (fun b => f b • x) (x_1 + y) = (fun b => f b • x) x_1 + (fun b => f b • x) y) }\n      (b • y) =\n    (RingHom.id R) b •\n      AddHom.toFun\n        { toFun := fun b => f b • x,\n          map_add' :=\n            (_ : ∀ (x_1 y : M₁), (fun b => f b • x) (x_1 + y) = (fun b => f b • x) x_1 + (fun b => f b • x) y) }\n        y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "LE.le",
   "Dist.dist",
   "Zero.toOfNat0",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "HSMul.hSMul",
   "HMul.hMul",
   "BoundedSMul.dist_pair_smul'",
   "PseudoMetricSpace",
   "BoundedSMul"],
  "name": "dist_pair_smul",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero α]\n  [inst_3 : Zero β] [inst_4 : SMul α β] [inst_5 : BoundedSMul α β] (x₁ x₂ : α) (y : β),\n  dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "OrderedCancelAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedCancelAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "two_mul",
   "Trans.trans",
   "Real.natCast",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "two_pos",
   "Real.strictOrderedSemiring",
   "instOfNatNat",
   "Nat",
   "NeZero.charZero_one",
   "Eq.symm",
   "Real.instLinearOrderedSemiringReal",
   "instOfNat",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real.partialOrder",
   "instHAdd",
   "nonneg_of_mul_nonneg_right",
   "OrderedSemiring.zeroLEOneClass",
   "Real.instRingReal",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.orderedSemiring",
   "LE.le",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.instZeroReal",
   "instTransEq_1",
   "instHMul",
   "Eq.ndrec",
   "StrictOrderedSemiring.to_charZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Real.semiring",
   "NonAssocSemiring.toNatCast",
   "instTransEq",
   "instNatAtLeastTwo",
   "HMul.hMul"],
  "name": "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
  "constType":
  "∀ {α : Sort u_3} {x y : α} (dist : α → α → ℝ),\n  (∀ (x : α), dist x x = 0) →\n    (∀ (x y : α), dist x y = dist y x) → (∀ (x y z : α), dist x z ≤ dist x y + dist y z) → 0 ≤ dist x y",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toSubtractionMonoid : SubtractionMonoid G] → (∀ (a b : G), a + b = b + a) → SubtractionCommMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "ENNReal", "WithTop.zero", "instNNRealZero", "NNReal"],
  "name": "instENNRealZero",
  "constType": "Zero ENNReal",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → CommMonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["Module.zero_smul",
   "DistribMulAction.toMulAction",
   "Module.toMulActionWithZero.proof_2",
   "Module.toDistribMulAction",
   "Semiring",
   "MulActionWithZero.mk",
   "Semiring.toMonoidWithZero",
   "MulActionWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero.proof_3",
   "inferInstance",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "AddMonoid.toZero",
   "Module",
   "MulAction",
   "Module.toMulActionWithZero.proof_1",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero",
  "constType":
  "{R : Type u_2} →\n  {M : Type u_5} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → MulActionWithZero R M",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{α : Type u_3} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "hasFDerivWithinAt_univ",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Eq.refl",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "Set.univ",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "UniqueDiffWithinAt.eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "propext",
   "HasFDerivAt",
   "Eq.mp",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "Eq.symm",
   "HasFDerivWithinAt",
   "uniqueDiffWithinAt_univ"],
  "name": "HasFDerivAt.unique",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f₀' f₁' : E →L[𝕜] F} {x : E}, HasFDerivAt f f₀' x → HasFDerivAt f f₁' x → f₀' = f₁'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "CauSeq.instNegCauSeq",
   "Subtype.val",
   "instHAdd",
   "IsCauSeq",
   "HAdd.hAdd",
   "CauSeq.instSubCauSeq.proof_1",
   "HSub.hSub",
   "Neg.neg",
   "CauSeq",
   "Sub",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.instAddCauSeq",
   "Sub.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "CauSeq.ofEq"],
  "name": "CauSeq.instSubCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Sub (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Bot.mk",
   "OrderBot",
   "OrderBot.mk",
   "Module",
   "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike.proof_1",
   "Submodule.instBotSubmodule",
   "Submodule.setLike",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name":
  "Submodule.instOrderBotSubmoduleToLEToPreorderInstPartialOrderSetLike",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → OrderBot (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Set", "Filter"],
  "name": "Filter.sets",
  "constType": "{α : Type u_1} → Filter α → Set (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Left.neg_neg_iff",
   "AddGroup",
   "propext",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Group.Defs._auxLemma.12",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, (-a < 0) = (0 < a)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "Module",
   "AddCommMonoid"],
  "name": "LinearMap",
  "constType":
  "{R : Type u_17} →\n  {S : Type u_18} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        (R →+* S) →\n          (M : Type u_19) →\n            (M₂ : Type u_20) →\n              [inst_2 : AddCommMonoid M] →\n                [inst_3 : AddCommMonoid M₂] → [inst : Module R M] → [inst : Module S M₂] → Type (max u_19 u_20)",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "Real.instSupReal",
   "AddMonoid.toAddZeroClass",
   "True",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "MulZeroClass.toMul",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "LinearOrderedRing.toLinearOrder",
   "Mathlib.Data.IsROrC.Basic._auxLemma.26",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "sq",
   "instHPow",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Neg.toHasAbs",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Real.instMonoidReal",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "abs_mul_self",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Monoid.toMulOneClass",
   "DistribLattice.toLattice",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "add_zero",
   "congrArg"],
  "name": "Real.isROrC.proof_11",
  "constType": "∀ (z : ℝ), |z| ^ 2 = z * z + 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.induced.proof_2",
   "TopologicalSpace.mk",
   "And",
   "Exists",
   "Set.preimage",
   "Set",
   "TopologicalSpace",
   "TopologicalSpace.induced.proof_3",
   "IsOpen",
   "TopologicalSpace.induced.proof_1",
   "Eq"],
  "name": "TopologicalSpace.induced",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → TopologicalSpace β → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoid : CommMonoid M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → CommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": [],
  "name": "Field",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Top.top",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Submodule.instTopSubmodule.proof_1",
   "AddMonoid.toAddZeroClass",
   "Set.univ",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "trivial",
   "Top",
   "AddSubmonoid.instTopAddSubmonoid",
   "Submodule.instTopSubmodule.proof_2",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "Module",
   "AddSubsemigroup.carrier",
   "Top.mk",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Top (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "OrderedSemiring",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        0 ≤ 1 →\n          (∀ (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b) →\n            (∀ (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c) → OrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["inf_le_left",
   "StronglyMeasurableAtFilter",
   "CompleteSpace",
   "NormedAddCommGroup",
   "Real.measurableSpace",
   "Real.normedField",
   "Real",
   "Inf.inf",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "Filter.Tendsto.mono_left",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Real.measureSpace",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "MeasureTheory.Measure.ae",
   "intervalIntegral",
   "Real.denselyNormedField",
   "Filter.instCompleteLatticeFilter",
   "IntervalIntegrable",
   "Lattice.toSemilatticeInf",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "intervalIntegral.integral_hasStrictDerivAt_of_tendsto_ae_right",
   "ContinuousAt",
   "PseudoMetricSpace.toUniformSpace",
   "HasStrictDerivAt",
   "Real.pseudoMetricSpace",
   "ConditionallyCompleteLattice.toLattice",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Filter.instInfFilter",
   "DenselyNormedField.toNontriviallyNormedField"],
  "name": "intervalIntegral.integral_hasStrictDerivAt_right",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E}\n  {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b →\n    StronglyMeasurableAtFilter f (nhds b) →\n      ContinuousAt f b → HasStrictDerivAt (fun u => ∫ (x : ℝ) in a..u, f x) (f b) b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["UniformSpace", "Filter.map", "Preorder", "Filter.atTop", "Cauchy"],
  "name": "CauchySeq",
  "constType":
  "{α : Type u} → {β : Type v} → [uniformSpace : UniformSpace α] → [inst : Preorder β] → (β → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_zero",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [self : RingHomClass F α β] (f : F), f 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "implies_congr",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_2",
  "constType": "∀ (a b c : ℝ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Div"],
  "name": "LinearOrderedSemifield.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real",
   "Real.instSupReal",
   "Norm.norm",
   "Real.norm",
   "rfl",
   "Abs.abs",
   "Real.instNegReal",
   "Eq"],
  "name": "Real.norm_eq_abs",
  "constType": "∀ (r : ℝ), ‖r‖ = |r|",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["SMul",
   "Prod.snd",
   "instHSMul",
   "instTopologicalSpaceProd",
   "Continuous",
   "HSMul.hSMul",
   "TopologicalSpace",
   "Prod",
   "ContinuousSMul",
   "Prod.fst"],
  "name": "ContinuousSMul.mk",
  "constType":
  "∀ {M : Type u_1} {X : Type u_2} [inst : SMul M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X],\n  (Continuous fun p => p.1 • p.2) → ContinuousSMul M X",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddSubmonoid.instTopAddSubmonoid",
   "instHAdd",
   "Top.top",
   "HAdd.hAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddSubsemigroup.add_mem'",
   "AddMonoid.toAddZeroClass",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name": "Submodule.instTopSubmodule.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddCommMonoid M] {a b : M}, a ∈ ⊤.carrier → b ∈ ⊤.carrier → a + b ∈ ⊤.carrier",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedRing"],
  "name": "LinearOrderedRing.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Metric.closedBall",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "UniformSpace.toTopologicalSpace",
   "ProperSpace",
   "IsCompact",
   "PseudoMetricSpace"],
  "name": "ProperSpace.isCompact_closedBall",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] [self : ProperSpace α] (x : α) (r : ℝ), IsCompact (Metric.closedBall x r)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "OfNat.ofNat",
   "Dist.mk",
   "Real.instLEReal",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Real.instSupReal",
   "Real.pseudoMetricSpace.proof_1",
   "UniformSpace.ofDist",
   "abs_sub_le",
   "Real.pseudoMetricSpace.proof_3",
   "Real.instLinearOrderedAddCommGroupReal",
   "Real.pseudoMetricSpace.proof_4",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Real.pseudoMetricSpace.proof_5",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "PseudoMetricSpace",
   "Subtype.mk",
   "PseudoMetricSpace.mk",
   "abs_sub_comm",
   "Real.pseudoMetricSpace.proof_2",
   "ENNReal.ofNNReal"],
  "name": "Real.pseudoMetricSpace",
  "constType": "PseudoMetricSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "Set.compl_inter",
   "ENNReal",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.measure_union_null",
   "congrArg",
   "MeasurableSpace",
   "Set.instUnionSet",
   "congrFun",
   "id",
   "Set.instInterSet"],
  "name": "MeasureTheory.Measure.ae.proof_3",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) {x y : Set α},\n  x ∈ {s | ↑↑μ sᶜ = 0} → y ∈ {s | ↑↑μ sᶜ = 0} → x ∩ y ∈ {s | ↑↑μ sᶜ = 0}",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "∀ {α ι : Type u_1} {κ : ι → Type u_1} (f : (a : ι) → κ a → Set α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Semiring.one_mul",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_2",
  "constType": "∀ (a : ℝ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.one_mul",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "instHSub",
   "NormedAddCommGroup.toMetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NormedAddCommGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NormedAddCommGroup.toNorm",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddCommGroup.dist_eq",
  "constType":
  "∀ {E : Type u_9} [self : NormedAddCommGroup E] (x y : E), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "OrderTopology.to_orderClosedTopology",
   "Real.partialOrder",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "T0Space",
   "T1Space.t0Space",
   "T2Space.t1Space",
   "UniformSpace.toTopologicalSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "OrderClosedTopology.to_t2Space"],
  "name": "Real.metricSpace.proof_1",
  "constType": "T0Space ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Top",
   "AddSubmonoid.instTopAddSubmonoid.proof_2",
   "AddSubsemigroup.mk",
   "AddSubmonoid.mk",
   "AddSubmonoid.instTopAddSubmonoid.proof_1",
   "Set.univ",
   "AddSubmonoid",
   "Top.mk",
   "AddZeroClass"],
  "name": "AddSubmonoid.instTopAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → Top (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Div"],
  "name": "LinearOrderedField.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Div α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semifield",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{α : Type u} → (α → α → α) → Sup α",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "IsROrC.toDenselyNormedField",
   "StarRing",
   "CommRing.toRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "semiOutParam"],
  "name": "IsROrC.toStarRing",
  "constType": "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → StarRing K",
  "constCategory": "Definition"},
 {"references":
  ["Set.Icc", "TopologicalSpace", "CompactIccSpace", "Preorder", "IsCompact"],
  "name": "CompactIccSpace.isCompact_Icc",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : CompactIccSpace α] {a b : α},\n  IsCompact (Set.Icc a b)",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "NonUnitalRing",
   "HMul.hMul",
   "Eq"],
  "name": "NonUnitalRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "zero_lt_two",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "LinearOrderedSemifield",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CommGroupWithZero.toCommMonoidWithZero",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "div_pos",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "instNatAtLeastTwo"],
  "name": "half_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 < a → 0 < a / 2",
  "constCategory": "Theorem"},
 {"references":
  ["Asymptotics.IsBigOWith_def",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "Eq.refl",
   "Asymptotics.IsBigOWith",
   "Filter.Eventually",
   "Asymptotics.IsLittleO",
   "implies_congr",
   "Asymptotics.IsLittleO_def",
   "LE.le",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Norm",
   "instHMul",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "LT.lt",
   "HMul.hMul",
   "Filter",
   "Norm.norm",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Asymptotics.isLittleO_iff",
  "constType":
  "∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : α → E} {g : α → F} {l : Filter α},\n  f =o[l] g ↔ ∀ ⦃c : ℝ⦄, 0 < c → ∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.instPartialOrderFilter.proof_3",
   "Membership.mem",
   "LE.mk",
   "And",
   "Filter.instPartialOrderFilter.proof_1",
   "PartialOrder.mk",
   "Set",
   "Not",
   "Filter",
   "LT.mk",
   "Filter.instPartialOrderFilter.proof_2",
   "Filter.instPartialOrderFilter.proof_4",
   "PartialOrder",
   "instMembershipSetFilter",
   "Preorder.mk"],
  "name": "Filter.instPartialOrderFilter",
  "constType": "{α : Type u} → PartialOrder (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Real",
   "Real.metricSpace.proof_1",
   "Real.pseudoMetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace"],
  "name": "Real.metricSpace",
  "constType": "MetricSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "AbsoluteValue.abs",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toOrderedSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name": "IsAbsoluteValue.abs_isAbsoluteValue",
  "constType":
  "∀ {S : Type u_1} [inst : LinearOrderedRing S], IsAbsoluteValue abs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Inhabited",
   "Real",
   "Inhabited.mk"],
  "name": "Real.instInhabitedReal",
  "constType": "Inhabited ℝ",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "AddCommMagma.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b : G), a + b = b + a) → AddCommMagma G",
  "constCategory": "Other"},
 {"references":
  ["OrderedSemiring",
   "inferInstance",
   "Real.strictOrderedCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Real",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Real.orderedSemiring",
  "constType": "OrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "Classical.choose",
   "Subtype.val",
   "NontriviallyNormedField.toNormedField",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "rfl",
   "RingHom.id",
   "Eq",
   "Subtype.property",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "HasFDerivAt",
   "UniformSpace.toTopologicalSpace",
   "Eq.symm",
   "Subtype",
   "id",
   "fderiv",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Subtype.ext",
   "Field.toSemifield",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Not",
   "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
   "NormedSpace.toModule",
   "ContinuousLinearMap.zero",
   "Subtype.mk",
   "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944"],
  "name": "fderiv_def",
  "constType":
  "∀ (𝕜 : Type u_6) [inst : NontriviallyNormedField 𝕜] {E : Type u_7} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_8} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E → F)\n  (x : E), fderiv 𝕜 f x = if h : ∃ f', HasFDerivAt f f' x then Classical.choose h else 0",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : StrictOrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "Rat.mk'",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Int.natAbs",
   "Inv.inv"],
  "name": "LinearOrderedField.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommRing : LinearOrderedCommRing α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toRatCast : RatCast α] →\n                    (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) →\n                      0⁻¹ = 0 →\n                        autoParam\n                            (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                              ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                            _auto✝⁴ →\n                          (qsmul : ℚ → α → α) →\n                            autoParam (∀ (a : ℚ) (x : α), qsmul a x = ↑a * x) _auto✝⁵ → LinearOrderedField α",
  "constCategory": "Other"},
 {"references": ["Zero", "SMulWithZero", "SMulZeroClass"],
  "name": "SMulWithZero.toSMulZeroClass",
  "constType":
  "{R : Type u_1} → {M : Type u_3} → [inst : Zero R] → [inst_1 : Zero M] → [self : SMulWithZero R M] → SMulZeroClass R M",
  "constCategory": "Definition"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α},\n  b < c → ∀ (a : α), b + a < c + a",
  "constCategory": "Theorem"},
 {"references":
  ["MulHomClass",
   "NonUnitalNonAssocSemiring",
   "outParam",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.toMulHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] → [self : NonUnitalRingHomClass F α β] → MulHomClass F α β",
  "constCategory": "Definition"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "setOf",
   "Set",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "Metric.closedBall",
  "constType": "{α : Type u} → [inst : PseudoMetricSpace α] → α → ℝ → Set α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHasEquiv",
   "Or",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toField",
   "LT.lt",
   "LE",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LE (CauSeq α abs)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "id"],
  "name": "RingHom.id.proof_1",
  "constType": "∀ (α : Type u_1) [inst : NonAssocSemiring α], id 1 = id 1",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingletonFinset",
  "constType": "{α : Type u_1} → Singleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "StronglyMeasurableAtFilter",
   "MeasureTheory.StronglyMeasurable",
   "TopologicalSpace",
   "Filter",
   "MeasureTheory.AEStronglyMeasurable.stronglyMeasurableAtFilter",
   "MeasurableSpace",
   "MeasureTheory.StronglyMeasurable.aestronglyMeasurable"],
  "name": "MeasureTheory.StronglyMeasurable.stronglyMeasurableAtFilter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace β] {l : Filter α} {f : α → β}\n  {μ : MeasureTheory.Measure α}, MeasureTheory.StronglyMeasurable f → StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "Subtype",
   "definition._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944"],
  "name": "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
  "constType": "Subtype (Eq definition✝)",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "Real.instLTReal",
   "LT.lt",
   "Real",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "Real.denselyNormedField.match_1",
  "constType":
  "∀ (x x_1 : ℝ) (motive : (∃ a, x < a ∧ a < x_1) → Prop) (x_2 : ∃ a, x < a ∧ a < x_1),\n  (∀ (x_3 : ℝ) (h : x < x_3 ∧ x_3 < x_1), motive (_ : ∃ a, x < a ∧ a < x_1)) → motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap",
   "Semiring",
   "TopologicalSpace",
   "LinearMap.instFunLike",
   "FunLike.coe_injective",
   "ContinuousLinearMap.coe_injective",
   "FunLike.coe",
   "Module",
   "LinearMap",
   "Eq",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_1",
  "constType":
  "∀ {R₁ : Type u_4} {R₂ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_2}\n  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_1} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] (x x_1 : M₁ →SL[σ₁₂] M₂),\n  (fun f => ⇑↑f) x = (fun f => ⇑↑f) x_1 → x = x_1",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "OfNat.ofNat",
   "Fintype",
   "PiLp",
   "IsROrC",
   "EuclideanSpace.proof_1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instOfNat"],
  "name": "EuclideanSpace",
  "constType":
  "(𝕜 : Type u_8) → [inst : IsROrC 𝕜] → (n : Type u_9) → [inst : Fintype n] → Type (max u_9 u_8)",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "Eq.mpr",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "OrderedAddCommMonoid.toPartialOrder",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "Prod.snd",
   "HasSubset.Subset",
   "Filter.principal_mono",
   "Prod.fst",
   "idRel",
   "LE.le",
   "GT.gt",
   "le_iInf₂",
   "Set.instMembershipSet",
   "Set.instHasSubsetSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "Prod.mk",
   "LT.lt",
   "idRel_subset",
   "Filter.instPartialOrderFilter",
   "Prod",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "congrFun",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedAddCommMonoid β] (d : α → α → β),\n  (∀ (x : α), d x x = 0) → Filter.principal idRel ≤ ⨅ i, ⨅ (_ : i > 0), Filter.principal {x | d x.1 x.2 < i}",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "neg_add_cancel_right",
   "id"],
  "name": "sub_add_cancel",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Exists",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "HasFDerivAt",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "DifferentiableAt",
  "constType":
  "(𝕜 : Type u_1) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} → [inst_3 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (E → F) → E → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_zero'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), AddGroupWithOne.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "Eq.mpr",
   "LinearOrderedRing.toLinearOrder",
   "Eq.ndrec",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul_abs_self",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "abs_mul_self",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a * a| = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["SMulZeroClass.mk",
   "instHMul",
   "SMul.mk",
   "SMulWithZero",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "SMulWithZero.mk",
   "MulZeroClass.toMul"],
  "name": "MulZeroClass.toSMulWithZero",
  "constType": "(R : Type u_1) → [inst : MulZeroClass R] → SMulWithZero R R",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.toNNReal.proof_1",
   "OfNat.ofNat",
   "Real.instLinearOrderedRingReal",
   "Real.instLEReal",
   "Real",
   "Max.max",
   "LinearOrderedRing.toMax",
   "NNReal",
   "LE.le",
   "Subtype.mk"],
  "name": "Real.toNNReal",
  "constType": "ℝ → NNReal",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "OrderedAddCommGroup.add_le_add_left",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.to_covariantClass_left_le",
  "constType":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Or", "propext", "or_true_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "MeasurableSet", "MeasurableSpace"],
  "name": "Measurable",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : MeasurableSpace α] → [inst : MeasurableSpace β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Real",
   "Real.instAddMonoidReal",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Real.isROrC.proof_9",
  "constType": "ℝ → 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "MonoidHom.monoidHomClass",
   "MulHomClass.toFunLike",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "MonoidHom.toOneHom",
   "Eq.rec",
   "RingHom.toMonoidHom",
   "Eq.symm",
   "FunLike.coe_injective'"],
  "name": "RingHom.instRingHomClass.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f g : α →+* β),\n  (fun f => f.toFun) f = (fun f => f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{α : Sort u} → Nonempty α → α",
  "constCategory": "Axiom"},
 {"references": ["Add"],
  "name": "AddHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Add M] → [inst : Add N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "HasSubset.Subset",
   "exists_congr",
   "And.left",
   "Filter.HasBasis.mem_iff",
   "nhds_basis_opens",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "And.right",
   "Set.instHasSubsetSet",
   "Iff",
   "TopologicalSpace",
   "Iff.trans",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "mem_nhds_iff",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, s ∈ nhds a ↔ ∃ t ⊆ s, IsOpen t ∧ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "min_le_right",
   "max_le",
   "Inf.mk",
   "le_min",
   "le_max_left",
   "Max.max",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "min_le_left",
   "le_max_right"],
  "name": "LinearOrder.toLattice",
  "constType": "{α : Type u} → [o : LinearOrder α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "outParam"],
  "name": "NonUnitalRingHomClass",
  "constType":
  "Type u_5 →\n  (α : outParam (Type u_6)) →\n    (β : outParam (Type u_7)) →\n      [inst : NonUnitalNonAssocSemiring α] → [inst : NonUnitalNonAssocSemiring β] → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "SubNegMonoid.zsmul_succ'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedSpace"],
  "name": "InnerProductSpace.toNormedSpace",
  "constType":
  "{𝕜 : Type u_4} →\n  {E : Type u_5} →\n    [inst : IsROrC 𝕜] → [inst_1 : NormedAddCommGroup E] → [self : InnerProductSpace 𝕜 E] → NormedSpace 𝕜 E",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_10",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Inv"],
  "name": "DivisionRing.toInv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Inv K",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.775"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.one",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "ContinuousMul",
   "TopologicalSemiring",
   "TopologicalSpace",
   "NonUnitalNonAssocSemiring.toMul"],
  "name": "TopologicalSemiring.toContinuousMul",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonUnitalNonAssocSemiring α] [self : TopologicalSemiring α],\n  ContinuousMul α",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references": ["Or", "IsTotal"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.toMax",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "Max.max",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedSemiring.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) →\n          [toNontrivial : Nontrivial α] →\n            0 ≤ 1 →\n              (∀ (a b c : α), a < b → 0 < c → c * a < c * b) →\n                (∀ (a b c : α), a < b → 0 < c → a * c < b * c) → StrictOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Filter.univ_mem'",
   "tendsto_nhds",
   "Set.preimage",
   "nhds",
   "Set",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Filter",
   "IsOpen",
   "Iff.mpr",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "tendsto_const_nhds",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] {a : α} {f : Filter β}, Filter.Tendsto (fun x => a) f (nhds a)",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "SetLike.instPartialOrder",
   "OrderTop.mk",
   "PartialOrder.toPreorder",
   "Submodule",
   "Top.top",
   "Semiring",
   "OrderTop",
   "Module",
   "Top.mk",
   "SetLike.instMembership",
   "Submodule.setLike",
   "Preorder.toLE",
   "Submodule.instTopSubmodule",
   "AddCommMonoid"],
  "name":
  "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → OrderTop (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "le_max_right",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "neg_le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), -a ≤ |a|",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "AddHom.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "LinearMap.smulRight.proof_2",
   "LinearMap.instFunLike",
   "LinearMap.mk",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "IsScalarTower",
   "RingHom.id",
   "SMulZeroClass.toSMul",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "LinearMap.smulRight.proof_1",
   "AddCommMonoid"],
  "name": "LinearMap.smulRight",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_6} →\n    {M : Type u_9} →\n      {M₁ : Type u_10} →\n        [inst : Semiring R] →\n          [inst_1 : AddCommMonoid M] →\n            [inst_2 : AddCommMonoid M₁] →\n              [inst_3 : Module R M] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Semiring S] →\n                    [inst_6 : Module R S] →\n                      [inst_7 : Module S M] → [inst_8 : IsScalarTower R S M] → (M₁ →ₗ[R] S) → M → M₁ →ₗ[R] M",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RingHom.instRingHomClass",
   "NormedAddCommGroup.toAddCommGroup",
   "AddZeroClass.toAdd",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Distrib.rightDistribClass",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "IsROrC.toStarRing",
   "Semifield.toCommSemiring",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "True",
   "add_mul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "starRingEnd",
   "RingHomClass.toAddMonoidHomClass",
   "Semiring.toNonAssocSemiring",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "instHAdd",
   "AddHomClass.toFunLike",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "MulHomClass.toFunLike",
   "map_add",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NormedField.toNormedCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "EuclideanDomain.toCommRing",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "congrArg",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "congrFun"],
  "name": "IsROrC.innerProductSpace.proof_3",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (x y z : 𝕜),\n  (starRingEnd 𝕜) (x + y) * z = (starRingEnd 𝕜) x * z + (starRingEnd 𝕜) y * z",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "HasDistribNeg",
  "constType": "(α : Type u_1) → [inst : Mul α] → Type u_1",
  "constCategory": "Other"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "OrderedAddCommGroup"],
  "name": "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "Ring.zsmul",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "Norm"],
  "name": "NormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.principal",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.instPartialOrderFilter",
   "Filter.lift'",
   "compRel",
   "Prod.swap",
   "Filter.Tendsto",
   "Prod",
   "Filter",
   "UniformSpace.Core",
   "idRel",
   "LE.le",
   "Preorder.toLE"],
  "name": "UniformSpace.Core.mk",
  "constType":
  "{α : Type u} →\n  (uniformity : Filter (α × α)) →\n    Filter.principal idRel ≤ uniformity →\n      Filter.Tendsto Prod.swap uniformity uniformity →\n        (Filter.lift' uniformity fun s => compRel s s) ≤ uniformity → UniformSpace.Core α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bornology",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "CompleteSpace",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instLEReal",
   "Real.normedField",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instAddReal",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Preorder.toLE",
   "NormedField.toNorm",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Ring.toNeg",
   "Real.instCommSemiringReal",
   "Nat",
   "NormedAlgebra",
   "HPow.hPow",
   "instHSub",
   "Or",
   "NormedField.toMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "PartialOrder",
   "And",
   "instHMul",
   "DecidableEq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "Real",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "instHPow",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "StarRing",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSemigroup.toAdd",
   "algebraMap",
   "HSub.hSub",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Real.instZeroReal",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DenselyNormedField",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "IsROrC.mk",
  "constType":
  "{K : semiOutParam (Type u_1)} →\n  [toDenselyNormedField : DenselyNormedField K] →\n    [toStarRing : StarRing K] →\n      [toNormedAlgebra : NormedAlgebra ℝ K] →\n        [toCompleteSpace : CompleteSpace K] →\n          (re im : K →+ ℝ) →\n            (I : K) →\n              re I = 0 →\n                I = 0 ∨ I * I = -1 →\n                  (∀ (z : K), (algebraMap ℝ K) (re z) + (algebraMap ℝ K) (im z) * I = z) →\n                    (∀ (r : ℝ), re ((algebraMap ℝ K) r) = r) →\n                      (∀ (r : ℝ), im ((algebraMap ℝ K) r) = 0) →\n                        (∀ (z w : K), re (z * w) = re z * re w - im z * im w) →\n                          (∀ (z w : K), im (z * w) = re z * im w + im z * re w) →\n                            (∀ (z : K), re ((starRingEnd K) z) = re z) →\n                              (∀ (z : K), im ((starRingEnd K) z) = -im z) →\n                                (starRingEnd K) I = -I →\n                                  (∀ (z : K), ‖z‖ ^ 2 = re z * re z + im z * im z) →\n                                    (∀ (z : K), im z * im I = im z) →\n                                      [toPartialOrder : PartialOrder K] →\n                                        (∀ {z w : K}, z ≤ w ↔ re z ≤ re w ∧ im z = im w) →\n                                          [toDecidableEq : DecidableEq K] → IsROrC K",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5031",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5148",
   "Semifield",
   "Inv",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "CommSemiring",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5070",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mk",
  "constType":
  "{α : Type u_4} →\n  [toCommSemiring : CommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → Semifield α",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    (∀ (a b c : α), a + b ≤ a + c → b ≤ c) → OrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["NatCast", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toNatCast",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSeminormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_13",
  "constType":
  "∀ (a : ℚ) (x : ℝ), (qsmulRec Rat.cast) a x = (qsmulRec Rat.cast) a x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Or",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "rfl",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Field.toCommRing",
   "NormedField.toField",
   "instHMul",
   "Or.intro_left",
   "Ring.toNeg",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_2",
  "constType": "0 = 0 ∨ 0 * 0 = -1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "setOf",
   "MeasureTheory.Measure.ae.proof_2",
   "MeasureTheory.Measure.ae.proof_1",
   "Set",
   "MeasureTheory.Measure.ae.proof_3",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Filter.mk",
   "Filter",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.ae",
  "constType":
  "{α : Type u_6} → {m : MeasurableSpace α} → MeasureTheory.Measure α → Filter α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "AddCommMonoid"],
  "name": "Module",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst : AddCommMonoid M] → Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "TopologicalSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "congrArg",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_nonneg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "true_or_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedField α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mul_comm",
  "constType": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Inter.inter",
   "Submodule.instInfSubmodule.proof_1",
   "Submodule.instInfSubmodule.proof_3",
   "AddMonoid.toAddZeroClass",
   "Inf.mk",
   "Inf",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.setLike",
   "Submodule.instInfSubmodule.proof_2",
   "AddCommMonoid",
   "Set.instInterSet",
   "SetLike.coe"],
  "name": "Submodule.instInfSubmodule",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Inf (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Norm", "NormedDivisionRing"],
  "name": "NormedDivisionRing.toNorm",
  "constType": "{α : Type u_5} → [self : NormedDivisionRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNorm",
   "NormedRing",
   "SeminormedRing",
   "NormedRing.norm_mul",
   "NormedRing.dist_eq",
   "MetricSpace.toPseudoMetricSpace",
   "NormedRing.toMetricSpace",
   "SeminormedRing.mk",
   "NormedRing.toRing"],
  "name": "NormedRing.toSeminormedRing",
  "constType": "{α : Type u_1} → [β : NormedRing α] → SeminormedRing α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "OfNat.ofNat",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_5",
  "constType": "∀ (r : ℝ), 0 ((algebraMap ℝ ℝ) r) = 0 ((algebraMap ℝ ℝ) r)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "DivisionRing.toDiv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.div_eq_mul_inv",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNormedRing.toNorm",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "NonUnitalNormedRing",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le"],
  "name": "NonUnitalNormedRing.norm_mul",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalNormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references": ["Zero", "SMul", "PseudoMetricSpace"],
  "name": "BoundedSMul",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) →\n    [inst : PseudoMetricSpace α] →\n      [inst : PseudoMetricSpace β] → [inst : Zero α] → [inst : Zero β] → [inst : SMul α β] → Prop",
  "constCategory": "Other"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NormedField.toNorm",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "IsROrC.mul_conj",
   "IsROrC.ofReal_re",
   "NormedAddCommGroup.toNorm",
   "MonoidWithZeroHom",
   "Nat",
   "HPow.hPow",
   "IsROrC.normSq",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "EuclideanDomain.toCommRing",
   "CommMagma.toMul",
   "instHMul",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "IsROrC.toStarRing",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "mul_comm",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Monoid.toNatPow",
   "Inner.inner",
   "instOfNatNat",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMonoidReal",
   "IsROrC.toDenselyNormedField",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddHomClass.toFunLike",
   "Inner.mk",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "IsROrC.normSq_eq_def'",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "IsROrC.ofReal",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Real.semiring",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "IsROrC.innerProductSpace.proof_1",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (x : 𝕜), ‖x‖ ^ 2 = IsROrC.re (inner x x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "List.finRange.proof_1",
   "List.pmap",
   "List.mem_range",
   "List.instMembershipList",
   "Fin.val",
   "List.mem_pmap",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "List",
   "LT.lt",
   "List.finRange",
   "Nat",
   "Eq.symm",
   "Fin.isLt",
   "Fin",
   "Fin.mk",
   "Fin.casesOn",
   "List.range"],
  "name": "List.mem_finRange",
  "constType": "∀ {n : ℕ} (a : Fin n), a ∈ List.finRange n",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace",
   "Filter",
   "definition._@.Mathlib.Topology.Basic._hyg.10659",
   "Subtype",
   "Eq"],
  "name": "wrapped._@.Mathlib.Topology.Basic._hyg.10659",
  "constType": "Subtype (Eq @definition✝)",
  "constCategory": "Other"},
 {"references": ["EuclideanDomain", "CommRing"],
  "name": "EuclideanDomain.toCommRing",
  "constType": "{R : Type u} → [self : EuclideanDomain R] → CommRing R",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (α → Sort u_3)} → (coe : F → (a : α) → β a) → Function.Injective coe → FunLike F α β",
  "constCategory": "Other"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Bot.bot",
   "LinearOrder",
   "Preorder.topology",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "nhds",
   "Classical.propDecidable",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Set.Iio",
   "CompleteLattice.toBot",
   "ite",
   "Eq",
   "DistribLattice.toLattice",
   "limUnder",
   "instDecidableNot",
   "TopologicalSpace",
   "Filter.Tendsto",
   "Not",
   "Filter",
   "instDecidableOr",
   "Function.leftLim.proof_1",
   "nhdsWithin",
   "Filter.instCompleteLatticeFilter"],
  "name": "Function.leftLim",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : LinearOrder α] → [inst : TopologicalSpace β] → (α → β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Data.AC.Expr.op",
   "Exists",
   "OfNat.ofNat",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Exists.intro",
   "Lean.IsNeutral",
   "Exists.casesOn",
   "Eq",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Eq.mpr",
   "Filter.inter_mem",
   "Lean.Data.AC.Context",
   "Option.none",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "instOfNatNat",
   "Filter",
   "Option.some",
   "List.nil",
   "Nat",
   "Eq.symm",
   "And.casesOn",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "List.cons",
   "setOf",
   "Set.inter_isComm",
   "Lean.Data.AC.eval",
   "instIsCommutative",
   "Lean.IsIdempotent",
   "Set.instMembershipSet",
   "And",
   "Eq.ndrec",
   "Lean.Data.AC.instEvalInformationContext",
   "instIsAssociative",
   "Lean.IsCommutative",
   "congr",
   "Bool",
   "And.intro",
   "congrArg",
   "Lean.Data.AC.Context.mk",
   "Lean.Data.AC.Expr.var",
   "Set.inter_isAssoc",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_3",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α) {x y : Set α},\n  x ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} →\n    y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} → x ∩ y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b}",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Zero.toOfNat0",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "AddGroup.toSubtractionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (x : G), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "Field",
   "Rat.cast",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Field.qsmul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Field.toRatCast",
   "Eq"],
  "name": "Field.qsmul_eq_mul'",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℚ) (x : K), Field.qsmul a x = ↑a * x",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SemilatticeSup",
   "Exists",
   "PartialOrder.toPreorder",
   "propext",
   "Set",
   "Filter.mem_atTop_sets",
   "GE.ge",
   "Filter",
   "Filter.atTop",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Nonempty",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.4",
  "constType":
  "∀ {α : Type u_3} [inst : Nonempty α] [inst : SemilatticeSup α] {s : Set α}, (s ∈ Filter.atTop) = ∃ a, ∀ b ≥ a, b ∈ s",
  "constCategory": "Theorem"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MulActionWithZero",
  "constType":
  "(R : Type u_1) → (M : Type u_3) → [inst : MonoidWithZero R] → [inst : Zero M] → Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "fderiv",
   "OfNat.ofNat",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "AddCommGroup.toAddCommMonoid",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "NormedSpace",
   "RingHom.id",
   "Semiring.toOne",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedField.toNormedSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "ContinuousMapClass.toFunLike"],
  "name": "deriv",
  "constType":
  "{𝕜 : Type u} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {F : Type v} → [inst_1 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (𝕜 → F) → 𝕜 → F",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "NonUnitalNormedRing"],
  "name": "NonUnitalNormedRing.toMetricSpace",
  "constType":
  "{α : Type u_5} → [self : NonUnitalNormedRing α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.GenerateSets.inter",
   "setOf",
   "Filter.GenerateSets",
   "Filter.mk",
   "Set",
   "Filter",
   "Filter.GenerateSets.superset",
   "Filter.GenerateSets.univ"],
  "name": "Filter.generate",
  "constType": "{α : Type u} → Set (Set α) → Filter α",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Sub"],
  "name": "AddGroupWithOne.toSub",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Sub R",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.instMulReal",
   "DivisionRing.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toIntCast",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Real.instInvReal",
   "Nat",
   "Ne",
   "Rat.cast_mk'",
   "Real.ofCauchy_natCast",
   "Rat.instLinearOrderedRingRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.intCast",
   "Real.ofCauchy",
   "DivisionRing.toInv",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Real.ofCauchy_inv",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv",
   "StrictOrderedRing.toRing",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toDivisionSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "DivisionRing.toRing",
   "Real",
   "Real.ofCauchy_ratCast",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "Rat.mk'",
   "Real.ofCauchy_intCast",
   "Inv.mk",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Rat.instSupRat",
   "Real.ofCauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "RatCast.mk",
   "Rat",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "LinearOrderedCommRing.mk",
   "Rat.divisionRing",
   "Real.linearOrderedCommRing",
   "Nat.Coprime",
   "HMul.hMul",
   "Int.natAbs"],
  "name": "Real.instLinearOrderedFieldReal.proof_12",
  "constType":
  "∀ (n : ℤ) (d : ℕ) (hd : d ≠ 0) (h2 : Nat.Coprime (Int.natAbs n) d), ↑(Rat.mk' n d) = ↑n * (↑d)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Field.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "Ring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ring.toNonAssocRing.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.instFunLike",
   "RingHom.id",
   "Eq",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "AddCommMonoid",
   "add_smul",
   "Semiring",
   "instHAdd",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "MulActionWithZero.toSMulWithZero",
   "Eq.ndrec",
   "LinearMap.map_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero"],
  "name": "LinearMap.smulRight.proof_1",
  "constType":
  "∀ {R : Type u_4} {S : Type u_2} {M : Type u_1} {M₁ : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M₁] [inst_3 : Module R M₁] [inst_4 : Semiring S] [inst_5 : Module R S] [inst_6 : Module S M]\n  (f : M₁ →ₗ[R] S) (x : M) (x_1 y : M₁), (fun b => f b • x) (x_1 + y) = (fun b => f b • x) x_1 + (fun b => f b • x) y",
  "constCategory": "Theorem"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "DistribMulAction.mk",
   "Pi.module.proof_2",
   "Semiring",
   "Pi.module.proof_1",
   "Semiring.toMonoidWithZero",
   "Pi.module.proof_3",
   "AddCommMonoid.toAddMonoid",
   "DistribMulAction",
   "Pi.addMonoid",
   "Pi.module.proof_4",
   "Pi.addCommMonoid",
   "MonoidWithZero.toMonoid",
   "Module",
   "Pi.distribMulAction",
   "AddCommMonoid",
   "Module.mk"],
  "name": "Pi.module",
  "constType":
  "(I : Type u) →\n  (f : I → Type v) →\n    (α : Type u_1) →\n      {r : Semiring α} →\n        {m : (i : I) → AddCommMonoid (f i)} → [inst : (i : I) → Module α (f i)] → Module α ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set",
   "MeasurableSpace.measurableSet_injective.match_1",
   "HasCompl.compl",
   "Eq.refl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.mk",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.iUnion",
   "Eq.ndrec",
   "Function.Injective",
   "Eq.rec",
   "MeasurableSet",
   "Nat",
   "MeasurableSpace"],
  "name": "MeasurableSpace.measurableSet_injective",
  "constType": "∀ {α : Type u_1}, Function.Injective (@MeasurableSet α)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Int"],
  "name": "SubNegMonoid.zsmul",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Filter.instInfFilter.proof_3",
   "Membership.mem",
   "And",
   "Exists",
   "Inf.mk",
   "Filter.instInfFilter.proof_1",
   "setOf",
   "Inf",
   "Filter.mk",
   "Set",
   "Inter.inter",
   "Filter",
   "Filter.instInfFilter.proof_2",
   "Set.instInterSet",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Filter.instInfFilter",
  "constType": "{α : Type u} → Inf (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "LinearOrder",
   "LinearOrder.max_def",
   "Real",
   "Real.nontrivial",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.commRing",
   "CommRing.mul_comm",
   "StrictOrderedRing.toNontrivial",
   "StrictOrderedRing.mul_pos",
   "CommRing",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "Nontrivial",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "Int",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), Semifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toSup : Sup α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ a ⊔ b) →\n        (∀ (a b : α), b ≤ a ⊔ b) → (∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references": ["SeminormedAddCommGroup", "PseudoMetricSpace"],
  "name": "SeminormedAddCommGroup.toPseudoMetricSpace",
  "constType":
  "{E : Type u_9} → [self : SeminormedAddCommGroup E] → PseudoMetricSpace E",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.Regular.toIsFiniteMeasureOnCompacts",
   "Real.borelSpace",
   "NormedAddCommGroup",
   "PartialOrder.toPreorder",
   "MeasureTheory.Measure.Regular.of_sigmaCompactSpace_of_isLocallyFiniteMeasure",
   "Real.lattice",
   "Real.measurableSpace",
   "Real",
   "Inf.inf",
   "ConditionallyCompleteLinearOrder.toCompactIccSpace",
   "BorelSpace.opensMeasurable",
   "MetricSpace.toMetrizableSpace",
   "MeasureTheory.Measure",
   "Lattice.toInf",
   "instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal",
   "SemilatticeSup.toSup",
   "locally_compact_of_proper",
   "SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace",
   "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "Lattice.toSemilatticeSup",
   "MeasureTheory.IntegrableOn.intervalIntegrable",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "ContinuousOn.integrableOn_Icc",
   "IntervalIntegrable",
   "Lattice.toSemilatticeInf",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.uIcc",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "instProperSpaceRealPseudoMetricSpace",
   "TopologicalSpace.MetrizableSpace.toPseudoMetrizableSpace",
   "Real.metricSpace",
   "instWeaklyLocallyCompactSpace_1",
   "Real.instConditionallyCompleteLinearOrderReal",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Real.instAddGroupReal",
   "Sup.sup",
   "ContinuousOn"],
  "name": "ContinuousOn.intervalIntegrable",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] {μ : MeasureTheory.Measure ℝ}\n  [inst_1 : MeasureTheory.IsLocallyFiniteMeasure μ] {u : ℝ → E} {a b : ℝ},\n  ContinuousOn u (Set.uIcc a b) → IntervalIntegrable u μ a b",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → ZeroHom M N",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "true_or", "iff_of_eq", "True"],
  "name": "true_or_iff",
  "constType": "∀ (p : Prop), True ∨ p ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "NontriviallyNormedField.toNormedField",
   "HasDerivAtFilter.proof_2",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedRing.toPseudoMetricSpace",
   "NormedSpace",
   "RingHom.id",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "HasFDerivAtFilter",
   "NormedField.toNormedSpace",
   "ContinuousLinearMap.smulRight",
   "Filter",
   "UniformSpace.toTopologicalSpace",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NontriviallyNormedField",
   "HasDerivAtFilter.proof_1",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "ContinuousLinearMap",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "ContinuousLinearMap.one"],
  "name": "HasDerivAtFilter",
  "constType":
  "{𝕜 : Type u} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {F : Type v} → [inst_1 : NormedAddCommGroup F] → [inst : NormedSpace 𝕜 F] → (𝕜 → F) → F → 𝕜 → Filter 𝕜 → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), LinearOrderedField.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "AddMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_add",
   "NonAssocSemiring",
   "outParam",
   "AddHomClass.mk",
   "RingHomClass.toMonoidHomClass",
   "AddMonoidHomClass.mk",
   "RingHomClass.map_zero"],
  "name": "RingHomClass.toAddMonoidHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] →\n        [inst_1 : NonAssocSemiring β] → [self : RingHomClass F α β] → AddMonoidHomClass F α β",
  "constCategory": "Definition"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} → [self : Field K] → CommRing K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Set.instHasSubsetSet",
   "Submodule",
   "Semiring",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Inter.inter",
   "Module",
   "Submodule.setLike",
   "Set.instInterSet",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.completeLattice.proof_6",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x x_1 x_2 : Submodule R M), ↑x ⊆ ↑x_1 → ↑x ⊆ ↑x_2 → ↑x ⊆ ↑x_1 ∩ ↑x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references": ["Bornology.cobounded'", "Filter", "Bornology"],
  "name": "Bornology.cobounded",
  "constType": "(α : Type u_4) → [inst : Bornology α] → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["PiLp.instPseudoMetricSpacePiLp",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "PiLp",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SeminormedAddCommGroup",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "Preorder.toLE",
   "SeminormedAddCommGroup.mk",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "PiLp.seminormedAddCommGroup.proof_1",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Fintype",
   "PiLp.hasNorm",
   "SeminormedAddCommGroup.toNorm",
   "AddCommGroup.toAddGroup",
   "Pi.addCommGroup",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "AddCommGroup",
   "PiLp.seminormedAddCommGroup.proof_2",
   "Fact",
   "AddCommGroup.mk"],
  "name": "PiLp.seminormedAddCommGroup",
  "constType":
  "(p : ENNReal) →\n  {ι : Type u_3} →\n    (β : ι → Type u_5) →\n      [inst : Fintype ι] →\n        [inst : Fact (1 ≤ p)] → [inst : (i : ι) → SeminormedAddCommGroup (β i)] → SeminormedAddCommGroup (PiLp p β)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NormedAlgebra.id.proof_3",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "Algebra.toRingHom",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "Algebra",
   "NormedAlgebra.id.proof_1",
   "NormedAlgebra",
   "DistribMulAction.toMulAction",
   "NormedAlgebra.id.proof_2",
   "NormedField",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "NormedField.toNormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedRing.toRing",
   "MulAction.toSMul",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "Algebra.mk",
   "NormedSpace.toModule",
   "NormedAlgebra.mk"],
  "name": "NormedAlgebra.id",
  "constType": "(𝕜 : Type u_5) → [inst : NormedField 𝕜] → NormedAlgebra 𝕜 𝕜",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Semiring.toNonAssocSemiring",
   "instHAdd",
   "Distrib.rightDistribClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "HMul.hMul",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "add_mul"],
  "name": "Semiring.toModule.proof_3",
  "constType":
  "∀ {R : Type u_1} [inst : Semiring R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.nonempty_iff_ne_empty",
   "Ne",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Not",
   "Set.instEmptyCollectionSet",
   "Classical.or_iff_not_imp_left",
   "Iff.mpr",
   "Eq"],
  "name": "Set.eq_empty_or_nonempty",
  "constType": "∀ {α : Type u} (s : Set α), s = ∅ ∨ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "NeZero.ne",
   "One",
   "One.toOfNat1"],
  "name": "one_ne_zero",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 1 ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderDual",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Definition"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Sort u) → Trans Eq r r",
  "constCategory": "Definition"},
 {"references":
  ["Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Real",
   "LinearOrderedAddCommGroup.to_noMinOrder",
   "nhdsWithin_Iio_self_neBot",
   "Eq",
   "MetricSpace.toMetrizableSpace",
   "Real.linearOrder",
   "Filter.Tendsto.mono_left",
   "StieltjesFunction.mono",
   "nhdsWithin_le_nhds",
   "tendsto_nhds_unique",
   "LinearOrderedField.toLinearOrderedSemifield",
   "nhdsWithin",
   "StieltjesFunction.id",
   "UniformSpace.toTopologicalSpace",
   "id",
   "TopologicalSpace.t2Space_of_metrizableSpace",
   "Function.leftLim",
   "Lattice.toSemilatticeInf",
   "nhds",
   "instDistribLattice",
   "Real.nontrivial",
   "PseudoMetricSpace.toUniformSpace",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Set.Iio",
   "Real.instLinearOrderedAddCommGroupReal",
   "continuousAt_id",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "DistribLattice.toLattice",
   "StieltjesFunction.toFun",
   "Real.metricSpace",
   "Real.instConditionallyCompleteLinearOrderReal",
   "ContinuousAt.tendsto",
   "LinearOrderedSemiField.toDenselyOrdered",
   "Monotone.tendsto_leftLim"],
  "name": "StieltjesFunction.id_leftLim",
  "constType": "∀ (x : ℝ), Function.leftLim (↑StieltjesFunction.id) x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrder",
   "instDistribLattice",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_neg",
   "abs_eq_max_neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "SemilatticeSup.toSup",
   "InvolutiveNeg.toNeg",
   "Max.max",
   "LinearOrder.toMax",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "max_comm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "abs_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] (a : α), |(-a)| = |a|",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references": ["MetricSpace", "PseudoMetricSpace"],
  "name": "MetricSpace.toPseudoMetricSpace",
  "constType": "{α : Type u} → [self : MetricSpace α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "AddHom", "Add", "Eq"],
  "name": "AddHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : Add M] → [inst_1 : Add N] → (toFun : M → N) → (∀ (x y : M), toFun (x + y) = toFun x + toFun y) → AddHom M N",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "instHSMul",
   "LinearMap.map_smul'",
   "AddHom.toFun",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "MonoidWithZero.toZero",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_3",
  "constType":
  "∀ {R₁ : Type u_4} {R₂ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_2}\n  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_1} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] (f : M₁ →SL[σ₁₂] M₂) (r : R₁) (x : M₁),\n  AddHom.toFun f.toAddHom (r • x) = σ₁₂ r • AddHom.toFun f.toAddHom x",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["LocallyCompactSpace",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "locallyCompactSpace_of_hasBasis",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Metric.closedBall",
   "LT.lt",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace.isCompact_closedBall",
   "UniformSpace.toTopologicalSpace",
   "ProperSpace",
   "PseudoMetricSpace",
   "Metric.nhds_basis_closedBall"],
  "name": "locally_compact_of_proper",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], LocallyCompactSpace α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalRing.to_topologicalAddGroup",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instLinearOrderedFieldReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.commRing",
   "Real.pseudoMetricSpace",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Real.instDivisionRingReal",
   "inferInstance",
   "LinearOrderedField.toTopologicalDivisionRing",
   "Real.instAddGroupReal",
   "TopologicalDivisionRing.toTopologicalRing",
   "UniformSpace.toTopologicalSpace",
   "TopologicalAddGroup"],
  "name":
  "instTopologicalAddGroupRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstAddGroupReal",
  "constType": "TopologicalAddGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Ring.toSemiring",
   "Int",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["Fintype", "NormedAddCommGroup", "InnerProductSpace", "IsROrC"],
  "name": "OrthonormalBasis",
  "constType":
  "(ι : Type u_1) →\n  (𝕜 : Type u_3) →\n    [inst : IsROrC 𝕜] →\n      (E : Type u_4) →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst : InnerProductSpace 𝕜 E] → [inst : Fintype ι] → Type (max (max u_1 u_3) u_4)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "AddMonoid"],
  "name": "Real.instAddMonoidReal",
  "constType": "AddMonoid ℝ",
  "constCategory": "Definition"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{α : Type u} → [self : Inf α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "DenselyOrdered",
  "constType": "(α : Type u) → [inst : LT α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "nhds",
   "Set",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Filter.HasBasis.mem_iff",
   "Metric.nhds_basis_ball",
   "GT.gt",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "LT.lt",
   "Filter",
   "Metric.ball",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "instMembershipSetFilter"],
  "name": "Metric.mem_nhds_iff",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {s : Set α}, s ∈ nhds x ↔ ∃ ε > 0, Metric.ball x ε ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "MeasureTheory.OuterMeasure.comap",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "IsScalarTower.right",
   "Subtype.val",
   "Set",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.OuterMeasure.restrict.proof_2",
   "Set.instMembershipSet",
   "MeasureTheory.OuterMeasure.restrict.proof_1",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.OuterMeasure.map",
   "OrderedSemiring.toSemiring",
   "LinearMap.comp",
   "MeasureTheory.OuterMeasure.instModule",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "LinearMap",
   "Subtype",
   "Semiring.toModule"],
  "name": "MeasureTheory.OuterMeasure.restrict",
  "constType":
  "{α : Type u_1} → Set α → MeasureTheory.OuterMeasure α →ₗ[ENNReal] MeasureTheory.OuterMeasure α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Real",
   "ENNReal.ofReal",
   "ENNReal.ofReal_lt_top",
   "True",
   "Eq",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "eq_true",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLinearOrder.toCompletelyDistribLattice"],
  "name": "Mathlib.MeasureTheory.Measure.Lebesgue.Basic._auxLemma.1",
  "constType": "∀ {r : ℝ}, (ENNReal.ofReal r < ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["DivisionRing",
   "DivisionRing.toRing",
   "TopologicalRing",
   "TopologicalSpace",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "TopologicalDivisionRing",
   "Ring.toNonAssocRing"],
  "name": "TopologicalDivisionRing.toTopologicalRing",
  "constType":
  "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : TopologicalSpace K] [self : TopologicalDivisionRing K],\n  TopologicalRing K",
  "constCategory": "Definition"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "∀ {α : Type u_1} (a : α), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "norm_mul_le",
   "NonUnitalSeminormedRing.toNorm",
   "NonUnitalNonAssocRing.toMul",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "NormedCommRing.toNormedRing",
   "NormedField.toNormedCommRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "LE.le",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NormedRing.toNonUnitalNormedRing",
   "instHMul",
   "HMul.hMul",
   "Norm.norm"],
  "name": "NormedField.toNormedSpace.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [self : OrderedCommSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.neg.match_1",
  "constType":
  "(motive : ℤ → Sort u_1) → (n : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((n : ℕ) → motive (Int.negSucc n)) → motive n",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "constCategory": "Other"},
 {"references": ["Dist", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toDist",
  "constType": "{α : Type u} → [self : PseudoMetricSpace α] → Dist α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "SetLike.instPartialOrder.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "PartialOrder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Preorder.mk",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "SetLike.instPartialOrder.proof_3",
   "Set.instBooleanAlgebraSet",
   "Preorder.toLT",
   "SetLike.instPartialOrder.proof_2",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → PartialOrder A",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "abs_le'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Iff",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "neg_le",
   "And",
   "and_comm",
   "Eq.ndrec",
   "propext",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_le",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, |a| ≤ b ↔ -b ≤ a ∧ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "CanonicallyLinearOrderedSemifield.toNontrivial",
   "instDecidableEq",
   "WithTop",
   "instLinearOrder",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "inferInstanceAs",
   "instNNRealCanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop",
   "CanonicallyOrderedCommSemiring",
   "NNReal"],
  "name": "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
  "constType": "CanonicallyOrderedCommSemiring ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_8",
  "constType": "∀ {α : Type u_1} [inst : Ring α], NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "EMetric.complete_of_cauchySeq_tendsto",
   "CompleteSpace",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "Filter.Tendsto",
   "UniformSpace.toTopologicalSpace",
   "Nat",
   "Filter.atTop",
   "PseudoMetricSpace",
   "Nat.strictOrderedSemiring",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name": "Metric.complete_of_cauchySeq_tendsto",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α],\n  (∀ (u : ℕ → α), CauchySeq u → ∃ a, Filter.Tendsto u Filter.atTop (nhds a)) → CompleteSpace α",
  "constCategory": "Theorem"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.ratCast",
  "constType": "{K : Type u} → [self : RatCast K] → ℚ → K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedField",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Submodule",
   "instHSMul",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "Submodule.span",
   "SetLike.instMembership",
   "Eq",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Set.instSingletonSet",
   "propext",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Singleton.singleton",
   "Submodule.mem_span_singleton",
   "MonoidWithZero.toZero",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Mathlib.LinearAlgebra.Span._auxLemma.11",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x y : M},\n  (x ∈ Submodule.span R {y}) = ∃ a, a • y = x",
  "constCategory": "Theorem"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "Module.toMulActionWithZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "IsScalarTower",
   "NormedSpace",
   "NormedField.toField",
   "Monoid.toMulAction",
   "DivisionSemiring.toSemiring",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "MulActionWithZero.toMulAction",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "HasDerivAtFilter.proof_1",
  "constType":
  "∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {F : Type u_1} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F], IsScalarTower 𝕜 𝕜 F",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "GaloisInsertion.liftCompleteLattice.proof_1",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "GaloisInsertion.liftCompleteLattice.proof_2",
   "GaloisInsertion.liftBoundedOrder",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice.proof_4",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "GaloisInsertion.liftCompleteLattice.proof_6",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "GaloisInsertion.choice",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.liftCompleteLattice.proof_5",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "GaloisInsertion.liftCompleteLattice.proof_7",
   "OrderBot.toBot",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisInsertion.liftCompleteLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : CompleteLattice α] → GaloisInsertion l u → CompleteLattice β",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass.zero_mul",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Semiring.toModule.proof_4",
  "constType": "∀ {R : Type u_1} [inst : Semiring R] (a : R), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Real.natCast",
   "Metric.closedBall",
   "Set",
   "Real",
   "Set.univ",
   "Real.orderedSemiring",
   "Real.instArchimedean",
   "Iff.mpr",
   "exists_nat_ge",
   "Dist.dist",
   "Eq",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "PseudoMetricSpace.toDist",
   "Set.iUnion",
   "Nat.cast",
   "Nat",
   "PseudoMetricSpace"],
  "name": "Metric.iUnion_closedBall_nat",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), ⋃ n, Metric.closedBall x ↑n = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "TopologicalSemiring",
   "TopologicalRing",
   "TopologicalSpace"],
  "name": "TopologicalRing.toTopologicalSemiring",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonUnitalNonAssocRing α] [self : TopologicalRing α],\n  TopologicalSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedField",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "Fin.fintype",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "OrthonormalBasis",
   "NormedField.toField",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "FiniteDimensional.finrank",
   "InnerProductSpace",
   "NormedDivisionRing.toDivisionRing",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NormedField.toNormedDivisionRing",
   "wrapped._@.Mathlib.Analysis.InnerProductSpace.PiL2._hyg.13914",
   "FiniteDimensional",
   "Fin"],
  "name": "stdOrthonormalBasis",
  "constType":
  "(𝕜 : Type u_8) →\n  [inst : IsROrC 𝕜] →\n    (E : Type u_9) →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : InnerProductSpace 𝕜 E] →\n          [inst_3 : FiniteDimensional 𝕜 E] → OrthonormalBasis (Fin (FiniteDimensional.finrank 𝕜 E)) 𝕜 E",
  "constCategory": "Definition"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "GroupWithZero",
   "HMul.hMul",
   "IsUnit.mul_div_cancel",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "mul_div_cancel",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "nhds",
   "Set",
   "mem_nhds_iff",
   "HasSubset.Subset",
   "Exists.intro",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Set.Subset.refl",
   "And",
   "Set.instHasSubsetSet",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "IsOpen",
   "instMembershipSetFilter"],
  "name": "IsOpen.mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] {a : α} {s : Set α}, IsOpen s → a ∈ s → s ∈ nhds a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "NatCast",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "CauSeq.Completion.instNatCastCauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "NatCast.mk",
   "Abs.abs",
   "Rat.instSupRat",
   "Nat.cast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.natCast",
  "constType": "NatCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instInfSetSubmodule",
   "SetLike.instPartialOrder",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Submodule",
   "Semiring",
   "Set",
   "InfSet.sInf",
   "Module",
   "LE.le",
   "Preorder.toLE",
   "Submodule.setLike",
   "Set.subset_iInter₂",
   "SetLike.coe",
   "Set.instMembershipSet",
   "AddCommMonoid"],
  "name":
  "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {S : Set (Submodule R M)} {p : Submodule R M}, (∀ q ∈ S, p ≤ q) → p ≤ sInf S",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalNonAssocRing",
   "InvolutiveNeg.toNeg",
   "Neg.neg",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubtractionMonoid.toInvolutiveNeg",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a : α), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Filter",
   "Set.Ici",
   "Preorder",
   "ConditionallyCompleteLattice.toInfSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.atTop",
  "constType": "{α : Type u_3} → [inst : Preorder α] → Filter α",
  "constCategory": "Definition"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Field.toNontrivial",
   "EuclideanDomain.mk",
   "Semifield.toCommGroupWithZero",
   "Field.toEuclideanDomain.proof_3",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Field.toEuclideanDomain.proof_4",
   "Field",
   "Ring.toSub",
   "Field.toEuclideanDomain.proof_1",
   "HDiv.hDiv",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "HSub.hSub",
   "Field.toSemifield",
   "CommGroupWithZero.toCommMonoidWithZero",
   "instHMul",
   "And",
   "Field.toEuclideanDomain.proof_2",
   "HMul.hMul",
   "Field.toDiv",
   "EuclideanDomain",
   "Field.toDivisionRing",
   "Field.toEuclideanDomain.proof_5"],
  "name": "Field.toEuclideanDomain",
  "constType": "{K : Type u_1} → [inst : Field K] → EuclideanDomain K",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [inst : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Exists",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "Real.natCast",
   "Real",
   "Real.instLEReal",
   "DenselyNormedField.toNormedField",
   "DenselyNormedField.lt_norm_lt",
   "Exists.intro",
   "NormedField.toNorm",
   "Real.instOneReal",
   "one_lt_two",
   "AddMonoid.toAddSemigroup",
   "DenselyNormedField.toNontriviallyNormedField.match_1",
   "Real.strictOrderedSemiring",
   "AddGroup.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "NeZero.charZero_one",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "instOfNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Real.partialOrder",
   "AddSemigroup.toAdd",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Real.instRingReal",
   "Real.orderedSemiring",
   "Real.instZeroReal",
   "And",
   "StrictOrderedSemiring.to_charZero",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "DenselyNormedField",
   "zero_le_one",
   "Real.instAddGroupReal",
   "instNatAtLeastTwo",
   "Norm.norm"],
  "name": "DenselyNormedField.toNontriviallyNormedField.proof_1",
  "constType": "∀ {α : Type u_1} [inst : DenselyNormedField α], ∃ x, 1 < ‖x‖",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSeminormedRing", "PseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toPseudoMetricSpace",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "Mul",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocRing α",
  "constCategory": "Other"},
 {"references": ["Nat.linearOrder", "LinearOrder.toLattice", "Lattice", "Nat"],
  "name": "Nat.instLatticeNat",
  "constType": "Lattice ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "instOfNatInt",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_zero'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "instHSub",
   "PseudoMetricSpace.toDist",
   "NormedField.toMetricSpace",
   "Real",
   "NormedField",
   "Ring.toSub",
   "HSub.hSub",
   "CommRing.toRing",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedField.toNorm",
   "Dist.dist",
   "Eq"],
  "name": "NormedField.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NormedField α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "le_rfl",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "abs_of_nonneg",
   "Eq",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_zero",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], |0| = 0",
  "constCategory": "Theorem"},
 {"references": ["TopologicalSpace", "MeasurableSpace"],
  "name": "BorelSpace",
  "constType":
  "(α : Type u_6) → [inst : TopologicalSpace α] → [inst : MeasurableSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "separated_t3",
   "T25Space.t2Space",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "T2Space",
   "TopologicalSpace",
   "T3Space.t25Space",
   "TopologicalSpace.MetrizableSpace",
   "MetricSpace.to_separated",
   "TopologicalSpace.metrizableSpaceMetric"],
  "name": "TopologicalSpace.t2Space_of_metrizableSpace",
  "constType":
  "∀ {X : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.MetrizableSpace X], T2Space X",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → (α → β) → Singleton α β",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "IsROrC.toNormedAlgebra",
   "Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "HAdd.hAdd",
   "Real",
   "Real.normedField",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Eq",
   "IsROrC.I",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "Real.instCommSemiringReal",
   "AddMonoid.toAddSemigroup",
   "IsROrC.toDenselyNormedField",
   "AddHomClass.toFunLike",
   "AddSemigroup.toAdd",
   "instHAdd",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.re_add_im_ax",
  "constType":
  "∀ {K : semiOutParam (Type u_1)} [self : IsROrC K] (z : K),\n  (algebraMap ℝ K) (IsROrC.re z) + (algebraMap ℝ K) (IsROrC.im z) * IsROrC.I = z",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Min", "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.toMin",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["FiniteDimensional.isROrC_to_real",
   "IsROrC.innerProductSpace",
   "inferInstance",
   "Real.borelSpace",
   "Real.measurableSpace",
   "Real",
   "MeasureTheory.MeasureSpace",
   "Real.isROrC",
   "measureSpaceOfInnerProductSpace",
   "Real.normedAddCommGroup"],
  "name": "Real.measureSpace",
  "constType": "MeasureTheory.MeasureSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : ℕ) → List (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegZeroMonoid.toSubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.neg_zero",
  "constType": "∀ {G : Type u_2} [self : SubNegZeroMonoid G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Monoid.toMulAction.proof_2",
   "MulOneClass.toMul",
   "SMul.mk",
   "Monoid",
   "MulAction.mk",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulAction.proof_1",
   "Monoid.toMulOneClass"],
  "name": "Monoid.toMulAction",
  "constType": "(M : Type u_1) → [inst : Monoid M] → MulAction M M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedSemiring.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "Norm",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "SeminormedAddCommGroup",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "AddCommGroup",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1573",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "PseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} →\n  [toNorm : Norm E] →\n    [toAddCommGroup : AddCommGroup E] →\n      [toPseudoMetricSpace : PseudoMetricSpace E] →\n        autoParam (∀ (x y : E), dist x y = ‖x - y‖) _auto✝ → SeminormedAddCommGroup E",
  "constCategory": "Other"},
 {"references": [],
  "name": "Inv",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "one_mul",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Monoid.toMulAction.proof_1",
  "constType": "∀ (M : Type u_1) [inst : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["One", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toOne",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → One α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Sup", "_private.Mathlib.Data.Real.Basic.0.Real.sup", "Real", "Sup.mk"],
  "name": "Real.instSupReal",
  "constType": "Sup ℝ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemiring", "Ord"],
  "name": "LinearOrderedSemiring.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["continuous_id",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "Semiring",
   "ContinuousLinearMap.mk",
   "TopologicalSpace",
   "LinearMap.id",
   "Module",
   "RingHom.id",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.id",
  "constType":
  "(R₁ : Type u_1) →\n  [inst : Semiring R₁] →\n    (M₁ : Type u_4) →\n      [inst_1 : TopologicalSpace M₁] → [inst_2 : AddCommMonoid M₁] → [inst_3 : Module R₁ M₁] → M₁ →L[R₁] M₁",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → (toFun : M → N) → toFun 0 = 0 → ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.gc_map_comap",
   "Filter.map",
   "GaloisConnection.monotone_l",
   "Filter.instPartialOrderFilter",
   "Monotone",
   "Filter.comap",
   "Filter"],
  "name": "Filter.map_mono",
  "constType":
  "∀ {α : Type u} {β : Type v} {m : α → β}, Monotone (Filter.map m)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "NNReal.toReal",
   "Real.linearOrder",
   "OfNat.ofNat",
   "NNReal.eq",
   "Real.instLEReal",
   "Real",
   "Real.toNNReal",
   "LE.le",
   "NNReal",
   "Eq",
   "max_eq_left"],
  "name": "Real.toNNReal_coe",
  "constType": "∀ {r : NNReal}, Real.toNNReal ↑r = r",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Submodule.completeLattice",
   "DenselyNormedField.toNormedField",
   "Module.Finite.mk",
   "Insert.insert",
   "Submodule.instTopSubmodule",
   "Submodule.instOrderTopSubmoduleToLEToPreorderInstPartialOrderSetLike",
   "IsROrC.I",
   "Finset.toSet",
   "HSMul.hSMul",
   "NormedAlgebra.toNormedSpace'",
   "IsROrC.re_add_im",
   "NormedCommRing.toNormedRing",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "SMulZeroClass.toSMul",
   "And",
   "IsROrC.toDecidableEq",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "And.intro",
   "NormedSpace.toModule",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "AddZeroClass.toAdd",
   "Exists",
   "DivisionRing.toDivisionSemiring",
   "Submodule",
   "eq_top_iff",
   "Set",
   "Real",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Submodule.span",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "Finset",
   "Submodule.mem_span_singleton",
   "Finset.instInsertFinset",
   "IsROrC.toDenselyNormedField",
   "Top.top",
   "AddHomClass.toFunLike",
   "algebraMap",
   "Field.toSemifield",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "LE.le",
   "Real.instDivisionRingReal",
   "NormedCommRing.toSeminormedCommRing",
   "Eq.ndrec",
   "SeminormedRing.toRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "AddMonoidHom",
   "Finset.instSingletonFinset",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.toNormedAlgebra",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.normedField",
   "Semifield.toCommSemiring",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "NormedRing.toNonUnitalNormedRing",
   "Eq.mpr",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Submodule.mem_span_insert",
   "Algebra.toSMul",
   "Eq.trans",
   "FiniteDimensional",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Algebra.smul_def",
   "instHMul",
   "MulActionWithZero.toSMulWithZero",
   "of_eq_true",
   "CommRing.toRing",
   "Singleton.singleton",
   "mul_one",
   "Finset.coe_singleton",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.im",
   "NormedAddCommGroup.toAddCommGroup",
   "RingHom",
   "OmegaCompletePartialOrder.toPartialOrder",
   "AddCommMonoid.toAddMonoid",
   "OrderTop.toTop",
   "Set.instSingletonSet",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "eq_self",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "Semiring.toOne",
   "IsROrC.ofReal",
   "DivisionSemiring.toSemiring",
   "HMul.hMul",
   "Finset.coe_insert",
   "AddMonoidHom.addMonoidHomClass",
   "Set.instInsertSet"],
  "name": "FiniteDimensional.isROrC_to_real",
  "constType": "∀ {K : Type u_1} [inst : IsROrC K], FiniteDimensional ℝ K",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Inv"],
  "name": "LinearOrderedField.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "Or",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid"],
  "name": "LinearOrderedCancelAddCommMonoid.le_total",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedCancelAddCommMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["Field", "Rat"],
  "name": "Field.qsmul",
  "constType": "{K : Type u} → [self : Field K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "Preorder.toLT",
   "HAdd.hAdd",
   "LT.lt",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "instIsTransLtToLT",
   "instOfNatNat",
   "Nat",
   "Preorder",
   "Nat.rel_of_forall_rel_succ_of_lt"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Real.mk_le",
   "Rat",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Rat.divisionRing",
   "propext",
   "Real.mk",
   "Rat.instNegRat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.8",
  "constType": "∀ {f g : CauSeq ℚ abs}, (Real.mk f ≤ Real.mk g) = (f ≤ g)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references": ["Int", "Semifield"],
  "name": "Semifield.zpow",
  "constType": "{α : Type u_4} → [self : Semifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Inv",
   "Inv.inv"],
  "name": "DivInvMonoid.div'",
  "constType": "{G : Type u} → [inst : Monoid G] → [inst : Inv G] → G → G → G",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "inferInstance",
   "Real.instLinearOrderedRingReal",
   "Real",
   "LinearOrderedRing.toLinearOrderedAddCommGroup"],
  "name": "Real.instLinearOrderedAddCommGroupReal",
  "constType": "LinearOrderedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["WithTop", "Option.some"],
  "name": "WithTop.some",
  "constType": "{α : Type u_1} → α → WithTop α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toRing : Ring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        [toNontrivial : Nontrivial α] → 0 ≤ 1 → (∀ (a b : α), 0 < a → 0 < b → 0 < a * b) → StrictOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "IsScalarTower.right",
   "Set",
   "MeasureTheory.Measure.restrictₗ.proof_1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule",
   "MeasureTheory.Measure.liftLinear",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Algebra.id",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.restrict",
   "LinearMap",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.restrictₗ",
  "constType":
  "{α : Type u_2} → {m0 : MeasurableSpace α} → Set α → MeasureTheory.Measure α →ₗ[ENNReal] MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.toLinearOrderedSemifield.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Topology.Constructions.0.instTopologicalSpaceProd._eq_1",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "nhds",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "Eq.refl",
   "Prod.fst",
   "Filter.instSProd",
   "Eq",
   "Lattice.toInf",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "TopologicalSpace",
   "Filter.comap",
   "Filter",
   "Prod",
   "Filter.prod",
   "nhds_induced",
   "nhds_inf",
   "TopologicalSpace.induced",
   "_private.Mathlib.Topology.Constructions.0.Filter.prod._eq_1",
   "id"],
  "name": "nhds_prod_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {a : α} {b : β},\n  nhds (a, b) = nhds a ×ˢ nhds b",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.ndinsert",
   "Finset.mk",
   "Finset.instInsertFinset.proof_1",
   "Insert",
   "Insert.mk"],
  "name": "Finset.instInsertFinset",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Insert α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedRing.toNonUnitalNormedRing.proof_9",
  "constType": "∀ {α : Type u_1} [β : NormedRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Filter.instCompleteLatticeFilter.proof_10",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Filter.instCompleteLatticeFilter.proof_11",
   "Filter.instCompleteLatticeFilter.proof_2",
   "Inf.inf",
   "Set",
   "Filter.instCompleteLatticeFilter.proof_4",
   "CompleteLattice.mk",
   "SupSet.mk",
   "Filter.generate",
   "CompleteLattice.toBot",
   "Lattice.mk",
   "Filter.join",
   "Filter.instCompleteLatticeFilter.proof_7",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Preorder.toLT",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.mem_inf_of_right",
   "Filter.instCompleteLatticeFilter.proof_5",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.proof_12",
   "Membership.mem",
   "Filter.sets",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPartialOrder",
   "Filter.instCompleteLatticeFilter.proof_8",
   "Top.top",
   "Function.comp",
   "SemilatticeSup.mk",
   "Filter.instCompleteLatticeFilter.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter.instCompleteLatticeFilter.proof_9",
   "Filter.instCompleteLatticeFilter.proof_1",
   "Filter.instCompleteLatticeFilter.proof_6",
   "Top.mk",
   "Filter.mem_inf_of_left"],
  "name": "Filter.instCompleteLatticeFilter",
  "constType": "{α : Type u} → CompleteLattice (Filter α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Neg",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "closure",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "Set.preimage",
   "HasSubset.Subset.trans",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "Exists.intro",
   "Exists.casesOn",
   "Set.Countable.image",
   "Eq",
   "Set.Countable",
   "And",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "closure_subset_preimage_closure_image",
   "Eq.ndrec",
   "propext",
   "Continuous",
   "TopologicalSpace",
   "Set.image_subset_iff",
   "And.intro",
   "Set.image",
   "And.casesOn",
   "id"],
  "name": "TopologicalSpace.IsSeparable.image",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β] {s : Set α},\n  TopologicalSpace.IsSeparable s → ∀ {f : α → β}, Continuous f → TopologicalSpace.IsSeparable (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "Field.toInv",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Field.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Field.toCommRing",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Field",
   "Rat.cast",
   "CommRing.toRing",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "Field.ratCast_mk",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["mul_add",
   "instHAdd",
   "Semiring",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Distrib.leftDistribClass",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Semiring.toModule.proof_2",
  "constType":
  "∀ {R : Type u_1} [inst : Semiring R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid",
   "AddSubsemigroup.carrier",
   "AddZeroClass",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubmonoid.mk",
  "constType":
  "{M : Type u_4} →\n  [inst : AddZeroClass M] → (toAddSubsemigroup : AddSubsemigroup M) → 0 ∈ toAddSubsemigroup.carrier → AddSubmonoid M",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OneHom.toFun",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_add'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β) (x y : α),\n  OneHom.toFun (↑↑self) (x + y) = OneHom.toFun (↑↑self) x + OneHom.toFun (↑↑self) y",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "SemilatticeSup.toSup",
   "Sup",
   "Rat",
   "Rat.instSemilatticeSupRat"],
  "name": "Rat.instSupRat",
  "constType": "Sup ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "id"],
  "name": "Set.Subset.refl",
  "constType": "∀ {α : Type u} (a : Set α), a ⊆ a",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{α : Type u} → (α → α) → Inv α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "CompleteLattice.toLattice",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "PartialOrder.le_antisymm",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_4",
  "constType": "∀ {α : Type u_1} (a b : (Filter α)ᵒᵈᵒᵈ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "Set",
   "Set.inter_self",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "True",
   "Eq",
   "And",
   "of_eq_true",
   "Filter",
   "And.intro",
   "congrArg",
   "Eq.trans",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_1",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α), ∃ a ∈ f, ∃ b ∈ g, Set.univ = a ∩ b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_5",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "FunLike.coe",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "PartialOrder"],
  "name": "OmegaCompletePartialOrder.mk",
  "constType":
  "{α : Type u_1} →\n  [toPartialOrder : PartialOrder α] →\n    (ωSup : OmegaCompletePartialOrder.Chain α → α) →\n      (∀ (c : OmegaCompletePartialOrder.Chain α) (i : ℕ), c i ≤ ωSup c) →\n        (∀ (c : OmegaCompletePartialOrder.Chain α) (x : α), (∀ (i : ℕ), c i ≤ x) → ωSup c ≤ x) →\n          OmegaCompletePartialOrder α",
  "constCategory": "Other"},
 {"references": ["Div", "Semifield"],
  "name": "Semifield.toDiv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Div α",
  "constCategory": "Definition"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "StronglyMeasurableAtFilter",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.restrict",
   "Exists.intro",
   "Set.univ",
   "MeasureTheory.AEStronglyMeasurable",
   "Filter.univ_mem",
   "Eq",
   "MeasureTheory.Measure",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "TopologicalSpace",
   "Filter",
   "And.intro",
   "MeasurableSpace",
   "MeasureTheory.Measure.restrict_univ",
   "instMembershipSetFilter",
   "id"],
  "name": "MeasureTheory.AEStronglyMeasurable.stronglyMeasurableAtFilter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace β] {l : Filter α} {f : α → β}\n  {μ : MeasureTheory.Measure α}, MeasureTheory.AEStronglyMeasurable f μ → StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "Function.swap",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "OrderIso.neg",
   "LE",
   "OrderDual",
   "OrderIso.symm_apply_le",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_le",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, -a ≤ b ↔ -b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.ofCauchy",
  "constType": "CauSeq.Completion.Cauchy abs → ℝ",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Iff.mpr",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddZeroClass.toZero",
   "AddGroup",
   "Iff",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.27",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.12",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "of_eq_true",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "sub_lt_self",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a - b < a",
  "constCategory": "Theorem"},
 {"references": ["AddHom", "Add"],
  "name": "AddHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Add M] → [inst_1 : Add N] → AddHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "Submodule.instInfSetSubmodule.proof_3",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Set",
   "Submodule.instInfSetSubmodule.proof_2",
   "InfSet",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.instMembershipSet",
   "InfSet.mk",
   "Submodule.instInfSetSubmodule.proof_1",
   "Submodule.mk",
   "Set.iInter",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.setLike",
   "AddCommMonoid",
   "SetLike.coe"],
  "name": "Submodule.instInfSetSubmodule",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → InfSet (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedCommMonoid.toCovariantClassRight",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "mul_le_mul_right'",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.mk_le",
   "Real",
   "Real.instLEReal",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.ndrec",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "le_refl",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_1",
  "constType": "∀ (a : ℝ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "Eq.symm"],
  "name": "Mathlib.Data.IsROrC.Basic._auxLemma.26",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), |a| * |b| = |a * b|",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Covariant",
   "Iff.mp",
   "AddGroup",
   "Contravariant",
   "AddGroup.covariant_iff_contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "CovariantClass.elim"],
  "name": "AddGroup.covconv",
  "constType":
  "∀ {N : Type u_2} {r : N → N → Prop} [inst : AddGroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  ContravariantClass N N (fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Max.max",
   "LinearOrderedRing.toMax",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Field.toSemifield.proof_1",
  "constType": "∀ {K : Type u_1} [inst : Field K] (a b : K), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Nonneg.conditionallyCompleteLinearOrderBot",
   "NNReal",
   "ConditionallyCompleteLinearOrderBot"],
  "name": "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
  "constType": "ConditionallyCompleteLinearOrderBot NNReal",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, (∀ (a : α), Acc r a) → WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "RingHom",
   "CommSemiring.toSemiring",
   "CommRing.toNonUnitalCommRing",
   "Semifield.toCommSemiring",
   "IsROrC.toStarRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "IsROrC.innerProductSpace.proof_3",
   "NormedRing.toNonUnitalNormedRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "NormedField.toNormedSpace",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Inner.mk",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "EuclideanDomain.toCommRing",
   "IsROrC.innerProductSpace.proof_4",
   "instHMul",
   "InnerProductSpace.mk",
   "IsROrC.innerProductSpace.proof_2",
   "InnerProductSpace",
   "Field.toEuclideanDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "IsROrC.innerProductSpace.proof_1",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "IsROrC.innerProductSpace",
  "constType": "{𝕜 : Type u_1} → [inst : IsROrC 𝕜] → InnerProductSpace 𝕜 𝕜",
  "constCategory": "Definition"},
 {"references":
  ["Finsupp",
   "Basis",
   "Semiring",
   "LinearEquiv.trans",
   "LinearEquiv.symm",
   "Semiring.toMonoidWithZero",
   "LinearEquiv",
   "Finsupp.linearEquivFunOnFinite",
   "Finsupp.module",
   "RingHom.id",
   "Basis.ofRepr",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "Pi.addCommMonoid",
   "Finsupp.addCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Basis.ofEquivFun.proof_1",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "Pi.module",
   "Finite.of_fintype",
   "Semiring.toModule",
   "AddCommMonoid",
   "RingHomInvPair.ids"],
  "name": "Basis.ofEquivFun",
  "constType":
  "{ι : Type u_1} →\n  {R : Type u_3} →\n    {M : Type u_6} →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → [inst_3 : Fintype ι] → (M ≃ₗ[R] ι → R) → Basis ι R M",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "Rat.cast",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedField.qsmul",
   "Rat",
   "HMul.hMul",
   "LinearOrderedField.toRatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.qsmul_eq_mul'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : ℚ) (x : α), LinearOrderedField.qsmul a x = ↑a * x",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ≠ a + c ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "add_le_add",
   "Set.Nonempty",
   "Eq.refl",
   "le_rfl",
   "Exists.intro",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Real.linearOrder",
   "Eq.mpr",
   "Eq.symm",
   "LinearOrderedRing.toMax",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Or.elim",
   "id",
   "Membership.mem",
   "Set.empty_union",
   "Or",
   "setOf",
   "Real.instLinearOrderedRingReal",
   "instHAdd",
   "Union.union",
   "LE.le.trans",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "LE.le",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "Real.orderedAddCommMonoid",
   "le_max_left",
   "Real.instPreorderReal",
   "Max.max",
   "Set.union_empty",
   "Set.eq_empty_or_nonempty",
   "congrArg",
   "le_max_right",
   "Set.instUnionSet",
   "congrFun"],
  "name": "Bornology.ofDist.proof_3",
  "constType":
  "∀ {α : Type u_1} (dist : α → α → ℝ),\n  (∀ (x y : α), dist x y = dist y x) →\n    (∀ (x y z : α), dist x z ≤ dist x y + dist y z) →\n      ∀ s ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C},\n        ∀ t ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C},\n          s ∪ t ∈ {s | ∃ C, ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → dist x y ≤ C}",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.SeparableSpace.mk",
   "closure",
   "Classical.choose_spec",
   "Exists",
   "Classical.choose",
   "Set.countable_iUnion",
   "Set",
   "Exists.intro",
   "closure_mono",
   "Dense",
   "compactCovering",
   "And.left",
   "Exists.casesOn",
   "instCountableNat",
   "Eq",
   "Set.Countable",
   "PseudoEMetricSpace.toUniformSpace",
   "And.right",
   "Set.iUnion",
   "Iff.mp",
   "Set.subset_iUnion",
   "EMetric.instIsCountablyGeneratedUniformity",
   "UniformSpace.secondCountable_of_separable",
   "EMetric.subset_countable_closure_of_compact",
   "TopologicalSpace.SeparableSpace",
   "PseudoEMetricSpace",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Membership.mem",
   "iUnion_compactCovering",
   "HasSubset.Subset",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "isCompact_compactCovering",
   "And",
   "SecondCountableTopology",
   "Set.instHasSubsetSet",
   "SigmaCompactSpace",
   "And.intro"],
  "name": "EMetric.secondCountable_of_sigmaCompact",
  "constType":
  "∀ (α : Type u) [inst : PseudoEMetricSpace α] [inst_1 : SigmaCompactSpace α], SecondCountableTopology α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompleteLinearOrder"],
  "name": "CompleteLinearOrder.toCompleteLattice",
  "constType":
  "{α : Type u_9} → [self : CompleteLinearOrder α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalCommRing.mk",
  "constType":
  "{α : Type u} → [toNonUnitalRing : NonUnitalRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Field.toSemifield",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "And",
   "instHMul",
   "Field",
   "HMul.hMul",
   "CommRing.toRing",
   "And.intro",
   "And.casesOn",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.match_2",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K) (motive : a * b = 0 ∧ a ≠ 0 → Prop) (x : a * b = 0 ∧ a ≠ 0),\n  (∀ (hab : a * b = 0) (hna : a ≠ 0), motive (_ : a * b = 0 ∧ a ≠ 0)) → motive x",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Submodule",
   "instHSMul",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Submodule.span",
   "SetLike.instMembership",
   "Iff.mpr",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "SMulWithZero.toSMulZeroClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddSubmonoid.mk",
   "Module",
   "Submodule.span_le",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid",
   "Membership.mem",
   "instHAdd",
   "Semiring",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HasSubset.Subset",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "LE.le",
   "Set.instMembershipSet",
   "SMulZeroClass.toSMul",
   "Set.instHasSubsetSet",
   "MulActionWithZero.toSMulWithZero",
   "Submodule.mk",
   "MonoidWithZero.toZero",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.span_induction",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M} {s : Set M}\n  {p : M → Prop},\n  x ∈ Submodule.span R s →\n    (∀ x ∈ s, p x) → p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (a : R) (x : M), p x → p (a • x)) → p x",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero", "Real", "Zero.mk", "_private.Mathlib.Data.Real.Basic.0.Real.zero"],
  "name": "Real.instZeroReal",
  "constType": "Zero ℝ",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.631", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.zero",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Monoid",
   "Real.instMonoidWithZeroReal",
   "MonoidWithZero.toMonoid",
   "Real"],
  "name": "Real.instMonoidReal",
  "constType": "Monoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NontriviallyNormedField",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "RingHom.id",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "wrapped._@.Mathlib.Analysis.Calculus.FDeriv.Basic._hyg.944",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "UniformSpace.toTopologicalSpace"],
  "name": "fderiv",
  "constType":
  "(𝕜 : Type u_6) →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_7} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_8} → [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → E → E →L[𝕜] F",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "MulHomClass",
   "outParam",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Eq"],
  "name": "MonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulOneClass M] →\n        [inst_1 : MulOneClass N] → [toMulHomClass : MulHomClass F M N] → (∀ (f : F), f 1 = 1) → MonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["SigmaCompactSpace", "TopologicalSpace", "Set.univ", "IsSigmaCompact"],
  "name": "SigmaCompactSpace.mk",
  "constType":
  "∀ {X : Type u_4} [inst : TopologicalSpace X], IsSigmaCompact Set.univ → SigmaCompactSpace X",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Set.Ioo",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "isOpen_Ioi",
   "isOpen_Iio",
   "IsOpen.inter",
   "SemilatticeInf.toPartialOrder",
   "TopologicalSpace",
   "OrderClosedTopology",
   "IsOpen"],
  "name": "isOpen_Ioo",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] {a b : α},\n  IsOpen (Set.Ioo a b)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "SemilatticeInf.inf_le_left",
  "constType": "∀ {α : Type u} [self : SemilatticeInf α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "star_star",
   "CommSemiring.toSemiring",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "StarRing.toStarAddMonoid",
   "starRingEnd",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "StarAddMonoid.toInvolutiveStar"],
  "name": "starRingEnd_self_apply",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R] (x : R), (starRingEnd R) ((starRingEnd R) x) = x",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] → [inst_1 : Zero N] → [self : ZeroHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references":
  ["continuousAt_const",
   "Continuous",
   "ContinuousAt",
   "TopologicalSpace",
   "continuous_iff_continuousAt",
   "Iff.mpr"],
  "name": "continuous_const",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {b : β}, Continuous fun x => b",
  "constCategory": "Theorem"},
 {"references":
  ["SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "AddHomClass.toFunLike",
   "Semiring",
   "Continuous",
   "ContinuousSemilinearMapClass.toSemilinearMapClass",
   "TopologicalSpace",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.map_continuous",
  "constType":
  "∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M₂ : outParam (Type u_5)} [inst_4 : TopologicalSpace M₂] [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M]\n  [inst_7 : Module S M₂] [self : ContinuousSemilinearMapClass F σ M M₂] (f : F), Continuous ⇑f",
  "constCategory": "Definition"},
 {"references": ["outParam", "NonAssocSemiring"],
  "name": "RingHomClass",
  "constType":
  "Type u_5 →\n  (α : outParam (Type u_6)) →\n    (β : outParam (Type u_7)) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "CauchySeq",
   "Metric.mem_nhds_iff",
   "CompleteSpace",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSupReal",
   "Mathlib.Topology.Instances.Real._auxLemma.4",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "Eq.mpr",
   "Iff.mp",
   "Filter.Tendsto",
   "Filter",
   "Metric.ball",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "CauSeq.instSubCauSeq",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Nat.instLatticeNat",
   "Real.instRingReal",
   "Set.instMembershipSet",
   "And",
   "CauSeq.equiv_lim",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LT.lt",
   "instInhabitedNat",
   "Filter.atTop",
   "Exists",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "Real",
   "Set",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Exists.imp",
   "Exists.intro",
   "Abs.abs",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Metric.cauchySeq_iff'",
   "instLENat",
   "Preorder.toLT",
   "Filter.map",
   "Lattice.toSemilatticeSup",
   "UniformSpace.toTopologicalSpace",
   "instNonempty",
   "id",
   "instMembershipSetFilter",
   "Neg.toHasAbs",
   "Membership.mem",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "CauSeq.lim",
   "Real.instLinearOrderedRingReal",
   "Set.preimage",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Metric.complete_of_cauchySeq_tendsto",
   "Real.pseudoMetricSpace",
   "CauSeq",
   "GT.gt",
   "Real.instZeroReal",
   "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
   "PseudoMetricSpace.toDist",
   "Set.instHasSubsetSet",
   "StrictOrderedSemiring.toPartialOrder",
   "Mathlib.Topology.Instances.Real._auxLemma.3",
   "Subtype.mk"],
  "name": "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
  "constType": "CompleteSpace ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "SMulWithZero.toSMulZeroClass",
   "instHSMul",
   "SMulWithZero",
   "HSMul.hSMul",
   "SMulWithZero.zero_smul",
   "SMulZeroClass.toSMul",
   "Eq"],
  "name": "zero_smul",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 • m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.toAlgebra",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "RingHom.id"],
  "name": "Algebra.id",
  "constType": "(R : Type u) → [inst : CommSemiring R] → Algebra R R",
  "constCategory": "Definition"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "Real.metricSpace",
   "Real",
   "MetricSpace.toPseudoMetricSpace",
   "rfl",
   "Eq",
   "Dist.dist"],
  "name": "Real.normedAddCommGroup.proof_1",
  "constType": "∀ (_r _y : ℝ), dist _r _y = dist _r _y",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NonUnitalNormedRing.toNonUnitalSeminormedRing",
   "IsROrC.innerProductSpace",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NormedAddCommGroup",
   "OrthonormalBasis.toBasis.proof_1",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "PiLp.seminormedAddCommGroup",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "OrthonormalBasis",
   "IsROrC",
   "LinearIsometryEquiv.toLinearEquiv",
   "RingHom.id",
   "NormedField.toField",
   "NormedRing.toNonUnitalNormedRing",
   "ENNReal",
   "SeminormedAddCommGroup.toAddCommGroup",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "fact_one_le_two_ennreal",
   "OrthonormalBasis.repr",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "IsROrC.toDenselyNormedField",
   "Basis",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "EuclideanSpace.proof_1",
   "EuclideanDomain.toCommRing",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "InnerProductSpace.toNormedSpace",
   "DivisionSemiring.toSemiring",
   "EuclideanSpace",
   "Field.toEuclideanDomain",
   "InnerProductSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "WithLp.instModule",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NormedSpace.toModule",
   "Pi.module",
   "NonUnitalNormedRing.toNormedAddCommGroup",
   "Basis.ofEquivFun"],
  "name": "OrthonormalBasis.toBasis",
  "constType":
  "{ι : Type u_1} →\n  {𝕜 : Type u_3} →\n    [inst : IsROrC 𝕜] →\n      {E : Type u_4} →\n        [inst_1 : NormedAddCommGroup E] →\n          [inst_2 : InnerProductSpace 𝕜 E] → [inst_3 : Fintype ι] → OrthonormalBasis ι 𝕜 E → Basis ι 𝕜 E",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "sub_self",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "MulZeroClass.mul_zero",
   "Semifield.toCommGroupWithZero",
   "div_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Eq",
   "CommGroupWithZero.toDiv",
   "Field",
   "sub_zero",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Classical.propDecidable",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "congr",
   "Not",
   "Field.toDiv",
   "mul_div_cancel'",
   "MonoidWithZero.toZero",
   "add_zero",
   "Field.toDivisionRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "congrFun",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "mul_div_cancel",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "zero_add",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "CommGroupWithZero.toGroupWithZero",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "eq_false",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero"],
  "name": "Field.toEuclideanDomain.proof_2",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b * (fun x x_1 => x / x_1) a b + (fun a b => a - a * b / b) a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet", "Eq"],
  "name": "Set.insert",
  "constType": "{α : Type u_1} → α → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "∀ {α : Type u_1} (x y : Set α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "BorelSpace.mk",
   "Set",
   "Eq.refl",
   "rfl",
   "BorelSpace.opensMeasurable",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "Continuous.measurable",
   "MeasureTheory.StronglyMeasurable",
   "Continuous",
   "TopologicalSpace",
   "Measurable",
   "SecondCountableTopologyEither.out",
   "TopologicalSpace.PseudoMetrizableSpace",
   "Set.image",
   "Eq.symm",
   "TopologicalSpace.IsSeparable.image",
   "id",
   "SecondCountableTopologyEither",
   "OpensMeasurableSpace",
   "Or",
   "borel",
   "Or.inr",
   "TopologicalSpace.isSeparable_of_separableSpace",
   "Measurable.stronglyMeasurable",
   "Or.casesOn",
   "Set.image_univ",
   "Set.univ",
   "TopologicalSpace.SecondCountableTopology.to_separableSpace",
   "And",
   "SecondCountableTopology",
   "Or.inl",
   "Eq.ndrec",
   "propext",
   "And.intro",
   "MeasurableSpace",
   "stronglyMeasurable_iff_measurable_separable"],
  "name": "Continuous.stronglyMeasurable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace β] [inst_4 : TopologicalSpace.PseudoMetrizableSpace β]\n  [h : SecondCountableTopologyEither α β] {f : α → β}, Continuous f → MeasureTheory.StronglyMeasurable f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_4",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Or",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "or_assoc",
   "CauSeq",
   "LE.le",
   "Or.imp_right",
   "Iff.mpr",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Or.inl",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "CauSeq.lt_total",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name": "CauSeq.le_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (f g : CauSeq α abs), f ≤ g ∨ g ≤ f",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableEq α] [inst_2 : DecidableRel fun x x_1 => x < x_1] (a b : α),\n  compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PseudoEMetricSpace.mk",
   "EDist.mk",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_2",
   "PseudoMetricSpace.edist",
   "Metric.uniformity_edist",
   "PseudoMetricSpace.toUniformSpace",
   "PseudoEMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_3",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_1",
   "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toPseudoEMetricSpace",
  "constType":
  "{α : Type u} → [inst : PseudoMetricSpace α] → PseudoEMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "instHMul",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedCommSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "OrderedCommSemiring.mk",
  "constType":
  "{α : Type u} → [toOrderedSemiring : OrderedSemiring α] → (∀ (a b : α), a * b = b * a) → OrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["MonoidWithZero.toMulActionWithZero.proof_3",
   "MonoidWithZero.toMulActionWithZero.proof_1",
   "SMulWithZero",
   "MulActionWithZero.mk",
   "MulZeroClass.toSMulWithZero",
   "MulActionWithZero",
   "MonoidWithZero.toMulActionWithZero.proof_2",
   "MulZeroOneClass.toMulZeroClass",
   "SMulZeroClass.toSMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Monoid.toMulAction",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "MulZeroClass.toZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "MonoidWithZero.toMulActionWithZero.proof_4",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero",
  "constType":
  "(R : Type u_1) → [inst : MonoidWithZero R] → MulActionWithZero R R",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "Continuous",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : TopologicalSpace α] → [inst : TopologicalSpace β] → (α → β) → Prop",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "∀ {α : Type u_1} (x y : Set α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "AddCommSemigroup.toAddCommMagma",
   "Submodule",
   "instHSMul",
   "HAdd.hAdd",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "AddCommMonoid.toAddMonoid",
   "Insert.insert",
   "Submodule.span",
   "SetLike.instMembership",
   "True",
   "iff_self",
   "Eq",
   "Set.instSingletonSet",
   "SMulWithZero.toSMulZeroClass",
   "SemilatticeSup.toSup",
   "Iff",
   "CompleteLattice.toConditionallyCompleteLattice",
   "AddMonoid.toZero",
   "Mathlib.Logic.Basic._auxLemma.33",
   "HSMul.hSMul",
   "Mathlib.LinearAlgebra.Span._auxLemma.13",
   "Lattice.toSemilatticeSup",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "AddCommMonoid",
   "Membership.mem",
   "funext",
   "Mathlib.LinearAlgebra.Span._auxLemma.11",
   "Semiring",
   "instHAdd",
   "eq_comm",
   "ConditionallyCompleteLattice.toLattice",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Submodule.span_insert",
   "SMulZeroClass.toSMul",
   "And",
   "MulActionWithZero.toSMulWithZero",
   "of_eq_true",
   "propext",
   "congr",
   "Sup.sup",
   "Singleton.singleton",
   "MonoidWithZero.toZero",
   "congrArg",
   "Submodule.setLike",
   "congrFun",
   "Set.instInsertSet"],
  "name": "Submodule.mem_span_insert",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M} {s : Set M}\n  {y : M}, x ∈ Submodule.span R (insert y s) ↔ ∃ a, ∃ z ∈ Submodule.span R s, x = a • y + z",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "Field.toEuclideanDomain.match_1",
   "OfNat.ofNat",
   "WellFounded.intro",
   "False.elim",
   "Field",
   "Field.toSemifield",
   "WellFounded",
   "Semifield.toCommGroupWithZero",
   "Acc.intro",
   "Acc",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_3",
  "constType":
  "∀ {K : Type u_1} [inst : Field K], WellFounded fun a b => a = 0 ∧ b ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.mk",
  "constType":
  "{α : Type u_6} → [toMeasurableSpace : MeasurableSpace α] → MeasureTheory.Measure α → MeasureTheory.MeasureSpace α",
  "constCategory": "Other"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.mul", "Mul", "Mul.mk"],
  "name": "Real.instMulReal",
  "constType": "Mul ℝ",
  "constCategory": "Definition"},
 {"references":
  ["setOf",
   "nhds",
   "Preorder.toLT",
   "LT.lt",
   "OrderTopology",
   "TopologicalSpace",
   "IsOpen.mem_nhds",
   "Filter.Eventually",
   "Preorder",
   "isOpen_gt'"],
  "name": "gt_mem_nhds",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderTopology α] {a b : α},\n  a < b → ∀ᶠ (x : α) in nhds a, x < b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure.Regular",
   "BorelSpace",
   "isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure",
   "MeasureTheory.Measure.WeaklyRegular.toOuterRegular",
   "MeasureTheory.Measure.WeaklyRegular.of_pseudoMetrizableSpace_secondCountable_of_locallyFinite",
   "TopologicalSpace.pseudoMetrizableSpacePseudoMetric",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.InnerRegularWRT.isCompact_isClosed",
   "SigmaCompactSpace",
   "TopologicalSpace",
   "MeasureTheory.Measure.Regular.mk",
   "IsClosed",
   "TopologicalSpace.PseudoMetrizableSpace",
   "EMetric.secondCountable_of_sigmaCompact",
   "MeasureTheory.Measure.InnerRegularWRT.trans",
   "IsCompact",
   "IsOpen",
   "MeasurableSpace",
   "PseudoMetricSpace",
   "MeasureTheory.Measure.InnerRegularWRT.of_pseudoMetrizableSpace",
   "MeasureTheory.IsLocallyFiniteMeasure",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name":
  "MeasureTheory.Measure.Regular.of_sigmaCompactSpace_of_isLocallyFiniteMeasure",
  "constType":
  "∀ {X : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.PseudoMetrizableSpace X]\n  [inst_2 : SigmaCompactSpace X] [inst_3 : MeasurableSpace X] [inst_4 : BorelSpace X] (μ : MeasureTheory.Measure X)\n  [inst_5 : MeasureTheory.IsLocallyFiniteMeasure μ], MeasureTheory.Measure.Regular μ",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.631",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.631",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["outParam", "FunLike", "ContinuousMapClass", "TopologicalSpace"],
  "name": "ContinuousMapClass.toFunLike",
  "constType":
  "{F : Type u_1} →\n  {α : outParam (Type u_2)} →\n    {β : outParam (Type u_3)} →\n      [inst : TopologicalSpace α] →\n        [inst_1 : TopologicalSpace β] → [self : ContinuousMapClass F α β] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DivisionRing", "Rat", "Rat.field", "Field.toDivisionRing"],
  "name": "Rat.divisionRing",
  "constType": "DivisionRing ℚ",
  "constCategory": "Definition"},
 {"references": ["Real", "StieltjesFunction"],
  "name": "StieltjesFunction.toFun",
  "constType": "StieltjesFunction → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.261",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Real.instLTReal",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "LE.le",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "And",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Iff",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "LT.lt",
   "Rat.instNegRat",
   "congr",
   "Not",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_3",
  "constType": "∀ (a b : ℝ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["IsROrC.re",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsROrC.norm_sq_eq_def",
   "NormedField.toNorm",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "MonoidWithZeroHom",
   "Nat",
   "Eq.symm",
   "HPow.hPow",
   "IsROrC.toDenselyNormedField",
   "Real.instMonoidReal",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "AddHomClass.toFunLike",
   "IsROrC.normSq",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Real.semiring",
   "HMul.hMul",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "IsROrC.im"],
  "name": "IsROrC.normSq_eq_def'",
  "constType":
  "∀ {K : Type u_1} [inst : IsROrC K] (z : K), IsROrC.normSq z = ‖z‖ ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["two_ne_zero",
   "Distrib.toAdd",
   "LinearOrderedSemifield.toSemifield",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "mul_div_cancel",
   "Eq",
   "Semiring.toNatCast",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_two",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "GroupWithZero.toDiv",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "ZeroLEOneClass.neZero.two",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero"],
  "name": "add_self_div_two",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] (a : α), (a + a) / 2 = a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Rat"],
  "name": "LinearOrderedField.qsmul",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℚ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "WithTop",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references":
  ["ZeroHom.mk",
   "MeasureTheory.Measure.zero_toOuterMeasure",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.add_toOuterMeasure",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.Measure",
   "AddZeroClass.toZero",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "SMulWithZero.toSMulZeroClass",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Module",
   "Algebra.toSMul",
   "AddMonoidHom.mk",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Function.Injective.module",
   "Semiring",
   "Module.toMulActionWithZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instENNRealZero",
   "IsScalarTower",
   "SMulZeroClass.toSMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulActionWithZero.toSMulWithZero",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule.proof_1",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasureTheory.OuterMeasure.instModule",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.instModule",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_6} →\n    [inst : Semiring R] →\n      [inst_1 : Module R ENNReal] →\n        [inst_2 : IsScalarTower R ENNReal ENNReal] → [inst_3 : MeasurableSpace α] → Module R (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M →+ N) (x y : M),\n  ZeroHom.toFun (↑self) (x + y) = ZeroHom.toFun (↑self) x + ZeroHom.toFun (↑self) y",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UniformSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OpensMeasurableSpace",
   "Continuous.borel_measurable",
   "Measurable.mono",
   "BorelSpace",
   "PartialOrder.toPreorder",
   "borel",
   "Continuous",
   "OpensMeasurableSpace.borel_le",
   "TopologicalSpace",
   "Measurable",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "le_of_eq",
   "MeasurableSpace",
   "BorelSpace.measurable_eq"],
  "name": "Continuous.measurable",
  "constType":
  "∀ {α : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace γ] [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ]\n  {f : α → γ}, Continuous f → Measurable f",
  "constCategory": "Theorem"},
 {"references":
  ["Continuous.stronglyMeasurable",
   "MeasureTheory.Measure",
   "SecondCountableTopologyEither",
   "OpensMeasurableSpace",
   "StronglyMeasurableAtFilter",
   "Continuous",
   "TopologicalSpace",
   "Filter",
   "TopologicalSpace.PseudoMetrizableSpace",
   "MeasureTheory.StronglyMeasurable.stronglyMeasurableAtFilter",
   "MeasurableSpace"],
  "name": "Continuous.stronglyMeasurableAtFilter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace β] [inst_4 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_5 : SecondCountableTopologyEither α β] {f : α → β},\n  Continuous f → ∀ (μ : MeasureTheory.Measure α) (l : Filter α), StronglyMeasurableAtFilter f l",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "HasSolidNorm.mk",
   "Neg.toHasAbs",
   "AddCommGroup.toDivisionAddCommMonoid",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Real.lattice",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LE.le",
   "Preorder.toLE",
   "Abs.abs",
   "SemilatticeSup.toSup",
   "HasSolidNorm",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.normedAddCommGroup",
   "id"],
  "name": "instHasSolidNormRealNormedAddCommGroupLattice",
  "constType": "HasSolidNorm ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Norm",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real",
   "Ring.toAddCommGroup",
   "Real.instRingReal",
   "AddCommGroup"],
  "name": "Real.instAddCommGroupReal",
  "constType": "AddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.min_def",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.mk",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.toMin",
   "OrderedCancelAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedAddCommGroup.toMax"],
  "name": "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
  "constType":
  "{α : Type u} → [inst : LinearOrderedAddCommGroup α] → LinearOrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "DivisionRing.toInv",
   "DivisionRing.zpow",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "Eq.ndrec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "id"],
  "name": "NeZero.one",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "NormedRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NormedRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_neg",
  "constType": "∀ {G : Type u} [self : SubtractionMonoid G] (x : G), - -x = x",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instHSMul",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Mathlib.Topology.Algebra.Module.Basic._auxLemma.20",
   "RingHom.id",
   "True",
   "iff_self",
   "Eq",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "one_smul",
   "Iff",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "TopologicalSpace",
   "ContinuousLinearMap.smulRight",
   "ContinuousSMul",
   "Module",
   "Eq.trans",
   "Semiring.toModule",
   "MulActionWithZero.toMulAction",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "AddCommMonoid",
   "Semiring",
   "One.toOfNat1",
   "FunLike.coe",
   "Module.toMulActionWithZero",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "SMulZeroClass.toSMul",
   "Semiring.toOne",
   "MulActionWithZero.toSMulWithZero",
   "MulAction.toSMul",
   "ContinuousLinearMap",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "congrArg",
   "ContinuousMapClass.toFunLike",
   "ContinuousLinearMap.one",
   "congrFun"],
  "name": "ContinuousLinearMap.smulRight_one_eq_iff",
  "constType":
  "∀ {R₁ : Type u_1} [inst : Semiring R₁] {M₂ : Type u_6} [inst_1 : TopologicalSpace M₂] [inst_2 : AddCommMonoid M₂]\n  [inst_3 : Module R₁ M₂] [inst_4 : TopologicalSpace R₁] [inst_5 : ContinuousSMul R₁ M₂] {f f' : M₂},\n  ContinuousLinearMap.smulRight 1 f = ContinuousLinearMap.smulRight 1 f' ↔ f = f'",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.tendsto_inf",
   "Prod.snd",
   "Filter.tendsto_comap_iff",
   "Inf.inf",
   "Function.comp",
   "Prod.fst",
   "Filter.instSProd",
   "Iff.mpr",
   "And",
   "Prod.mk",
   "SProd.sprod",
   "Filter.instInfFilter",
   "Filter.comap",
   "Filter",
   "Filter.Tendsto",
   "Prod",
   "And.intro"],
  "name": "Filter.Tendsto.prod_mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : Filter α} {g : Filter β} {h : Filter γ} {m₁ : α → β} {m₂ : α → γ},\n  Filter.Tendsto m₁ f g → Filter.Tendsto m₂ f h → Filter.Tendsto (fun x => (m₁ x, m₂ x)) f (g ×ˢ h)",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHomClass.toFunLike",
   "Semiring",
   "ZeroHom.zeroHomClass",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "AddCommGroup.toAddCommMonoid",
   "ZeroHom",
   "Module.rank",
   "FunLike.coe",
   "Nat",
   "Module",
   "AddCommGroup"],
  "name": "FiniteDimensional.finrank",
  "constType":
  "(R : Type u_1) → (V : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommGroup V] → [inst : Module R V] → ℕ",
  "constCategory": "Definition"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.innerProductSpace",
   "NormedAddCommGroup",
   "CompleteSpace",
   "OfNat.ofNat",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "Inf.inf",
   "Real.normedField",
   "Real.measurableSpace",
   "Real.instSubReal",
   "intervalIntegral.integral_const",
   "Real.isROrC",
   "AddCommGroup.toAddCommMonoid",
   "Asymptotics.IsLittleO",
   "Real.locallyFinite_volume",
   "Real.instOneReal",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "HSMul.hSMul",
   "Filter",
   "Real.measureSpace",
   "Filter.Tendsto",
   "NormedAddCommGroup.toNorm",
   "Eq.trans",
   "Real.normedAddCommGroup",
   "instHSub",
   "PseudoMetricSpace.toUniformSpace",
   "Real.norm",
   "Module.toMulActionWithZero",
   "SMulZeroClass.toSMul",
   "InnerProductSpace.toNormedSpace",
   "MulActionWithZero.toSMulWithZero",
   "Eq.mp",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "congr",
   "mul_one",
   "NormedSpace.toModule",
   "congrArg",
   "NormedAddCommGroup.toAddCommGroup",
   "Pi.instSub",
   "AddCommGroup.toDivisionAddCommMonoid",
   "StronglyMeasurableAtFilter",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "NormedSpace",
   "MeasureTheory.MeasureSpace.volume",
   "NormedAddGroup.toAddGroup",
   "UniformSpace.toTopologicalSpace",
   "intervalIntegral",
   "MeasureTheory.Measure.ae",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "funext",
   "IntervalIntegrable",
   "Real.instMonoidWithZeroReal",
   "nhds",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "HSub.hSub",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "intervalIntegral.FTCFilter",
   "intervalIntegral.measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
   "Real.semiring",
   "Filter.instInfFilter",
   "NormedAddCommGroup.toNormedAddGroup",
   "NegZeroClass.toZero"],
  "name":
  "intervalIntegral.integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right",
  "constType":
  "∀ {ι : Type u_1} {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E]\n  {f : ℝ → E} {c : E} {lb lb' : Filter ℝ} {lt : Filter ι} {a b : ℝ} {u v : ι → ℝ}\n  [inst_3 : intervalIntegral.FTCFilter b lb lb'],\n  IntervalIntegrable f MeasureTheory.volume a b →\n    StronglyMeasurableAtFilter f lb' →\n      Filter.Tendsto f (lb' ⊓ MeasureTheory.Measure.ae MeasureTheory.volume) (nhds c) →\n        Filter.Tendsto u lt lb →\n          Filter.Tendsto v lt lb →\n            (fun t => ((∫ (x : ℝ) in a..v t, f x) - ∫ (x : ℝ) in a..u t, f x) - (v t - u t) • c) =o[lt] (v - u)",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance", "Real", "Real.commRing", "Ring", "CommRing.toRing"],
  "name": "Real.instRingReal",
  "constType": "Ring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "absurd",
   "rfl",
   "Eq"],
  "name": "dif_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references": ["And", "setOf", "Preorder.toLT", "Set", "LT.lt", "Preorder"],
  "name": "Set.Ioo",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "SeminormedRing",
   "Norm",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace"],
  "name": "SeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → SeminormedRing α",
  "constCategory": "Other"},
 {"references":
  ["Finset.nodup",
   "DecidableEq",
   "Finset",
   "Multiset.ndinsert",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.ndinsert"],
  "name": "Finset.instInsertFinset.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), Multiset.Nodup (Multiset.ndinsert a s.val)",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → Norm E",
  "constCategory": "Definition"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "Algebra",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst : Semiring A] → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "TopologicalSemiring.toContinuousMul",
   "CommRing.toNonUnitalCommRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "TopologicalDivisionRing.mk",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "LinearOrderedField.topologicalRing",
   "Field.toCommRing",
   "LinearOrderedField",
   "LinearOrderedField.toField",
   "TopologicalRing.toTopologicalSemiring",
   "TopologicalSpace",
   "OrderTopology",
   "LinearOrderedField.toLinearOrderedSemifield",
   "TopologicalDivisionRing",
   "LinearOrderedSemifield.toHasContinuousInv₀",
   "Field.toDivisionRing",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedField.toTopologicalDivisionRing",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜],\n  TopologicalDivisionRing 𝕜",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrder.mk",
   "LinearOrderedAddCommGroup.min_def",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd"],
  "name": "LinearOrderedAddCommGroup.toLinearOrder",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references": [],
  "name": "Dist",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "TopologicalSpace.isOpen_inter",
   "TopologicalSpace",
   "Inter.inter",
   "IsOpen",
   "Set.instInterSet"],
  "name": "IsOpen.inter",
  "constType":
  "∀ {α : Type u} {s₁ s₂ : Set α} [inst : TopologicalSpace α], IsOpen s₁ → IsOpen s₂ → IsOpen (s₁ ∩ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "Function.swap",
   "PartialOrder.toPreorder",
   "covariant_swap_add_of_covariant_add",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassRight",
  "constType":
  "∀ (M : Type u_3) [inst : OrderedAddCommMonoid M],\n  CovariantClass M M (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set.mem_setOf",
   "Set",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Filter.tendsto_principal_principal",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "OrderedAddCommMonoid",
   "Filter.principal",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Filter",
   "Filter.Tendsto",
   "OrderedAddCommMonoid.toPartialOrder",
   "Filter.instCompleteLatticeFilter",
   "id",
   "Membership.mem",
   "setOf",
   "Prod.snd",
   "Filter.tendsto_iInf_iInf",
   "Prod.fst",
   "ConditionallyCompleteLattice.toInfSet",
   "GT.gt",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "iInf",
   "CompleteLattice.toInfSet",
   "propext",
   "LT.lt",
   "Prod.swap",
   "Prod",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofFun.proof_2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedAddCommMonoid β] (d : α → α → β),\n  (∀ (x y : α), d x y = d y x) →\n    Filter.Tendsto Prod.swap (⨅ r, ⨅ (_ : r > 0), Filter.principal {x | d x.1 x.2 < r})\n      (⨅ r, ⨅ (_ : r > 0), Filter.principal {x | d x.1 x.2 < r})",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "ZeroLEOneClass.zero_le_one",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "zero_le_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "Prod.snd",
   "instHSMul",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "ContinuousSMul.continuous_smul",
   "Continuous",
   "HSMul.hSMul",
   "Continuous.prod_mk",
   "TopologicalSpace",
   "Prod",
   "Prod.fst",
   "ContinuousSMul",
   "Continuous.comp"],
  "name": "Continuous.smul",
  "constType":
  "∀ {M : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : SMul M X] [inst_4 : ContinuousSMul M X] {f : Y → M} {g : Y → X},\n  Continuous f → Continuous g → Continuous fun x => f x • g x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Nat.succ",
   "id",
   "IsCancelAdd.toIsLeftCancelAdd",
   "lt_add_one",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "strictMono_nat_of_lt_succ",
   "StrictMono.injective"],
  "name": "StrictOrderedSemiring.to_charZero",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedSemiring α], CharZero α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_zero'",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), Ring.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "instHMul",
   "outParam",
   "FunLike",
   "HMul.hMul",
   "FunLike.coe",
   "Mul",
   "Eq"],
  "name": "MulHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Mul M] →\n        [inst_1 : Mul N] →\n          [toFunLike : FunLike F M fun x => N] → (∀ (f : F) (x y : M), f (x * y) = f x * f y) → MulHomClass F M N",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["TopologicalSpace.IsSeparable",
   "TopologicalSpace.isSeparable_univ_iff",
   "Set",
   "TopologicalSpace.SeparableSpace",
   "TopologicalSpace",
   "Set.univ",
   "Set.subset_univ",
   "Iff.mpr",
   "TopologicalSpace.IsSeparable.mono"],
  "name": "TopologicalSpace.isSeparable_of_separableSpace",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] [h : TopologicalSpace.SeparableSpace α] (s : Set α),\n  TopologicalSpace.IsSeparable s",
  "constCategory": "Theorem"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "Classical.choose_spec",
   "Exists",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "Classical.choose",
   "NontriviallyNormedField.toNormedField",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "dite",
   "NormedSpace",
   "RingHom.id",
   "Eq",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "HasFDerivAt",
   "fderiv_def",
   "UniformSpace.toTopologicalSpace",
   "id",
   "fderiv",
   "NontriviallyNormedField",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "dif_pos",
   "Classical.propDecidable",
   "PseudoMetricSpace.toUniformSpace",
   "Field.toSemifield",
   "DivisionSemiring.toSemiring",
   "DifferentiableAt",
   "ContinuousLinearMap",
   "Eq.ndrec",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Not",
   "NormedSpace.toModule",
   "ContinuousLinearMap.zero"],
  "name": "DifferentiableAt.hasFDerivAt",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {x : E}, DifferentiableAt 𝕜 f x → HasFDerivAt f (fderiv 𝕜 f x) x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Mul"],
  "name": "MulHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Mul M] → [inst : Mul N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["AddCommMonoid.nat_isScalarTower",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring.toMonoidWithZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoid.toAddMonoid",
   "Module.toMulActionWithZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "IsScalarTower",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid.toNatSMul",
   "SMulZeroClass.toSMul",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Nat",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.instAddCommMonoid.proof_1",
  "constType": "IsScalarTower ℕ ENNReal ENNReal",
  "constCategory": "Theorem"},
 {"references": ["Inner"],
  "name": "Inner.inner",
  "constType":
  "{𝕜 : Type u_4} → {E : Type u_5} → [self : Inner 𝕜 E] → E → E → 𝕜",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Submodule.mem_sup",
   "AddCommSemigroup.toAddCommMagma",
   "Exists",
   "Submodule",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.completeLattice",
   "AddCommMagma.toAdd",
   "SetLike.instMembership",
   "Eq",
   "And",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Sup.sup",
   "Module",
   "Lattice.toSemilatticeSup",
   "AddCommMonoid.toAddCommSemigroup",
   "Submodule.setLike",
   "AddCommMonoid"],
  "name": "Mathlib.LinearAlgebra.Span._auxLemma.13",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M}\n  {p p' : Submodule R M}, (x ∈ p ⊔ p') = ∃ y ∈ p, ∃ z ∈ p', y + z = x",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "NormedAddGroup"],
  "name": "NormedAddGroup.toAddGroup",
  "constType": "{E : Type u_9} → [self : NormedAddGroup E] → AddGroup E",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "LinearOrder.mk",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLT"],
  "name": "LinearOrderedRing.toLinearOrder",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u_1} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references": ["NormedField", "SeminormedAddCommGroup"],
  "name": "NormedSpace",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [inst : NormedField α] → [inst : SeminormedAddCommGroup β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "AddHom.toFun",
   "Semiring",
   "ContinuousLinearMap.casesOn",
   "ContinuousLinearMap.mk",
   "Eq.refl",
   "autoParam",
   "AddCommMagma.toAdd",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "ContinuousLinearMap",
   "Function.Injective",
   "Eq.rec",
   "Continuous",
   "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
   "TopologicalSpace",
   "Module",
   "Eq.symm",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.coe_injective",
  "constType":
  "∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4}\n  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_6} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂],\n  Function.Injective ContinuousLinearMap.toLinearMap",
  "constCategory": "Theorem"},
 {"references": ["AddGroupWithOne", "Int"],
  "name": "AddGroupWithOne.zsmul",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references": ["OmegaCompletePartialOrder", "PartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_1} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "LinearOrderedAddCommMonoid",
   "Preorder.toLE",
   "AddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toLinearOrder : LinearOrder α] →\n    [toAddCommMonoid : AddCommMonoid α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → LinearOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "DenselyOrdered",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "le_refl",
   "SemilatticeInf.toPartialOrder",
   "OrderTopology",
   "TopologicalSpace",
   "NoMaxOrder",
   "nhdsWithin",
   "Set.Ioi",
   "Filter.NeBot",
   "nhdsWithin_Ioi_neBot"],
  "name": "nhdsWithin_Ioi_self_neBot",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMaxOrder α] (a : α), Filter.NeBot (nhdsWithin a (Set.Ioi a))",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_3",
  "constType": "∀ (a : ℝ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocSemiring",
   "MulHomClass",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] →\n          [toMulHomClass : MulHomClass F α β] →\n            (∀ (f : F) (x y : α), f (x + y) = f x + f y) → (∀ (f : F), f 0 = 0) → NonUnitalRingHomClass F α β",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instZeroCardinal",
  "constType": "Zero Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "Semiring",
   "FunLike.mk",
   "LinearMap.instFunLike",
   "FunLike.coe",
   "AddCommMagma.toAdd",
   "SemilinearMapClass.mk",
   "AddHomClass.mk",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_2",
   "ContinuousLinearMap",
   "ContinuousSemilinearMapClass",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_1",
   "ContinuousLinearMap.continuousSemilinearMapClass.proof_3",
   "TopologicalSpace",
   "Module",
   "ContinuousSemilinearMapClass.mk",
   "ContinuousLinearMap.cont",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass",
  "constType":
  "{R₁ : Type u_1} →\n  {R₂ : Type u_2} →\n    [inst : Semiring R₁] →\n      [inst_1 : Semiring R₂] →\n        {σ₁₂ : R₁ →+* R₂} →\n          {M₁ : Type u_4} →\n            [inst_2 : TopologicalSpace M₁] →\n              [inst_3 : AddCommMonoid M₁] →\n                {M₂ : Type u_6} →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] →\n                      [inst_6 : Module R₁ M₁] →\n                        [inst_7 : Module R₂ M₂] → ContinuousSemilinearMapClass (M₁ →SL[σ₁₂] M₂) σ₁₂ M₁ M₂",
  "constCategory": "Definition"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{α : Type u_1} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Prod.snd",
   "setOf",
   "instTopologicalSpaceProd",
   "TopologicalSpace",
   "OrderClosedTopology",
   "Prod",
   "Prod.fst",
   "IsClosed",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderClosedTopology.mk",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α], IsClosed {p | p.1 ≤ p.2} → OrderClosedTopology α",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["Eq.mpr",
   "Filter.Tendsto.prod_mk",
   "nhds_prod_eq",
   "Eq.ndrec",
   "instTopologicalSpaceProd",
   "Prod.mk",
   "nhds",
   "SProd.sprod",
   "Eq.refl",
   "TopologicalSpace",
   "Prod",
   "Filter.Tendsto",
   "Filter",
   "Filter.instSProd",
   "Eq",
   "id"],
  "name": "Filter.Tendsto.prod_mk_nhds",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {γ : Type u_5} {a : α} {b : β}\n  {f : Filter γ} {ma : γ → α} {mb : γ → β},\n  Filter.Tendsto ma f (nhds a) → Filter.Tendsto mb f (nhds b) → Filter.Tendsto (fun c => (ma c, mb c)) f (nhds (a, b))",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_self",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "left_neg_eq_right_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {a b : G}, a + b = 0 → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Abs.abs",
   "True",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "CauSeq.Completion.instInvCauchyToRing",
   "Eq.trans",
   "GroupWithZero.toInv",
   "CauSeq.Completion.Cauchy.field",
   "eq_self",
   "Neg.toHasAbs",
   "DivisionSemiring.toGroupWithZero",
   "Rat",
   "Field.toSemifield",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "Rat.field",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal.proof_11",
  "constType": "0⁻¹ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["SecondCountableTopology",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "secondCountable_of_proper",
   "Real.pseudoMetricSpace",
   "UniformSpace.toTopologicalSpace",
   "instProperSpaceRealPseudoMetricSpace"],
  "name":
  "instSecondCountableTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpace",
  "constType": "SecondCountableTopology ℝ",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.GenerateMeasurable.compl",
   "MeasurableSpace.GenerateMeasurable.iUnion",
   "MeasurableSpace.GenerateMeasurable",
   "Set",
   "MeasurableSpace.mk",
   "MeasurableSpace",
   "MeasurableSpace.GenerateMeasurable.empty"],
  "name": "MeasurableSpace.generateFrom",
  "constType": "{α : Type u_1} → Set (Set α) → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast.ratCast", "RatCast"],
  "name": "Rat.cast",
  "constType": "{K : Type u} → [inst : RatCast K] → ℚ → K",
  "constCategory": "Definition"},
 {"references":
  ["instLinearOrder.proof_3",
   "instLinearOrder.proof_1",
   "LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Max.mk",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrder.decidableLE",
   "instLinearOrder.proof_2",
   "Min.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "Lattice.toInf",
   "ConditionallyCompleteLinearOrder.decidableEq",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "LinearOrder.mk",
   "Sup.sup",
   "ConditionallyCompleteLinearOrder",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "ConditionallyCompleteLinearOrder.decidableLT"],
  "name": "instLinearOrder",
  "constType":
  "(α : Type u_5) → [inst : ConditionallyCompleteLinearOrder α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instMulReal",
   "Real",
   "NormedDivisionRing.toNorm",
   "HMul.hMul",
   "Norm.norm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NormedDivisionRing.norm_mul'",
   "NormedDivisionRing",
   "NormedRing.toRing",
   "Ring.toNonAssocRing",
   "Eq"],
  "name": "norm_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NormedDivisionRing α] (a b : α), ‖a * b‖ = ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.add", "Real", "Add", "Add.mk"],
  "name": "Real.instAddReal",
  "constType": "Add ℝ",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "Exists",
   "And",
   "frequently_gt_nhds",
   "Filter.Frequently.exists",
   "Preorder.toLT",
   "nhds",
   "LT.lt",
   "TopologicalSpace",
   "Filter.Eventually",
   "nhdsWithin",
   "Preorder",
   "Set.Ioi",
   "Filter.NeBot",
   "GT.gt"],
  "name": "Filter.Eventually.exists_gt",
  "constType":
  "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] {a : α}\n  [inst_2 : Filter.NeBot (nhdsWithin a (Set.Ioi a))] {p : α → Prop}, (∀ᶠ (x : α) in nhds a, p x) → ∃ b > a, p b",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NormedAddCommGroup.dist_eq",
   "AddCommGroup.toAddGroup",
   "NormedAddGroup",
   "NormedAddCommGroup.toNorm",
   "NormedAddGroup.mk"],
  "name": "NormedAddCommGroup.toNormedAddGroup",
  "constType":
  "{E : Type u_6} → [inst : NormedAddCommGroup E] → NormedAddGroup E",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "implies_congr",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Preorder.toLE",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.mpr",
   "Iff",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "id",
   "Neg.toHasAbs",
   "CauSeq.le_antisymm",
   "Real.instLTReal",
   "Mathlib.Data.Real.Basic._auxLemma.7",
   "Real.mk_le",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "LE.le",
   "Preorder.mk",
   "CauSeq.equiv",
   "And",
   "Eq.ndrec",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "propext",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "LT.lt",
   "Real.mk",
   "le_refl",
   "congr",
   "Not",
   "HasEquiv.Equiv",
   "congrArg",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.partialOrder.proof_4",
  "constType": "∀ (a b : ℝ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "mul_neg",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "abs_of_nonneg",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "HasDistribNeg.toInvolutiveNeg",
   "abs_eq",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "DistribLattice.toLattice",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "propext",
   "StrictOrderedSemiring.toOrderedSemiring",
   "congr",
   "LinearOrder.toPartialOrder",
   "MonoidWithZero.toZero",
   "congrArg",
   "OrderedSemiring.toPosMulMono",
   "OrderedAddCommGroup.toAddCommGroup",
   "mul_nonneg",
   "StrictOrderedRing.toRing",
   "abs_nonneg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedRing.toStrictOrderedRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "True",
   "le_total",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedRing",
   "InvolutiveNeg.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
   "Lattice.toSemilatticeSup",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Or.inr",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "abs_of_nonpos",
   "Eq.ndrec",
   "Or.inl",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "NegZeroClass.toNeg"],
  "name": "abs_mul",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), |a * b| = |a| * |b|",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.28",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "IsROrC.re",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Module.toDistribMulAction",
   "NormedAddCommGroup",
   "OfNat.ofNat",
   "instHSMul",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "NormedAddCommGroup.toNorm",
   "Nat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AddCommMagma.toAdd",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "MulAction.toSMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "CommRing.toRing",
   "Norm.norm",
   "NormedSpace.toModule",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "NormedAddCommGroup.toAddCommGroup",
   "RingHom",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "IsROrC.toStarRing",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NormedSpace",
   "NormedField.toField",
   "Field.toCommRing",
   "Inner",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedAddCommGroup.toAddCommGroup",
   "starRingEnd",
   "instHPow",
   "Monoid.toNatPow",
   "Inner.inner",
   "instOfNatNat",
   "AddCommMonoid.toAddCommSemigroup",
   "DistribMulAction.toMulAction",
   "NonUnitalNonAssocRing.toMul",
   "IsROrC.toDenselyNormedField",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "InnerProductSpace",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "InnerProductSpace.mk",
  "constType":
  "{𝕜 : Type u_4} →\n  {E : Type u_5} →\n    [inst : IsROrC 𝕜] →\n      [inst_1 : NormedAddCommGroup E] →\n        [toNormedSpace : NormedSpace 𝕜 E] →\n          [toInner : Inner 𝕜 E] →\n            (∀ (x : E), ‖x‖ ^ 2 = IsROrC.re (inner x x)) →\n              (∀ (x y : E), (starRingEnd 𝕜) (inner y x) = inner x y) →\n                (∀ (x y z : E), inner (x + y) z = inner x z + inner y z) →\n                  (∀ (x y : E) (r : 𝕜), inner (r • x) y = (starRingEnd 𝕜) r * inner x y) → InnerProductSpace 𝕜 E",
  "constCategory": "Other"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{α : Type u_1} → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "LE.le",
   "BddAbove",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "upperBounds",
   "BddBelow",
   "lowerBounds",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "ConditionallyCompleteLattice.mk",
  "constType":
  "{α : Type u_5} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      [toInfSet : InfSet α] →\n        (∀ (s : Set α) (a : α), BddAbove s → a ∈ s → a ≤ sSup s) →\n          (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a) →\n            (∀ (s : Set α) (a : α), BddBelow s → a ∈ s → sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s) → ConditionallyCompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "instHSMul",
   "Submodule",
   "Semiring",
   "Submodule.toAddSubmonoid",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "SetLike.coe_injective'",
   "Module.toMulActionWithZero",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "SMulZeroClass.toSMul",
   "Eq",
   "Set.instMembershipSet",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Eq.ndrec",
   "Eq.rec",
   "AddMonoid.toZero",
   "Submodule.casesOn",
   "Submodule.mk",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "Eq.symm",
   "AddSubsemigroup.carrier",
   "AddCommMonoid"],
  "name": "Submodule.setLike.proof_1",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p q : Submodule R M), (fun s => s.carrier) p = (fun s => s.carrier) q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "EmptyCollection.emptyCollection",
   "Set",
   "Eq.mp",
   "Eq.refl",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "Eq.symm",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Bornology.ofBounded.proof_1",
  "constType": "∀ {α : Type u_1} (B : Set (Set α)), ∅ ∈ B → Set.univᶜ ∈ B",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "Real.normedField",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "MeasureTheory.wrapped._@.Mathlib.MeasureTheory.Integral.Bochner._hyg.12924",
   "NormedSpace",
   "MeasurableSpace"],
  "name": "MeasureTheory.integral",
  "constType":
  "{α : Type u_6} →\n  {G : Type u_7} →\n    [inst : NormedAddCommGroup G] →\n      [inst : NormedSpace ℝ G] → {x : MeasurableSpace α} → MeasureTheory.Measure α → (α → G) → G",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "RatCast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ratCast",
  "constType": "RatCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), x * -y = -(x * y)",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "MonoidHomClass",
   "outParam",
   "MulOneClass.toMul",
   "MulOneClass"],
  "name": "MonoidHomClass.toMulHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [self : MonoidHomClass F M N] → MulHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrder.mk",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.exists_metric",
  "constType":
  "∀ {X : Type u_5} [t : TopologicalSpace X] [self : TopologicalSpace.MetrizableSpace X],\n  ∃ m, UniformSpace.toTopologicalSpace = t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "AddHom.toFun",
   "LinearMap.map_smul'",
   "Semiring",
   "FunLike.mk",
   "LinearMap.semilinearMapClass.proof_2",
   "AddCommMagma.toAdd",
   "SemilinearMapClass.mk",
   "AddHomClass.mk",
   "LinearMap.semilinearMapClass.proof_1",
   "Semiring.toNonAssocSemiring",
   "SemilinearMapClass",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap.toAddHom",
   "AddCommMonoid"],
  "name": "LinearMap.semilinearMapClass",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_6} →\n    {M : Type u_9} →\n      {M₃ : Type u_12} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M] → [inst_5 : Module S M₃] → {σ : R →+* S} → SemilinearMapClass (M →ₛₗ[σ] M₃) σ M M₃",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
   "Semiring.mk",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.npow",
   "OrderedSemiring.mk",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
   "CanonicallyOrderedCommSemiring.toOne",
   "OrderedCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "OrderedCommSemiring.mk",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : CanonicallyOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4148",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "Eq",
   "instHMul",
   "One",
   "HMul.hMul",
   "instOfNatNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4187",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            autoParam (∀ (x : M), npow 0 x = 1) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), npow (n + 1) x = x * npow n x) _auto✝¹ → Monoid M",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Filter.EventuallyEq",
   "MeasureTheory.StronglyMeasurable",
   "Filter.EventuallyEq.refl",
   "TopologicalSpace",
   "And.intro",
   "Exists.intro",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace",
   "MeasureTheory.AEStronglyMeasurable"],
  "name": "MeasureTheory.StronglyMeasurable.aestronglyMeasurable",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} {x : MeasurableSpace α} [inst : TopologicalSpace β] {f : α → β}\n  {μ : MeasureTheory.Measure α}, MeasureTheory.StronglyMeasurable f → MeasureTheory.AEStronglyMeasurable f μ",
  "constCategory": "Theorem"},
 {"references": ["Set", "Add", "AddSubsemigroup"],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_4} → [inst : Add M] → AddSubsemigroup M → Set M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.OuterMeasure.coeFnAddMonoidHom",
   "MeasureTheory.OuterMeasure.coe_fn_injective",
   "MeasureTheory.OuterMeasure.addCommMonoid",
   "MeasureTheory.OuterMeasure.instModule.proof_1",
   "Function.Injective.module",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "SMulZeroClass.toSMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "Pi.addCommMonoid",
   "SMulWithZero.toSMulZeroClass",
   "MulActionWithZero.toSMulWithZero",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
   "Algebra.id",
   "Module",
   "MonoidWithZero.toZero",
   "Pi.module",
   "MeasureTheory.OuterMeasure",
   "Algebra.toSMul"],
  "name": "MeasureTheory.OuterMeasure.instModule",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_3} →\n    [inst : Semiring R] →\n      [inst_1 : Module R ENNReal] → [inst_2 : IsScalarTower R ENNReal ENNReal] → Module R (MeasureTheory.OuterMeasure α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_6",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instLinearOrderedRingReal",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedCommRing.toOrderedCommRing",
   "CanonicallyOrderedCommSemiring",
   "LinearOrderedRing.noZeroDivisors",
   "NNReal",
   "Nonneg.canonicallyOrderedCommSemiring"],
  "name": "instNNRealCanonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring NNReal",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Inhabited", "Nat", "Inhabited.mk"],
  "name": "instInhabitedNat",
  "constType": "Inhabited ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Real.instConditionallyCompleteLinearOrderReal.proof_3",
   "LinearOrder.decidableLE",
   "Real.instConditionallyCompleteLinearOrderReal.proof_1",
   "LinearOrder",
   "Real.lattice",
   "Real",
   "LinearOrder.le_total",
   "InfSet.sInf",
   "SupSet.mk",
   "Lattice.mk",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Real.instSupSetReal",
   "Real.instConditionallyCompleteLinearOrderReal.proof_2",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "ConditionallyCompleteLattice.mk",
   "Lattice.toInf",
   "InfSet.mk",
   "Real.linearOrder",
   "Real.instConditionallyCompleteLinearOrderReal.proof_6",
   "Real.instConditionallyCompleteLinearOrderReal.proof_5",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "Lattice",
   "ConditionallyCompleteLinearOrder",
   "Lattice.toSemilatticeSup",
   "Real.instConditionallyCompleteLinearOrderReal.proof_4",
   "Real.instInfSetReal",
   "ConditionallyCompleteLinearOrder.mk"],
  "name": "Real.instConditionallyCompleteLinearOrderReal",
  "constType": "ConditionallyCompleteLinearOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "NontriviallyNormedField.toNormedField",
   "AddCommGroup.toAddCommMonoid",
   "NormedSpace",
   "Asymptotics.IsLittleO",
   "RingHom.id",
   "NormedField.toField",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "NormedAddGroup.toAddGroup",
   "NormedAddCommGroup.toNorm",
   "UniformSpace.toTopologicalSpace",
   "ContinuousSemilinearMapClass.toContinuousMapClass",
   "instHSub",
   "NontriviallyNormedField",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "HSub.hSub",
   "Field.toSemifield",
   "Prod.fst",
   "FunLike.coe",
   "ContinuousLinearMap.continuousSemilinearMapClass",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "ContinuousLinearMap",
   "Prod.mk",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Prod",
   "NormedAddCommGroup.toNormedAddGroup",
   "NormedSpace.toModule",
   "ContinuousMapClass.toFunLike"],
  "name": "HasStrictFDerivAt",
  "constType":
  "{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {F : Type u_3} →\n            [inst_3 : NormedAddCommGroup F] → [inst_4 : NormedSpace 𝕜 F] → (E → F) → (E →L[𝕜] F) → E → Prop",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Norm",
   "Real",
   "Real.instSupReal",
   "Norm.mk",
   "Abs.abs",
   "Real.instNegReal"],
  "name": "Real.norm",
  "constType": "Norm ℝ",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "MonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : MulOneClass M] → [inst : MulOneClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toNeg",
   "add_left_neg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "Eq"],
  "name": "AddGroup.toSubtractionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Norm",
   "Real",
   "Asymptotics.wrapped._@.Mathlib.Analysis.Asymptotics.Asymptotics._hyg.579",
   "Filter"],
  "name": "Asymptotics.IsBigOWith",
  "constType":
  "{α : Type u_17} →\n  {E : Type u_18} → {F : Type u_19} → [inst : Norm E] → [inst : Norm F] → ℝ → Filter α → (α → E) → (α → F) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "IsScalarTower.mk",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalRingHomClass.toMulHomClass",
   "MulZeroClass.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "mul_assoc",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CommSemiring",
   "HSMul.hSMul",
   "Algebra",
   "smul_eq_mul",
   "Algebra.toSMul",
   "id",
   "Mul.toSMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semiring",
   "algebraMap",
   "Algebra.smul_def",
   "MulZeroClass.toSMulWithZero",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "IsScalarTower",
   "SMulZeroClass.toSMul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "MonoidWithZero.toZero"],
  "name": "IsScalarTower.right",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A], IsScalarTower R A A",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero",
   "MulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toMulAction",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : MonoidWithZero R] → [inst_1 : Zero M] → [self : MulActionWithZero R M] → MulAction R M",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedSemiring.toMax",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedSemifield",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedField.toLinearOrderedSemifield.proof_1",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedField.inv_zero",
   "LinearOrderedField.toDiv",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedSemifield.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedField.zpow_neg'",
   "LinearOrderedField.zpow",
   "LinearOrderedField.toInv",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedField.toLinearOrderedSemifield",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LinearOrderedSemifield α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "EmptyCollection.emptyCollection",
   "Real.natCast",
   "em",
   "Metric.closedBall",
   "Set",
   "Real",
   "Exists.intro",
   "Nonempty",
   "Iff.mpr",
   "Nonempty.casesOn",
   "Eq",
   "Set.iUnion",
   "Nat.cast",
   "Nat",
   "UniformSpace.toTopologicalSpace",
   "Metric.iUnion_closedBall_nat",
   "SigmaCompactSpace.mk",
   "PseudoMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace",
   "Membership.mem",
   "Or",
   "isCompact_empty",
   "PseudoMetricSpace.toUniformSpace",
   "ProperSpace.isCompact_closedBall",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "Set.univ",
   "Set.instMembershipSet",
   "Set.iUnion_eq_univ_iff",
   "Nonempty.intro",
   "And",
   "SecondCountableTopology",
   "False.elim",
   "SigmaCompactSpace",
   "Not",
   "EMetric.secondCountable_of_sigmaCompact",
   "And.intro",
   "ProperSpace",
   "IsCompact"],
  "name": "secondCountable_of_proper",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], SecondCountableTopology α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "NormedAddCommGroup",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "NormedLatticeAddCommGroup",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "HasSolidNorm",
   "AddCommGroup.toAddGroup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "NormedLatticeAddCommGroup.mk",
  "constType":
  "{α : Type u_1} →\n  [toNormedAddCommGroup : NormedAddCommGroup α] →\n    [toLattice : Lattice α] →\n      [toHasSolidNorm : HasSolidNorm α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → NormedLatticeAddCommGroup α",
  "constCategory": "Other"},
 {"references": ["Field", "Nontrivial"],
  "name": "Field.toNontrivial",
  "constType": "∀ {K : Type u} [self : Field K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Subtype.val",
   "Real.instLEReal",
   "Real",
   "NNReal",
   "LE.le"],
  "name": "NNReal.toReal",
  "constType": "NNReal → ℝ",
  "constCategory": "Definition"},
 {"references": ["Set.insert", "Set", "Insert", "Insert.mk"],
  "name": "Set.instInsertSet",
  "constType": "{α : Type u_1} → Insert α (Set α)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedAddCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddMonoidHomClass (M →+ N) M N",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.63",
   "Set.instInsertSet"],
  "name": "Finset.coe_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), ↑(insert a s) = insert a ↑s",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DenselyNormedField",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Real.instCommSemiringReal",
   "Semiring",
   "Real"],
  "name": "Real.semiring",
  "constType": "Semiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Distrib.toAdd",
   "Exists",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "AddCommSemigroup.toAddCommMagma",
   "add_halves",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "add_lt_add",
   "HAdd.hAdd",
   "Real",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "IsCancelAdd.toIsRightCancelAdd",
   "LinearOrderedField.toDiv",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "Eq.rec",
   "AddMonoid.toZero",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "AddCommMonoid.toAddCommSemigroup",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "instHDiv",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Real.partialOrder",
   "instHAdd",
   "AddCommMagma.toAdd",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "GT.gt",
   "And",
   "LinearOrderedSemifield.toDiv",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "instNatAtLeastTwo",
   "And.intro",
   "half_pos",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "UniformSpace.ofDist.proof_1",
  "constType": "∀ ε > 0, ∃ δ > 0, ∀ x < δ, ∀ y < δ, x + y < ε",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "ENNReal.coe_lt_top",
   "Top.top",
   "Preorder.toLT",
   "LT.lt",
   "Real",
   "CompleteLattice.toTop",
   "ENNReal.ofReal",
   "Real.toNNReal",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "ENNReal.ofReal_lt_top",
  "constType": "∀ {r : ℝ}, ENNReal.ofReal r < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "AddHomClass.map_add",
   "Eq"],
  "name": "map_add",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Add M] [inst_1 : Add N] [inst_2 : AddHomClass F M N] (f : F)\n  (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "NontriviallyNormedField",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["SMul"],
  "name": "SMul.mk",
  "constType": "{M : Type u} → {α : Type v} → (M → α → α) → SMul M α",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing.toNonUnitalNormedRing",
   "DifferentiableAt.hasFDerivAt",
   "fderiv",
   "DifferentiableAt",
   "NormedAddCommGroup",
   "NontriviallyNormedField",
   "NontriviallyNormedField.toNormedField",
   "NormedField.toNormedSpace",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "NormedCommRing.toNormedRing",
   "deriv",
   "HasFDerivAt.hasDerivAt",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "HasDerivAt",
   "NonUnitalNormedRing.toNormedAddCommGroup"],
  "name": "DifferentiableAt.hasDerivAt",
  "constType":
  "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜}, DifferentiableAt 𝕜 f x → HasDerivAt f (deriv f x) x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MonoidWithZero.toZero",
   "MulActionWithZero.toMulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.zero_smul",
  "constType":
  "∀ {R : Type u_1} {M : Type u_3} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (m : M),\n  0 • m = 0",
  "constCategory": "Definition"},
 {"references": ["Norm", "SeminormedAddCommGroup"],
  "name": "SeminormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} → [self : SeminormedAddCommGroup E] → Norm E",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "Set.Nonempty", "Preorder"],
  "name": "BddBelow",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.toNat.proof_2",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Classical.choose",
   "ZeroHom.mk",
   "ZeroHom",
   "dite",
   "Cardinal.partialOrder",
   "Cardinal.toNat.proof_1",
   "Cardinal.linearOrder",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "instOfNatNat",
   "Not",
   "Nat"],
  "name": "Cardinal.toNat",
  "constType": "ZeroHom Cardinal.{v} ℕ",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl"],
  "name": "Or.intro_left",
  "constType": "∀ {a : Prop} (b : Prop), a → a ∨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [inst : Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "LinearMap.instFunLike.proof_1",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.mk",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "AddCommMonoid"],
  "name": "LinearMap.instFunLike",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_6} →\n    {M : Type u_9} →\n      {M₃ : Type u_12} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring S] →\n            [inst_2 : AddCommMonoid M] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M] → [inst_5 : Module S M₃] → {σ : R →+* S} → FunLike (M →ₛₗ[σ] M₃) M fun x => M₃",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_2",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "NormedAddCommGroup.toAddCommGroup",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "PartialOrder.toPreorder",
   "instHAdd",
   "Real.lattice",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Real",
   "add_le_add",
   "le_rfl",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "Real.orderedAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Real.instPreorderReal",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SemilatticeSup.toPartialOrder",
   "Real.normedAddCommGroup"],
  "name": "Real.normedLatticeAddCommGroup.proof_1",
  "constType": "∀ (x x_1 : ℝ), x ≤ x_1 → ∀ (x_2 : ℝ), x_2 + x ≤ x_2 + x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "Real.instLinearOrderedFieldReal.proof_12",
   "zpowRec",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrder.decidableLE",
   "Monoid.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_5",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Real.linearOrder",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.instInvReal",
   "Real.strictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_11",
   "Real.instLinearOrderedFieldReal.proof_2",
   "Semigroup.mk",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Real.instLinearOrderedFieldReal.proof_13",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.ratCast",
   "Real.instLinearOrderedFieldReal.proof_7",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "DivInvMonoid.div'",
   "Ring.toSemiring",
   "Real.instLinearOrderedFieldReal.proof_4",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.instLinearOrderedFieldReal.proof_10",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "Real.linearOrderedCommRing",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "Real.instLinearOrderedFieldReal.proof_3",
   "LinearOrderedCommRing",
   "Real.instLinearOrderedFieldReal.proof_6",
   "LinearOrderedCommRing.mul_comm",
   "Real.instLinearOrderedFieldReal.proof_9",
   "Real.instLinearOrderedFieldReal.proof_1",
   "LinearOrderedRing.mk",
   "Real.instLinearOrderedFieldReal.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal",
  "constType": "LinearOrderedField ℝ",
  "constCategory": "Definition"},
 {"references": ["And", "setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Icc",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_2",
  "constType": "∀ (x y : ℝ), 0 ≤ |x - y|",
  "constCategory": "Theorem"},
 {"references":
  ["SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "ContinuousSemilinearMapClass",
   "AddHomClass.toFunLike",
   "SemilinearMapClass",
   "Semiring",
   "Continuous",
   "TopologicalSpace",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousSemilinearMapClass.mk",
  "constType":
  "{F : Type u_1} →\n  {R : outParam (Type u_2)} →\n    {S : outParam (Type u_3)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          {σ : outParam (R →+* S)} →\n            {M : outParam (Type u_4)} →\n              [inst_2 : TopologicalSpace M] →\n                [inst_3 : AddCommMonoid M] →\n                  {M₂ : outParam (Type u_5)} →\n                    [inst_4 : TopologicalSpace M₂] →\n                      [inst_5 : AddCommMonoid M₂] →\n                        [inst_6 : Module R M] →\n                          [inst_7 : Module S M₂] →\n                            [toSemilinearMapClass : SemilinearMapClass F σ M M₂] →\n                              (∀ (f : F), Continuous ⇑f) → ContinuousSemilinearMapClass F σ M M₂",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "NatCast.natCast",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{α : Type u_1} → List α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "OrderDual.instPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Filter.generate",
   "CompleteLattice.sInf_le",
   "Set.Set.completeAtomicBooleanAlgebra",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter",
   "Filter.giGenerate",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.liftCompleteLattice"],
  "name": "Filter.instCompleteLatticeFilter.proof_9",
  "constType": "∀ {α : Type u_1} (s : Set (Filter α)ᵒᵈᵒᵈ), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Quotient",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} → [inst_1 : Ring β] → (abv : β → α) → [inst : IsAbsoluteValue abv] → Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "TopologicalSpace",
   "Module",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : Semiring S] →\n        (R →+* S) →\n          (M : Type u_3) →\n            [inst_2 : TopologicalSpace M] →\n              [inst_3 : AddCommMonoid M] →\n                (M₂ : Type u_4) →\n                  [inst_4 : TopologicalSpace M₂] →\n                    [inst_5 : AddCommMonoid M₂] → [inst : Module R M] → [inst : Module S M₂] → Type (max u_3 u_4)",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Max.max",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["upperBounds", "Set", "Set.Nonempty", "Preorder"],
  "name": "BddAbove",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Set",
   "GE.ge",
   "Eq.refl",
   "IsOpen.inter",
   "Inter.inter",
   "Exists.intro",
   "isOpen_univ",
   "Eq",
   "Filter.principal",
   "Filter.HasBasis",
   "Eq.mpr",
   "CompleteLattice.toConditionallyCompleteLattice",
   "TopologicalSpace",
   "Filter",
   "Set.inter_subset_right",
   "IsOpen",
   "id",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "setOf",
   "nhds",
   "nhds_basis_opens.match_1",
   "Set.univ",
   "Set.instLESet",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "nhds_def",
   "Order.Preimage",
   "And",
   "Eq.ndrec",
   "iInf",
   "Filter.hasBasis_biInf_principal",
   "And.intro",
   "Set.inter_subset_left",
   "Set.mem_univ",
   "Set.instInterSet"],
  "name": "nhds_basis_opens",
  "constType":
  "∀ {α : Type u} [inst : TopologicalSpace α] (a : α), Filter.HasBasis (nhds a) (fun s => a ∈ s ∧ IsOpen s) fun s => s",
  "constCategory": "Theorem"},
 {"references": ["One"],
  "name": "OneHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : One M] → [inst : One N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_1",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → GroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "outParam",
   "MonoidHomClass"],
  "name": "RingHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] →\n        [inst_1 : NonAssocSemiring β] →\n          [toMonoidHomClass : MonoidHomClass F α β] →\n            (∀ (f : F) (x y : α), f (x + y) = f x + f y) → (∀ (f : F), f 0 = 0) → RingHomClass F α β",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NormedField",
   "Eq.le",
   "Real",
   "Real.instMulReal",
   "NormedDivisionRing.toNorm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "norm_mul",
   "instHMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Norm.norm",
   "NormedField.toNormedDivisionRing",
   "NormedRing.toRing"],
  "name": "NormedField.toNormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "constCategory": "Other"},
 {"references": ["SMul", "Semiring", "CommSemiring", "Algebra"],
  "name": "Algebra.toSMul",
  "constType":
  "{R : Type u} → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [self : Algebra R A] → SMul R A",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "NormedField"],
  "name": "NormedAlgebra",
  "constType":
  "(𝕜 : Type u_5) → (𝕜' : Type u_6) → [inst : NormedField 𝕜] → [inst : SeminormedRing 𝕜'] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "setOf",
   "Real.instLTReal",
   "Set",
   "LT.lt",
   "Real",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "Metric.ball",
  "constType": "{α : Type u} → [inst : PseudoMetricSpace α] → α → ℝ → Set α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Topology.Algebra.Module.Basic._hyg.2648",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "CanonicallyLinearOrderedSemifield.toCanonicallyLinearOrderedAddCommMonoid",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "WithTop",
   "inferInstanceAs",
   "CanonicallyLinearOrderedAddCommMonoid",
   "WithTop.instCanonicallyLinearOrderedAddCommMonoidWithTop",
   "NNReal"],
  "name": "ENNReal.instCanonicallyLinearOrderedAddCommMonoidENNReal",
  "constType": "CanonicallyLinearOrderedAddCommMonoid ENNReal",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["DenselyOrdered", "And", "Exists", "LT.lt", "LT"],
  "name": "DenselyOrdered.mk",
  "constType":
  "∀ {α : Type u} [inst : LT α], (∀ (a₁ a₂ : α), a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂) → DenselyOrdered α",
  "constCategory": "Other"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegZeroMonoid",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.mk",
  "constType":
  "{G : Type u_2} → [toSubNegMonoid : SubNegMonoid G] → -0 = 0 → SubNegZeroMonoid G",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_1",
   "PartialOrder.toPreorder",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "le_iSup_of_le",
   "OrderHom.mk",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "le_refl",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (i : ℕ), x i ≤ (fun c => ⨆ i, c i) x",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le.trans",
   "CovariantClass",
   "add_le_add_right",
   "Preorder",
   "Add",
   "LE.le",
   "add_le_add_left",
   "Preorder.toLE"],
  "name": "add_le_add",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c d : α},\n  a ≤ b → c ≤ d → a + c ≤ b + d",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk", "_private.Mathlib.Data.Real.Basic.0.Real.le", "Real", "LE"],
  "name": "Real.instLEReal",
  "constType": "LE ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "NontriviallyNormedField",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "LT.lt",
   "NormedField",
   "Norm.norm",
   "One.toOfNat1",
   "NormedField.toNorm",
   "Real.instOneReal"],
  "name": "NontriviallyNormedField.mk",
  "constType":
  "{α : Type u_5} → [toNormedField : NormedField α] → (∃ x, 1 < ‖x‖) → NontriviallyNormedField α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedField.toField",
   "Field.toCommRing",
   "instHMul",
   "NormedField",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NormedField.toNormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.toLinearOrder",
   "LinearOrderedAddCommMonoid.toAddCommMonoid",
   "OrderedAddCommMonoid.mk",
   "LinearOrder.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.add_le_add_left"],
  "name": "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["PseudoMetricSpace"],
  "name": "ProperSpace",
  "constType": "(α : Type u) → [inst : PseudoMetricSpace α] → Prop",
  "constCategory": "Other"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing",
   "DivisionRing.toRing",
   "NormedDivisionRing.toDivisionRing",
   "NormedDivisionRing.toNormedRing.proof_1",
   "NormedDivisionRing.toNorm",
   "NormedRing.mk",
   "NormedDivisionRing",
   "NormedDivisionRing.dist_eq",
   "NormedDivisionRing.toMetricSpace"],
  "name": "NormedDivisionRing.toNormedRing",
  "constType": "{α : Type u_1} → [β : NormedDivisionRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "∀ {α : Sort u}, α → Nonempty α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "IsCauSeq", "Ring", "Nat", "Subtype"],
  "name": "CauSeq",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → (β : Type u_2) → [inst : Ring β] → (β → α) → Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5362",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "LinearOrder",
   "instDistribLattice",
   "eq_comm",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Abs.abs",
   "Eq",
   "Mathlib.Algebra.Order.Group.Abs._auxLemma.1",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "AddGroup",
   "SemilatticeSup.toSup",
   "propext",
   "InvolutiveNeg.toNeg",
   "Eq.mp",
   "congr",
   "abs_choice",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "congrArg",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "eq_or_eq_neg_of_abs_eq",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] {a b : α}, |a| = b → a = b ∨ a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Semiring.toModule.proof_1",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Semiring.toModule.proof_2",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Semiring.toModule.proof_4",
   "Module",
   "Semiring.toModule.proof_3",
   "MulActionWithZero.toMulAction",
   "Module.mk"],
  "name": "Semiring.toModule",
  "constType": "{R : Type u_2} → [inst : Semiring R] → Module R R",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty",
  "constType": "∀ {α : Sort u} [inst : Inhabited α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "EquivLike.coe",
   "RingHomClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "RingEquivClass.toRingHomClass.proof_5",
   "FunLike.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "RingEquivClass.toRingHomClass.proof_2",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "RingEquivClass.toRingHomClass.proof_1",
   "MulEquivClass.toEquivLike",
   "RingEquivClass.toRingHomClass.proof_3",
   "RingEquivClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingEquivClass.toMulEquivClass",
   "RingEquivClass.toRingHomClass.proof_4",
   "MonoidHomClass.mk"],
  "name": "RingEquivClass.toRingHomClass",
  "constType":
  "{F : Type u_1} →\n  {R : Type u_4} →\n    {S : Type u_5} →\n      [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → [h : RingEquivClass F R S] → RingHomClass F R S",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Set.univ_inter",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_right",
  "constType": "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ g → s ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "NormedAddCommGroup",
   "IntervalIntegrable",
   "ContinuousOn.intervalIntegrable",
   "Real.lattice",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "Continuous",
   "Real.measurableSpace",
   "Real",
   "NormedAddCommGroup.toSeminormedAddCommGroup",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "Set.uIcc",
   "UniformSpace.toTopologicalSpace",
   "Continuous.continuousOn",
   "MeasureTheory.IsLocallyFiniteMeasure"],
  "name": "Continuous.intervalIntegrable",
  "constType":
  "∀ {E : Type u_3} [inst : NormedAddCommGroup E] {μ : MeasureTheory.Measure ℝ}\n  [inst_1 : MeasureTheory.IsLocallyFiniteMeasure μ] {u : ℝ → E}, Continuous u → ∀ (a b : ℝ), IntervalIntegrable u μ a b",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Top",
   "setOf",
   "Filter.mk",
   "Filter.instTopFilter.proof_2",
   "Set",
   "Filter.instTopFilter.proof_1",
   "Filter",
   "Set.mem_univ",
   "Top.mk",
   "Set.instMembershipSet"],
  "name": "Filter.instTopFilter",
  "constType": "{α : Type u} → Top (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsScalarTower.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MulZeroClass.toSMulWithZero",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "Algebra.toSMul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "SMulZeroClass.toSMul"],
  "name": "MeasureTheory.Measure.restrict.proof_1",
  "constType": "IsScalarTower ENNReal ENNReal ENNReal",
  "constCategory": "Theorem"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "ContinuousLinearMap.toLinearMap",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Semiring",
   "HAdd.hAdd",
   "map_add",
   "FunLike.coe",
   "AddCommMagma.toAdd",
   "Eq",
   "SemilinearMapClass.toAddHomClass",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap",
   "TopologicalSpace",
   "Module",
   "LinearMap",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.continuousSemilinearMapClass.proof_2",
  "constType":
  "∀ {R₁ : Type u_4} {R₂ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_2}\n  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_1} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] (f : M₁ →SL[σ₁₂] M₂) (x y : M₁),\n  ↑f (x + y) = ↑f x + ↑f y",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "Ord"],
  "name": "LinearOrderedRing.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "Semiring",
   "AddHomClass.toFunLike",
   "Semiring.toMonoidWithZero",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Eq",
   "SMulZeroClass.toSMul",
   "RingHomClass.toNonUnitalRingHomClass",
   "outParam",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "SemilinearMapClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddHomClass",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Module",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "SemilinearMapClass.mk",
  "constType":
  "{F : Type u_17} →\n  {R : outParam (Type u_18)} →\n    {S : outParam (Type u_19)} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] →\n          {σ : outParam (R →+* S)} →\n            {M : outParam (Type u_20)} →\n              {M₂ : outParam (Type u_21)} →\n                [inst_2 : AddCommMonoid M] →\n                  [inst_3 : AddCommMonoid M₂] →\n                    [inst_4 : Module R M] →\n                      [inst_5 : Module S M₂] →\n                        [toAddHomClass : AddHomClass F M M₂] →\n                          (∀ (f : F) (r : R) (x : M), f (r • x) = σ r • f x) → SemilinearMapClass F σ M M₂",
  "constCategory": "Other"},
 {"references": ["Abs"],
  "name": "Abs.abs",
  "constType": "{α : Type u_1} → [self : Abs α] → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedAddCommGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "instOfNatNat",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "instAddNat",
   "instHAdd",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_5",
  "constType":
  "∀ (n : ℕ) (x : ℝ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["top_le_iff",
   "OrderTop.toTop",
   "Iff.symm",
   "Iff",
   "PartialOrder.toPreorder",
   "Top.top",
   "OrderTop",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_top_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a = ⊤ ↔ ⊤ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "Submodule",
   "Submodule.toAddSubmonoid",
   "Semiring",
   "AddSubmonoid.toAddSubsemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddSubsemigroup.carrier",
   "Submodule.setLike.proof_1",
   "AddCommMonoid"],
  "name": "Submodule.setLike",
  "constType":
  "{R : Type u} →\n  {M : Type v} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → SetLike (Submodule R M) M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Inf.inf",
   "Inter.inter",
   "Exists.intro",
   "Set.univ",
   "Filter.univ_mem",
   "Set.inter_univ",
   "Eq",
   "And",
   "Filter.instInfFilter",
   "Filter",
   "And.intro",
   "Eq.symm",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.mem_inf_of_left",
  "constType": "∀ {α : Type u} {f g : Filter α} {s : Set α}, s ∈ f → s ∈ f ⊓ g",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "MulPosMono",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toMulPosMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], MulPosMono α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddGroup",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (n : ℕ) (x : G), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toNonUnitalCommRing",
   "Semifield.toCommSemiring",
   "IsROrC.toStarRing",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "True",
   "Eq",
   "mul_comm",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "starRingEnd_self_apply",
   "map_mul",
   "Eq.trans",
   "eq_self",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "EuclideanDomain.toCommRing",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "congr",
   "congrArg"],
  "name": "IsROrC.innerProductSpace.proof_2",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (x y : 𝕜), (starRingEnd 𝕜) ((starRingEnd 𝕜) y * x) = (starRingEnd 𝕜) x * y",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["ConditionallyCompleteLinearOrder", "ConditionallyCompleteLinearOrderBot"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrderBot α] → ConditionallyCompleteLinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "MulAction",
   "AddMonoid",
   "DistribMulAction",
   "Eq"],
  "name": "DistribMulAction.mk",
  "constType":
  "{M : Type u_10} →\n  {A : Type u_11} →\n    [inst : Monoid M] →\n      [inst_1 : AddMonoid A] →\n        [toMulAction : MulAction M A] →\n          (∀ (a : M), a • 0 = 0) → (∀ (a : M) (x y : A), a • (x + y) = a • x + a • y) → DistribMulAction M A",
  "constCategory": "Other"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β → Prop",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommMonoid", "AddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddCommMonoid.nat_isScalarTower",
   "instHSMul",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.Measure.smul_toOuterMeasure",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "AddMonoid.toNatSMul",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.instSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "HSMul.hSMul",
   "OrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.instAddCommMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] (x : MeasureTheory.Measure α) (x_1 : ℕ), ↑(x_1 • x) = x_1 • ↑x",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["Filter.Frequently.and_eventually",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "le_rfl",
   "And.left",
   "Iff.mpr",
   "LE.le.eq_or_lt",
   "And.right",
   "upperBounds",
   "OrderTopology.to_orderClosedTopology",
   "Filter.instPureFilter",
   "Std.Classes.Order._auxLemma.3",
   "Set.Icc_subset_Icc_union_Icc",
   "Set.Ico",
   "Or",
   "Mathlib.Order.Basic._auxLemma.1",
   "instDistribLattice",
   "Set.instSDiffSet",
   "SDiff.sdiff",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "IsLUB",
   "And",
   "eq_true",
   "False.elim",
   "Filter.le_principal_iff",
   "propext",
   "LT.lt",
   "congr",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "congrFun",
   "Exists",
   "Set.diff_subset_iff",
   "Set",
   "GE.ge",
   "Eq.refl",
   "mem_nhdsWithin_Iic_iff_exists_Ioc_subset'",
   "Exists.intro",
   "Set.Iic",
   "Set.Subset.rfl",
   "True",
   "Ioc_mem_nhdsWithin_Iic",
   "CompactIccSpace.mk''",
   "instMembershipSetFilter",
   "mem_nhdsWithin_of_mem_nhds",
   "Filter.le_pure_iff",
   "Or.inr",
   "LE.le.trans",
   "ConditionallyCompleteLattice.toLattice",
   "LE.le",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Or.inl",
   "mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset",
   "IsCompact",
   "Set.instUnionSet",
   "and_self",
   "Ultrafilter.instMembershipSetUltrafilter",
   "dite",
   "Set.Icc_self",
   "Exists.casesOn",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "isLUB_csSup",
   "Mathlib.Tactic.PushNeg.not_and_eq",
   "Eq.mpr",
   "Iff.mp",
   "ConditionallyCompleteLattice.toSupSet",
   "instLinearOrder",
   "OrderTopology",
   "Filter",
   "And.casesOn",
   "not_false_eq_true",
   "Eq.trans",
   "Ultrafilter.toFilter",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "setOf",
   "Filter.Frequently.exists",
   "Lattice.toSemilatticeInf",
   "Classical.propDecidable",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.Iio",
   "Or.casesOn",
   "BddAbove",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Ultrafilter",
   "of_eq_true",
   "Filter.instPartialOrderFilter",
   "Singleton.singleton",
   "Not",
   "Set.Ioc",
   "Mathlib.Tactic.Contrapose.mtr",
   "ConditionallyCompleteLinearOrder",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "congrArg",
   "Set.Icc",
   "IsLUB.frequently_mem",
   "Filter.mem_of_superset",
   "CompactIccSpace",
   "Set.Ici",
   "Mathlib.Topology.Compactness.Compact._auxLemma.23",
   "Mathlib.Init.Order.Defs._auxLemma.2",
   "Pure.pure",
   "Set.Ioc_subset_Ioc_left",
   "Filter.principal",
   "Set.Icc_subset_Icc_union_Ioc",
   "Set.instSingletonSet",
   "forall_congr",
   "Preorder.toLT",
   "TopologicalSpace",
   "Ultrafilter.diff_mem_iff",
   "nhdsWithin",
   "Set.union_comm",
   "Set.Icc_eq_empty",
   "id",
   "isCompact_iff_ultrafilter_le_nhds",
   "le_or_lt",
   "Membership.mem",
   "funext",
   "pure_le_nhds",
   "LT.lt.le",
   "False",
   "nhds",
   "Union.union",
   "SemilatticeInf.toPartialOrder",
   "SupSet.sSup",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.4",
   "eq_false",
   "LE.le.not_lt",
   "lowerBounds",
   "Set.Subset.trans",
   "Set.union_subset_union",
   "Set.Ico_union_right"],
  "name": "ConditionallyCompleteLinearOrder.toCompactIccSpace",
  "constType":
  "∀ (α : Type u_1) [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α],\n  CompactIccSpace α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_self",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedAddCommGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["RingHomInvPair",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "IsROrC.toDenselyNormedField",
   "Field.toSemifield",
   "DenselyNormedField.toNormedField",
   "Semifield.toDivisionSemiring",
   "IsROrC",
   "RingHom.id",
   "RingHomInvPair.ids"],
  "name": "OrthonormalBasis.toBasis.proof_1",
  "constType":
  "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜], RingHomInvPair (RingHom.id 𝕜) (RingHom.id 𝕜)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomClass.mk",
   "RingHom",
   "MulOneClass.toMul",
   "RingHom.instRingHomClass.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MulOneClass.toOne",
   "FunLike.mk",
   "RingHom.instRingHomClass.proof_2",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "NonAssocSemiring",
   "OneHom.toFun",
   "RingHom.instRingHomClass.proof_1",
   "MonoidHom.toOneHom",
   "RingHom.map_zero'",
   "RingHom.map_add'",
   "RingHom.toMonoidHom",
   "MonoidHomClass.mk"],
  "name": "RingHom.instRingHomClass",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → RingHomClass (α →+* β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Iff.mp",
   "AddMonoid.toZero",
   "Field",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Ne",
   "mul_eq_zero",
   "Or",
   "False",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Or.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "And",
   "instHMul",
   "Field.toEuclideanDomain.match_2",
   "CommRing.toRing",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.noZeroDivisors",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.proof_5",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b ≠ 0 → a * b = 0 ∧ a ≠ 0 → False",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Units.mk0",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Or",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "And.left",
   "implies_congr",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Units.ne_zero",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "Units",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "And",
   "And.right",
   "Eq.mpr",
   "Mathlib.Tactic.PushNeg.not_or_eq",
   "Units.instMulOneClassUnits",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toNontrivial",
   "GroupWithZero",
   "HMul.hMul",
   "Not",
   "Mathlib.Tactic.Contrapose.mtr",
   "MonoidWithZero.toZero",
   "id"],
  "name": "GroupWithZero.noZeroDivisors",
  "constType": "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀], NoZeroDivisors G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "EuclideanDomain",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Cardinal.isEquivalent"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasureTheory.MeasureSpace",
  "constType": "Type u_6 → Type u_6",
  "constCategory": "Other"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Add M] → [inst : Add N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), ∀ t ∈ s, ∀ a ∈ t, ∃ t ∈ s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["SeminormedAddCommGroup.mk",
   "NonUnitalSeminormedRing.dist_eq",
   "NonUnitalSeminormedRing.toNorm",
   "SeminormedAddCommGroup",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
  "constType":
  "{α : Type u_1} → [inst : NonUnitalSeminormedRing α] → SeminormedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["AddMonoid.nsmul", "SMul", "SMul.mk", "Nat", "AddMonoid"],
  "name": "AddMonoid.toNatSMul",
  "constType": "{M : Type u_2} → [inst : AddMonoid M] → SMul ℕ M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCancelAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instCommSemiringReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "StarRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "starRingOfComm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name":
  "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
  "constType": "StarRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "RingHomClass.toRingHom.proof_3",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "AddMonoidHomClass.toAddMonoidHom",
   "RingHomClass.toAddMonoidHomClass",
   "RingHomClass.toRingHom.proof_1",
   "RingHomClass.toMonoidHomClass",
   "MonoidHom.toOneHom",
   "RingHomClass.toRingHom.proof_2",
   "MonoidHom.mk",
   "AddMonoidHom"],
  "name": "RingHomClass.toRingHom",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → F → α →+* β",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "MeasureTheory.OuterMeasure.empty'",
   "Set",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "instENNRealZero",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "congrFun"],
  "name": "MeasureTheory.Measure.ae.proof_1",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α), ↑↑μ Set.univᶜ = 0",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Basis",
  "constType":
  "Type u_1 →\n  (R : Type u_3) →\n    (M : Type u_6) →\n      [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Type (max (max u_1 u_3) u_6)",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1771",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "PosMulMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MulAction", "AddMonoid", "DistribMulAction"],
  "name": "DistribMulAction.toMulAction",
  "constType":
  "{M : Type u_10} →\n  {A : Type u_11} → [inst : Monoid M] → [inst_1 : AddMonoid A] → [self : DistribMulAction M A] → MulAction M A",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "ContinuousLinearMap.toLinearMap",
   "ContinuousLinearMap",
   "AddHom.toFun",
   "Semiring",
   "Continuous",
   "TopologicalSpace",
   "Module",
   "AddCommMagma.toAdd",
   "LinearMap.toAddHom",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "ContinuousLinearMap.cont",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {σ : R →+* S} {M : Type u_3}\n  [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M] {M₂ : Type u_4} [inst_4 : TopologicalSpace M₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M] [inst_7 : Module S M₂] (self : M →SL[σ] M₂), Continuous self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalSeminormedRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "PseudoMetricSpace",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalSeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toNonUnitalRing : NonUnitalRing α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NonUnitalSeminormedRing α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "Field",
   "Field.toSemifield",
   "Semifield.toDivisionSemiring",
   "HDiv.hDiv",
   "div_zero",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_1",
  "constType": "∀ {K : Type u_1} [inst : Field K] (a : K), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "Min.min",
   "OrderedAddCommGroup",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.mk",
  "constType":
  "{α : Type u} →\n  [toOrderedAddCommGroup : OrderedAddCommGroup α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedAddCommGroup α",
  "constCategory": "Other"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → CommMagma α",
  "constCategory": "Definition"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Set.union_eq_self_of_subset_left",
   "Union.union",
   "Set",
   "Filter.mem_of_superset",
   "Eq.refl",
   "HasSubset.Subset",
   "Inter.inter",
   "Exists.intro",
   "Exists.casesOn",
   "Set.subset_union_left",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Eq.mpr",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.inter_union_distrib_right",
   "Filter",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Set.instUnionSet",
   "id",
   "instMembershipSetFilter",
   "Set.instInterSet"],
  "name": "Filter.instInfFilter.proof_2",
  "constType":
  "∀ {α : Type u_1} (f g : Filter α) {x y : Set α},\n  x ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b} → x ⊆ y → y ∈ {s | ∃ a ∈ f, ∃ b ∈ g, s = a ∩ b}",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNonUnitalRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.214",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["NormedAddCommGroup", "AddCommGroup"],
  "name": "NormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} → [self : NormedAddCommGroup E] → AddCommGroup E",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.neg_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), -x * y = -(x * y)",
  "constCategory": "Definition"},
 {"references": ["Set.range", "InfSet.sInf", "InfSet"],
  "name": "iInf",
  "constType":
  "{α : Type u_1} → [inst : InfSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["UniformSpace.Core.uniformity",
   "UniformSpace",
   "Prod",
   "Filter",
   "UniformSpace.toCore"],
  "name": "uniformity",
  "constType": "(α : Type u) → [inst : UniformSpace α] → Filter (α × α)",
  "constCategory": "Definition"},
 {"references": ["TopologicalSpace"],
  "name": "SecondCountableTopology",
  "constType": "(α : Type u) → [t : TopologicalSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["SMulZeroClass.mk",
   "Zero",
   "MulAction.toSMul",
   "SMulWithZero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero.smul_zero",
   "MulActionWithZero",
   "MulActionWithZero.zero_smul",
   "MonoidWithZero.toZero",
   "SMulWithZero.mk",
   "MulActionWithZero.toMulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toSMulWithZero",
  "constType":
  "(R : Type u_1) →\n  (M : Type u_3) → [inst : MonoidWithZero R] → [inst_1 : Zero M] → [m : MulActionWithZero R M] → SMulWithZero R M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "One.toOfNat1",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "instOfNatNat",
   "LinearOrder.decidableEq",
   "Nat",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.instLinearOrderedFieldReal.proof_4",
  "constType": "∀ (x : ℝ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalCommRing", "NonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalRing",
  "constType": "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Rat",
   "Rat.instLinearOrderedCommRingRat"],
  "name": "Rat.instLinearOrderedRingRat",
  "constType": "LinearOrderedRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_neg'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references": ["instHMul", "Rat", "HMul.hMul", "Mul"],
  "name": "qsmulRec",
  "constType": "{K : Type u_3} → (ℚ → K) → [inst : Mul K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "RingHom",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "OneHom.map_one'",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  OneHom.toFun (↑↑f) 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "instHMul",
   "NormedRing.norm_mul",
   "NormedCommRing",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Filter",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Rat", "Rat.neg", "Neg", "Neg.mk"],
  "name": "Rat.instNegRat",
  "constType": "Neg ℚ",
  "constCategory": "Definition"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} → [self : Ring R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "NormedRing.toNorm",
   "NormedRing.toNonUnitalNormedRing.proof_6",
   "AddCommMonoid.toAddMonoid",
   "NormedRing.toNonUnitalNormedRing.proof_7",
   "Ring.toNeg",
   "NormedRing.toNonUnitalNormedRing.proof_3",
   "NormedRing.dist_eq",
   "Ring.toSub",
   "NormedRing.toNonUnitalNormedRing.proof_2",
   "NormedRing.toNonUnitalNormedRing.proof_11",
   "NonUnitalNormedRing",
   "NormedRing.toNonUnitalNormedRing.proof_10",
   "NormedRing.toRing",
   "AddCommGroup.mk",
   "NormedRing.toNonUnitalNormedRing.proof_5",
   "NormedRing.toNonUnitalNormedRing.proof_1",
   "NormedRing.toNonUnitalNormedRing.proof_9",
   "NormedRing.norm_mul",
   "AddGroup.mk",
   "NormedRing.toMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "NormedRing",
   "Ring.zsmul",
   "NormedRing.toNonUnitalNormedRing.proof_4",
   "NormedRing.toNonUnitalNormedRing.proof_8",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNormedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.toNonUnitalNormedRing",
  "constType": "{α : Type u_1} → [β : NormedRing α] → NonUnitalNormedRing α",
  "constCategory": "Definition"},
 {"references": ["Semifield", "Inv"],
  "name": "Semifield.toInv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "OrderedAddCommGroup",
   "NormedLatticeAddCommGroup.toLattice",
   "NormedLatticeAddCommGroup",
   "NormedLatticeAddCommGroup.add_le_add_left",
   "Lattice.toSemilatticeSup",
   "NormedLatticeAddCommGroup.toNormedAddCommGroup",
   "OrderedAddCommGroup.mk",
   "SemilatticeSup.toPartialOrder"],
  "name": "NormedLatticeAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{α : Type u_1} → [h : NormedLatticeAddCommGroup α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "WellFounded",
   "EuclideanDomain",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "EuclideanDomain.mk",
  "constType":
  "{R : Type u} →\n  [toCommRing : CommRing R] →\n    [toNontrivial : Nontrivial R] →\n      (quotient : R → R → R) →\n        (∀ (a : R), quotient a 0 = 0) →\n          (remainder : R → R → R) →\n            (∀ (a b : R), b * quotient a b + remainder a b = a) →\n              (r : R → R → Prop) →\n                WellFounded r →\n                  (∀ (a : R) {b : R}, b ≠ 0 → r (remainder a b) b) →\n                    (∀ (a : R) {b : R}, b ≠ 0 → ¬r (a * b) a) → EuclideanDomain R",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq.le_total",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "IsTotal",
   "Rat.instNegRat",
   "congr",
   "IsTotal.mk",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.instIsTotalRealLeInstLEReal",
  "constType": "IsTotal ℝ fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Set",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
   "Prop.partialOrder",
   "LT.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "MeasurableSpace.instLEMeasurableSpace",
   "And",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "MeasurableSet",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
   "Not",
   "MeasurableSpace"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace",
  "constType": "{α : Type u_1} → PartialOrder (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "Ring.toNonAssocRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_5",
   "CanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_2",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_11",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_6",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_13",
   "Semiring.toNatCast",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_1",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_9",
   "Semiring.npow",
   "WithTop",
   "CommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_4",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.mk",
   "WithTop.commSemiring",
   "WithTop.canonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mk",
   "CanonicallyOrderedAddCommMonoid.toOrderBot",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_15",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_12",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "DecidableEq",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_14",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_10",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_3",
   "CanonicallyOrderedAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_7"],
  "name": "WithTop.instCanonicallyOrderedCommSemiringWithTop",
  "constType":
  "{α : Type u_1} →\n  [inst : DecidableEq α] →\n    [inst : CanonicallyOrderedCommSemiring α] → [inst : Nontrivial α] → CanonicallyOrderedCommSemiring (WithTop α)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedCancelAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.decidableLE",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{α : Type u_1} → Union (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "And",
   "sup_lt_iff",
   "PartialOrder.toPreorder",
   "Iff",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "instDistribLattice",
   "LT.lt",
   "LinearOrder.toMax",
   "Max.max",
   "SemilatticeInf.toPartialOrder"],
  "name": "max_lt_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, max a b < c ↔ a < c ∧ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.Tendsto.mono_left",
   "Set.instHasSubsetSet",
   "nhds",
   "Set",
   "nhdsWithin_mono",
   "HasSubset.Subset",
   "TopologicalSpace",
   "nhdsWithin",
   "ContinuousOn",
   "Set.instMembershipSet"],
  "name": "ContinuousOn.mono",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s t : Set α},\n  ContinuousOn f s → t ⊆ s → ContinuousOn f t",
  "constCategory": "Theorem"},
 {"references":
  ["MetricSpace",
   "Exists",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "TopologicalSpace",
   "TopologicalSpace.MetrizableSpace",
   "UniformSpace.toTopologicalSpace",
   "Eq"],
  "name": "TopologicalSpace.MetrizableSpace.mk",
  "constType":
  "∀ {X : Type u_5} [t : TopologicalSpace X],\n  (∃ m, UniformSpace.toTopologicalSpace = t) → TopologicalSpace.MetrizableSpace X",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPreorder",
   "PartialOrder.toPreorder",
   "Filter.giGenerate.proof_1",
   "Filter.giGenerate.proof_3",
   "Set",
   "Filter.generate",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter.mkOfClosure",
   "Filter.le_generate_iff",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "GaloisInsertion.mk",
   "Filter",
   "Filter.giGenerate.proof_2",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "Filter.giGenerate",
  "constType": "(α : Type u_2) → GaloisInsertion Filter.generate Filter.sets",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "Ring"],
  "name": "SeminormedRing.toRing",
  "constType": "{α : Type u_5} → [self : SeminormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "WithTop",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "inferInstanceAs",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop",
   "NNReal"],
  "name": "ENNReal.instCompleteLinearOrderENNReal",
  "constType": "CompleteLinearOrder ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.npow",
   "One.toOfNat1",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (x : α), CanonicallyOrderedCommSemiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toRing",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : FunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "MetricSpace"],
  "name": "NormedRing.toMetricSpace",
  "constType": "{α : Type u_5} → [self : NormedRing α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references": ["MulHomClass", "outParam", "FunLike", "Mul"],
  "name": "MulHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Mul M] → [inst_1 : Mul N] → [self : MulHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["Inner"],
  "name": "Inner.mk",
  "constType": "{𝕜 : Type u_4} → {E : Type u_5} → (E → E → 𝕜) → Inner 𝕜 E",
  "constCategory": "Other"},
 {"references": ["InvolutiveNeg", "InvolutiveNeg.toNeg", "Neg.neg", "Eq"],
  "name": "InvolutiveNeg.neg_neg",
  "constType": "∀ {A : Type u_2} [self : InvolutiveNeg A] (x : A), - -x = x",
  "constCategory": "Definition"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "Module"],
  "name": "NormedSpace.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    [inst : NormedField α] →\n      [inst_1 : SeminormedAddCommGroup β] →\n        [toModule : Module α β] → (∀ (a : α) (b : β), ‖a • b‖ ≤ ‖a‖ * ‖b‖) → NormedSpace α β",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedRing.toNorm",
   "NonUnitalSeminormedRing.norm_mul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le"],
  "name": "norm_mul_le",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalSeminormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedCommRing α] → LinearOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "TopologicalSpace",
   "And.intro",
   "And.casesOn",
   "IsOpen",
   "Set.instMembershipSet"],
  "name": "Continuous.tendsto.match_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace β] {f : α → β} (x : α) (t : Set β)\n  (motive : f x ∈ t ∧ IsOpen t → Prop) (x_1 : f x ∈ t ∧ IsOpen t),\n  (∀ (hxt : f x ∈ t) (ht : IsOpen t), motive (_ : f x ∈ t ∧ IsOpen t)) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toZero",
   "ZeroHom.mk",
   "AddMonoidHom.id.proof_2",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.id.proof_1"],
  "name": "AddMonoidHom.id",
  "constType": "(M : Type u_9) → [inst : AddZeroClass M] → M →+ M",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5109",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["SMul"],
  "name": "SMul.smul",
  "constType": "{M : Type u} → {α : Type v} → [self : SMul M α] → M → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "SeminormedAddCommGroup.toPseudoMetricSpace",
   "NormedField",
   "Semiring.toMonoidWithZero",
   "NormedSpace.norm_smul_le",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "SeminormedRing.toPseudoMetricSpace",
   "Field.toSemifield",
   "BoundedSMul.of_norm_smul_le",
   "Semifield.toCommGroupWithZero",
   "Module.toMulActionWithZero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SMulZeroClass.toSMul",
   "NormedField.toField",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "MulActionWithZero.toSMulWithZero",
   "SMulWithZero.toSMulZeroClass",
   "SeminormedAddCommGroup.toAddCommGroup",
   "SeminormedCommRing.toSeminormedRing",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "BoundedSMul"],
  "name": "NormedSpace.boundedSMul",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : NormedField α] [inst_1 : SeminormedAddCommGroup β] [inst_2 : NormedSpace α β],\n  BoundedSMul α β",
  "constCategory": "Definition"},
 {"references":
  ["LinearMap.semilinearMapClass",
   "SemilinearMapClass.toAddHomClass",
   "AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Function.Injective",
   "AddHomClass.toFunLike",
   "Semiring",
   "FunLike.coe",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearMap",
   "FunLike.coe_injective'",
   "AddCommMonoid"],
  "name": "LinearMap.instFunLike.proof_1",
  "constType":
  "∀ {R : Type u_4} {S : Type u_3} {M : Type u_2} {M₃ : Type u_1} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S},\n  Function.Injective FunLike.coe",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{α : Type u_4} → (elems : Finset α) → (∀ (x : α), x ∈ elems) → Fintype α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Acc",
  "constType": "{α : Sort u} → (α → α → Prop) → α → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "DivisionSemiring",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing.mul_inv_cancel",
   "DivisionRing",
   "DivisionRing.div_eq_mul_inv",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "DivisionSemiring",
   "DivisionRing.zpow_zero'",
   "DivisionSemiring.mk",
   "DivisionRing.inv_zero",
   "Ring.toSemiring",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toDiv",
   "DivisionRing.toInv"],
  "name": "DivisionRing.toDivisionSemiring",
  "constType": "{α : Type u_1} → [inst : DivisionRing α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.decidableLT",
   "Ord.compare",
   "Ordering",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "of_eq_true",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom.id",
   "AddMonoidHom",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_8",
  "constType": "∀ (z : ℝ), (AddMonoidHom.id ℝ) z = (AddMonoidHom.id ℝ) z",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "DenselyOrdered",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "zero_lt_two",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "div_lt_div_of_lt",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "NeZero.one",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "add_lt_add_right",
   "DenselyOrdered.mk",
   "Semiring.toNatCast",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "IsCancelAdd.toIsLeftCancelAdd",
   "LinearOrderedSemifield",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "add_self_div_two",
   "add_lt_add_left",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instTransEq_1",
   "And",
   "LinearOrderedSemifield.toDiv",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "instTransEq",
   "And.intro"],
  "name": "LinearOrderedSemiField.toDenselyOrdered",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α], DenselyOrdered α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ext",
   "EmptyCollection.emptyCollection",
   "Union.union",
   "Set",
   "Set.instEmptyCollectionSet",
   "or_false_iff",
   "Set.instUnionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.union_empty",
  "constType": "∀ {α : Type u} (a : Set α), a ∪ ∅ = a",
  "constCategory": "Theorem"},
 {"references": ["iInf", "Set", "Set.instInfSetSet"],
  "name": "Set.iInter",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.OuterMeasure", "MeasurableSpace"],
  "name": "MeasureTheory.Measure.toOuterMeasure",
  "constType":
  "{α : Type u_6} → [inst : MeasurableSpace α] → MeasureTheory.Measure α → MeasureTheory.OuterMeasure α",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} → [self : RelHomClass F r s] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_5",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "LinearOrderedCancelAddCommMonoid",
   "Preorder.toLE",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3051",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "compareOfLessAndEq",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "OrderedAddCommMonoid.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedCancelAddCommMonoid : OrderedCancelAddCommMonoid α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace.isBasis_countableBasis",
   "Membership.mem",
   "TopologicalSpace.SeparableSpace.mk",
   "Classical.choose_spec",
   "TopologicalSpace.nonempty_of_mem_countableBasis",
   "Classical.choose",
   "Subtype.val",
   "TopologicalSpace.IsTopologicalBasis.dense_iff",
   "Set",
   "Set.Nonempty",
   "TopologicalSpace.encodableCountableBasis",
   "Inter.inter",
   "Exists.intro",
   "Dense",
   "TopologicalSpace.countableBasis",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Subtype.property",
   "Set.Countable",
   "Set.range",
   "And",
   "SecondCountableTopology",
   "Set.Elem",
   "Encodable.countable",
   "TopologicalSpace.SeparableSpace",
   "TopologicalSpace",
   "Set.countable_range",
   "And.intro",
   "Set.mem_range_self",
   "Subtype",
   "Subtype.mk",
   "Set.instInterSet"],
  "name": "TopologicalSpace.SecondCountableTopology.to_separableSpace",
  "constType":
  "∀ {α : Type u} [t : TopologicalSpace α] [inst : SecondCountableTopology α], TopologicalSpace.SeparableSpace α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["UniformSpace", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toUniformSpace",
  "constType": "{α : Type u} → [self : PseudoMetricSpace α] → UniformSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLattice.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice.mk",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left"],
  "name": "instDistribLattice",
  "constType": "{α : Type u} → [inst : LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Not.elim",
   "Exists",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Filter.empty_mem_iff_bot",
   "Set",
   "Set.instEmptyCollectionSet",
   "CompleteLattice.toBot",
   "Filter.NeBot",
   "LE.le",
   "ClusterPt",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Filter.principal",
   "Iff.mp",
   "Filter.le_principal_iff",
   "Filter.instPartialOrderFilter",
   "TopologicalSpace",
   "Filter",
   "IsCompact",
   "Filter.NeBot.ne",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter"],
  "name": "isCompact_empty",
  "constType": "∀ {X : Type u} [inst : TopologicalSpace X], IsCompact ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "DistribMulAction.toMulAction",
   "OfNat.ofNat",
   "Module.toDistribMulAction",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "Semiring",
   "AddMonoid.toZero",
   "Semiring.toMonoidWithZero",
   "HSMul.hSMul",
   "AddCommMonoid.toAddMonoid",
   "MonoidWithZero.toZero",
   "Module",
   "Eq",
   "AddCommMonoid"],
  "name": "Module.zero_smul",
  "constType":
  "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 • x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MonoidHom",
   "OneHom",
   "Eq"],
  "name": "MonoidHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : MulOneClass M] →\n      [inst_1 : MulOneClass N] →\n        (toOneHom : OneHom M N) →\n          (∀ (x y : M), OneHom.toFun toOneHom (x * y) = OneHom.toFun toOneHom x * OneHom.toFun toOneHom y) → M →* N",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.one_smul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "One.toOfNat1",
   "MulAction",
   "Eq"],
  "name": "one_smul",
  "constType":
  "∀ (M : Type u_1) {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α] (b : α), 1 • b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHDiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedField.toDiv",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["IsROrC", "semiOutParam"],
  "name": "IsROrC.I",
  "constType": "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K",
  "constCategory": "Definition"},
 {"references": ["Real", "Dist"],
  "name": "Dist.dist",
  "constType": "{α : Type u_3} → [self : Dist α] → α → α → ℝ",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Real",
   "Lattice",
   "Real.instDistribLatticeReal"],
  "name": "Real.lattice",
  "constType": "Lattice ℝ",
  "constCategory": "Definition"},
 {"references": ["NontriviallyNormedField", "NormedField"],
  "name": "NontriviallyNormedField.toNormedField",
  "constType":
  "{α : Type u_5} → [self : NontriviallyNormedField α] → NormedField α",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "instHAdd",
   "PseudoMetricSpace.dist_triangle",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "dist_triangle",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] (x y z : α), dist x z ≤ dist x y + dist y z",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Filter.HasBasis.tendsto_right_iff",
   "Filter.Eventually",
   "implies_congr",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Filter.HasBasis.eventually_iff",
   "Filter.HasBasis",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "propext",
   "Filter",
   "Filter.Tendsto",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Filter.HasBasis.tendsto_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {ι' : Sort u_5} {la : Filter α} {pa : ι → Prop} {sa : ι → Set α}\n  {lb : Filter β} {pb : ι' → Prop} {sb : ι' → Set β} {f : α → β},\n  Filter.HasBasis la pa sa →\n    Filter.HasBasis lb pb sb → (Filter.Tendsto f la lb ↔ ∀ (ib : ι'), pb ib → ∃ ia, pa ia ∧ ∀ x ∈ sa ia, f x ∈ sb ib)",
  "constCategory": "Theorem"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Monoid.toSemigroup",
   "mul_assoc",
   "Monoid",
   "HMul.hMul",
   "Eq"],
  "name": "Monoid.toMulAction.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : Monoid M] (a b c : M), a * b * c = a * (b * c)",
  "constCategory": "Theorem"}]