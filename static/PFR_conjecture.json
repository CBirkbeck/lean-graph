[{"references":
  ["Membership.mem",
   "Inf.inf",
   "AddSubgroup.instInfAddSubgroup",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubgroup.toAddGroup",
   "SetLike.instMembership",
   "Eq",
   "AddSubgroup.map",
   "Subtype.image_preimage_coe",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "SetLike.ext'",
   "AddSubgroup.addSubgroupOf",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.subtype",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.addSubgroupOf_map_subtype",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H K : AddSubgroup G),\n  AddSubgroup.map (AddSubgroup.subtype K) (AddSubgroup.addSubgroupOf H K) = H ⊓ K",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.neg.proof_1",
   "Subtype.val",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toNeg",
   "Neg",
   "Neg.mk",
   "Subtype",
   "Subtype.mk",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.coe"],
  "name": "AddSubgroup.neg",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Neg ↥H",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Complex",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "NonAssocRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "One",
   "Nat.cast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instAddNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Neg.neg",
   "One.toOfNat1",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "instNatCastInt",
   "Int.negSucc",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "NonAssocRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                [toIntCast : IntCast α] →\n                  autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝² →\n                    autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝³ → NonAssocRing α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mk",
  "constType":
  "{α : Type u} → [toLinearOrderedRing : LinearOrderedRing α] → (∀ (a b : α), a * b = b * a) → LinearOrderedCommRing α",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "Nontrivial"],
  "name": "StrictOrderedSemiring.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["AddSubgroup.instCompleteLatticeAddSubgroup.proof_7",
   "Inf.inf",
   "AddSubgroup.mem_top",
   "CompleteLattice.mk",
   "Lattice.mk",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_2",
   "SetLike.instMembership",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_5",
   "AddSubgroup.instTopAddSubgroup",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instBotAddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_3",
   "Membership.mem",
   "Bot.bot",
   "Top.top",
   "AddSubgroup.instInfAddSubgroup",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_4",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_8",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_9",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "SetLike.instPartialOrder",
   "CompleteLattice",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_6",
   "CompleteLattice.toInfSet",
   "Bot.mk",
   "Top.mk"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → CompleteLattice (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemigroup"],
  "name": "Real.instCommSemigroupReal",
  "constType": "CommSemigroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "Nonempty.intro", "OfNat.ofNat", "Nonempty"],
  "name": "Zero.nonempty",
  "constType": "∀ {α : Type u_2} [inst : Zero α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "Nat.cast_le",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "PFR.Main._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Ring.zsmul",
  "constType": "{R : Type u} → [self : Ring R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.le_total",
  "constType": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "FunLike",
   "EquivLike.toEmbeddingLike",
   "Equiv.instEquivLikeEquiv"],
  "name": "Equiv.instFunLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α fun x => β",
  "constCategory": "Definition"},
 {"references": ["Complex.ofReal'", "Real", "Complex.exp", "Complex.re"],
  "name": "Real.exp",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "heq_of_eq",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Subsingleton.elim",
   "outParam",
   "Invertible.subsingleton",
   "Nat.cast",
   "One",
   "MonoidWithZero.toMonoid",
   "Eq.rec",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Mul",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "HEq.refl",
   "Int.cast",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isRat_eq_true.match_1",
   "Int",
   "HMul"],
  "name": "Mathlib.Meta.NormNum.isRat_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a b : α} {n : ℤ} {d : ℕ},\n  Mathlib.Meta.NormNum.IsRat a n d → Mathlib.Meta.NormNum.IsRat b n d → a = b",
  "constCategory": "Theorem"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [inst : Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["AddSubgroup.instInfAddSubgroup.proof_2",
   "Inf.mk",
   "AddGroup",
   "Inf",
   "AddSubmonoid.toAddSubsemigroup",
   "Inf.inf",
   "AddSubgroup.instInfAddSubgroup.proof_1",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddSubgroup.toAddSubmonoid",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.instInfAddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid"],
  "name": "AddSubgroup.instInfAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Inf (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "Nat",
   "ElementaryAddCommGroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "addOrderOf"],
  "name": "ElementaryAddCommGroup.orderOf_of_ne",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {p : outParam ℕ} [self : ElementaryAddCommGroup G p] {x : G},\n  x ≠ 0 → addOrderOf x = p",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Set", "Not", "Set.Finite"],
  "name": "Set.Infinite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.inv_zero",
  "constType": "∀ {K : Type u} [self : DivisionRing K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "AddSubgroup.instBotAddSubgroup.proof_2",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "AddGroup",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "Bot.mk",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddSubgroup.instBotAddSubgroup.proof_1"],
  "name": "AddSubgroup.instBotAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Bot (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "exists_nat_pow_near",
   "HAdd.hAdd",
   "OmegaCompletePartialOrder.toPartialOrder",
   "IsPGroup",
   "Exists.intro",
   "Exists.casesOn",
   "instLTNat",
   "Iff.mpr",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Sylow.exists_subgroup_le_card_pow_prime_of_le_card",
   "Nat.Prime",
   "instLENat",
   "instHPow",
   "Nat.one_le_iff_ne_zero",
   "Nat.monoid",
   "Subgroup",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Group",
   "instArchimedeanNatToOrderedAddCommMonoidOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Nat",
   "And.casesOn",
   "Nat.linearOrderedSemiring",
   "Subtype",
   "id",
   "Nat.strictOrderedSemiring",
   "Nat.Prime.one_lt",
   "Membership.mem",
   "HPow.hPow",
   "Subgroup.instCompleteLatticeSubgroup",
   "Ne",
   "instAddNat",
   "instHAdd",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LE.le.trans",
   "Nat.canonicallyOrderedCommSemiring",
   "Monoid.toMulOneClass",
   "LE.le",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "And",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "Eq.mp",
   "congr",
   "HMul.hMul",
   "pow_succ",
   "And.intro",
   "instMulNat",
   "congrArg",
   "Nat.card",
   "congrFun",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Sylow.exists_subgroup_le_card_le",
  "constType":
  "∀ {G : Type u} [inst : Group G] {k p : ℕ},\n  Nat.Prime p →\n    IsPGroup p G → ∀ {H : Subgroup G}, k ≤ Nat.card ↥H → k ≠ 0 → ∃ H' ≤ H, Nat.card ↥H' ≤ k ∧ k < p * Nat.card ↥H'",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Nat"],
  "name": "Nat.monoid",
  "constType": "Monoid ℕ",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass",
   "Neg",
   "Eq"],
  "name": "NegZeroClass.mk",
  "constType":
  "{G : Type u_2} → [toZero : Zero G] → [toNeg : Neg G] → -0 = 0 → NegZeroClass G",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.SetTheory.Cardinal.Finite._auxLemma.2",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "ZeroHom.zeroHomClass",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.68",
   "Cardinal.partialOrder",
   "instLTNat",
   "Nonempty",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "Cardinal.toNat",
   "Iff",
   "Cardinal.aleph0",
   "ZeroHomClass.toFunLike",
   "Preorder.toLT",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Cardinal.mk",
   "Nat",
   "Eq.trans",
   "Ne",
   "Nat.linearOrderedCommMonoidWithZero",
   "Mathlib.Logic.IsEmpty._auxLemma.4",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.6",
   "Finite",
   "ZeroHom",
   "FunLike.coe",
   "IsEmpty",
   "Cardinal.instZeroCardinal",
   "And",
   "of_eq_true",
   "LT.lt",
   "Cardinal",
   "congr",
   "Not",
   "Nat.card",
   "congrArg",
   "congrFun"],
  "name": "Nat.card_pos_iff",
  "constType": "∀ {α : Type u_1}, 0 < Nat.card α ↔ Nonempty α ∧ Finite α",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "Semiring",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
   "StrictOrderedRing.toNontrivial",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
   "StrictOrderedRing.zero_le_one",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_1"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedRing α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Eq"],
  "name": "CommMonoid.mul_comm",
  "constType": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["add_assoc",
   "Set.image2",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.image2_assoc",
   "AddSemigroup",
   "Eq"],
  "name": "Set.addSemigroup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddSemigroup α] (x x_1 x_2 : Set α),\n  Set.image2 (fun x x_3 => x + x_3) (Set.image2 (fun x x_3 => x + x_3) x x_1) x_2 =\n    Set.image2 (fun x x_3 => x + x_3) x (Set.image2 (fun x x_3 => x + x_3) x_1 x_2)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.prf",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {coe : outParam (β → α)} {cond : outParam (α → Prop)} [self : CanLift α β coe cond]\n  (x : α), cond x → ∃ y, coe y = x",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real.instLTReal",
   "Real.instMulReal",
   "Real",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.normedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Real.rpow_pos_of_pos",
   "NormedCommRing.toSeminormedCommRing",
   "instHPow",
   "Real.strictOrderedSemiring",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "mul_pos",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Mathlib.Tactic.RPowRing.pow_pos",
  "constType": "∀ {a b e : ℝ}, 0 < a → 0 < b → 0 < a ^ e * b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{K : Type u} → [self : DivisionRing K] → Ring K",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1334", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Exists", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.Nonempty",
  "constType": "{α : Type u_1} → Finset α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemiring", "Max"],
  "name": "LinearOrderedSemiring.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Function.minimalPeriod",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Nat",
   "AddMonoid.toAddZeroClass",
   "AddMonoid"],
  "name": "addOrderOf",
  "constType": "{G : Type u_1} → [inst : AddMonoid G] → G → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.subtype.proof_2",
   "AddSubgroup.subtype.proof_1",
   "ZeroHom.mk",
   "Subtype.val",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddZeroClass.toZero",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.subtype",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → ↥H →+ G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Ring.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Semiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mk",
  "constType":
  "{α : Type u_4} →\n  [toSemiring : Semiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → DivisionSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "Subtype.val",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Subtype.mk",
   "Subtype",
   "Preorder.toLE",
   "CovariantClass.elim"],
  "name": "mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  b ≤ c → 0 ≤ a → a * b ≤ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["HAdd.hAdd",
   "Set.Nonempty",
   "Finset.coe_sub",
   "Exists.casesOn",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "Set.Elem",
   "Finset.toSet",
   "Fintype.card_coe",
   "Nat",
   "And.casesOn",
   "Finset.sub",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Subtype",
   "instHSub",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Set.add",
   "Classical.propDecidable",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "And",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "congr",
   "AddCommGroup",
   "Finset.instHasSubsetFinset",
   "congrArg",
   "Finset.add",
   "congrFun",
   "AddZeroClass.toAdd",
   "Finset.card",
   "Exists",
   "Set",
   "CanLift.prf",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "instLENat",
   "Finset",
   "Set.sub",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "id",
   "Finset.coe_add",
   "Membership.mem",
   "instHAdd",
   "HSub.hSub",
   "Fintype.card",
   "Finset.exists_subset_add_sub",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Set.Finite",
   "Mathlib.Data.Set.Finite._auxLemma.22",
   "Mathlib.Data.Finset.Basic._auxLemma.10",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "instMulNat",
   "Nat.card",
   "and_self"],
  "name": "Set.exists_subset_add_sub",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] {s t : Set α},\n  Set.Finite s →\n    Set.Finite t → Set.Nonempty t → ∃ u, Nat.card ↑u * Nat.card ↑t ≤ Nat.card ↑(s + t) ∧ s ⊆ u + t - t ∧ Set.Finite u",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (r : α → β → Sort u) → Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "AddMonoidHom.id",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_4",
  "constType":
  "∀ (f : ℝ), (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f) = (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.toDiv",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Real.instLinearOrderedFieldReal.proof_7",
  "constType": "∀ (a : ℝ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.inv_zero",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "SeminormedCommRing.toSeminormedRing",
   "Nat.cast",
   "Ring.toNeg",
   "SeminormedRing.toRing",
   "instNatCastInt",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "SeminormedCommRing",
   "Nat.succ",
   "Int",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "LinearOrderedSemiring.toMax",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "OrderedAddCommMonoid.mk",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} → [self : Ring R] → Neg R",
  "constCategory": "Definition"},
 {"references": ["SeminormedRing", "SeminormedCommRing"],
  "name": "SeminormedCommRing.toSeminormedRing",
  "constType":
  "{α : Type u_5} → [self : SeminormedCommRing α] → SeminormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toSeminormedRing : SeminormedRing α] → (∀ (x y : α), x * y = y * x) → SeminormedCommRing α",
  "constCategory": "Other"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.3933"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.lt",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.image2",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "And.intro",
   "And.casesOn",
   "id"],
  "name": "Set.image2_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f f' : α → β → γ} {s : Set α} {t : Set β},\n  (∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) → Set.image2 f s t = Set.image2 f' s t",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.decidableLT",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OfNat.ofNat",
   "instHSMul",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "Multiplicative.toAdd",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "pow_one",
   "Eq",
   "Eq.mpr",
   "Nat.Prime",
   "RelIso",
   "HSMul.hSMul",
   "Subgroup",
   "Nat",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.trans",
   "Subtype",
   "HPow.hPow",
   "Ne",
   "Or",
   "eq_or_ne",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.casesOn",
   "pow_zero",
   "RelHomClass.toFunLike",
   "instHMul",
   "And",
   "addOrderOf_nsmul_eq_zero",
   "Multiplicative",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "LT.lt",
   "Eq.mp",
   "And.intro",
   "AddCommGroup",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "OrderIso.symm",
   "addOrderOf",
   "congrFun",
   "Group.toDivisionMonoid",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OmegaCompletePartialOrder.toPartialOrder",
   "IsPGroup",
   "Exists.intro",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Zero.toOfNat0",
   "RelIso.instRelHomClassRelIso",
   "instLENat",
   "instHPow",
   "AddMonoid.toZero",
   "AddSubgroup",
   "Nat.monoid",
   "Sylow.exists_subgroup_le_card_le",
   "Monoid.toNatPow",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "AddSubgroup.toSubgroup",
   "ElementaryAddCommGroup.orderOf_of_ne",
   "id",
   "Subgroup.instCompleteLatticeSubgroup",
   "Membership.mem",
   "eq_self",
   "One.toOfNat1",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "instOneMultiplicative",
   "AddMonoid.toNatSMul",
   "Equiv.instFunLikeEquiv",
   "SetLike.instPartialOrder",
   "InvOneClass.toOne",
   "Eq.ndrec",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "Group.toDivInvMonoid",
   "instMulNat",
   "ElementaryAddCommGroup",
   "Nat.card",
   "NegZeroClass.toZero",
   "Subgroup.instSetLikeSubgroup"],
  "name": "ElementaryAddCommGroup.exists_subgroup_subset_card_le",
  "constType":
  "∀ {G : Type u_1} {p : ℕ},\n  Nat.Prime p →\n    ∀ [inst : AddCommGroup G] [h : ElementaryAddCommGroup G p] {k : ℕ} (H : AddSubgroup G),\n      k ≤ Nat.card ↥H → k ≠ 0 → ∃ H', Nat.card ↥H' ≤ k ∧ k < p * Nat.card ↥H' ∧ H' ≤ H",
  "constCategory": "Theorem"},
 {"references":
  ["Real.commRing.proof_25",
   "Semiring.mk",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "nsmulRec",
   "npowRec",
   "CommRing.mk",
   "Real.instOneReal",
   "Real.commRing.proof_24",
   "zsmulRec",
   "Real.commRing.proof_3",
   "Real.commRing.proof_1",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Real.commRing.proof_20",
   "Rat.instNegRat",
   "Sub.sub",
   "Real.commRing.proof_10",
   "Nat",
   "Real.commRing.proof_11",
   "Add.mk",
   "Real.commRing.proof_6",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.commRing.proof_4",
   "AddMonoid.mk",
   "instHMul",
   "IntCast.mk",
   "Real.commRing.proof_21",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Zero.mk",
   "Real.commRing.proof_13",
   "CauSeq.Completion.Cauchy",
   "Ring.mk",
   "Real.commRing.proof_8",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Neg.mk",
   "Mul.mk",
   "CauSeq.Completion.instIntCastCauchy",
   "Real.commRing.proof_15",
   "Real.commRing.proof_5",
   "DivisionRing.toRing",
   "Real",
   "CauSeq.Completion.instNatCastCauchy",
   "Real.commRing.proof_23",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Abs.abs",
   "Real.commRing.proof_17",
   "Rat.instSupRat",
   "Real.instNegReal",
   "Sub.mk",
   "Zero.toOfNat0",
   "Real.commRing.proof_9",
   "Real.commRing.proof_18",
   "Real.commRing.proof_7",
   "Real.commRing.proof_22",
   "Real.commRing.proof_12",
   "Real.commRing.proof_14",
   "Real.commRing.proof_2",
   "Real.commRing.proof_16",
   "Real.commRing.proof_19",
   "Neg.toHasAbs",
   "AddSemigroup.mk",
   "instHAdd",
   "One.mk",
   "Rat",
   "One.toOfNat1",
   "Neg.neg",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "HMul.hMul"],
  "name": "Real.commRing",
  "constType": "CommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Real.field",
   "NormedAddCommGroup",
   "Field.zpow_zero'",
   "Real.instLinearOrderedRingReal",
   "NormedField",
   "Real",
   "Field.mk",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "NormedAddCommGroup.toMetricSpace",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "abs_mul",
   "Field",
   "NormedField.mk",
   "Field.inv_zero",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Real.normedAddCommGroup",
   "Field.div_eq_mul_inv"],
  "name": "Real.normedField",
  "constType": "NormedField ℝ",
  "constCategory": "Definition"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "mul_neg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "InvolutiveNeg.toNeg",
   "Ring.toSub",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "Eq.trans",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "congr",
   "congrArg",
   "left_distrib"],
  "name": "CancelDenoms.sub_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e1 e2 t1 t2 : α}, n * e1 = t1 → n * e2 = t2 → n * (e1 - e2) = t1 - t2",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "Mathlib.Meta.NormNum.IsRat",
   "HMul.hMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Nat",
   "Int",
   "DivisionRing.toInv",
   "Ring.toNonAssocRing",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.isRat_div.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α]\n  (motive : (x x_1 : α) → (x_2 : ℤ) → (x_3 : ℕ) → Mathlib.Meta.NormNum.IsRat (x * x_1⁻¹) x_2 x_3 → Prop) (x x_1 : α)\n  (x_2 : ℤ) (x_3 : ℕ) (x_4 : Mathlib.Meta.NormNum.IsRat (x * x_1⁻¹) x_2 x_3),\n  (∀ (x x_5 : α) (x_6 : ℤ) (x_7 : ℕ) (h : Mathlib.Meta.NormNum.IsRat (x * x_5⁻¹) x_6 x_7), motive x x_5 x_6 x_7 h) →\n    motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "PseudoMetricSpace.toDist",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "SeminormedRing.toPseudoMetricSpace",
   "Norm.norm",
   "SeminormedCommRing",
   "SeminormedRing.dist_eq",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_12",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "NeZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NeZero.mk",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "one_ne_zero",
   "One.toOfNat1",
   "Real.instRingReal",
   "NeZero.charZero_one",
   "Real.instOneReal"],
  "name": "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
  "constType": "NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd", "instHAdd", "HAdd.hAdd", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.add_assoc",
  "constType":
  "∀ {G : Type u} [self : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHMul",
   "Int.negOfNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.add.match_1"],
  "name": "Int.mul",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Countable",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "DivisionRing",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionRing.mul_inv_cancel",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Mathlib.Meta.NormNum.isNat_eq_true.match_1",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a b : α} {c : ℕ},\n  Mathlib.Meta.NormNum.IsNat a c → Mathlib.Meta.NormNum.IsNat b c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["nonzero_of_invertible",
   "MonoidWithZero.toMulZeroOneClass",
   "Invertible.invOf",
   "Monoid.toOne",
   "GroupWithZero.toNontrivial",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "invOf_eq_right_inv",
   "mul_inv_cancel",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "Invertible",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toInv",
   "Inv.inv"],
  "name": "invOf_eq_inv",
  "constType":
  "∀ {α : Type u} [inst : GroupWithZero α] (a : α) [inst_1 : Invertible a], ⅟a = a⁻¹",
  "constCategory": "Theorem"},
 {"references": ["maxOfLe", "instLENat", "Max", "Nat", "Nat.decLe"],
  "name": "Nat.instMaxNat",
  "constType": "Max ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "add_comm",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMagma.toAdd",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "AddSubgroup",
   "Neg.neg",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.neg",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H), ↑(-x) = ↑(-x)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "lt_of_lt_of_le.match_2",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "instNontrivial",
   "Real.instRingReal",
   "Nontrivial"],
  "name": "Real.nontrivial",
  "constType": "Nontrivial ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "Int.negSucc",
   "Unit",
   "Int.negOfNat.match_1",
   "Nat",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Complex.mk",
   "Real",
   "Complex"],
  "name": "Complex.ofReal'",
  "constType": "ℝ → ℂ",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["DivisionCommMonoid.mk",
   "DivisionMonoid",
   "DivisionMonoid.mul_inv_rev",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.inv_inv",
   "CommGroupWithZero",
   "GroupWithZero.toDivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "CommGroupWithZero.toDivisionCommMonoid.proof_1"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "instHMul",
   "instLENat",
   "Finset.card_image₂_le",
   "DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Add",
   "LE.le",
   "Finset.add"],
  "name": "Finset.card_add_le",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] {s t : Finset α},\n  Finset.card (s + t) ≤ Finset.card s * Finset.card t",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial", "Semifield"],
  "name": "Semifield.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : Semifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real",
   "Real.instMulReal",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "Real.instOneReal",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "instHPow",
   "Real.semiring",
   "Real.instPowReal",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Real.rpow_one",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.RPowRing.atom_pow_pf",
  "constType": "∀ (a : ℝ), a = a ^ 1 * 1",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["RelIso.instRelHomClassRelIso.proof_2",
   "RelEmbedding",
   "RelIso.toRelEmbedding",
   "RelHomClass",
   "FunLike.mk",
   "RelIso",
   "FunLike.coe",
   "RelHomClass.mk",
   "RelIso.instRelHomClassRelIso.proof_1",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "RelHomClass.toFunLike"],
  "name": "RelIso.instRelHomClassRelIso",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → RelHomClass (r ≃r s) r s",
  "constCategory": "Definition"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.Nonempty",
   "Set.Nonempty.image2",
   "Add"],
  "name": "Set.Nonempty.add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α}, Set.Nonempty s → Set.Nonempty t → Set.Nonempty (s + t)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "DivisionRing.toRing",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Iff.mpr",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "RingHomClass.toAddMonoidHomClass",
   "Iff.mp",
   "RingHomClass.toMonoidWithZeroHomClass",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "injective_iff_map_eq_zero",
   "map_eq_zero",
   "DivisionRing",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "MonoidHomClass.toMulHomClass",
   "AddHomClass.toFunLike",
   "Semiring",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "GroupWithZero.toMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "Function.Injective",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "SubNegMonoid.toAddMonoid",
   "Nontrivial",
   "AddMonoidHomClass.toAddHomClass",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero"],
  "name": "RingHom.injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DivisionRing α] [inst_1 : Semiring β] [inst_2 : Nontrivial β] (f : α →+* β),\n  Function.Injective ⇑f",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield",
   "Semifield.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Eq.ndrec",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "lt_of_lt_of_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LT.lt.trans_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "Ring.zsmul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Inv"],
  "name": "LinearOrderedSemifield.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Inv α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
   "Sub",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "AddMonoidWithOne",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddGroupWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toIntCast : IntCast R] →\n    [toAddMonoidWithOne : AddMonoidWithOne R] →\n      [toNeg : Neg R] →\n        [toSub : Sub R] →\n          autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n            (zsmul : ℤ → R → R) →\n              autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                  autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                    (∀ (a : R), -a + a = 0) →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → AddGroupWithOne R",
  "constCategory": "Other"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references": ["Fintype.finite", "Fintype", "Finite"],
  "name": "Finite.of_fintype",
  "constType": "∀ (α : Type u_4) [inst : Fintype α], Finite α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivisionMonoid.toDivInvOneMonoid.proof_1",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.zpow_neg'",
   "DivInvMonoid.zpow",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [inst : DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PosMulMono",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toPosMulMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], PosMulMono α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b : G), a + b = b + a) → AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["Field", "Div"],
  "name": "Field.toDiv",
  "constType": "{K : Type u} → [self : Field K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toNeg",
   "Int.cast_neg",
   "InvolutiveNeg.toNeg",
   "Ring.toIntCast",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "Int.instNegInt",
   "Nat",
   "Eq.symm",
   "neg_mul",
   "Int.neg",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Int.cast",
   "HMul.hMul",
   "Int",
   "Mathlib.Meta.NormNum.isRat_neg.match_1"],
  "name": "Mathlib.Meta.NormNum.isRat_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α} {a : α} {n n' : ℤ} {d : ℕ},\n  f = Neg.neg → Mathlib.Meta.NormNum.IsRat a n d → Int.neg n = n' → Mathlib.Meta.NormNum.IsRat (-a) n' d",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "DivisionRing",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "DivisionRing.toRing",
   "div_eq_mul_inv",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Ring.toNonAssocRing",
   "DivisionRing.toInv",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "Eq.mpr",
   "HMul.hMul",
   "HDiv.hDiv",
   "Nat",
   "congrArg",
   "DivisionRing.toDivInvMonoid",
   "Int",
   "Mathlib.Meta.NormNum.isRat_div.match_1",
   "DivisionRing.toDiv",
   "DivInvMonoid.toDiv",
   "congrFun",
   "id",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.isRat_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {a b : α} {cn : ℤ} {cd : ℕ},\n  Mathlib.Meta.NormNum.IsRat (a * b⁻¹) cn cd → Mathlib.Meta.NormNum.IsRat (a / b) cn cd",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_pos.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ} (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Set",
   "Set.toFinset",
   "Subtype.fintype",
   "Set.decidableSetOf",
   "Set.toFinite",
   "True",
   "Eq",
   "iff_self",
   "DecidablePred",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset.ext",
   "Finset",
   "Finset.filter",
   "Eq.trans",
   "Set.toFinite_toFinset",
   "Membership.mem",
   "setOf",
   "Finset.instMembershipFinset",
   "Set.toFinset_setOf",
   "Set.Finite",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.univ",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Finite.of_fintype",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "Set.Finite.toFinset",
   "congrFun"],
  "name": "Set.Finite.toFinset_setOf",
  "constType":
  "∀ {α : Type u} [inst : Fintype α] (p : α → Prop) [inst_1 : DecidablePred p] (h : Set.Finite {x | p x}),\n  Set.Finite.toFinset h = Finset.filter p Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toSubtractionMonoid : SubtractionMonoid G] → (∀ (a b : G), a + b = b + a) → SubtractionCommMonoid G",
  "constCategory": "Other"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → CommMonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Nat.cast_nonneg",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "OrderedSemiring.toSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "id"],
  "name": "Mathlib.Meta.Positivity.nonneg_of_isNat",
  "constType":
  "∀ {A : Type u_1} {e : A} {n : ℕ} [inst : OrderedSemiring A], Mathlib.Meta.NormNum.IsNat e n → 0 ≤ e",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "HMul.hMul",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalSeminormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalSeminormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "Zero.mk",
   "instZeroAddMonoidHom.proof_1",
   "instZeroAddMonoidHom.proof_2",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom"],
  "name": "instZeroAddMonoidHom",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → Zero (M →+ N)",
  "constCategory": "Definition"},
 {"references": ["Min.min", "Eq.refl", "Nat", "instMinNat", "Eq"],
  "name": "Nat.linearOrder.proof_1",
  "constType": "∀ (a b : ℕ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "SeminormedRing.norm_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_13",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.Basic._auxLemma.1",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * b + a * c = a * (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "Real.instSupReal",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "MulZeroClass.toMul",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "LinearOrderedRing.toLinearOrder",
   "Mathlib.Data.IsROrC.Basic._auxLemma.26",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "sq",
   "instHPow",
   "MulZeroClass.toZero",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Neg.toHasAbs",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Real.instMonoidReal",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "abs_mul_self",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.normedCommRing",
   "Monoid.toMulOneClass",
   "DistribLattice.toLattice",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "add_zero",
   "congrArg"],
  "name": "Real.isROrC.proof_11",
  "constType": "∀ (z : ℝ), |z| ^ 2 = z * z + 0 * 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoid : CommMonoid M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → CommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "Real.strictOrderedCommSemiring",
   "Real",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring"],
  "name": "Real.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderHom",
   "Nat",
   "Preorder",
   "Nat.strictOrderedSemiring"],
  "name": "OmegaCompletePartialOrder.Chain",
  "constType": "(α : Type u) → [inst : Preorder α] → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "LinearOrderedSemiring.toMin",
   "Eq"],
  "name": "LinearOrderedSemiring.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Real.partialOrder",
   "StrictMono.monotone",
   "Real",
   "Real.instPreorderReal",
   "Monotone",
   "Real.exp",
   "Real.exp_strictMono"],
  "name": "Real.exp_monotone",
  "constType": "Monotone Real.exp",
  "constCategory": "Theorem"},
 {"references":
  ["Top.top",
   "DiscreteMeasurableSpace",
   "Set",
   "DiscreteMeasurableSpace.mk",
   "CompleteLattice.toTop",
   "MeasurableSpace.measurableSet_top",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "MeasurableSpace"],
  "name":
  "instDiscreteMeasurableSpaceTopMeasurableSpaceToTopInstCompleteLatticeMeasurableSpace",
  "constType": "∀ {α : Type u_1}, DiscreteMeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.mul_zero",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "DivisionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toDivisionMonoid : DivisionMonoid G] → (∀ (a b : G), a * b = b * a) → DivisionCommMonoid G",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "Set",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform",
  "constType":
  "{Ω : Type uΩ} →\n  {S : Type uS} → [mΩ : MeasurableSpace Ω] → Set S → (Ω → S) → autoParam (MeasureTheory.Measure Ω) _auto✝ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHomClass.toFunLike",
   "ZeroHom.zeroHomClass",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "ZeroHom",
   "FunLike.coe",
   "Cardinal.mk",
   "Nat"],
  "name": "Nat.card",
  "constType": "Type u_3 → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "implies_congr",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_2",
  "constType": "∀ (a b c : ℝ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.le.step",
   "Nat.le",
   "Nat.below",
   "Nat.brecOn",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.le_trans.match_1"],
  "name": "Nat.le_trans",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_1",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_9",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_3",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_5",
   "Ring.toNeg",
   "SeminormedRing.toNorm",
   "NonUnitalSeminormedCommRing.mk",
   "Ring.toSub",
   "NonUnitalSeminormedRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_8",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_6",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_13",
   "AddCommGroup.mk",
   "SeminormedCommRing.mul_comm",
   "NonUnitalSeminormedCommRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_10",
   "AddGroup.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_4",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_7",
   "Ring.zsmul",
   "SeminormedRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_2",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_11",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_12"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing",
  "constType":
  "{α : Type u_1} → [β : SeminormedCommRing α] → NonUnitalSeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Div"],
  "name": "LinearOrderedSemifield.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_2",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "OfNat.ofNat",
   "add_nonpos",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "neg_le_abs_self",
   "Real.instOneReal",
   "Semiring.toNatCast",
   "Linarith.le_of_le_of_eq",
   "inferInstance",
   "measurableSet_discrete",
   "Real.linearOrder",
   "IsROrC.charZero_isROrC",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Finset.toSet",
   "Real.instPowReal",
   "refPackage.mk",
   "AddTorsor.nonempty",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "addGroupIsAddTorsor",
   "ProbabilityTheory.IsUniform.measureReal_preimage_sub",
   "ProbabilityTheory.IsUniform.entropy_eq'",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Subtype",
   "Finset.filter_congr_decidable",
   "Nat.strictOrderedSemiring",
   "instHDiv",
   "Set.image2",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "instDistribLattice",
   "AddCommMagma.toAdd",
   "PFR.Main._auxLemma.4",
   "DivisionRing.toInv",
   "Mathlib.Tactic.RPowRing.atom_pf",
   "NatCast.natCast",
   "Prod.instMeasurableSpace",
   "PartialOrder",
   "refPackage.X₀₁",
   "Set.subtractionMonoid",
   "instFiniteRangeHSubForAllInstHSubInstSubToSubToSubNegAddMonoid",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Set.image2_add",
   "False.elim",
   "propext",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "instNatAtLeastTwo",
   "AddSubgroup.toAddCommGroup",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Set.inter_subset_left",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "DivisionRing.toDivisionSemiring",
   "HEq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "CharP.cast_eq_zero",
   "Mathlib.Tactic.RPowRing.mul_pf_left",
   "Eq.refl",
   "Int.rawCast",
   "Subtype.fintype",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddSubgroup.sub_mem",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "ProbabilityTheory.exists_isUniform_measureSpace",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "OrderedRing.toOrderedSemiring",
   "Measurable",
   "Lattice.toSemilatticeSup",
   "Decidable.byContradiction",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Nat.linearOrderedCommMonoidWithZero",
   "Real.instLTReal",
   "Top.top",
   "entropic_PFR_conjecture",
   "LE.le.trans",
   "Mathlib.Meta.NormNum.isRat_lt_true",
   "Mathlib.Tactic.Ring.mul_add",
   "Field.toSemifield",
   "add_lt_of_le_of_neg",
   "AddSubgroup.instFintypeSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "Neg.neg",
   "LE.le",
   "OrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup.sub_eq_add",
   "ElementaryAddCommGroup",
   "Set.instInterSet",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Nat.card_eq_fintype_card",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "FiniteRange",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "le_trans",
   "Sub.sub",
   "Nat.card_mono",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.trans",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Real.field",
   "Set.sub_subset_sub",
   "Lattice.toSemilatticeInf",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "instNontrivial",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Set.Finite.coe_toFinset",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "Set.instMembershipSet",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.exp_log",
   "Mathlib.Tactic.Ring.neg_mul",
   "True.intro",
   "Finset.univ",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "mul_one",
   "Singleton.singleton",
   "mul_pos",
   "MeasurableSingletonClass.mk",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.prob_ge_exp_neg_entropy'",
   "ProbabilityTheory.IndepFun",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Pi.instSub",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "Set.fintypeEmpty",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Mathlib.Tactic.RPowRing.pow_congr",
   "Set.instSingletonSet",
   "Linarith.mul_nonpos",
   "AddMonoid.toZero",
   "Real.rpow_def_of_pos",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Set.sub",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "le_div_iff",
   "id",
   "sub_eq_zero_of_eq",
   "eq_self",
   "Membership.mem",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "refPackage",
   "HasSubset.Subset.trans",
   "AddMonoidWithOne.toAddMonoid",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Set.not_nonempty_iff_eq_empty",
   "Mathlib.Meta.NormNum.IsRat.neg_to_eq",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Set.Finite",
   "Measurable.comp",
   "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "MeasureTheory.MeasureSpace",
   "Eq.casesOn",
   "Bool",
   "instMulNat",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2",
   "OrderedSemiring.toPartialOrder",
   "add_sub_assoc",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "EmptyCollection.emptyCollection",
   "Nat.cast_pos",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Set.Nonempty",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Finite.Set.finite_image2",
   "instDiscreteMeasurableSpaceTopMeasurableSpaceToTopInstCompleteLatticeMeasurableSpace",
   "Real.exp_monotone",
   "Mathlib.Meta.NormNum.isRat_add",
   "Iff.mpr",
   "Nat.cast_zero",
   "Real.orderedRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "trivial",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Finite.Set.finite_inter_of_left",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_not_gt",
   "Real.strictOrderedSemiring",
   "Bool.true",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HDiv.hDiv",
   "Set.inter_subset_right",
   "instHSub",
   "HPow.hPow",
   "Set.add",
   "eq_of_heq",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.instRingReal",
   "MeasureTheory.Measure.real",
   "le_abs_self",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Real.rpow_pos_of_pos",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Set.Finite.toFinset_setOf",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Set.add_subset_add_left",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Meta.NormNum.isRat_neg",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Field.toDiv",
   "AddCommGroup",
   "OrderedSemiring.toPosMulMono",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "Int",
   "Finite.of_fintype",
   "SetLike.coe",
   "Inv.inv",
   "true_and",
   "Exists",
   "rdist_le_of_isUniform_of_card_add_le",
   "Real",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semiring.toMonoidWithZero",
   "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
   "Fintype.card_ofFinset",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "Set.toFinite",
   "True",
   "Real.one_rpow",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.RPowRing.atom_pow_pf",
   "AddMonoid.toAddSemigroup",
   "one_pos",
   "Finset",
   "Finset.filter",
   "CancelDenoms.add_subst",
   "ProbabilityTheory.IsUniform.of_identDistrib",
   "Neg.toHasAbs",
   "Mathlib.Meta.NormNum.isRat_mul",
   "PFR.Main._auxLemma.7",
   "Mathlib.Tactic.RPowRing.pow_pf",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "lt_of_lt_of_le",
   "Real.nontrivial",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Countable",
   "sub_neg_of_lt",
   "Set.instHasSubsetSet",
   "Int.mul",
   "Bool.false",
   "CompleteLattice.toTop",
   "Real.instPreorderReal",
   "Prod",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "MulZeroOneClass.toMulOneClass",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real.commRing",
   "Inter.inter",
   "diff_ent_le_rdist",
   "Set.image2_congr",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Eq",
   "OrderedRing.toRing",
   "measurable_id'",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Fintype",
   "Eq.mpr",
   "Ring.toNeg",
   "rdist",
   "Nat",
   "Real.exp_add",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "setOf",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Classical.propDecidable",
   "Nat.rawCast",
   "Finite",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "DistribLattice.toLattice",
   "Set.exists_subset_add_sub",
   "instHMul",
   "refPackage.X₀₂",
   "mul_le_mul_of_nonneg_left",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Not",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "Set.image2_sub",
   "congrArg",
   "Finset.card",
   "Zero",
   "Finset.Nonempty",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "refPackage.η",
   "Mathlib.Meta.NormNum.isNat_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "Nat.card_pos",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "instLENat",
   "one_mul",
   "instFiniteRange",
   "Subtype.fintype.proof_1",
   "instHPow",
   "Preorder.toLT",
   "AddSubgroup",
   "Ring.toSub",
   "LE",
   "Linarith.mul_neg",
   "CancelDenoms.neg_subst",
   "add_sub_add_right_eq_sub",
   "PFR_conjecture_pos_aux",
   "add_lt_of_neg_of_le",
   "Real.strictOrderedRing",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "funext",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Set.preimage",
   "lt_of_le_of_lt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "ProbabilityTheory.IdentDistrib.symm",
   "Fintype.card",
   "Mathlib.Meta.NormNum.isRat_eq_true",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Real.exp",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Mathlib.Meta.NormNum.isRat_le_true",
   "DivisionSemiring.toSemiring",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "ProbabilityTheory.independent_copies_two",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "PFR.Main._auxLemma.8",
   "Real.log",
   "Mathlib.Tactic.RPowRing.mul_pf_right",
   "CharP.ofCharZero",
   "Measurable.sub",
   "LinearOrderedField.toField",
   "SubtractionMonoid.toSubNegMonoid",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Set.Finite.toFinset",
   "Nat.semiring"],
  "name": "PFR_conjecture_aux",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ} [inst_2 : Countable G]\n  [inst_3 : ElementaryAddCommGroup G 2] [inst_4 : Fintype G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) →\n      ∃ H c,\n        ↑(Nat.card ↑c) ≤ K ^ (13 / 2) * ↑(Nat.card ↑A) ^ (1 / 2) * ↑(Nat.card ↑↑H) ^ (-1 / 2) ∧\n          ↑(Nat.card ↥H) ≤ K ^ 11 * ↑(Nat.card ↑A) ∧ ↑(Nat.card ↑A) ≤ K ^ 11 * ↑(Nat.card ↥H) ∧ A ⊆ c + ↑H",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Set.Basic._auxLemma.11",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "congr",
   "Not",
   "congrArg",
   "Mathlib.Data.Set.Basic._auxLemma.10",
   "Eq.trans"],
  "name": "Set.not_nonempty_iff_eq_empty",
  "constType": "∀ {α : Type u} {s : Set α}, ¬Set.Nonempty s ↔ s = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Ring",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Int.cast_ofNat",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "Invertible.mk",
   "mul_one",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isRat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsRat a (Int.ofNat n) 1",
  "constCategory": "Theorem"},
 {"references": ["subset_trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "HasSubset.Subset.trans",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage",
  "constType":
  "(Ω₀₁ : Type u_1) →\n  (Ω₀₂ : Type u_2) →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst : MeasureTheory.MeasureSpace Ω₀₂] → (G : Type uG) → [inst : MeasurableSpace G] → Type (max (max uG u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "rfl",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt (Int.rawCast n) n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "dite",
   "lt_of_not_ge",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_or_le",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Semiring.one_mul",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_2",
  "constType": "∀ (a : ℝ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivisionSemiring",
   "DivisionSemiring.toInv",
   "DivisionSemiring.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.negSucc n) a = (DivisionSemiring.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "instHSub",
   "NormedAddCommGroup.toMetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NormedAddCommGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NormedAddCommGroup.toNorm",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddCommGroup.dist_eq",
  "constType":
  "∀ {E : Type u_9} [self : NormedAddCommGroup E] (x y : E), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommSemiring : LinearOrderedCommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → LinearOrderedSemifield α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedCommRing",
   "HMul.hMul",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalSeminormedCommRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNonUnitalSeminormedRing : NonUnitalSeminormedRing α] → (∀ (x y : α), x * y = y * x) → NonUnitalSeminormedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Membership.mem",
   "Subtype.val",
   "HSub.hSub",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.sub",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x - x_1) = ↑(x - x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedRing",
   "GE.ge",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "OrderedRing.toRing",
   "Ring.toNeg",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.4",
   "Preorder.toLT",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "OrderedRing.toOrderedSemiring",
   "Std.Classes.Order._auxLemma.3",
   "le_of_lt",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "neg_neg_of_pos",
   "OrderedRing.toOrderedAddCommGroup",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "mul_nonneg_of_nonpos_of_nonpos",
   "OrderedRing.toPartialOrder",
   "instHMul",
   "LT.lt",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Eq.mp",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Linarith.mul_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedRing α] {a b : α}, a ≤ 0 → 0 < b → b * a ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Div"],
  "name": "LinearOrderedField.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Div α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semifield",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "Semifield.toCommGroupWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "mul_comm",
   "Field.toCommRing",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_assoc",
   "one_mul",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "DivisionCommMonoid.toDivisionMonoid",
   "Field",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "id",
   "instHDiv",
   "NonUnitalNonAssocRing.toMul",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "One.toOfNat1",
   "CommMagma.toMul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "mul_div_left_comm",
   "Eq.ndrec",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Semifield.toDivisionSemiring",
   "Field.toDiv"],
  "name": "CancelDenoms.div_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Field α] {n1 n2 k e1 e2 t1 : α}, n1 * e1 = t1 → n2 / e2 = 1 → n1 * n2 = k → k * (e1 / e2) = t1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Function.swap",
   "Covariant",
   "Iff.mp",
   "AddGroup",
   "Contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covariant_swap_iff_contravariant_swap",
   "AddGroup.toSubNegMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "CovariantClass.elim"],
  "name": "AddGroup.covconv_swap",
  "constType":
  "∀ {N : Type u_2} {r : N → N → Prop} [inst : AddGroup N]\n  [inst_1 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) r],\n  ContravariantClass N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommGroupWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Fintype",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set.Elem",
   "Set",
   "Finset",
   "Set.instEmptyCollectionSet",
   "Fintype.ofFinset",
   "Set.fintypeEmpty.proof_1"],
  "name": "Set.fintypeEmpty",
  "constType": "{α : Type u} → Fintype ↑∅",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_irrefl", "Not", "Preorder"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "NonUnitalRing",
   "HMul.hMul",
   "Eq"],
  "name": "NonUnitalRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3954",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3915",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u} → α → Bot α",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "AbsoluteValue.abs",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toOrderedSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name": "IsAbsoluteValue.abs_isAbsoluteValue",
  "constType":
  "∀ {S : Type u_1} [inst : LinearOrderedRing S], IsAbsoluteValue abs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {R : Type u_1} {a c b : R}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SMul",
   "SMul.mk",
   "instHSMul",
   "Subtype.val",
   "Set",
   "AddSubgroup.zsmul.proof_1",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "HSMul.hSMul",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Int",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.zsmul",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → {H : AddSubgroup G} → SMul ℤ ↥H",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid.mk",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.add_comm",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMonoidWithOne",
   "AddCommMonoid"],
  "name": "AddCommMonoidWithOne.toAddCommMonoid",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddCommMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "HasDistribNeg.toInvolutiveNeg",
   "Ring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{α : Type u_1} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "Eq",
   "AddGroupWithOne.intCast_ofNat"],
  "name": "Int.cast_ofNat",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "Nat.lt_iff_le_not_le.match_1",
   "LT.lt",
   "Not",
   "Nat.le_of_lt",
   "And.intro",
   "Nat",
   "Nat.lt_of_not_ge",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_iff_le_not_le",
  "constType": "∀ {m n : ℕ}, m < n ↔ m ≤ n ∧ ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "AddCommMagma.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b : G), a + b = b + a) → AddCommMagma G",
  "constCategory": "Other"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "DivInvMonoid",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "GroupWithZero.toDiv",
   "GroupWithZero.toInv"],
  "name": "GroupWithZero.toDivInvMonoid",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → DivInvMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α] (motive : Mathlib.Meta.NormNum.IsInt a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsInt a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsInt a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Inf.inf",
   "AddGroup.toSubtractionMonoid",
   "Exists.casesOn",
   "Preorder.toLE",
   "SetLike.instMembership",
   "AddSubgroup.comap",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Set.Elem",
   "AddSubgroup.addSubgroupOf",
   "Std.Classes.Order._auxLemma.3",
   "Set.image",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "And.casesOn",
   "Eq.trans",
   "Subtype",
   "Equiv.symm",
   "setOf",
   "Set.add",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "inf_of_le_left",
   "Std.Logic._auxLemma.32",
   "Set.image_add",
   "Set.instMembershipSet",
   "Nat.card_congr",
   "instHMul",
   "And",
   "eq_true",
   "of_eq_true",
   "Subtype.range_coe_subtype",
   "AddSubgroup.leftTransversals",
   "And.intro",
   "AddSubgroup.subtype",
   "congrArg",
   "AddSubgroup.add",
   "congrFun",
   "SetLike.coe",
   "AddZeroClass.toAdd",
   "Exists",
   "Subtype.val",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "GE.ge",
   "AddSubgroup.zero",
   "Eq.refl",
   "AddSubgroup.exists_left_transversal",
   "AddSubgroup.toAddSubmonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddSubgroup.IsComplement.add_eq",
   "AddSubgroup.toAddGroup",
   "True",
   "iff_self",
   "Equiv.Set.image",
   "Set.range",
   "Zero.toOfNat0",
   "AddGroup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "Mathlib.GroupTheory.Complement._auxAddLemma.16",
   "AddSubgroup",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.image_congr",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSubgroup.instInfAddSubgroup",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "ConditionallyCompleteLattice.toLattice",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.image_univ",
   "AddSubgroup.IsComplement.card_mul_card",
   "Set.univ",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "AddSubgroup.map",
   "Zero.nonempty",
   "Eq.ndrec",
   "congr_arg₂",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "AddSubgroup.subtype_injective",
   "AddMonoidHom.addMonoidHomClass",
   "instMulNat",
   "NegZeroClass.toZero",
   "Nat.card",
   "AddSubgroup.addSubgroupOf_map_subtype",
   "AddMonoidHom"],
  "name": "AddSubgroup.exists_left_transversal_of_le",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H' H : AddSubgroup G},\n  H' ≤ H → ∃ S, S + ↑H' = ↑H ∧ Nat.card ↑S * Nat.card ↥H' = Nat.card ↥H",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "inferInstance",
   "Real.strictOrderedCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Real",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Real.orderedSemiring",
  "constType": "OrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.toInfSet",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_8",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)) (a : AddSubgroup G), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.coe_toFinset",
   "Finset.toSet",
   "Set",
   "Set.Finite.fintype",
   "Set.Finite.toFinset",
   "Set.Finite",
   "Eq"],
  "name": "Set.Finite.coe_toFinset",
  "constType":
  "∀ {α : Type u} {s : Set α} (hs : Set.Finite s), ↑(Set.Finite.toFinset hs) = s",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IdentDistrib",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : MeasurableSpace α] →\n        [inst_1 : MeasurableSpace β] →\n          [inst_2 : MeasurableSpace γ] →\n            (α → γ) →\n              (β → γ) → autoParam (MeasureTheory.Measure α) _auto✝ → autoParam (MeasureTheory.Measure β) _auto✝¹ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "Subtype"],
  "name": "PosMulStrictMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommGroup",
   "OfNat.ofNat",
   "IsCancelAdd.toIsLeftCancelAdd",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "neg_neg_iff_pos",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Zero.toOfNat0",
   "AddCancelMonoid.toIsCancelAdd",
   "Preorder.toLT",
   "LT.lt",
   "AddGroup.toAddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "Iff.mp",
   "Set.Elem",
   "Finset.toSet",
   "Fintype.card_coe",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Subtype",
   "Nat.strictOrderedSemiring",
   "Set.add_empty",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Set.add",
   "Mathlib.Order.Basic._auxLemma.1",
   "Classical.propDecidable",
   "Set.infinite_or_finite",
   "Nat.canonicallyOrderedCommSemiring",
   "Set.instEmptyCollectionSet",
   "Finset.instMembershipFinset",
   "Or.casesOn",
   "And",
   "instHMul",
   "of_eq_true",
   "Set.empty_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "Finset.add",
   "congrFun",
   "Finset.card",
   "Exists",
   "Set.fintypeEmpty",
   "Set",
   "CanLift.prf",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "Zero.toOfNat0",
   "instLENat",
   "Set.finite_add",
   "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
   "Finset",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Finset.card_add_le",
   "Set.Infinite.card_eq_zero",
   "Eq.symm",
   "Set.Infinite",
   "id",
   "Finset.coe_add",
   "Membership.mem",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "Fintype.card",
   "IsCancelAdd",
   "LE.le",
   "Set.Finite",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "HMul.hMul",
   "instMulNat",
   "Add",
   "Nat.card",
   "Nat.semiring"],
  "name": "Set.card_add_le",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsCancelAdd α] {s t : Set α}, Nat.card ↑(s + t) ≤ Nat.card ↑s * Nat.card ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "AddGroup",
   "AddSubgroup.instSetLikeAddSubgroup.proof_1",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instSetLikeAddSubgroup",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → SetLike (AddSubgroup G) G",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : StrictOrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SMul",
   "SMul.mk",
   "instHSMul",
   "Subtype.val",
   "Set",
   "AddSubgroup.nsmul.proof_1",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "AddMonoid.toNatSMul",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "HSMul.hSMul",
   "SubNegMonoid.toAddMonoid",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.nsmul",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → {H : AddSubgroup G} → SMul ℕ ↥H",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddLeftCancelMonoid.mk",
   "Eq.symm",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mk'",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.169",
   "autoParam",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "LinearOrderedField",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.128",
   "Int.natAbs",
   "Inv.inv"],
  "name": "LinearOrderedField.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommRing : LinearOrderedCommRing α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toRatCast : RatCast α] →\n                    (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) →\n                      0⁻¹ = 0 →\n                        autoParam\n                            (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                              ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                            _auto✝⁴ →\n                          (qsmul : ℚ → α → α) →\n                            autoParam (∀ (a : ℚ) (x : α), qsmul a x = ↑a * x) _auto✝⁵ → LinearOrderedField α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_5",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Cardinal.mk_toNat_eq_card",
   "Fintype.card",
   "Nat",
   "Nat.card",
   "Eq"],
  "name": "Nat.card_eq_fintype_card",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α], Nat.card α = Fintype.card α",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "PartialOrder"],
  "name": "OrderedAddCommGroup.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Fintype", "Fintype.equivFin", "Finite.intro", "Finite", "Fintype.card"],
  "name": "Fintype.finite",
  "constType": "∀ {α : Type u_4}, Fintype α → Finite α",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.refl",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "SetLike",
   "MulOneClass.toMul",
   "SetLike.mk",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Subgroup.instSetLikeSubgroup.proof_1",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.instSetLikeSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → SetLike (Subgroup G) G",
  "constCategory": "Definition"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{α : Type u_1} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_zero'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a : G), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["outParam", "Nat", "AddCommGroup"],
  "name": "ElementaryAddCommGroup",
  "constType": "(G : Type u_1) → [inst : AddCommGroup G] → outParam ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "dite",
   "sub_eq_add_neg",
   "two_nsmul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddGroup.toAddCancelMonoid",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "ElementaryAddCommGroup.orderOf_of_ne",
   "id",
   "eq_self",
   "instHSub",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "Classical.propDecidable",
   "HSub.hSub",
   "Neg.neg",
   "add_eq_zero_iff_neg_eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toNatSMul",
   "add_right_inj",
   "addOrderOf_nsmul_eq_zero",
   "Eq.ndrec",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "propext",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "Not",
   "ElementaryAddCommGroup",
   "AddCommGroup",
   "add_zero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "addOrderOf",
   "congrFun"],
  "name": "ElementaryAddCommGroup.sub_eq_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] [elem : ElementaryAddCommGroup G 2] (x y : G), x - y = x + y",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Set.Elem",
   "Iff.rfl",
   "propext",
   "Set",
   "Finite",
   "Eq.refl",
   "Set.finite_def",
   "finite_iff_nonempty_fintype",
   "Nonempty",
   "Set.Finite",
   "Eq",
   "id"],
  "name": "Set.finite_coe_iff",
  "constType": "∀ {α : Type u} {s : Set α}, Finite ↑s ↔ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "neg_add_cancel_right",
   "id"],
  "name": "sub_add_cancel",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NormedRing.toNorm",
   "NormedCommRing.toSeminormedCommRing.proof_2",
   "NormedCommRing",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "SeminormedCommRing",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toSeminormedCommRing.proof_1",
   "SeminormedRing.mk",
   "NormedRing.toRing",
   "SeminormedCommRing.mk"],
  "name": "NormedCommRing.toSeminormedCommRing",
  "constType": "{α : Type u_1} → [β : NormedCommRing α] → SeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Real", "LT", "LT.mk", "_private.Mathlib.Data.Real.Basic.0.Real.lt"],
  "name": "Real.instLTReal",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Real.linearOrderedCommRing",
   "Real"],
  "name": "Real.instLinearOrderedRingReal",
  "constType": "LinearOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Nat.strictMono_cast",
   "Nat.linearOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "StrictMono.le_iff_le",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Int.mul", "Mul", "Int", "Mul.mk"],
  "name": "Int.instMulInt",
  "constType": "Mul ℤ",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.add.match_1",
  "constType":
  "(motive : ℤ → ℤ → Sort u_1) →\n  (m n : ℤ) →\n    ((m n : ℕ) → motive (Int.ofNat m) (Int.ofNat n)) →\n      ((m n : ℕ) → motive (Int.ofNat m) (Int.negSucc n)) →\n        ((m n : ℕ) → motive (Int.negSucc m) (Int.ofNat n)) →\n          ((m n : ℕ) → motive (Int.negSucc m) (Int.negSucc n)) → motive m n",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "OrderedAddCommGroup.add_le_add_left",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.to_covariantClass_left_le",
  "constType":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.mk",
  "constType": "{α : Type u} → (α → α → Prop) → HasSubset α",
  "constCategory": "Other"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references": ["Set.preimage", "Set", "MeasurableSet", "MeasurableSpace"],
  "name": "Measurable",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : MeasurableSpace α] → [inst : MeasurableSpace β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nonempty_subtype",
   "Iff",
   "Set.Elem",
   "Set",
   "Set.Nonempty",
   "Nonempty",
   "Set.instMembershipSet"],
  "name": "Set.nonempty_coe_sort",
  "constType": "∀ {α : Type u} {s : Set α}, Nonempty ↑s ↔ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Real",
   "Real.instAddMonoidReal",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Real.isROrC.proof_9",
  "constType": "ℝ → 0 = -0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemifield", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedSemifield.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instAddNat",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_add",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Nat.rec",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "congr",
   "mul_one",
   "instMulNat",
   "congrArg",
   "congrFun",
   "Nat.semiring"],
  "name": "Nat.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "Membership.mem",
   "SubNegMonoid.toSub",
   "AddGroup",
   "HSub.hSub",
   "AddSubgroup",
   "sub_mem",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership"],
  "name": "AddSubgroup.sub_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x y : G}, x ∈ H → y ∈ H → x - y ∈ H",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "Nontrivial"],
  "name": "StrictOrderedRing.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["DecidablePred",
   "Finset.univ",
   "Fintype",
   "Subtype.fintype.proof_1",
   "Finset.filter",
   "Fintype.subtype",
   "Subtype"],
  "name": "Subtype.fintype",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → [inst : Fintype α] → Fintype { x // p x }",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "NonAssocRing.toIntCast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Int.cast_mul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.mul a' b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Subtype.property", "Subtype.val", "Subtype"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b c : R} (x : R) (e : ℕ), a + b = c → x ^ e * a + x ^ e * b = x ^ e * c",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Function.Injective.addCommGroup",
   "AddSubgroup.toAddCommGroup.proof_1",
   "Subtype.val",
   "AddSubgroup.toAddCommGroup.proof_3",
   "AddSubgroup.zero",
   "AddSubgroup.toAddCommGroup.proof_4",
   "AddSubgroup.toAddCommGroup.proof_7",
   "SetLike.instMembership",
   "AddSubgroup.zsmul",
   "AddSubgroup.toAddCommGroup.proof_5",
   "AddSubgroup.nsmul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddSubgroup.toAddCommGroup.proof_2",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.neg",
   "AddSubgroup.toAddCommGroup.proof_6",
   "AddSubgroup.sub",
   "Subtype",
   "AddSubgroup.add"],
  "name": "AddSubgroup.toAddCommGroup",
  "constType":
  "{G : Type u_5} → [inst : AddCommGroup G] → (H : AddSubgroup G) → AddCommGroup ↥H",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring.proof_1",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Real.log_lt_log",
   "Eq.mpr",
   "ne_of_gt",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "instHPow",
   "Real.strictOrderedSemiring",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "lt_trans",
   "Eq.symm",
   "id",
   "Real.exp_lt_exp",
   "HPow.hPow",
   "Or",
   "le_iff_eq_or_lt",
   "Real.partialOrder",
   "Real.instLTReal",
   "Real.zero_rpow",
   "Or.inr",
   "Or.casesOn",
   "LE.le",
   "Real.exp",
   "Real.instZeroReal",
   "instHMul",
   "Real.rpow_pos_of_pos",
   "Real.log",
   "Eq.ndrec",
   "Or.inl",
   "propext",
   "LT.lt",
   "Eq.mp",
   "Real.instPreorderReal",
   "mul_lt_mul_of_pos_right",
   "HMul.hMul"],
  "name": "Real.rpow_lt_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → x < y → 0 < z → x ^ z < y ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "SubNegMonoid.zsmul_succ'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Nat.ble",
   "instLENat",
   "propext",
   "Bool.true",
   "Bool",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "LE.le",
   "Eq"],
  "name": "Nat.ble_eq",
  "constType": "∀ {x y : ℕ}, (Nat.ble x y = true) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Pi.instSub",
   "inferInstance",
   "SubNegMonoid.toSub",
   "prod",
   "Prod.snd",
   "FiniteRange",
   "AddGroup",
   "Function.comp",
   "instFiniteRangeProdProd",
   "HSub.hSub",
   "letFun",
   "instFiniteRangeComp",
   "Prod",
   "Prod.fst",
   "AddGroup.toSubNegMonoid"],
  "name": "instFiniteRangeHSubForAllInstHSubInstSubToSubToSubNegAddMonoid",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} (X Y : Ω → G) [inst : AddGroup G] [hX : FiniteRange X] [hY : FiniteRange Y],\n  FiniteRange (X - Y)",
  "constCategory": "Definition"},
 {"references": ["refPackage", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.X₀₁",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → Ω₀₁ → G",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Inv"],
  "name": "DivisionRing.toInv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Inv K",
  "constCategory": "Definition"},
 {"references":
  ["IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsGLB.of_image",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "SetLike.instPartialOrder",
   "AddSubgroup.instInfSetAddSubgroup",
   "isGLB_biInf",
   "AddGroup",
   "SetLike.coe_subset_coe",
   "AddSubgroup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_s : Set (AddSubgroup G)), IsGLB _s (sInf _s)",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.702", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.one",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "Units.exists_iff_ne_zero",
   "IsUnit",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "Iff.mpr"],
  "name": "Ne.isUnit",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → IsUnit a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "Zero.mk",
   "Complex"],
  "name": "Complex.instZeroComplex",
  "constType": "Zero ℂ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image2",
  "constType":
  "{α : Type u_1} → {β : Type u_3} → {γ : Type u_5} → (α → β → γ) → Set α → Set β → Set γ",
  "constCategory": "Definition"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["DecidablePred",
   "Eq.ndrec",
   "Eq.rec",
   "Decidable",
   "Finset",
   "Eq.refl",
   "Finset.filter",
   "instSubsingletonDecidable",
   "instSubsingletonForAll",
   "Subsingleton.elim",
   "Eq"],
  "name": "Finset.filter_congr_decidable",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) (p : α → Prop) (h : DecidablePred p) [inst : DecidablePred p],\n  Finset.filter p s = Finset.filter p s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Nat.decidablePrime1",
   "instOfNatNat",
   "Bool",
   "Nat"],
  "name": "Nat.prime_two",
  "constType": "Nat.Prime 2",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "OfNat.ofNat",
   "One",
   "Real",
   "One.mk",
   "One.toOfNat1",
   "Complex",
   "Real.instOneReal"],
  "name": "Complex.instOneComplex",
  "constType": "One ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.mk",
   "Finset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.Subtype.fintype",
  "constType": "{α : Type u_1} → (s : Finset α) → Fintype { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Set.add_singleton",
   "OfNat.ofNat",
   "AddCommGroup.toAddCommMonoid",
   "MeasureTheory.IsProbabilityMeasure",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Iff",
   "Set.Elem",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "AddOpposite.op",
   "Finset.toSet",
   "HSMul.hSMul",
   "HDiv.hDiv",
   "Set.image",
   "Finset.Subtype.fintype",
   "Subtype",
   "instHSub",
   "instHDiv",
   "Set.add",
   "eq_of_heq",
   "Function.comp",
   "Finset.preimage",
   "MeasureTheory.Measure.real",
   "instHVAdd",
   "AddCommMagma.toAdd",
   "PFR.Main._auxLemma.4",
   "propext",
   "congr",
   "AddCommGroup",
   "Finset.image_add_right",
   "MeasurableSpace",
   "Finite.of_fintype",
   "Int",
   "Finset.add",
   "congrFun",
   "Finset.vaddFinset",
   "AddZeroClass.toAdd",
   "Measurable.add_const",
   "NatCast",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddMonoid.toOppositeAddAction",
   "HEq",
   "instOfNatInt",
   "Set",
   "Real",
   "Eq.refl",
   "HDiv",
   "MeasurableAdd.measurable_add_const",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "iff_self",
   "add_left_injective",
   "MeasureTheory.Measure",
   "Set.ext",
   "zero_add",
   "DiscreteMeasurableSpace.toMeasurableAdd",
   "Eq.rec",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Finset",
   "AddGroup.toAddCancelMonoid",
   "Measurable",
   "HVAdd.hVAdd",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset.coe_add",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Finset.card_add_singleton",
   "Mathlib.Tactic.Abel.term_atomg",
   "Eq.ndrec",
   "letFun",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "ProbabilityTheory.IsUniform.comp",
   "NegZeroClass.toNeg",
   "Finset.instSingletonFinset",
   "Set.instInterSet",
   "instHSMul",
   "Finset.coe_preimage",
   "neg_zero",
   "Real.instMulReal",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Inter.inter",
   "autoParam",
   "Eq",
   "ProbabilityTheory.IndepFun.comp",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Nat.card_eq_fintype_card",
   "Eq.mpr",
   "Fintype",
   "Ring.toNeg",
   "Finset.card_vadd_finset",
   "Fintype.card_coe",
   "Nat",
   "PFR.Main._auxLemma.3",
   "Eq.trans",
   "Finite.to_countable",
   "measurable_id",
   "Classical.propDecidable",
   "Mathlib.Tactic.Abel.termg",
   "Mathlib.Tactic.Abel.term_neg",
   "Finset.instMembershipFinset",
   "AddOpposite.addGroup",
   "SubNegMonoid.SMulInt",
   "Set.instMembershipSet",
   "instHMul",
   "Function.Injective.injOn",
   "of_eq_true",
   "HEq.refl",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "AddAction.toVAdd",
   "Singleton.singleton",
   "sub_eq_zero",
   "Mathlib.Tactic.Abel.term_add_constg",
   "Finset.coe_singleton",
   "add_zero",
   "congrArg",
   "ProbabilityTheory.IndepFun",
   "Finset.card",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Zero.toOfNat0",
   "outParam",
   "Int.instRingInt",
   "Set.instSingletonSet",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Finset.image",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "AddCommGroup.toAddGroup",
   "Int.instNegInt",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.preimage",
   "ProbabilityTheory.IsUniform.measureReal_preimage_sub_zero",
   "instHAdd",
   "HSub.hSub",
   "Fintype.card",
   "AddGroup.toSubNegMonoid",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "one_zsmul",
   "SubtractionMonoid.toSubNegMonoid",
   "MeasureTheory.MeasureSpace",
   "Set.image_add_right",
   "SubNegMonoid.toAddMonoid",
   "AddOpposite",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat.card",
   "NegZeroClass.toZero",
   "ProbabilityTheory.IsUniform",
   "HMul"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_sub",
  "constType":
  "∀ {G : Type u_1} {Ω : Type u_2} [inst : AddCommGroup G] [inst_1 : Fintype G] [inst_2 : MeasurableSpace G]\n  [inst_3 : MeasurableSingletonClass G] {A B : Finset G} [inst_4 : MeasureTheory.MeasureSpace Ω]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {U V : Ω → G},\n  ProbabilityTheory.IsUniform (↑A) U →\n    Measurable U →\n      ProbabilityTheory.IsUniform (↑B) V →\n        Measurable V →\n          ProbabilityTheory.IndepFun U V →\n            ∀ (x : G),\n              MeasureTheory.volume.real ((U - V) ⁻¹' {x}) =\n                ↑(Nat.card ↑(↑A ∩ (↑B + {x}))) / (↑(Nat.card { x // x ∈ A }) * ↑(Nat.card { x // x ∈ B }))",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemiring.toMax",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "Max.max",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedSemiring.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{α : Type u} → [self : Div α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["outParam", "AddTorsor", "AddGroup", "Nonempty"],
  "name": "AddTorsor.nonempty",
  "constType":
  "∀ {G : outParam (Type u_1)} {P : Type u_2} [inst : outParam (AddGroup G)] [self : AddTorsor G P], Nonempty P",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.subtype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.toAddGroup",
   "SetLike.instMembership",
   "Subtype",
   "AddSubgroup.comap"],
  "name": "AddSubgroup.addSubgroupOf",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → AddSubgroup G → (K : AddSubgroup G) → AddSubgroup ↥K",
  "constCategory": "Definition"},
 {"references": ["Group"],
  "name": "Subgroup",
  "constType": "(G : Type u_5) → [inst : Group G] → Type u_5",
  "constCategory": "Other"},
 {"references": [],
  "name": "RelIso",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Subtype", "Set.instMembershipSet"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "InfSet",
   "AddSubgroup.instInfSetAddSubgroup.proof_3",
   "AddSubgroup.toAddSubmonoid",
   "AddSubgroup.instInfSetAddSubgroup.proof_1",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.copy",
   "AddSubgroup.instInfSetAddSubgroup.proof_2",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "InfSet.mk",
   "AddGroup",
   "iInf",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "Set.iInter",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfSetAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → InfSet (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "le_max_right",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "neg_le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), -a ≤ |a|",
  "constCategory": "Theorem"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{α : Type u_1} → [inst : SupSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "MulOneClass.toOne",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Mathlib.Meta.NormNum.IsInt.to_isRat.match_1",
   "Semiring.toOne",
   "instHMul",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "mul_one",
   "Invertible.mk",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isRat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, Mathlib.Meta.NormNum.IsInt a n → Mathlib.Meta.NormNum.IsRat a n 1",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "CommSemigroup.mk",
   "NonUnitalCommSemiring.mul_comm",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommSemigroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "NonUnitalCommSemiring.toCommSemigroup",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → CommSemigroup α",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "Nat.cast_zero",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "NeZero",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "Nat.strictOrderedSemiring",
   "False",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.5",
   "LE.le",
   "PartialOrder",
   "Mathlib.Order.Basic._auxLemma.2",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Nat.zero",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "CovariantClass",
   "congr",
   "congrArg",
   "AddCommMonoidWithOne",
   "Nat.casesOn",
   "Std.Data.Nat.Lemmas._auxLemma.6"],
  "name": "Nat.cast_pos'",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "LE.le",
   "AddZeroClass",
   "Preorder.toLE",
   "Left.add_nonpos"],
  "name": "add_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "HasSubset.Subset",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "inferInstance",
   "BooleanAlgebra.toBiheytingAlgebra",
   "instIsTransLeToLE",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "letFun",
   "GeneralizedCoheytingAlgebra.toLattice",
   "IsTrans",
   "BiheytingAlgebra.toCoheytingAlgebra"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet",
  "constType": "∀ {α : Type u}, IsTrans (Set α) fun x x_1 => x ⊆ x_1",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "instHAdd",
   "Real",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.rpow_add",
   "Eq.refl",
   "CommMagma.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Eq.mpr",
   "Real.instCommSemigroupReal",
   "Eq.ndrec",
   "mul_mul_mul_comm",
   "CommSemigroup.toCommMagma",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "HMul.hMul",
   "id"],
  "name": "Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
  "constType":
  "∀ {x a₂ b₂ c : ℝ} (ea eb : ℝ), 0 < x → a₂ * b₂ = c → x ^ ea * a₂ * (x ^ eb * b₂) = x ^ (ea + eb) * c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.toOrd",
   "LinearOrder",
   "LinearOrderedAddCommMonoid.decidableLE",
   "LinearOrder.mk",
   "LinearOrderedAddCommMonoid.decidableEq",
   "LinearOrderedAddCommMonoid.toMin",
   "LinearOrderedAddCommMonoid.min_def",
   "LinearOrderedAddCommMonoid.le_total",
   "LinearOrderedAddCommMonoid.toMax",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommMonoid.max_def",
   "LinearOrderedAddCommMonoid.decidableLT"],
  "name": "LinearOrderedAddCommMonoid.toLinearOrder",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "Norm"],
  "name": "NormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "One.toOfNat1",
   "Int.cast_ofNat",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "Int",
   "Nat.cast_one",
   "id"],
  "name": "Int.cast_one",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Nat"],
  "name": "Nat.semiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "CompleteSpace",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instLEReal",
   "Real.normedField",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instAddReal",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Preorder.toLE",
   "NormedField.toNorm",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Ring.toNeg",
   "Real.instCommSemiringReal",
   "Nat",
   "NormedAlgebra",
   "HPow.hPow",
   "instHSub",
   "Or",
   "NormedField.toMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "PartialOrder",
   "And",
   "instHMul",
   "DecidableEq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "Real",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "instHPow",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "StarRing",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSemigroup.toAdd",
   "algebraMap",
   "HSub.hSub",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Real.instZeroReal",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DenselyNormedField",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "IsROrC.mk",
  "constType":
  "{K : semiOutParam (Type u_1)} →\n  [toDenselyNormedField : DenselyNormedField K] →\n    [toStarRing : StarRing K] →\n      [toNormedAlgebra : NormedAlgebra ℝ K] →\n        [toCompleteSpace : CompleteSpace K] →\n          (re im : K →+ ℝ) →\n            (I : K) →\n              re I = 0 →\n                I = 0 ∨ I * I = -1 →\n                  (∀ (z : K), (algebraMap ℝ K) (re z) + (algebraMap ℝ K) (im z) * I = z) →\n                    (∀ (r : ℝ), re ((algebraMap ℝ K) r) = r) →\n                      (∀ (r : ℝ), im ((algebraMap ℝ K) r) = 0) →\n                        (∀ (z w : K), re (z * w) = re z * re w - im z * im w) →\n                          (∀ (z w : K), im (z * w) = re z * im w + im z * re w) →\n                            (∀ (z : K), re ((starRingEnd K) z) = re z) →\n                              (∀ (z : K), im ((starRingEnd K) z) = -im z) →\n                                (starRingEnd K) I = -I →\n                                  (∀ (z : K), ‖z‖ ^ 2 = re z * re z + im z * im z) →\n                                    (∀ (z : K), im z * im I = im z) →\n                                      [toPartialOrder : PartialOrder K] →\n                                        (∀ {z w : K}, z ≤ w ↔ re z ≤ re w ∧ im z = im w) →\n                                          [toDecidableEq : DecidableEq K] → IsROrC K",
  "constCategory": "Other"},
 {"references": ["DivisionSemiring", "Inv"],
  "name": "DivisionSemiring.toInv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "autoParam",
   "Semifield",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "CommSemiring",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mk",
  "constType":
  "{α : Type u_4} →\n  [toCommSemiring : CommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → Semifield α",
  "constCategory": "Other"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Int.negOfNat.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((m : ℕ) → motive (Nat.succ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["congrArg₂", "Eq"],
  "name": "congr_arg₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "MeasurableSub₂.measurable_sub",
   "Measurable.prod_mk",
   "Prod.snd",
   "Prod.mk",
   "HSub.hSub",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Measurable.comp",
   "Prod.instMeasurableSpace"],
  "name": "Measurable.sub",
  "constType":
  "∀ {G : Type u_2} {α : Type u_3} [inst : MeasurableSpace G] [inst_1 : Sub G] {m : MeasurableSpace α} {f g : α → G}\n  [inst_2 : MeasurableSub₂ G], Measurable f → Measurable g → Measurable fun a => f a - g a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Eq.mpr",
   "Real.instCommSemigroupReal",
   "Eq.ndrec",
   "CommSemigroup.toCommMagma",
   "Real.instMulReal",
   "Real",
   "Eq.refl",
   "HMul.hMul",
   "CommMagma.toMul",
   "mul_left_comm",
   "id",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.mul_pf_right",
  "constType": "∀ {a b₂ c : ℝ} (b₁ : ℝ), a * b₂ = c → a * (b₁ * b₂) = b₁ * c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedSemifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.toMeasurableSpace",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "completeLatticeOfInf",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "LE.le",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "SetLike.instPartialOrder",
   "And",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "And.intro",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b _c : AddSubgroup G),\n  _a ≤ _b → _a ≤ _c → ∀ _x ∈ _a, _x ∈ ↑_b.toAddSubmonoid ∧ _x ∈ ↑_c.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "MeasureTheory.Measure.map",
   "ProbabilityTheory.IdentDistrib.aemeasurable_fst",
   "ProbabilityTheory.IdentDistrib.aemeasurable_snd",
   "ProbabilityTheory.IdentDistrib",
   "Eq.symm",
   "MeasurableSpace",
   "ProbabilityTheory.IdentDistrib.mk"],
  "name": "ProbabilityTheory.IdentDistrib.symm",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ},\n  ProbabilityTheory.IdentDistrib f g → ProbabilityTheory.IdentDistrib g f",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_10",
  "constType": "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_13",
  "constType":
  "∀ (a : ℚ) (x : ℝ), (qsmulRec Rat.cast) a x = (qsmulRec Rat.cast) a x",
  "constCategory": "Theorem"},
 {"references":
  ["Subgroup.instInfSubgroup",
   "Subgroup.instCompleteLatticeSubgroup.proof_3",
   "Inf.inf",
   "Subgroup.instBotSubgroup",
   "CompleteLattice.mk",
   "Subgroup.instCompleteLatticeSubgroup.proof_8",
   "Subgroup.instTopSubgroup",
   "Lattice.mk",
   "SetLike.instMembership",
   "Subgroup.instCompleteLatticeSubgroup.proof_5",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "Subgroup.instCompleteLatticeSubgroup.proof_7",
   "Membership.mem",
   "Bot.bot",
   "Subgroup.instCompleteLatticeSubgroup.proof_4",
   "Top.top",
   "Subgroup.instCompleteLatticeSubgroup.proof_2",
   "completeLatticeOfInf",
   "Subgroup.instInfSetSubgroup",
   "SetLike.instPartialOrder",
   "Subgroup.instCompleteLatticeSubgroup.proof_6",
   "Subgroup.instCompleteLatticeSubgroup.proof_9",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Subgroup.mem_top",
   "Bot.mk",
   "Top.mk",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup",
  "constType":
  "{G : Type u_1} → [inst : Group G] → CompleteLattice (Subgroup G)",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_6",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Or",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "rfl",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Field.toCommRing",
   "NormedField.toField",
   "instHMul",
   "Or.intro_left",
   "Ring.toNeg",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_2",
  "constType": "0 = 0 ∨ 0 * 0 = -1",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.mk",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, a = ↑n → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references": ["Int", "Neg", "Int.neg", "Neg.mk"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real",
   "Real.instAddMonoidReal",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Real.normedCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "AddZeroClass.toZero",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "congrFun"],
  "name": "Real.isROrC.proof_12",
  "constType": "ℝ → 0 * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.10",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Ring.toNeg",
   "mul_pos_of_neg_of_neg",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "StrictOrderedRing",
   "HasDistribNeg.toInvolutiveNeg",
   "AddGroup.toAddCancelMonoid",
   "neg_mul",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "StrictOrderedRing.toPartialOrder",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "neg_neg_of_pos",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "StrictOrderedSemiring.toSemiring",
   "GT.gt",
   "instHMul",
   "Std.Classes.Order._auxLemma.4",
   "AddCancelMonoid.toIsCancelAdd",
   "neg_of_neg_pos",
   "LT.lt",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references": ["AddGroup"],
  "name": "AddSubgroup",
  "constType": "(G : Type u_5) → [inst : AddGroup G] → Type u_5",
  "constCategory": "Other"},
 {"references": ["Norm", "SeminormedRing"],
  "name": "SeminormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : SeminormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Ring", "CommRing.toRing", "Int", "Int.instCommRingInt"],
  "name": "Int.instRingInt",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Nat.card_pos_iff",
   "OfNat.ofNat",
   "LT.lt",
   "Finite",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Nat.card",
   "instLTNat",
   "Iff.mpr",
   "Nonempty"],
  "name": "Nat.card_pos",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α] [inst : Finite α], 0 < Nat.card α",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.neg", "Real", "Neg", "Neg.mk"],
  "name": "Real.instNegReal",
  "constType": "Neg ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "mul_mul_invOf_self_cancel'",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) {x : Invertible b}, a * b * ⅟b = a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedField α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommMonoid",
   "CommSemiring",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.mk",
   "CommMonoid.mul_comm"],
  "name": "CommSemiring.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [inst : CommSemiring α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mul_comm",
  "constType": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Nat.cast_add",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.add a' b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["refPackage", "Real", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.η",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "OfNat.ofNat",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_5",
  "constType": "∀ (r : ℝ), 0 ((algebraMap ℝ ℝ) r) = 0 ((algebraMap ℝ ℝ) r)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "DivisionRing.toDiv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.div_eq_mul_inv",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instOfNatInt",
   "One.toOfNat1",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Int",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), LinearOrderedSemifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Set.image2",
   "Set",
   "HSub.hSub",
   "Set.sub",
   "Sub.sub",
   "Sub",
   "rfl",
   "Eq"],
  "name": "Set.image2_sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s t : Set α}, Set.image2 Sub.sub s t = s - t",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Prod.snd",
   "DiscreteMeasurableSpace",
   "HSub.hSub",
   "measurable_discrete",
   "MeasurableSub₂.mk",
   "Prod",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "DiscreteMeasurableSpace.toMeasurableSub₂",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : Sub α] [inst_2 : DiscreteMeasurableSpace (α × α)],\n  MeasurableSub₂ α",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x < x_1 → Prop) (x x_1 : α) (x_2 : x < x_1),\n  (∀ (_a _b : α) (hab : _a < _b), motive _a _b hab) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "LinearOrderedSemifield.toInv",
   "PartialOrder.toPreorder",
   "div_eq_mul_inv",
   "Eq.refl",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "id",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "mul_pos",
   "inv_pos",
   "Inv.inv"],
  "name": "div_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → 0 < a / b",
  "constCategory": "Theorem"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.image2_empty_left",
   "Set.instEmptyCollectionSet",
   "Add",
   "Eq"],
  "name": "Set.empty_add",
  "constType": "∀ {α : Type u_2} [inst : Add α] {s : Set α}, ∅ + s = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "inferInstance",
   "Real",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Real.orderedSemiring"],
  "name": "Real.orderedAddCommMonoid",
  "constType": "OrderedAddCommMonoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "MulOneClass.toMul",
   "Iff.rfl",
   "div_eq_mul_inv",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "Eq.mpr",
   "IsUnit.eq_mul_inv_iff_mul_eq",
   "Eq.ndrec",
   "Iff",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "IsUnit.eq_div_iff",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit c → (a = b / c ↔ a * c = b)",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Inv"],
  "name": "DivInvMonoid.toInv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Eq",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Div"],
  "name": "DivisionSemiring.toDiv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toDivInvMonoid : DivInvMonoid G] →\n    (∀ (x : G), x⁻¹⁻¹ = x) →\n      (∀ (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹) → (∀ (a b : G), a * b = 1 → a⁻¹ = b) → DivisionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne", "AddMonoidWithOne.toNatCast", "Nat.cast", "Nat"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "Real.partialOrder.proof_4",
   "Real.partialOrder.proof_2",
   "LT.mk",
   "Real.partialOrder.proof_1",
   "LE.le",
   "PartialOrder",
   "Real.partialOrder.proof_3",
   "Preorder.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Zero.toOfNat0",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "AddGroup.toSubtractionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (x : G), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSMul",
   "AddSubgroup.nsmul",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Nat",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℕ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "CommMagma.toMul", "Eq"],
  "name": "CommMagma.mul_comm",
  "constType": "∀ {G : Type u} [self : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Fintype.card_of_finset'",
   "Fintype",
   "Set.Elem",
   "Iff.rfl",
   "Multiset",
   "Finset",
   "Finset.val",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "Nat",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "Eq",
   "id"],
  "name": "Fintype.card_coe",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) [inst : Fintype { x // x ∈ s }], Fintype.card { x // x ∈ s } = Finset.card s",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Nat.le.refl", "Nat", "LE.le"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["HEq",
   "eq_of_heq",
   "Eq.refl",
   "Neg.neg",
   "Eq",
   "Ring.toNeg",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int",
   "Int.neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α) →\n      (x_1 : α) → (x_2 x_3 : ℤ) → x = Neg.neg → Mathlib.Meta.NormNum.IsInt x_1 x_2 → Int.neg x_2 = x_3 → Prop)\n  (x : α → α) (x_1 : α) (x_2 x_3 : ℤ) (x_4 : x = Neg.neg) (x_5 : Mathlib.Meta.NormNum.IsInt x_1 x_2)\n  (x_6 : Int.neg x_2 = x_3),\n  (∀ (n : ℤ),\n      motive Neg.neg (↑n) n (Int.neg n) (_ : Neg.neg = Neg.neg) (_ : Mathlib.Meta.NormNum.IsInt (↑n) n)\n        (_ : Int.neg n = Int.neg n)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["measurable_id", "Measurable", "MeasurableSpace"],
  "name": "measurable_id'",
  "constType":
  "∀ {α : Type u_1} {x : MeasurableSpace α}, Measurable fun a => a",
  "constCategory": "Theorem"},
 {"references": ["MeasurableSpace"],
  "name": "MeasurableSingletonClass",
  "constType": "(α : Type u_7) → [inst : MeasurableSpace α] → Prop",
  "constCategory": "Other"},
 {"references": ["OrderedRing", "Ring"],
  "name": "OrderedRing.toRing",
  "constType": "{α : Type u} → [self : OrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HSub.hSub",
   "zero_sub",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegMonoid.sub_eq_add_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "congr",
   "Eq.symm",
   "congrArg",
   "neg_sub",
   "Eq.trans",
   "SubNegMonoid.zsmul_zero'",
   "id"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : SubtractionMonoid α], -0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.nonempty",
   "AddGroup",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "Nonempty",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "addGroupIsAddTorsor.proof_1",
  "constType": "∀ (G : Type u_1) [inst : AddGroup G], Nonempty G",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NormedCommRing",
   "NormedCommRing.toNormedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : NormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "Real.instAddMonoidReal",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "Real.orderedRing",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "IsROrC.charZero_isROrC",
   "SemilatticeSup.toSup",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_not_gt",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddTorsor.nonempty",
   "HDiv.hDiv",
   "addGroupIsAddTorsor",
   "instOfNat",
   "HPow.hPow",
   "instHSub",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "instHDiv",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "instDistribLattice",
   "Real.instRingReal",
   "DivisionRing.toInv",
   "Prod.instMeasurableSpace",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "Int",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Inv.inv",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Abs.abs",
   "Mathlib.Tactic.Ring.sub_pf",
   "Field.toCommRing",
   "MeasureTheory.Measure",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedRing.toOrderedSemiring",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "Field.toSemifield",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Countable",
   "sub_neg_of_lt",
   "Int.mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "le_max_left",
   "Bool.false",
   "Mathlib.Tactic.Ring.one_mul",
   "letFun",
   "Real.instPreorderReal",
   "Semifield.toDivisionSemiring",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toNeg",
   "Real.orderedAddCommGroup",
   "Mathlib.Tactic.Ring.mul_congr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "OrderedAddCommGroup.toPartialOrder",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.isROrC",
   "Real.commRing",
   "Real.instSupReal",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "ProbabilityTheory.max_entropy_le_entropy_sub",
   "Semiring.toNonAssocSemiring",
   "rdist",
   "FiniteRange",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "Real.instCommSemiringReal",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "And.casesOn",
   "LinearOrderedRing.toMax",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Real.field",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Real.partialOrder",
   "Nat.rawCast",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "DistribLattice.toLattice",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "LinearOrder.toMax",
   "Real.instAddGroupReal",
   "le_max_right",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.IndepFun",
   "OrderedAddCommGroup.toAddCommGroup",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Linarith.lt_irrefl",
   "DivisionRing.toRing",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "ProbabilityTheory.independent_copies_finiteRange",
   "MeasurableSub₂",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedField.toDiv",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Linarith.mul_nonpos",
   "instHPow",
   "Preorder.toLT",
   "Ring.toSub",
   "Linarith.mul_neg",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "CancelDenoms.neg_subst",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Real.strictOrderedRing",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "ProbabilityTheory.IdentDistrib.entropy_eq",
   "Eq.symm",
   "id",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "abs_le",
   "GT.gt",
   "Semiring.toOne",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Max.max",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Bool"],
  "name": "diff_ent_le_rdist",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [hG : MeasurableSpace G]\n  [inst : MeasurableSingletonClass G] [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G]\n  {X : Ω → G} {Y : Ω' → G} [inst_3 : FiniteRange X] [inst_4 : FiniteRange Y]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure μ] [inst_6 : MeasureTheory.IsProbabilityMeasure μ'],\n  Measurable X → Measurable Y → |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ']",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSeminormedCommRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedCommRing α] → NonUnitalSeminormedRing α",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.instMulReal",
   "DivisionRing.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toIntCast",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Real.instInvReal",
   "Nat",
   "Ne",
   "Rat.cast_mk'",
   "Real.ofCauchy_natCast",
   "Rat.instLinearOrderedRingRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.intCast",
   "Real.ofCauchy",
   "DivisionRing.toInv",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Real.ofCauchy_inv",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv",
   "StrictOrderedRing.toRing",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toDivisionSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "DivisionRing.toRing",
   "Real",
   "Real.ofCauchy_ratCast",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "Rat.mk'",
   "Real.ofCauchy_intCast",
   "Inv.mk",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Rat.instSupRat",
   "Real.ofCauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "RatCast.mk",
   "Rat",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "LinearOrderedCommRing.mk",
   "Rat.divisionRing",
   "Real.linearOrderedCommRing",
   "Nat.Coprime",
   "HMul.hMul",
   "Int.natAbs"],
  "name": "Real.instLinearOrderedFieldReal.proof_12",
  "constType":
  "∀ (n : ℤ) (d : ℕ) (hd : d ≠ 0) (h2 : Nat.Coprime (Int.natAbs n) d), ↑(Rat.mk' n d) = ↑n * (↑d)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "inferInstance",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Real",
   "Real.strictOrderedRing"],
  "name": "Real.orderedAddCommGroup",
  "constType": "OrderedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "Ring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ring.toNonAssocRing.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "pow_one",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "mul_one",
   "add_zero",
   "congrArg",
   "Nat.semiring",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "PosMulStrictMono",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toPosMulStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], PosMulStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "instLTNat",
   "rfl",
   "Iff.mpr",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.ble",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "instLENat",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Preorder.toLT",
   "Bool.true",
   "instOfNatNat",
   "Nat",
   "id",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "instNontrivial",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Nat.ble_eq",
   "StrictOrderedSemiring.to_charZero",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Eq.mp",
   "OrderedSemiring.toSemiring",
   "Bool",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.Positivity.pos_of_isNat",
  "constType":
  "∀ {A : Type u_1} {e : A} {n : ℕ} [inst : StrictOrderedSemiring A],\n  Mathlib.Meta.NormNum.IsNat e n → Nat.ble 1 n = true → 0 < e",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.instDvdNat",
   "Dvd.dvd",
   "decidable_of_iff'",
   "instDecidableAnd",
   "LE.le",
   "instLTNat",
   "And",
   "Nat.Prime",
   "instLENat",
   "instDecidableNot",
   "LT.lt",
   "Decidable",
   "Nat.decidable_dvd",
   "instOfNatNat",
   "Not",
   "Nat.prime_def_lt'",
   "Nat",
   "Nat.decLe",
   "Nat.decidableLoHi"],
  "name": "Nat.decidablePrime1",
  "constType": "(p : ℕ) → Decidable (Nat.Prime p)",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Int"],
  "name": "SubNegMonoid.zsmul",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "LinearOrder",
   "LinearOrder.max_def",
   "Real",
   "Real.nontrivial",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.commRing",
   "CommRing.mul_comm",
   "StrictOrderedRing.toNontrivial",
   "StrictOrderedRing.mul_pos",
   "CommRing",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "Nontrivial",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_6",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "Int",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), Semifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{α : Type u_1} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Monoid", "DivInvMonoid"],
  "name": "DivInvMonoid.toMonoid",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveInv.toInv",
   "InvolutiveInv.inv_inv",
   "InvolutiveInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_inv",
  "constType": "∀ {G : Type u_1} [inst : InvolutiveInv G] (a : G), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real.commRing",
   "AddGroup.toSubtractionMonoid",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Preorder.toLE",
   "Iff.mpr",
   "Real.instOneReal",
   "Eq",
   "Real.linearOrder",
   "Eq.mpr",
   "HasDistribNeg.toInvolutiveNeg",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Real.instInvReal",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Real.one_le_exp",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Function.comp",
   "Real.orderedSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LT.lt",
   "Real.instAddGroupReal",
   "LinearOrder.toPartialOrder",
   "inv_pos",
   "Inv.inv",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedSemifield.toInv",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "neg_neg",
   "le_total",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "zero_lt_one",
   "Real.exp_neg",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Or.elim",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Real.instLTReal",
   "lt_of_lt_of_le",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Real.exp",
   "Real.instZeroReal",
   "neg_nonneg",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "Real.instPreorderReal",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.exp_pos",
  "constType": "∀ (x : ℝ), 0 < Real.exp x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n + 0",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Nontrivial"],
  "name": "DivisionRing.toNontrivial",
  "constType": "∀ {K : Type u} [self : DivisionRing K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "One.toOfNat1",
   "zero_lt_one",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "one_pos",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), LinearOrderedField.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} → [self : InvolutiveNeg A] → Neg A",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → (coe : A → Set B) → Function.Injective coe → SetLike A B",
  "constCategory": "Other"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} → [self : Field K] → CommRing K",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp", "Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Set.Finite"],
  "name": "Set.toFinite",
  "constType": "∀ {α : Type u} (s : Set α) [inst : Finite ↑s], Set.Finite s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (motive : Mathlib.Meta.NormNum.IsNat (a + b) 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat (a + b) 0),\n  (∀ (h : a + b = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat (a + b) 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instHasEquiv",
   "Set",
   "Function.update",
   "dite",
   "Quotient.out_eq'",
   "Exists.intro",
   "Quotient",
   "QuotientAddGroup.leftRel",
   "QuotientAddGroup.instHasQuotientAddSubgroup",
   "QuotientAddGroup.mk",
   "Eq",
   "Set.range",
   "AddGroup",
   "Quotient.out'",
   "Eq.rec",
   "AddSubgroup",
   "HasQuotient.Quotient",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.symm",
   "Membership.mem",
   "Quotient.decidableEq",
   "congr_arg",
   "Classical.propDecidable",
   "Function.update_noteq",
   "Set.instMembershipSet",
   "And",
   "Quotient.mk''",
   "Function.update_same",
   "AddSubgroup.leftTransversals",
   "Not",
   "And.intro",
   "AddSubgroup.range_mem_leftTransversals",
   "HasEquiv.Equiv",
   "SetLike.coe"],
  "name": "AddSubgroup.exists_left_transversal",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (g : G), ∃ S ∈ AddSubgroup.leftTransversals ↑H, g ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "LinearOrderedCommRing"],
  "name": "LinearOrderedField.toLinearOrderedCommRing",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedField α] → LinearOrderedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "Trans.trans",
   "Eq.refl",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "invOf_mul_self_assoc'",
   "Commute",
   "True",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "Commute.eq",
   "Eq.ndrec",
   "of_eq_true",
   "instTransEq",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Commute.invOf_left",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible b], Commute b a → Commute (⅟b) a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["DivisionMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group.toDivisionMonoid.proof_1",
   "Group.toDivisionMonoid.proof_2",
   "DivisionMonoid.mk",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Group.toDivisionMonoid",
  "constType": "{G : Type u_1} → [inst : Group G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NormedAlgebra.id.proof_3",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "NormedField.toField",
   "Algebra.toRingHom",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "Algebra",
   "NormedAlgebra.id.proof_1",
   "NormedAlgebra",
   "DistribMulAction.toMulAction",
   "NormedAlgebra.id.proof_2",
   "NormedField",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedRing.toRing",
   "MulAction.toSMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Semifield.toDivisionSemiring",
   "Algebra.mk",
   "Algebra.id",
   "NormedSpace.toModule",
   "NormedAlgebra.mk"],
  "name": "NormedAlgebra.id",
  "constType": "(𝕜 : Type u_5) → [inst : NormedField 𝕜] → NormedAlgebra 𝕜 𝕜",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_right",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "NeZero.ne",
   "One",
   "One.toOfNat1"],
  "name": "one_ne_zero",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 1 ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "mul_left_comm",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₃ c : R} (b₁ : R) (b₂ : ℕ), a * b₃ = c → a * (b₁ ^ b₂ * b₃) = b₁ ^ b₂ * c",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "congr",
   "HMul.hMul",
   "congrArg",
   "CommMagma.toMul",
   "CommSemigroup",
   "Eq.trans",
   "mul_left_comm",
   "True",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "mul_mul_mul_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c d : G), a * b * (c * d) = a * c * (b * d)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toLinearOrder.proof_4",
   "Lattice.toLinearOrder.proof_2",
   "Min.mk",
   "Lattice.toLinearOrder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "IsTotal",
   "LinearOrder.mk",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Lattice.toLinearOrder.proof_3",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder",
  "constType":
  "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "le_max_left",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), a ≤ |a|",
  "constCategory": "Theorem"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real",
   "Set",
   "ENNReal.toReal",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.real",
  "constType":
  "{α : Type u_1} → {x : MeasurableSpace α} → MeasureTheory.Measure α → Set α → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Invertible.invOf",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "mul_one",
   "One.toOfNat1",
   "invOf_eq_right_inv",
   "Monoid.toMulOneClass",
   "Invertible",
   "Eq"],
  "name": "invOf_one'",
  "constType": "∀ {α : Type u} [inst : Monoid α] {x : Invertible 1}, ⅟1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "PseudoMetricSpace"],
  "name": "MetricSpace.toPseudoMetricSpace",
  "constType": "{α : Type u} → [self : MetricSpace α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references": ["Or", "em'", "Set", "Set.Infinite", "Set.Finite"],
  "name": "Set.infinite_or_finite",
  "constType": "∀ {α : Type u} (s : Set α), Set.Infinite s ∨ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "HEq.refl",
   "Ring",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsNat x x_1 → Prop) (x : α)\n  (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsNat x x_1),\n  (∀ (n : ℕ), motive (↑n) n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["cast", "HEq", "letFun", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["Set.image2", "instHAdd", "HAdd.hAdd", "Set", "Add", "Add.mk"],
  "name": "Set.add",
  "constType": "{α : Type u_2} → [inst : Add α] → Add (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "Mathlib.Meta.NormNum.invertibleOfMul",
   "HMul.hMul",
   "instMulNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Mathlib.Meta.NormNum.invertibleOfMul'.proof_1",
   "Invertible",
   "Eq",
   "Semiring.toNatCast"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul'",
  "constType":
  "{α : Type u_1} → [inst : Semiring α] → {a k b : ℕ} → [inst_1 : Invertible ↑a] → a = k * b → Invertible ↑b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : SeminormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "PartialOrder.toPreorder",
   "Iff",
   "LinearOrder",
   "not_congr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Iff.trans",
   "LinearOrder.toPartialOrder",
   "not_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_iff_lt_of_le_iff_le",
  "constType":
  "∀ {α : Type u} {β : Type u_3} [inst : LinearOrder α] [inst_1 : LinearOrder β] {a b : α} {c d : β},\n  (a ≤ b ↔ c ≤ d) → (b < a ↔ d < c)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.add_left_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NormedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toNormedRing : NormedRing α] → (∀ (x y : α), x * y = y * x) → NormedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "PosMulStrictMono",
   "Preorder",
   "Mul",
   "Subtype.mk",
   "Subtype",
   "CovariantClass.elim"],
  "name": "mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],\n  b < c → 0 < a → a * b < a * c",
  "constCategory": "Theorem"},
 {"references": ["Cardinal", "Cardinal.isEquivalent", "Quotient.mk'"],
  "name": "Cardinal.mk",
  "constType": "Type u → Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "Trans.trans",
   "Eq.refl",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "invOf_mul_self_assoc'",
   "Commute",
   "True",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "Commute.eq",
   "Eq.ndrec",
   "of_eq_true",
   "instTransEq",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Commute.invOf_right",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible b], Commute a b → Commute a ⅟b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec", "Ring.toNeg", "Ring", "Eq.refl", "Neg.neg", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.toAdd",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_add",
   "Ring.toNonAssocRing",
   "Int.instAddInt",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.add",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.add a' b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "OrderedRing",
   "StrictOrderedCommRing.toOrderedCommRing",
   "OrderedCommRing.toOrderedRing"],
  "name": "Real.orderedRing",
  "constType": "OrderedRing ℝ",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α], 0 ≤ 1 → ZeroLEOneClass α",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Ring.toSemiring",
   "Int",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references": ["NormedField", "DenselyNormedField"],
  "name": "DenselyNormedField.toNormedField",
  "constType": "{α : Type u_5} → [self : DenselyNormedField α] → NormedField α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "AddMonoid"],
  "name": "Real.instAddMonoidReal",
  "constType": "AddMonoid ℝ",
  "constCategory": "Definition"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{α : Type u} → [self : Inf α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "div_eq_mul_inv",
  "constType":
  "∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "instHDiv",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "propext",
   "GroupWithZero",
   "HMul.hMul",
   "div_eq_iff",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.1",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c) = (a = c * b)",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "Ring.toSemiring",
   "LinearOrderedRing.max_def",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "LinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [self : OrderedCommSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "SetLike.instPartialOrder.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "PartialOrder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Preorder.mk",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "SetLike.instPartialOrder.proof_3",
   "Set.instBooleanAlgebraSet",
   "Preorder.toLT",
   "SetLike.instPartialOrder.proof_2",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → PartialOrder A",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Equiv",
   "Zero",
   "OfNat.ofNat",
   "One",
   "Multiplicative",
   "One.mk",
   "FunLike.coe",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv"],
  "name": "instOneMultiplicative",
  "constType": "{α : Type u} → [inst : Zero α] → One (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "div_eq_mul_inv",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Ring.toNeg",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.cast_negOfNat",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HDiv.hDiv",
   "Nat",
   "neg_mul",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "DivisionRing.toDiv",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHDiv",
   "DivisionRing",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Int.negOfNat",
   "Mathlib.Meta.NormNum.IsRat",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "Int.cast",
   "congr",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsRat.neg_to_eq.match_1",
   "congrArg",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.neg_to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ} {a n' d' : α},\n  Mathlib.Meta.NormNum.IsRat a (Int.negOfNat n) d → ↑n = n' → ↑d = d' → a = -(n' / d')",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_8",
  "constType": "∀ {α : Type u_1} [inst : Ring α], NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Iff.intro",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero_of_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat", "Int.negOfNat", "Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.neg",
  "constType": "ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "instLENat",
   "Nat.lt_of_le_of_lt",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "instLTNat",
   "absurd",
   "Nat.succ",
   "rfl",
   "LE.le",
   "Eq",
   "Nat.le_antisymm.match_1"],
  "name": "Nat.le_antisymm",
  "constType": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "∀ {M : Type u_1} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "One.toOfNat1",
   "Real.rpow_def_of_nonneg",
   "Real.exp",
   "Real.instOneReal",
   "Eq",
   "ite",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "ne_of_gt",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "HMul.hMul",
   "le_of_lt",
   "if_neg",
   "id"],
  "name": "Real.rpow_def_of_pos",
  "constType":
  "∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), x ^ y = Real.exp (Real.log x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedField",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Eq.ndrec",
   "instHPow",
   "Real.instPowReal",
   "Real",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.pow_congr",
  "constType": "∀ {a a' b c : ℝ}, a = a' → a' ^ b = c → a ^ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Injective.injOn",
   "Equiv.Set.imageOfInjOn",
   "Set.Elem",
   "Function.Injective",
   "Set",
   "Set.image"],
  "name": "Equiv.Set.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Function.Injective f → ↑s ≃ ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace"],
  "name": "MeasureTheory.MeasureSpace.volume",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.mk",
   "NonUnitalSeminormedCommRing.mul_comm",
   "NonUnitalSeminormedRing.toNonUnitalRing"],
  "name": "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
  "constType":
  "{α : Type u_1} → [β : NonUnitalSeminormedCommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "CommMagma.toMul",
   "CommRing",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "mul_comm",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "id"],
  "name": "CancelDenoms.mul_subst",
  "constType":
  "∀ {α : Type u_1} [inst : CommRing α] {n1 n2 k e1 e2 t1 t2 : α},\n  n1 * e1 = t1 → n2 * e2 = t2 → n1 * n2 = k → k * (e1 * e2) = t1 * t2",
  "constCategory": "Theorem"},
 {"references": ["SeminormedRing", "PseudoMetricSpace"],
  "name": "SeminormedRing.toPseudoMetricSpace",
  "constType":
  "{α : Type u_5} → [self : SeminormedRing α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Zero",
   "AddGroup",
   "AddSubmonoid.zero",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubgroup.zero",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Zero ↥H",
  "constCategory": "Definition"},
 {"references":
  ["GroupWithZero.toDivisionMonoid.proof_1",
   "DivisionMonoid.mk",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "Inv.mk",
   "GroupWithZero.toDiv",
   "DivisionMonoid",
   "GroupWithZero.toDivisionMonoid.proof_2",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero",
   "GroupWithZero.zpow_zero'",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "Inv.inv",
   "GroupWithZero.toInv",
   "GroupWithZero.zpow",
   "GroupWithZero.zpow_neg'"],
  "name": "GroupWithZero.toDivisionMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : GroupWithZero G₀] → DivisionMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "NatCast",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "CauSeq.Completion.instNatCastCauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "NatCast.mk",
   "Abs.abs",
   "Rat.instSupRat",
   "Nat.cast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.natCast",
  "constType": "NatCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "NonUnitalNonAssocRing.toMul",
   "HEq",
   "DivisionRing.toRing",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ}\n  (motive : (x x_1 x_2 : α) → Mathlib.Meta.NormNum.IsRat x (Int.ofNat n) d → ↑n = x_1 → ↑d = x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : Mathlib.Meta.NormNum.IsRat x (Int.ofNat n) d) (x_4 : ↑n = x_1) (x_5 : ↑d = x_2),\n  (∀ (inv : Invertible ↑d),\n      motive (↑(Int.ofNat n) * ⅟↑d) ↑n ↑d (_ : Mathlib.Meta.NormNum.IsRat (↑(Int.ofNat n) * ⅟↑d) (Int.ofNat n) d)\n        (_ : ↑n = ↑n) (_ : ↑d = ↑d)) →\n    motive x x_1 x_2 x_3 x_4 x_5",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Unit",
   "Unit.unit",
   "ProbabilityTheory.kernel.IndepFun",
   "MeasureTheory.Measure.dirac",
   "autoParam",
   "MeasurableSpace",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.514"],
  "name": "ProbabilityTheory.IndepFun",
  "constType":
  "{Ω : Type u_1} →\n  {β : Type u_6} →\n    {γ : Type u_7} →\n      [inst : MeasurableSpace Ω] →\n        [inst_1 : MeasurableSpace β] →\n          [inst_2 : MeasurableSpace γ] → (Ω → β) → (Ω → γ) → autoParam (MeasureTheory.Measure Ω) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "Add",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.add",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubgroup.add",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Add ↥H",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible",
   "Eq"],
  "name": "Invertible.mk",
  "constType":
  "{α : Type u} → [inst : Mul α] → [inst_1 : One α] → {a : α} → (invOf : α) → invOf * a = 1 → a * invOf = 1 → Invertible a",
  "constCategory": "Other"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "setOf",
   "Subtype.val",
   "Set",
   "Subtype.range_coe",
   "Subtype",
   "Eq"],
  "name": "Subtype.range_coe_subtype",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop}, Set.range Subtype.val = {x | p x}",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [inst : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Field.toNontrivial",
   "EuclideanDomain.mk",
   "Semifield.toCommGroupWithZero",
   "Field.toEuclideanDomain.proof_3",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Field.toEuclideanDomain.proof_4",
   "Field",
   "Ring.toSub",
   "Field.toEuclideanDomain.proof_1",
   "HDiv.hDiv",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "HSub.hSub",
   "Field.toSemifield",
   "CommGroupWithZero.toCommMonoidWithZero",
   "instHMul",
   "And",
   "Field.toEuclideanDomain.proof_2",
   "HMul.hMul",
   "Field.toDiv",
   "EuclideanDomain",
   "Field.toDivisionRing",
   "Field.toEuclideanDomain.proof_5"],
  "name": "Field.toEuclideanDomain",
  "constType": "{K : Type u_1} → [inst : Field K] → EuclideanDomain K",
  "constCategory": "Definition"},
 {"references":
  ["add_left_iterate",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHSMul",
   "Function.minimalPeriod",
   "_private.Mathlib.GroupTheory.OrderOfElement.0.addOrderOf._eq_1",
   "Nat.iterate",
   "instHAdd",
   "HAdd.hAdd",
   "Function.isPeriodicPt_minimalPeriod",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Eq",
   "AddMonoid.toNatSMul",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Nat",
   "add_zero",
   "Eq.trans",
   "id",
   "addOrderOf"],
  "name": "addOrderOf_nsmul_eq_zero",
  "constType":
  "∀ {G : Type u_1} [inst : AddMonoid G] (x : G), addOrderOf x • x = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Multiplicative",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.mul_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "CommSemiring",
   "AddMonoid.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.val",
   "Finite.of_injective",
   "Finite",
   "Subtype.coe_injective",
   "Subtype"],
  "name": "Subtype.finite",
  "constType":
  "∀ {α : Sort u_4} [inst : Finite α] {p : α → Prop}, Finite { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "instHPow",
   "Monoid.toNatPow",
   "Monoid.npow_zero",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "pow_zero",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "Mul",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocRing α",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nontrivial.mk",
   "Exists.intro",
   "instDecidableEqNat",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "Bool.true",
   "AddMonoid.toZero",
   "Eq.rec",
   "instOfNatNat",
   "Nontrivial",
   "Bool",
   "Nat",
   "Nat.cast_one"],
  "name": "instNontrivial",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst : CharZero α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "instOfNatInt",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_zero'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSeminormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": [],
  "name": "LinearOrderedSemifield",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instSubReal",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Real.instAddCommGroupReal",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "sub_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Real.normedCommRing",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.isROrC.proof_6",
  "constType": "∀ (z w : ℝ), z * w = z * w - 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedField.toField",
   "Real",
   "Field"],
  "name": "Real.field",
  "constType": "Field ℝ",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.add",
   "Set.image2_empty_right",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.instEmptyCollectionSet",
   "Add",
   "Eq"],
  "name": "Set.add_empty",
  "constType": "∀ {α : Type u_2} [inst : Add α] {s : Set α}, s + ∅ = ∅",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real.instMulReal",
   "dite",
   "Real.rpow_def_of_nonneg",
   "MulZeroClass.toMul",
   "Nat.cast_zero",
   "Real.instOneReal",
   "Eq",
   "ite",
   "Real.decidableEq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Real.strictOrderedSemiring",
   "Real.instPowReal",
   "true_or",
   "le_trans",
   "not_false_eq_true",
   "LinearOrderedRing.noZeroDivisors",
   "Real.exp_add",
   "Eq.trans",
   "false_or",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real.partialOrder",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.5",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.instRingReal",
   "Real.normedCommRing",
   "Real.orderedSemiring",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.2",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "LE.le.lt_of_ne'",
   "eq_true",
   "False.elim",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Eq.mp",
   "congr",
   "mul_one",
   "Not",
   "OrderedSemiring.toPosMulMono",
   "congrArg",
   "mul_nonneg",
   "congrFun",
   "Real",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "Real.log_mul",
   "instHPow",
   "Real.rpow_def_of_pos",
   "MulZeroClass.toZero",
   "if_neg",
   "id",
   "eq_self",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Real.instLinearOrderedRingReal",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "One.toOfNat1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "StrictOrderedSemiring.toSemiring",
   "Real.exp",
   "LE.le",
   "Real.instZeroReal",
   "NormedCommRing.toSeminormedCommRing",
   "eq_false",
   "Real.log",
   "if_pos",
   "Eq.ndrec",
   "Real.semiring",
   "HMul.hMul",
   "not_true_eq_false",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1"],
  "name": "Real.mul_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → 0 ≤ y → (x * y) ^ z = x ^ z * y ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "Subtype.val",
   "Set",
   "HSub.hSub",
   "Sub",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Sub.mk",
   "Set.instMembershipSet",
   "AddSubgroup.sub.proof_1",
   "SubNegMonoid.toSub",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.sub",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Sub ↥H",
  "constCategory": "Definition"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NegZeroClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semifield.toCommSemiring",
   "Real",
   "DenselyNormedField.toNormedField",
   "NonUnitalRingHomClass.toMulHomClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "Eq.trans",
   "Real.denselyNormedField",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "Neg.neg",
   "RingHom.map_zero",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroOneClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.isROrC.proof_10",
  "constType": "(starRingEnd ℝ) 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.mk_le_mk_of_subset",
   "Set.instHasSubsetSet",
   "instLENat",
   "Set.Elem",
   "Set",
   "Set.Finite.lt_aleph0",
   "HasSubset.Subset",
   "Nat",
   "Cardinal.mk",
   "Nat.card",
   "Cardinal.toNat_le_of_le_of_lt_aleph0",
   "LE.le",
   "Set.Finite"],
  "name": "Nat.card_mono",
  "constType":
  "∀ {α : Type u_1} {s t : Set α}, Set.Finite t → s ⊆ t → Nat.card ↑s ≤ Nat.card ↑t",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt",
  "constType": "{α : Type u_1} → [inst : Ring α] → α → ℤ → Prop",
  "constCategory": "Other"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.one_mul",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["Top",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddGroup",
   "Top.top",
   "AddSubgroup.instTopAddSubgroup.proof_2",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.instTopAddSubgroup.proof_1",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Top.mk"],
  "name": "AddSubgroup.instTopAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Top (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mul_inv_rev",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegZeroMonoid.toSubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.neg_zero",
  "constType": "∀ {G : Type u_2} [self : SubNegZeroMonoid G], -0 = 0",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_trans", "Preorder"],
  "name": "LT.lt.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedSemiring.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoid.mul_comm",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "CommGroupWithZero.toDivisionCommMonoid.proof_1",
  "constType":
  "∀ {G₀ : Type u_1} [inst : CommGroupWithZero G₀] (a b : G₀), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inv",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["semiOutParam"],
  "name": "IsROrC",
  "constType": "semiOutParam (Type u_1) → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Sup", "_private.Mathlib.Data.Real.Basic.0.Real.sup", "Real", "Sup.mk"],
  "name": "Real.instSupReal",
  "constType": "Sup ℝ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemiring", "Ord"],
  "name": "LinearOrderedSemiring.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "constCategory": "Other"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Inv"],
  "name": "LinearOrderedField.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "AddMonoidWithOne",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "HEq.refl",
   "Unit.unit",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {n : ℕ}\n  (motive : (x x_1 : α) → Mathlib.Meta.NormNum.IsNat x n → ↑n = x_1 → Prop) (x x_1 : α)\n  (x_2 : Mathlib.Meta.NormNum.IsNat x n) (x_3 : ↑n = x_1),\n  (Unit → motive ↑n ↑n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : ↑n = ↑n)) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["Multiplicative.group.proof_2",
   "DivInvMonoid",
   "add_left_neg",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.toInv",
   "DivInvMonoid.zpow",
   "AddGroup",
   "Multiplicative",
   "Multiplicative.group.proof_4",
   "Group.mk",
   "Multiplicative.group.proof_3",
   "Multiplicative.group.proof_1",
   "Group",
   "Multiplicative.divInvMonoid",
   "DivInvMonoid.toDiv"],
  "name": "Multiplicative.group",
  "constType": "{α : Type u} → [inst : AddGroup α] → Group (Multiplicative α)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "instNatPowNat",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references": ["Int", "Semifield"],
  "name": "Semifield.zpow",
  "constType": "{α : Type u_4} → [self : Semifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Inv",
   "Inv.inv"],
  "name": "DivInvMonoid.div'",
  "constType": "{G : Type u} → [inst : Monoid G] → [inst : Inv G] → G → G → G",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv"],
  "name": "DivInvMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toMonoid : Monoid G] →\n    [toInv : Inv G] →\n      [toDiv : Div G] →\n        autoParam (∀ (a b : G), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G → G) →\n            autoParam (∀ (a : G), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  DivInvMonoid G",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toNormedCommRing.proof_2",
   "NormedField.toField",
   "Field.toCommRing",
   "NormedCommRing",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "CommRing.toRing",
   "NormedRing.mk",
   "NormedCommRing.mk",
   "NormedField.toNormedCommRing.proof_1",
   "NormedField.toNorm"],
  "name": "NormedField.toNormedCommRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Decidable.decide",
   "OrderedRing.toRing",
   "mul_assoc",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.commute_cast",
   "Bool.true",
   "Ring.toIntCast",
   "Int.cast_strictMono",
   "Int.cast_mul",
   "Nat",
   "mul_lt_mul_of_pos_left",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Invertible.invOf",
   "Int.decLt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.instLTInt",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Int.cast",
   "LT.lt",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isRat_lt_true.match_1",
   "congr",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddGroupWithOne.toIntCast",
   "of_decide_eq_true",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "StrictOrderedRing.toOrderedRing",
   "mul_mul_invOf_self_cancel'",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toNatCast",
   "LinearOrderedRing",
   "Preorder.toLT",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Eq.symm",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "Ring.toSemiring",
   "StrictOrderedSemiring.toSemiring",
   "OrderedRing.toPartialOrder",
   "Semiring.toOne",
   "pos_invOf_of_invertible_cast",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "HMul.hMul",
   "mul_lt_mul_of_pos_right",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nontrivial",
   "Bool",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono"],
  "name": "Mathlib.Meta.NormNum.isRat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Nontrivial α] {a b : α} {na nb : ℤ} {da db : ℕ},\n  Mathlib.Meta.NormNum.IsRat a na da → Mathlib.Meta.NormNum.IsRat b nb db → decide (na * ↑db < nb * ↑da) = true → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toRing : Ring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        [toNontrivial : Nontrivial α] → 0 ≤ 1 → (∀ (a b : α), 0 < a → 0 < b → 0 < a * b) → StrictOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_2",
   "Mathlib.Order.OmegaCompletePartialOrder._auxLemma.14",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "RelHomClass.toFunLike",
   "OrderHom.mk",
   "Eq.mpr",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (s : α),\n  (∀ (i : ℕ), x i ≤ s) → (fun c => ⨆ i, c i) x ≤ s",
  "constCategory": "Theorem"},
 {"references":
  ["Algebra.toRingHom",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "algebraMap",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.toLinearOrderedSemifield.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references": [],
  "name": "Neg",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "id"],
  "name": "neg_add_cancel_right",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + -b + b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OrderHom",
   "inferInstanceAs",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Nat",
   "Preorder",
   "Preorder.toLE",
   "OrderHomClass",
   "Nat.strictOrderedSemiring"],
  "name":
  "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
  "constType":
  "{α : Type u} → [inst : Preorder α] → OrderHomClass (OmegaCompletePartialOrder.Chain α) ℕ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Finset.Nonempty",
   "MeasureTheory.MeasureSpace.mk",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "MeasureTheory.IsProbabilityMeasure",
   "Exists.casesOn",
   "MeasureTheory.MeasureSpace.volume",
   "MeasureTheory.Measure",
   "ProbabilityTheory.exists_isUniform",
   "MeasurableSingletonClass",
   "And",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "FiniteRange",
   "Finset.toSet",
   "MeasureTheory.MeasureSpace",
   "Finset",
   "Measurable",
   "And.intro",
   "And.casesOn",
   "MeasurableSpace",
   "ProbabilityTheory.IsUniform"],
  "name": "ProbabilityTheory.exists_isUniform_measureSpace",
  "constType":
  "∀ {S : Type u} [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] (H : Finset S),\n  Finset.Nonempty H →\n    ∃ Ω mΩ U,\n      MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n        Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ (∀ (ω : Ω), U ω ∈ H) ∧ FiniteRange U",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.symm",
  "constType": "∀ {a b : Prop}, a ∨ b → b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "Finite",
   "instOfNatNat",
   "Nat",
   "Nat.card",
   "instLTNat",
   "True",
   "Nonempty",
   "Eq",
   "Nat.card_pos"],
  "name": "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α] [inst : Finite α], (0 < Nat.card α) = True",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "SemilatticeSup.toSup",
   "Sup",
   "Rat",
   "Rat.instSemilatticeSupRat"],
  "name": "Rat.instSupRat",
  "constType": "Sup ℚ",
  "constCategory": "Definition"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{α : Type u} → (α → α) → Inv α",
  "constCategory": "Other"},
 {"references":
  ["Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "Real.instSubReal",
   "Real",
   "ProbabilityTheory.entropy",
   "autoParam",
   "MeasureTheory.Measure.prod",
   "LinearOrderedField.toDiv",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "rdist",
   "AddCommGroup.toAddGroup",
   "HDiv.hDiv",
   "ProbabilityTheory.IdentDistrib.entropy_eq",
   "instOfNat",
   "Eq.trans",
   "eq_self",
   "_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.140",
   "instHSub",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "instHDiv",
   "Prod.snd",
   "HSub.hSub",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "AddGroup.toSubNegMonoid",
   "Prod.instMeasurableSpace",
   "of_eq_true",
   "rdist.proof_1",
   "congr",
   "Prod",
   "AddCommGroup",
   "congrArg",
   "MeasurableSpace",
   "congrFun"],
  "name": "ProbabilityTheory.IdentDistrib.rdist_eq",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {Ω'' : Type u_3} {Ω''' : Type u_4} {G : Type u_5} [mΩ : MeasurableSpace Ω]\n  {μ : MeasureTheory.Measure Ω} [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [mΩ'' : MeasurableSpace Ω'']\n  {μ'' : MeasureTheory.Measure Ω''} [mΩ''' : MeasurableSpace Ω'''] {μ''' : MeasureTheory.Measure Ω'''}\n  [hG : MeasurableSpace G] [inst : AddCommGroup G] {X : Ω → G} {Y : Ω' → G} {X' : Ω'' → G} {Y' : Ω''' → G},\n  ProbabilityTheory.IdentDistrib X X' →\n    ProbabilityTheory.IdentDistrib Y Y' → d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ''']",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.instSemigroupReal",
   "Real.instMulReal",
   "Real",
   "Eq.refl",
   "HMul.hMul",
   "id",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.mul_pf_left",
  "constType": "∀ {a₂ b c : ℝ} (a₁ : ℝ), a₂ * b = c → a₁ * a₂ * b = a₁ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "HPow.hPow",
   "InvOneClass.toOne",
   "Exists",
   "OfNat.ofNat",
   "DivInvOneMonoid.toInvOneClass",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "Nat",
   "DivisionMonoid.toDivInvOneMonoid",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "IsPGroup",
  "constType": "ℕ → (G : Type u_1) → [inst : Group G] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "NatCast.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Nat",
   "CauSeq.instNatCast",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instNatCastCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → NatCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "LinearOrderedSemifield.toInv",
   "mul_lt_mul_left",
   "PartialOrder.toPreorder",
   "div_eq_mul_inv",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "Semifield.toCommGroupWithZero",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Preorder.toLT",
   "inv_lt_inv",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "of_eq_true",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "LT.lt",
   "congr",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "congrArg",
   "congrFun",
   "Inv.inv"],
  "name": "div_lt_div_left",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < a → 0 < b → 0 < c → (a / b < a / c ↔ c < b)",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "CompletelyDistribLattice.toCompleteLattice",
   "Mathlib.MeasureTheory.Measure.Typeclasses._auxLemma.3",
   "PartialOrder.toPreorder",
   "MeasureTheory.IsFiniteMeasure.mk",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "One.toOfNat1",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.IsFiniteMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "Set.univ",
   "True",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "congrArg",
   "Eq.trans",
   "MeasurableSpace",
   "congrFun"],
  "name": "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsProbabilityMeasure μ],\n  MeasureTheory.IsFiniteMeasure μ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "LE",
   "add_le_add_iff_right",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_5",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "FunLike.coe",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "PartialOrder"],
  "name": "OmegaCompletePartialOrder.mk",
  "constType":
  "{α : Type u_1} →\n  [toPartialOrder : PartialOrder α] →\n    (ωSup : OmegaCompletePartialOrder.Chain α → α) →\n      (∀ (c : OmegaCompletePartialOrder.Chain α) (i : ℕ), c i ≤ ωSup c) →\n        (∀ (c : OmegaCompletePartialOrder.Chain α) (x : α), (∀ (i : ℕ), c i ≤ x) → ωSup c ≤ x) →\n          OmegaCompletePartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toInv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.inv_zero",
  "constType": "∀ {α : Type u_4} [self : Semifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references": ["Div", "Semifield"],
  "name": "Semifield.toDiv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Div α",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Complex.cpow_one",
   "True",
   "Real.instOneReal",
   "Eq",
   "Complex.re",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.rpow_one",
  "constType": "∀ (x : ℝ), x ^ 1 = x",
  "constCategory": "Theorem"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} → [self : Field K] → DivisionRing K",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.left",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_left",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ s",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.mk",
   "Nat.decLt",
   "Nat",
   "compareOfLessAndEq",
   "instLTNat",
   "instDecidableEqNat",
   "Ord"],
  "name": "instOrdNat",
  "constType": "Ord ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Set.image2", "Set.add", "instHAdd", "HAdd.hAdd", "Set", "Add", "rfl", "Eq"],
  "name": "Set.image2_add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α}, Set.image2 (fun x x_1 => x + x_1) s t = s + t",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "One.toOfNat1",
   "DivisionSemiring.zpow",
   "Int",
   "Eq"],
  "name": "DivisionSemiring.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), DivisionSemiring.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["MeasurableSpace.prod", "Prod", "MeasurableSpace"],
  "name": "Prod.instMeasurableSpace",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → [m₁ : MeasurableSpace α] → [m₂ : MeasurableSpace β] → MeasurableSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Real.instMulReal",
   "Real",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Real.instOneReal",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "Real.semiring",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.RPowRing.atom_pf",
  "constType": "∀ (a : ℝ), a = a * 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "PFR.Main._auxLemma.4",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.ofCauchy",
  "constType": "CauSeq.Completion.Cauchy abs → ℝ",
  "constCategory": "Other"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Zero M] → [inst : Zero N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1004"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.neg",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "AddMonoid.toZero",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Mathlib.Tactic.Ring.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Or", "em", "Eq"],
  "name": "eq_or_ne",
  "constType": "∀ {α : Sort u_1} (x y : α), x = y ∨ x ≠ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.mk_le",
   "Real",
   "Real.instLEReal",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.ndrec",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "le_refl",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_1",
  "constType": "∀ (a : ℝ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["sub_add_cancel",
   "SubNegMonoid.toSub",
   "AddTorsor",
   "AddTorsor.mk",
   "AddGroup",
   "VSub.mk",
   "SubNegMonoid.toAddMonoid",
   "Sub.sub",
   "AddMonoid.toAddAction",
   "add_sub_cancel",
   "AddGroup.toSubNegMonoid",
   "addGroupIsAddTorsor.proof_1"],
  "name": "addGroupIsAddTorsor",
  "constType": "(G : Type u_1) → [inst : AddGroup G] → AddTorsor G G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.zero_mul",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "Std.Classes.Order._auxLemma.3",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DivisionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Trans",
   "Preorder.toLT",
   "lt_of_lt_of_le",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLtToLTLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LT.lt LE.le LT.lt",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{α : Type u_1} → [inst : Mul α] → [self : HasDistribNeg α] → InvolutiveNeg α",
  "constCategory": "Definition"},
 {"references": ["Real", "Pow.mk", "Pow", "Real.rpow"],
  "name": "Real.instPowReal",
  "constType": "Pow ℝ ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Set.Nonempty",
   "AddCommGroup.toAddCommMonoid",
   "And.left",
   "instLTNat",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Eq",
   "mul_pos_iff",
   "Real.linearOrder",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Nat.cast",
   "Set.Elem",
   "or_false",
   "Set.Finite.image2",
   "Nat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "Set.add",
   "Finite",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMagma.toAdd",
   "Real.orderedSemiring",
   "And",
   "instHMul",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "Set",
   "Real",
   "LT.lt.trans_le",
   "Semiring.toMonoidWithZero",
   "Ring.toNonAssocRing",
   "Set.Nonempty.add",
   "Set.toFinite",
   "True",
   "Zero.toOfNat0",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
   "Set.nonempty_coe_sort",
   "and_false",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Init.Order.Defs._auxLemma.1",
   "instOfNatNat",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "False",
   "Real.instLinearOrderedRingReal",
   "Real.instLTReal",
   "instHAdd",
   "Real.nontrivial",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Set.Finite",
   "Real.instZeroReal",
   "eq_false",
   "Set.finite_coe_iff",
   "Real.instPreorderReal",
   "letFun",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2"],
  "name": "PFR_conjecture_pos_aux'",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ},\n  Set.Nonempty A → ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) → 0 < ↑(Nat.card ↑A) ∧ 0 < ↑(Nat.card ↑(A + A)) ∧ 0 < K",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{α : Type u} → (α → α → α) → Div α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddMonoidHom.map_zero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "congrArg",
   "Eq.trans",
   "AddMonoidHom",
   "AddMonoidHom.id",
   "congrFun"],
  "name": "Real.isROrC.proof_1",
  "constType": "(AddMonoidHom.id ℝ) 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Preorder.toLT",
   "Real.lattice",
   "LT.lt",
   "Classical.propDecidable",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "Real.instIsTotalRealLeInstLEReal",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Real.linearOrder",
  "constType": "LinearOrder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "DiscreteMeasurableSpace",
   "MeasurableSet",
   "DiscreteMeasurableSpace.forall_measurableSet",
   "MeasurableSpace"],
  "name": "measurableSet_discrete",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : DiscreteMeasurableSpace α] (s : Set α), MeasurableSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Real.linearOrder",
   "inferInstance",
   "instDecidableEq",
   "Real",
   "Decidable",
   "Eq"],
  "name": "Real.decidableEq",
  "constType": "(a b : ℝ) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["One", "Real", "One.mk", "_private.Mathlib.Data.Real.Basic.0.Real.one"],
  "name": "Real.instOneReal",
  "constType": "One ℝ",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "PartialOrder.toPreorder",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "LE.le",
   "OrderedCommMonoid",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toCommMonoid : CommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b) → OrderedCommMonoid α",
  "constCategory": "Other"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.Measure", "MeasurableSpace"],
  "name": "MeasureTheory.IsProbabilityMeasure",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_9",
  "constType": "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.toFinset", "Set", "Finset", "Set.Finite.fintype", "Set.Finite"],
  "name": "Set.Finite.toFinset",
  "constType": "{α : Type u} → {s : Set α} → Set.Finite s → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ≠ a + c ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Nat.cast_zero",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Nat.mono_cast",
   "AddMonoidWithOne.toOne",
   "Eq.rec",
   "AddMonoid.toZero",
   "CovariantClass",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_nonneg'",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalCommRing.mk",
  "constType":
  "{α : Type u} → [toNonUnitalRing : NonUnitalRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "eq_of_heq",
   "Ring.toIntCast",
   "Ring",
   "Eq.refl",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1) → Prop)\n  (x : α) (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1)),\n  (∀ (a : ℕ), motive (↑(Int.ofNat a)) a (_ : Mathlib.Meta.NormNum.IsInt (↑(Int.ofNat a)) (Int.ofNat a))) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedRingReal",
   "Real",
   "Eq.le",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "abs_mul",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Lattice.toSemilatticeSup"],
  "name": "Real.normedCommRing.proof_1",
  "constType": "∀ (x y : ℝ), |x * y| ≤ |x| * |y|",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instHSMul",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.Measure.prod",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "ProbabilityTheory.IndepFun.comp",
   "inferInstance",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "one_smul",
   "MonoidWithZero.toMonoid",
   "Measurable.aemeasurable",
   "MeasureTheory.Measure.map_snd_prod",
   "MonoidWithZero.toMulActionWithZero",
   "HSMul.hSMul",
   "MeasureTheory.Measure.instMulAction",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "measurable_snd",
   "Prod.snd",
   "IsScalarTower.right",
   "Function.comp",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "MeasureTheory.Measure.prod.measureSpace",
   "instENNRealZero",
   "ProbabilityTheory.IdentDistrib.mk",
   "Prod.instMeasurableSpace",
   "And",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.map_fst_prod",
   "And.intro",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun",
   "congrFun",
   "Exists",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "measurable_fst",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.instSFinite",
   "MeasureTheory.Measure.instSMul",
   "ProbabilityTheory.indepFun_fst_snd",
   "Exists.intro",
   "rfl",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "IsScalarTower.left",
   "MeasureTheory.Measure.map_map",
   "Measurable",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "eq_self",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Set.univ",
   "Measurable.comp",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Prod",
   "MeasureTheory.Measure.instIsProbabilityMeasureProdToMeasurableSpaceMeasureSpaceVolume"],
  "name": "ProbabilityTheory.independent_copies_two",
  "constType":
  "∀ {α : Type u_7} {β : Type u_9} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {Ω : Type u} {Ω' : Type v}\n  [inst_2 : MeasureTheory.MeasureSpace Ω] [inst_3 : MeasureTheory.MeasureSpace Ω']\n  [inst_4 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X : Ω → α} {Y : Ω' → β},\n  Measurable X →\n    Measurable Y →\n      ∃ Ω'' m'' X' Y',\n        MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n          Measurable X' ∧\n            Measurable Y' ∧\n              ProbabilityTheory.IndepFun X' Y' ∧\n                ProbabilityTheory.IdentDistrib X' X ∧ ProbabilityTheory.IdentDistrib Y' Y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero", "Real", "Zero.mk", "_private.Mathlib.Data.Real.Basic.0.Real.zero"],
  "name": "Real.instZeroReal",
  "constType": "Zero ℝ",
  "constCategory": "Definition"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Invertible",
   "Preorder.toLE",
   "Iff.mpr",
   "Semiring.toNatCast",
   "Eq",
   "OrderedRing.toRing",
   "Decidable.decide",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.commute_cast",
   "Ring.toIntCast",
   "Bool.true",
   "Int.cast_mul",
   "Nat",
   "Eq.trans",
   "invOf_nonneg",
   "StrictOrderedRing.toPartialOrder",
   "Invertible.invOf",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "mul_le_mul_of_nonneg_left",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Eq.mp",
   "congr",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toMulPosMono",
   "congrArg",
   "OrderedSemiring.toPosMulMono",
   "Int",
   "Int.instLEInt",
   "congrFun",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Int.decLe",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddGroupWithOne.toIntCast",
   "of_decide_eq_true",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "StrictOrderedRing.toOrderedRing",
   "mul_mul_invOf_self_cancel'",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toNatCast",
   "LinearOrderedRing",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Eq.symm",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.cast_nonneg",
   "Ring.toSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "OrderedRing.toPartialOrder",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun",
   "HMul.hMul",
   "Int.cast_mono",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Bool",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Mathlib.Meta.NormNum.isRat_le_true.match_1"],
  "name": "Mathlib.Meta.NormNum.isRat_le_true",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] {a b : α} {na nb : ℤ} {da db : ℕ},\n  Mathlib.Meta.NormNum.IsRat a na da →\n    Mathlib.Meta.NormNum.IsRat b nb db → decide (Int.mul na (Int.ofNat db) ≤ Int.mul nb (Int.ofNat da)) = true → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.577"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.zero",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Prod.snd",
   "Subtype.val",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Prod.fst",
   "AddMonoid.toAddZeroClass",
   "Equiv.ofBijective",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Set.instMembershipSet",
   "instHMul",
   "Nat.card_congr",
   "AddGroup",
   "Set.Elem",
   "Nat.card_prod",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.IsComplement",
   "HMul.hMul",
   "Prod",
   "Nat",
   "instMulNat",
   "Nat.card",
   "Eq.symm",
   "Eq.trans"],
  "name": "AddSubgroup.IsComplement.card_mul_card",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G},\n  AddSubgroup.IsComplement S T → Nat.card ↑S * Nat.card ↑T = Nat.card G",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_of_le_of_lt.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.mk",
  "constType": "{K : Type u} → (ℚ → K) → RatCast K",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Eq.rec",
   "Set.mem_image",
   "And.intro",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Set.image_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {s : Set α}, (∀ a ∈ s, f a = g a) → f '' s = g '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn", "letFun", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "Preorder",
   "add_lt_add_right",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "instTransEq_1",
   "Function.swap",
   "AddZeroClass.toZero",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "instTransLtToLTLeToLE",
   "AddZeroClass"],
  "name": "add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedRing"],
  "name": "Real.strictOrderedRing",
  "constType": "StrictOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Set.Nonempty",
   "And.left",
   "instLTNat",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Eq",
   "mul_pos_iff",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Nat.cast",
   "Set.Elem",
   "or_false",
   "Set.Finite.image2",
   "Nat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
   "Eq.trans",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "Finite",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "Set.Nonempty.sub",
   "And",
   "instHMul",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "Set",
   "Real",
   "LT.lt.trans_le",
   "Semiring.toMonoidWithZero",
   "Ring.toNonAssocRing",
   "Set.toFinite",
   "True",
   "Zero.toOfNat0",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
   "Set.nonempty_coe_sort",
   "and_false",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Set.sub",
   "Mathlib.Init.Order.Defs._auxLemma.1",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "False",
   "Real.instLinearOrderedRingReal",
   "Real.instLTReal",
   "Real.nontrivial",
   "HSub.hSub",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Set.Finite",
   "Real.instZeroReal",
   "eq_false",
   "Set.finite_coe_iff",
   "Real.instPreorderReal",
   "letFun",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2"],
  "name": "PFR_conjecture_pos_aux",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ},\n  Set.Nonempty A → ↑(Nat.card ↑(A - A)) ≤ K * ↑(Nat.card ↑A) → 0 < ↑(Nat.card ↑A) ∧ 0 < ↑(Nat.card ↑(A - A)) ∧ 0 < K",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] → [inst_1 : Zero N] → [self : ZeroHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["Complex.cpow", "Complex", "Pow.mk", "Pow"],
  "name": "Complex.instPowComplex",
  "constType": "Pow ℂ ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare", "Ordering", "Eq.refl", "instOrdNat", "Nat", "Eq"],
  "name": "Nat.linearOrder.proof_3",
  "constType": "∀ (a b : ℕ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["Countable",
   "MeasurableSingletonClass",
   "SetCoe.countable",
   "DiscreteMeasurableSpace",
   "Set",
   "DiscreteMeasurableSpace.mk",
   "Set.Countable.measurableSet",
   "Set.to_countable",
   "MeasurableSpace"],
  "name": "MeasurableSingletonClass.toDiscreteMeasurableSpace",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] [inst_2 : Countable α],\n  DiscreteMeasurableSpace α",
  "constCategory": "Definition"},
 {"references": ["outParam", "AddGroup"],
  "name": "AddTorsor",
  "constType":
  "(G : outParam (Type u_1)) → Type u_2 → [inst : outParam (AddGroup G)] → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["Eq.rec", "le_refl", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "CauchySeq",
   "Metric.mem_nhds_iff",
   "CompleteSpace",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSupReal",
   "Mathlib.Topology.Instances.Real._auxLemma.4",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "Eq.mpr",
   "Iff.mp",
   "Filter.Tendsto",
   "Filter",
   "Metric.ball",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "CauSeq.instSubCauSeq",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Nat.instLatticeNat",
   "Real.instRingReal",
   "Set.instMembershipSet",
   "And",
   "CauSeq.equiv_lim",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LT.lt",
   "instInhabitedNat",
   "Filter.atTop",
   "Exists",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "Real",
   "Set",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Exists.imp",
   "Exists.intro",
   "Abs.abs",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Metric.cauchySeq_iff'",
   "instLENat",
   "Preorder.toLT",
   "Filter.map",
   "Lattice.toSemilatticeSup",
   "UniformSpace.toTopologicalSpace",
   "instNonempty",
   "id",
   "instMembershipSetFilter",
   "Neg.toHasAbs",
   "Membership.mem",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "CauSeq.lim",
   "Real.instLinearOrderedRingReal",
   "Set.preimage",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Metric.complete_of_cauchySeq_tendsto",
   "Real.pseudoMetricSpace",
   "CauSeq",
   "GT.gt",
   "Real.instZeroReal",
   "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
   "PseudoMetricSpace.toDist",
   "Set.instHasSubsetSet",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun",
   "Mathlib.Topology.Instances.Real._auxLemma.3",
   "Subtype.mk"],
  "name": "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
  "constType": "CompleteSpace ℝ",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references": ["refPackage", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.X₀₂",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → Ω₀₂ → G",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Cardinal.toNat_congr", "Nat", "Nat.card", "Eq"],
  "name": "Nat.card_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2}, α ≃ β → Nat.card α = Nat.card β",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["Add", "Int.add", "Int", "Add.mk"],
  "name": "Int.instAddInt",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_4",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "Eq"],
  "name": "SubNegMonoid.sub_eq_add_neg",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommSemiring",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring",
   "Real.instStrictOrderedCommRingReal",
   "Real"],
  "name": "Real.strictOrderedCommSemiring",
  "constType": "StrictOrderedCommSemiring ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Complex.ofReal'",
   "HPow.hPow",
   "Complex.instPowComplex",
   "instHPow",
   "Real",
   "Complex",
   "Complex.re"],
  "name": "Real.rpow",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instSubReal",
   "Real.commRing",
   "MulZeroClass.mul_zero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Complex.exp_add",
   "Eq",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "MulZeroClass.toZero",
   "sub_zero",
   "Complex.ofReal_add",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Complex.ofReal'",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "Complex.exp_ofReal_im",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.instAddComplex",
   "Real.exp",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.im",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Complex",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Real.exp_add",
  "constType": "∀ (x y : ℝ), Real.exp (x + y) = Real.exp x * Real.exp y",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.inv'", "Real", "Inv", "Inv.mk"],
  "name": "Real.instInvReal",
  "constType": "Inv ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Function.swap",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "add_le_add_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b c : α},\n  b + a ≤ c + a ↔ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "instHDiv",
   "MeasureTheory.Measure.map",
   "Prod.snd",
   "Real.natCast",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.407",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "ProbabilityTheory.entropy",
   "Prod.fst",
   "MeasureTheory.Measure.prod",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "LinearOrderedField.toDiv",
   "Prod.instMeasurableSpace",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "rdist.proof_1",
   "Prod",
   "AddCommGroup.toAddGroup",
   "HDiv.hDiv",
   "AddCommGroup",
   "instOfNat",
   "MeasurableSpace",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.380"],
  "name": "rdist",
  "constType":
  "{Ω : Type u_1} →\n  {Ω' : Type u_2} →\n    {G : Type u_5} →\n      [mΩ : MeasurableSpace Ω] →\n        [mΩ' : MeasurableSpace Ω'] →\n          [hG : MeasurableSpace G] →\n            [inst : AddCommGroup G] →\n              (Ω → G) →\n                (Ω' → G) → autoParam (MeasureTheory.Measure Ω) _auto✝ → autoParam (MeasureTheory.Measure Ω') _auto✝¹ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
   "OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "mul_le_mul",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
   "Semiring.toNatCast",
   "Real.instOneReal",
   "inferInstance",
   "Real.linearOrder",
   "Nat.ble",
   "IsROrC.charZero_isROrC",
   "Set.Elem",
   "PFR_conjecture_pos_aux'",
   "Real.instPowReal",
   "instTransLtToLTLeToLE",
   "LinearOrderedField.toLinearOrderedSemifield",
   "AddTorsor.nonempty",
   "le_of_lt",
   "addGroupIsAddTorsor",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "Subtype",
   "Nat.prime_two",
   "Nat.strictOrderedSemiring",
   "add_assoc",
   "div_lt_iff",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AddCommMagma.toAdd",
   "DivisionRing.toInv",
   "PartialOrder",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "propext",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "congr",
   "LinearOrder.toPartialOrder",
   "AddSubgroup.toAddCommGroup",
   "And.intro",
   "MonoidWithZero.toZero",
   "Real.rpow_one",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "DivisionRing.toDivisionSemiring",
   "sub_nonpos_of_le",
   "Set",
   "GE.ge",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Mathlib.Tactic.RPowRing.mul_pf_left",
   "Int.rawCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.sub_pf",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "div_lt_div_of_lt_left",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Nat.linearOrderedCommMonoidWithZero",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.mul_add",
   "instTransLeToLE",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "mul_le_mul_of_nonneg_right",
   "Monoid.toMulOneClass",
   "GroupWithZero.toMonoidWithZero",
   "LE.le",
   "GroupWithZero.toDiv",
   "Real.instDivisionRingReal",
   "NormedCommRing.toSeminormedCommRing",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "eq_div_iff",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "AddGroup.toSubtractionMonoid",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "Nat.cast_one",
   "Set.card_add_le",
   "neg_neg_of_pos",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HasSubset.Subset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSubgroup.exists_left_transversal_of_le",
   "Real.orderedSemiring",
   "lt_of_not_ge",
   "MulZeroOneClass.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "True.intro",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "cast",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "mul_one",
   "mul_pos",
   "Mathlib.Tactic.Ring.mul_one",
   "instTransLeToLELtToLT",
   "Int.ofNat",
   "LinearOrderedSemifield.toSemifield",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.9",
   "Mathlib.Tactic.RPowRing.pow_congr",
   "ne_of_gt",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "le_or_lt",
   "Membership.mem",
   "eq_self",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Nat.cast_nonneg",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "PFR_conjecture_aux",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Bool",
   "instMulNat",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "LT.lt.ne'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.cast_pos",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.1",
   "mul_div_assoc'",
   "Set.Nonempty",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isRat_add",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Real.strictOrderedSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HDiv.hDiv",
   "mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "Or",
   "Set.add",
   "Real.instRingReal",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.normedCommRing",
   "CommMagma.toMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Real.rpow_pos_of_pos",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "OrderedSemiring.toMulPosMono",
   "AddCommGroup",
   "OrderedSemiring.toPosMulMono",
   "Finite.of_fintype",
   "Int",
   "SetLike.coe",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Real.rpow_le_rpow",
   "True",
   "Real.one_rpow",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.RPowRing.atom_pow_pf",
   "AddMonoid.toAddSemigroup",
   "one_pos",
   "div_div_eq_mul_div",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Mathlib.Meta.NormNum.isRat_mul",
   "Mathlib.Tactic.RPowRing.pow_pf",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Real.nontrivial",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Mathlib.Tactic.Ring.neg_add",
   "Countable",
   "Set.instHasSubsetSet",
   "Int.mul",
   "Real.instPreorderReal",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "zero_lt_two",
   "Real.instMulReal",
   "Real.instLEReal",
   "ElementaryAddCommGroup.exists_subgroup_subset_card_le",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Eq",
   "Nat.linearOrder",
   "Fintype",
   "Eq.mpr",
   "DivisionCommMonoid.toDivisionMonoid",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "DivisionSemiring.toGroupWithZero",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Finite",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instTransEq_1",
   "instHMul",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "mul_le_mul_of_nonneg_left",
   "div_pos",
   "Mathlib.Meta.NormNum.isInt_neg",
   "congrArg",
   "OrderedAddCommGroup.toAddCommGroup",
   "Zero",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "Mathlib.Tactic.RPowRing.pow_pos",
   "le_of_eq",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Nat.card_pos",
   "mul_comm",
   "Zero.toOfNat0",
   "instLENat",
   "one_mul",
   "Preorder.toLT",
   "instHPow",
   "AddSubgroup",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "LT.lt.le",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "lt_of_le_of_lt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Set.addSemigroup",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.RPowRing.mul_pf_right",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "PFR_conjecture",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ} [inst_2 : Countable G]\n  [inst_3 : ElementaryAddCommGroup G 2] [inst_4 : Fintype G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) →\n      ∃ H c, ↑(Nat.card ↑c) < 2 * K ^ 12 ∧ Nat.card ↥H ≤ Nat.card ↑A ∧ A ⊆ c + ↑H",
  "constCategory": "Theorem"},
 {"references":
  ["VSub.vsub",
   "outParam",
   "AddTorsor",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddAction.toVAdd",
   "VSub",
   "HVAdd.hVAdd",
   "instHVAdd",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "Nonempty",
   "Eq"],
  "name": "AddTorsor.mk",
  "constType":
  "{G : outParam (Type u_1)} →\n  {P : Type u_2} →\n    [inst : outParam (AddGroup G)] →\n      [toAddAction : AddAction G P] →\n        [toVSub : VSub G P] →\n          [nonempty : Nonempty P] →\n            (∀ (p1 p2 : P), p1 -ᵥ p2 +ᵥ p2 = p1) → (∀ (g : G) (p : P), g +ᵥ p -ᵥ p = g) → AddTorsor G P",
  "constCategory": "Other"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.mul", "Mul", "Mul.mk"],
  "name": "Real.instMulReal",
  "constType": "Mul ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Neg.neg",
   "Sub",
   "Real.instNegReal",
   "Sub.mk"],
  "name": "Real.instSubReal",
  "constType": "Sub ℝ",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "one_le_two",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "zero_lt_one",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "zero_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.mul_one",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "of_eq_true",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "congr",
   "AddCommSemigroup.toAddSemigroup",
   "congrArg",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "Eq.trans",
   "True",
   "Eq"],
  "name": "add_add_add_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Distrib.rightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "add_mul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b c₁ a₂ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "DivisionRing", "Rat", "Rat.field", "Field.toDivisionRing"],
  "name": "Rat.divisionRing",
  "constType": "DivisionRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Ring",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Real.instLTReal",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "LE.le",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "And",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Iff",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "LT.lt",
   "Rat.instNegRat",
   "congr",
   "Not",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_3",
  "constType": "∀ (a b : ℝ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u_1} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "AddCommSemigroup.toAddCommMagma",
   "Covariant",
   "covariant_flip_iff",
   "flip",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommSemigroup",
   "AddCommMagma.to_isCommutative",
   "isSymmOp_of_isCommutative",
   "CovariantClass.mk",
   "AddCommMagma.toAdd",
   "Iff.mpr",
   "CovariantClass.elim"],
  "name": "covariant_swap_add_of_covariant_add",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) [inst : AddCommSemigroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemifield", "Int"],
  "name": "LinearOrderedSemifield.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "HAdd.hAdd",
   "AddCommGroup.toAddCommMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddGroup",
   "AddCommMonoid.add_comm",
   "HSMul.hSMul",
   "AddCommGroup.toAddGroup",
   "Nat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg",
   "AddCommGroup.mk",
   "AddCommMonoid",
   "instHSub",
   "instHAdd",
   "AddGroup.mk",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "Function.Injective.addGroup",
   "AddMonoid.toNatSMul",
   "AddGroup.add_left_neg",
   "Function.Injective",
   "SubNegMonoid.toAddMonoid",
   "Function.Injective.addCommMonoid",
   "AddCommGroup",
   "Add",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Function.Injective.addCommGroup",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : AddCommGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddCommGroup M₁",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocRing α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "LT.lt.le",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.rpow_pos_of_pos",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "Real.rpow_mul",
   "HMul.hMul",
   "Real.mul_rpow",
   "id"],
  "name": "Mathlib.Tactic.RPowRing.pow_pf",
  "constType":
  "∀ {a b e₂ b' e₁ : ℝ}, 0 < a → 0 < b → b ^ e₂ = b' → (a ^ e₁ * b) ^ e₂ = a ^ (e₁ * e₂) * b'",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Nat.cast_commute",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Ring",
   "Commute.invOf_right",
   "Int.cast_mul",
   "invertibleMul",
   "Nat",
   "Eq.trans",
   "Mathlib.Meta.NormNum.invertibleOfMul'",
   "Invertible.invOf",
   "congr_arg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Commute.right_comm",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Int.cast",
   "Eq.mp",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Commute.invOf_left",
   "AddGroupWithOne.toIntCast",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "mul_mul_invOf_self_cancel'",
   "True",
   "Ring.toNonAssocRing",
   "Nat.cast_mul",
   "mul_mul_invOf_self_cancel",
   "AddMonoidWithOne.toNatCast",
   "Eq.symm",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsRat",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "instMulNat",
   "Nat.mul"],
  "name": "Mathlib.Meta.NormNum.isRat_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {na nb nc : ℤ} {da db dc k : ℕ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsRat a na da →\n      Mathlib.Meta.NormNum.IsRat b nb db →\n        Int.mul na nb = Int.mul (↑k) nc → Nat.mul da db = Nat.mul k dc → Mathlib.Meta.NormNum.IsRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "inv_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HMul.hMul",
   "HDiv.hDiv",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_rev",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "DivInvMonoid.toDiv",
   "Inv.inv"],
  "name": "div_div_eq_mul_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a b c : α), a / (b / c) = a * c / b",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred",
   "Finset",
   "Finset.val",
   "Multiset.filter",
   "Finset.filter.proof_1",
   "Finset.mk"],
  "name": "Finset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → Finset α → Finset α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "DivisionRing.toInv",
   "DivisionRing.zpow",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.giGenerateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice",
   "setOf",
   "Set",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "MeasurableSpace",
   "GaloisInsertion.liftCompleteLattice",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "MeasurableSpace.instCompleteLatticeMeasurableSpace",
  "constType": "{α : Type u_1} → CompleteLattice (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "Eq.ndrec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "id"],
  "name": "NeZero.one",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid"],
  "name": "AddSubgroup.toAddSubmonoid",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → AddSubgroup G → AddSubmonoid G",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "NonAssocSemiring",
   "Eq",
   "Nat.cast_mul"],
  "name": "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑m * ↑n = ↑(m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "NormedRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NormedRing α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_eq_of_add",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), a + b = 0 → -a = b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_9} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Ring.toNeg",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "And.right",
   "propext",
   "And.intro",
   "True",
   "Eq"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "propext",
   "Finset",
   "Finset.mem_filter",
   "Finset.filter",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.140",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, (a ∈ Finset.filter p s) = (a ∈ s ∧ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "Nat.succ",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_8",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_neg",
  "constType": "∀ {G : Type u} [self : SubtractionMonoid G] (x : G), - -x = x",
  "constCategory": "Definition"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "HasSubset.Subset",
   "Add",
   "Set.image2_subset_left"],
  "name": "Set.add_subset_add_left",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t₁ t₂ : Set α}, t₁ ⊆ t₂ → s + t₁ ⊆ s + t₂",
  "constCategory": "Theorem"},
 {"references": ["setOf", "AddGroup", "Set", "AddSubgroup.IsComplement"],
  "name": "AddSubgroup.leftTransversals",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Set G → Set (Set G)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "StrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.one_mul",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toSemiring",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "of_eq_true",
   "Ring",
   "Ring.toAddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_1} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["MetricSpace", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toMetricSpace",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → MetricSpace E",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup",
   "NormedCommRing",
   "Real.normedCommRing.proof_1",
   "Real",
   "Real.commRing",
   "CommRing.toRing",
   "NormedRing.mk",
   "CommRing.mul_comm",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "NormedCommRing.mk",
   "CommRing",
   "Real.normedAddCommGroup"],
  "name": "Real.normedCommRing",
  "constType": "NormedCommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mul_pos",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Real", "Real.commRing", "Ring", "CommRing.toRing"],
  "name": "Real.instRingReal",
  "constType": "Ring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a",
  "constCategory": "Theorem"},
 {"references": ["CommMonoid", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toCommMonoid",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → CommMonoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Zero.toOfNat0",
   "Left.neg_neg_iff",
   "AddGroup",
   "Iff",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_neg_iff_pos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Set.Finite.exists_finset_coe",
   "Finset",
   "CanLift.mk",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite",
  "constType":
  "∀ {α : Type u}, CanLift (Set α) (Finset α) Finset.toSet Set.Finite",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "And.right",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_right",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "SeminormedRing",
   "Norm",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace"],
  "name": "SeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → SeminormedRing α",
  "constCategory": "Other"},
 {"references": ["Norm", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → Norm E",
  "constCategory": "Definition"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_1} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, a = ↑n → Mathlib.Meta.NormNum.IsInt a n",
  "constCategory": "Other"},
 {"references": ["outParam", "VSub"],
  "name": "VSub.mk",
  "constType":
  "{G : outParam (Type u_1)} → {P : Type u_2} → (P → P → G) → VSub G P",
  "constCategory": "Other"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["Set.Elem",
   "Set",
   "Finite",
   "Inter.inter",
   "Set.inter_subset_left",
   "Finite.Set.subset",
   "Set.instInterSet"],
  "name": "Finite.Set.finite_inter_of_left",
  "constType":
  "∀ {α : Type u} (s t : Set α) [inst : Finite ↑s], Finite ↑(s ∩ t)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "AddMonoid.toAddSemigroup",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instZeroAddMonoidHom",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "Real.normedCommRing",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "congrFun"],
  "name": "Real.isROrC.proof_3",
  "constType": "∀ (z : ℝ), z + 0 z * 0 = z",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Nat.cast_commute",
   "Int.cast_add",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Ring",
   "Commute.invOf_right",
   "Int.cast_mul",
   "invertibleMul",
   "Nat",
   "Int.add",
   "Eq.trans",
   "Mathlib.Meta.NormNum.invertibleOfMul'",
   "Invertible.invOf",
   "congr_arg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Commute.right_comm",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.instAddInt",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Eq.mp",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Commute.invOf_left",
   "AddGroupWithOne.toIntCast",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "mul_mul_invOf_self_cancel'",
   "True",
   "Ring.toNonAssocRing",
   "add_mul",
   "Nat.cast_mul",
   "mul_mul_invOf_self_cancel",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Eq.symm",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Mathlib.Meta.NormNum.IsRat",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalSemiring.toSemigroupWithZero",
   "instMulNat",
   "Nat.mul"],
  "name": "Mathlib.Meta.NormNum.isRat_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {na nb nc : ℤ} {da db dc k : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsRat a na da →\n      Mathlib.Meta.NormNum.IsRat b nb db →\n        Int.add (Int.mul na ↑db) (Int.mul nb ↑da) = Int.mul (↑k) nc →\n          Nat.mul da db = Nat.mul k dc → Mathlib.Meta.NormNum.IsRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Set.image2",
   "Prod.snd",
   "Set",
   "Finite",
   "Eq.refl",
   "Prod.fst",
   "Finite.Set.finite_image",
   "Eq",
   "inferInstance",
   "Eq.mpr",
   "Set.image_prod",
   "Eq.ndrec",
   "Set.Elem",
   "SProd.sprod",
   "Prod",
   "Set.image",
   "Eq.symm",
   "Finite.Set.finite_prod",
   "id"],
  "name": "Finite.Set.finite_image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} (f : α → β → γ) (s : Set α) (t : Set β) [inst : Finite ↑s] [inst : Finite ↑t],\n  Finite ↑(Set.image2 f s t)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_zero",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Function.Injective",
   "Subtype.val",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Subtype.coe_injective",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership"],
  "name": "AddSubgroup.toAddCommGroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_pos'",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "instLTNat",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Nat",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_pos",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Preorder.toLT", "LT.lt", "Ne.symm", "Preorder", "LT.lt.ne"],
  "name": "LT.lt.ne'",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "Semifield.toCommSemiring",
   "NormedField",
   "Algebra",
   "Field.toSemifield",
   "NormedAlgebra",
   "Ring.toSemiring"],
  "name": "NormedAlgebra.toAlgebra",
  "constType":
  "{𝕜 : Type u_5} →\n  {𝕜' : Type u_6} → [inst : NormedField 𝕜] → [inst_1 : SeminormedRing 𝕜'] → [self : NormedAlgebra 𝕜 𝕜'] → Algebra 𝕜 𝕜'",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "Function.swap",
   "PartialOrder.toPreorder",
   "covariant_swap_add_of_covariant_add",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassRight",
  "constType":
  "∀ (M : Type u_3) [inst : OrderedAddCommMonoid M],\n  CovariantClass M M (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "SubNegMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "Nat.cast_nonneg",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "eq_true",
   "Nat.cast",
   "OrderedSemiring.toSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.2",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), (0 ≤ ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Group"],
  "name": "Group.toDivInvMonoid",
  "constType": "{G : Type u} → [self : Group G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Nat.succ",
   "id",
   "IsCancelAdd.toIsLeftCancelAdd",
   "lt_add_one",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "strictMono_nat_of_lt_succ",
   "StrictMono.injective"],
  "name": "StrictOrderedSemiring.to_charZero",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedSemiring α], CharZero α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "Finite",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership",
   "Subtype.finite"],
  "name":
  "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) [inst_1 : Finite G], Finite ↥K",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_zero'",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), Ring.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Function.comp",
   "Set",
   "MeasurableSet",
   "Measurable",
   "MeasurableSpace"],
  "name": "Measurable.comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}\n  {x_2 : MeasurableSpace γ} {g : β → γ} {f : α → β}, Measurable g → Measurable f → Measurable (g ∘ f)",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Set.Finite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Complex.log_one",
   "Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "dite",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Eq.mpr",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "NeZero.charZero_one",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "eq_self",
   "HPow.hPow",
   "Complex.instZeroComplex",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "False",
   "Complex.charZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.exp_zero",
   "NormedField.toNormedCommRing",
   "Complex.cpow_def",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "if_pos",
   "Eq.ndrec",
   "False.elim",
   "of_eq_true",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "Eq.mp",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Not",
   "Complex",
   "Complex.log",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.one_cpow",
  "constType": "∀ (x : ℂ), 1 ^ x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "OrderedSemiring.toSemiring",
   "Nat",
   "Nat.cast_nonneg'",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_nonneg",
  "constType": "∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Exists",
   "Function.comp",
   "FunLike.coe",
   "Exists.casesOn",
   "Countable.exists_injective_nat",
   "instCountableNat",
   "Equiv.instFunLikeEquiv",
   "Countable",
   "Function.Injective.countable",
   "Function.Injective.Prod_map",
   "Function.Injective",
   "Nat.pairEquiv",
   "Prod.map",
   "Function.Injective.comp",
   "Equiv.injective",
   "Prod",
   "Nat"],
  "name": "instCountableProd",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Countable α] [inst : Countable β], Countable (α × β)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivInvMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_inv",
  "constType": "∀ {G : Type u} [self : DivisionMonoid G] (x : G), x⁻¹⁻¹ = x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero.mk",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → GroupWithZero G₀",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x ≤ x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x ≤ x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a ≤ _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "Mul", "Eq"],
  "name": "CommMagma.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b : G), a * b = b * a) → CommMagma G",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α] (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["lt_or_le",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Or.symm",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_or_lt",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b < a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b : AddSubgroup G) (_x : G),\n  _x ∈ ↑_a.toAddSubmonoid ∧ _x ∈ ↑_b.toAddSubmonoid → _x ∈ ↑_b.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "ne_of_lt",
   "div_eq_mul_one_div",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "mul_mul_div",
   "Preorder.toLT",
   "div_mul_cancel",
   "Eq.rec",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "LT.lt.le",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "One.toOfNat1",
   "Ne.symm",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Monoid.toMulOneClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Semiring.toOne",
   "Iff.intro",
   "instTransEq_1",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "one_div_pos",
   "instTransEq",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "OrderedSemiring.toMulPosMono"],
  "name": "le_div_iff",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → (a ≤ b / c ↔ a * c ≤ b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Distrib",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instAddNat",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "Eq",
   "AddGroupWithOne.intCast_negSucc",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Int.cast",
   "Int.negSucc",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat"],
  "name": "Int.cast_negSucc",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑(Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.ble",
   "Iff.mp",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "Bool",
   "Nat",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → Nat.ble b' a' = false → a < b",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u_1} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m < ↑n) = (m < n)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "mul_mul_invOf_self_cancel",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) [inst_1 : Invertible b], a * b * ⅟b = a",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → Prop) (x : _a ≤ _b ∧ ¬_b ≤ _a),\n  (∀ (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive (_ : _a ≤ _b ∧ ¬_b ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references": ["OmegaCompletePartialOrder", "PartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_1} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "IntCast"],
  "name": "AddGroupWithOne.toIntCast",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["instHSub", "HSub.hSub", "Sub", "Sub.mk"],
  "name": "Pi.instSub",
  "constType":
  "{I : Type u} → {f : I → Type v₁} → [inst : (i : I) → Sub (f i)] → Sub ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["Trans",
   "lt_of_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLeToLELtToLT",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LT.lt LT.lt",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "Real.instLEReal",
   "ENNReal.ofReal",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "CanonicallyOrderedCommSemiring.toOne",
   "Exists.casesOn",
   "Nonempty",
   "Preorder.toLE",
   "Eq",
   "MeasurableSingletonClass",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "FiniteRange",
   "MeasureTheory.measure_ne_top",
   "CompletelyDistribLattice.toCompleteLattice",
   "MulOneClass.toOne",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "MeasureTheory.Measure.real",
   "MeasurableSet.singleton",
   "instHMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "_private.PFR.ForMathlib.Entropy.Basic.0.MeasureTheory.Measure.real._eq_1",
   "propext",
   "Eq.mp",
   "Singleton.singleton",
   "ENNReal.toReal",
   "MeasurableSpace",
   "ProbabilityTheory.prob_ge_exp_neg_entropy",
   "Exists",
   "CanonicallyOrderedCommSemiring.toMul",
   "MeasureTheory.map_measureReal_apply",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "GE.ge",
   "Eq.refl",
   "ge_iff_le",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Real.instNegReal",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Set.instSingletonSet",
   "one_mul",
   "Measurable",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.symm",
   "Set.preimage",
   "Real.toNNReal",
   "Neg.neg",
   "One.toOfNat1",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Real.exp",
   "LE.le",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Eq.ndrec",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "letFun",
   "HMul.hMul",
   "ENNReal.ofReal_le_iff_le_toReal",
   "OrderedSemiring.toPartialOrder",
   "ENNReal.ofNNReal"],
  "name": "ProbabilityTheory.prob_ge_exp_neg_entropy'",
  "constType":
  "∀ {S : Type uS} [inst : Nonempty S] [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] {Ω : Type u_1}\n  [inst_2 : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [inst_3 : MeasureTheory.IsProbabilityMeasure μ]\n  (X : Ω → S), Measurable X → ∀ [inst_4 : FiniteRange X], ∃ s, Real.exp (-H[X ; μ]) ≤ μ.real (X ⁻¹' {s})",
  "constCategory": "Theorem"},
 {"references":
  ["MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Set",
   "MeasurableSet",
   "Singleton.singleton",
   "MeasurableSpace"],
  "name": "MeasurableSingletonClass.mk",
  "constType":
  "∀ {α : Type u_7} [inst : MeasurableSpace α], (∀ (x : α), MeasurableSet {x}) → MeasurableSingletonClass α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "Preorder",
   "MulZeroClass.toMul",
   "Left.mul_pos"],
  "name": "mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_3",
  "constType": "∀ (a : ℝ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Neg.toHasAbs",
   "LT.lt.ne'",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Real.exp_log_eq_abs",
   "Real.exp",
   "Abs.abs",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.linearOrder",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "abs_of_pos",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "id"],
  "name": "Real.exp_log",
  "constType": "∀ {x : ℝ}, 0 < x → Real.exp (Real.log x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instZeroCardinal",
  "constType": "Zero Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Or.resolve_right",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "le_total"],
  "name": "lt_of_not_ge",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{α : Type u_1} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "prod",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "measurable_fst",
   "Real.instSubReal",
   "Real",
   "Eq.refl",
   "ProbabilityTheory.entropy",
   "MeasureTheory.Measure.prod",
   "MeasureTheory.IsFiniteMeasure",
   "MeasurableSub₂",
   "LinearOrderedField.toDiv",
   "Eq",
   "MeasureTheory.Measure",
   "outParam",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff.mp",
   "rdist",
   "Measurable.aemeasurable",
   "Eq.rec",
   "MeasureTheory.Measure.map_map",
   "Measurable",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "measurable_snd",
   "rdist_def",
   "id",
   "ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map",
   "instHSub",
   "instHDiv",
   "Prod.snd",
   "Function.comp",
   "HSub.hSub",
   "Prod.fst",
   "ProbabilityTheory.measureEntropy",
   "AddGroup.toSubNegMonoid",
   "Prod.instMeasurableSpace",
   "ProbabilityTheory.entropy_def",
   "Measurable.prod_mk",
   "Measurable.sub",
   "Eq.ndrec",
   "Prod.mk",
   "letFun",
   "instNatAtLeastTwo",
   "HSub",
   "Prod",
   "AddCommGroup",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.IndepFun.rdist_eq",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [hG : MeasurableSpace G]\n  [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] {X : Ω → G} [inst_2 : MeasureTheory.IsFiniteMeasure μ]\n  {Y : Ω → G},\n  ProbabilityTheory.IndepFun X Y →\n    Measurable X → Measurable Y → d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ] / 2 - H[Y ; μ] / 2",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_7",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["OmegaCompletePartialOrder.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
   "iSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "CompleteLattice",
   "instLENat",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "(α : Type u) → [inst : CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Div",
   "HDiv.hDiv",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoidWithZero",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "Nontrivial",
   "Int",
   "Inv.inv"],
  "name": "CommGroupWithZero.mk",
  "constType":
  "{G₀ : Type u_4} →\n  [toCommMonoidWithZero : CommMonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → CommGroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["neg_add_self",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "left_neg_eq_right_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {a b : G}, a + b = 0 → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing",
   "Monoid.mk",
   "DivisionRing.div_eq_mul_inv",
   "NonUnitalSemiring.mul_assoc",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.zpow_zero'",
   "DivInvMonoid",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "DivInvMonoid.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toInv",
   "Semiring.toOne",
   "Semiring.npow",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toDiv",
   "Semigroup.mk"],
  "name": "DivisionRing.toDivInvMonoid",
  "constType": "{K : Type u} → [self : DivisionRing K] → DivInvMonoid K",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Abs.abs",
   "True",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "CauSeq.Completion.instInvCauchyToRing",
   "Eq.trans",
   "GroupWithZero.toInv",
   "CauSeq.Completion.Cauchy.field",
   "eq_self",
   "Neg.toHasAbs",
   "DivisionSemiring.toGroupWithZero",
   "Rat",
   "Field.toSemifield",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "Rat.field",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal.proof_11",
  "constType": "0⁻¹ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.image2",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "Finite.Set.finite_image2",
   "Finite.of_fintype",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} {s : Set α} {t : Set β} (f : α → β → γ),\n  Set.Finite s → Set.Finite t → Set.Finite (Set.image2 f s t)",
  "constCategory": "Theorem"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{α : Type u} → [self : Sub α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_one",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "SubNegMonoid.toNeg",
   "neg_zero",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_add",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Eq",
   "Int.instInhabitedInt",
   "Int.eq_nat_or_neg",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Int.cast_neg",
   "HasDistribNeg.toInvolutiveNeg",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "Eq.trans",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Std.Logic._auxLemma.32",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.cast_zero",
   "instHMul",
   "Nat.rec",
   "NonAssocRing.toIntCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "congr",
   "congrArg",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "forall_congr",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.instNegInt",
   "neg_mul",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "Mathlib.Algebra.Group.Basic._auxLemma.14",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Ring.toAddCommGroup",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "Int.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocRing α] (m n : ℤ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references": ["Rat", "RatCast.ratCast", "RatCast"],
  "name": "Rat.cast",
  "constType": "{K : Type u} → [inst : RatCast K] → ℚ → K",
  "constCategory": "Definition"},
 {"references": ["Max.max", "Eq.refl", "Nat", "Nat.instMaxNat", "Eq"],
  "name": "Nat.linearOrder.proof_2",
  "constType": "∀ (a b : ℕ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "Invertible.congr",
   "Semiring.toMonoidWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "Invertible",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "invertibleOne",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsRat.to_isInt.match_1",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "invOf_one'",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "letFun",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsRat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, Mathlib.Meta.NormNum.IsRat a n 1 → Mathlib.Meta.NormNum.IsInt a n",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "FiniteRange",
  "constType": "{Ω : Type u_1} → {G : Type u_2} → (Ω → G) → Prop",
  "constCategory": "Other"},
 {"references": ["One", "Mul"],
  "name": "Invertible",
  "constType": "{α : Type u} → [inst : Mul α] → [inst : One α] → α → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Eq.refl",
   "Commute.zero_left",
   "NonAssocSemiring.toMulZeroOneClass",
   "Commute",
   "Nat.cast_zero",
   "Commute.one_left",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "Commute.add_left",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast"],
  "name": "Nat.cast_commute",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (n : ℕ) (x : α), Commute (↑n) x",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.add", "Real", "Add", "Add.mk"],
  "name": "Real.instAddReal",
  "constType": "Add ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "IsUnit.eq_div_iff",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Iff",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "eq_div_iff",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (c = a / b ↔ c * b = a)",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "Monoid.mk",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Semiring.npow_succ",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "HDiv.hDiv",
   "Real.strictOrderedRing",
   "Semigroup.mk",
   "StrictOrderedRing.toPartialOrder",
   "instHDiv",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "DivInvMonoid.div'",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_6",
  "constType": "∀ (a b : ℝ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "implies_congr",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Preorder.toLE",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.mpr",
   "Iff",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "id",
   "Neg.toHasAbs",
   "CauSeq.le_antisymm",
   "Real.instLTReal",
   "Mathlib.Data.Real.Basic._auxLemma.7",
   "Real.mk_le",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "LE.le",
   "Preorder.mk",
   "CauSeq.equiv",
   "And",
   "Eq.ndrec",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "propext",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "LT.lt",
   "Real.mk",
   "le_refl",
   "congr",
   "Not",
   "HasEquiv.Equiv",
   "congrArg",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.partialOrder.proof_4",
  "constType": "∀ (a b : ℝ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.commRing",
   "Eq",
   "Real.instOneReal",
   "Eq.mpr",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "Eq.trans",
   "Ne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.ofCauchy.injEq",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "CommMagma.toMul",
   "CauSeq.Completion.inv_mul_cancel",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Mathlib.Data.Real.Basic._auxLemma.18",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Not",
   "LinearOrderedCommRing.mul_comm",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "Abs.abs",
   "Inv.mk",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "mul_comm",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "CauSeq.Completion.instMulCauchy",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Eq.ndrec",
   "Mathlib.Data.Real.Basic._auxLemma.3",
   "Rat.divisionRing",
   "LinearOrderedCommRing.mk",
   "Real.linearOrderedCommRing",
   "Real.casesOn",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Real.instLinearOrderedFieldReal.proof_10",
  "constType": "∀ (a : ℝ), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Real.field",
   "inferInstance",
   "DivisionRing",
   "Real",
   "Field.toDivisionRing"],
  "name": "Real.instDivisionRingReal",
  "constType": "DivisionRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_mul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Mathlib.Meta.NormNum.isNat_mul.match_1",
   "Nat.mul",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.mul a' b' = c → Mathlib.Meta.NormNum.IsNat (a * b) c",
  "constCategory": "Theorem"},
 {"references": ["OrderedRing", "PartialOrder"],
  "name": "OrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "LeftDistribClass.mk",
   "LeftDistribClass",
   "Distrib.left_distrib",
   "Distrib",
   "Distrib.toMul"],
  "name": "Distrib.leftDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], LeftDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "NormedRing.dist_eq",
   "NormedCommRing",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_2",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Subtype.mk",
   "Subtype",
   "Preorder.toLE",
   "MulPosMono",
   "CovariantClass.elim"],
  "name": "mul_le_mul_of_nonneg_right",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  b ≤ c → 0 ≤ a → b * a ≤ c * a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "RatCast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ratCast",
  "constType": "RatCast ℝ",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "inferInstance",
   "Fintype",
   "AddGroup",
   "letFun",
   "AddSubgroup",
   "Subtype.fintype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership"],
  "name":
  "AddSubgroup.instFintypeSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
  "constType":
  "{G : Type u_1} →\n  [inst : AddGroup G] →\n    (K : AddSubgroup G) → [inst_1 : DecidablePred fun x => x ∈ K] → [inst_2 : Fintype G] → Fintype ↥K",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "congr",
   "congrArg",
   "add_zero",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ c₁ b₂ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "add_nonpos",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Real.instOneReal",
   "DiscreteMeasurableSpace.toMeasurableAdd₂",
   "Semiring.toNatCast",
   "Linarith.le_of_le_of_eq",
   "Real.linearOrder",
   "inferInstance",
   "IsROrC.charZero_isROrC",
   "instOfNat",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "AddCommMagma.toAdd",
   "DivisionRing.toInv",
   "refPackage.X₀₁",
   "Prod.instMeasurableSpace",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Linarith.le_of_eq_of_le",
   "instNatAtLeastTwo",
   "congr",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "DivisionRing.toDivisionSemiring",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "is_tau_min",
   "IsCancelAdd.toIsRightCancelAdd",
   "tau_minimizes",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedRing.toOrderedSemiring",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.mul_add",
   "add_lt_of_le_of_neg",
   "Field.toSemifield",
   "Neg.neg",
   "LE.le",
   "Real.instDivisionRingReal",
   "OrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "AddSubgroup.instSetLikeAddSubgroup",
   "And.casesOn",
   "Eq.trans",
   "Nat.cast_one",
   "Finite.to_countable",
   "Real.field",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "refPackage.hmeas2",
   "Mathlib.Tactic.Ring.mul_one",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "tau",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "sub_eq_zero_of_eq",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "refPackage",
   "IsCancelAdd.toIsLeftCancelAdd",
   "tau_strictly_decreases",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "NonUnitalNonAssocSemiring.toMul",
   "instCountableProd",
   "MeasureTheory.MeasureSpace",
   "Bool",
   "ProbabilityTheory.IsUniform",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Iff.mpr",
   "Real.orderedRing",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.neg_congr",
   "HDiv.hDiv",
   "instHSub",
   "HPow.hPow",
   "neg_eq_zero",
   "_private.PFR.EntropyPFR.0.tau._eq_1",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.isRat_div",
   "Field.toDiv",
   "AddCommGroup",
   "Finite.of_fintype",
   "Int",
   "refPackage.hmeas1",
   "SetLike.coe",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Real.instAddCommGroupReal",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "tau_minimizer_exists",
   "CancelDenoms.add_subst",
   "Linarith.mul_eq",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "rdist_symm",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Int.mul",
   "sub_neg_of_lt",
   "Bool.false",
   "Real.instPreorderReal",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "Real.instLEReal",
   "Real.instMulReal",
   "Real.commRing",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "AddZeroClass.toZero",
   "MeasurableSingletonClass",
   "Fintype",
   "rdist",
   "Linarith.eq_of_eq_of_eq",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "exists_isUniform_of_rdist_eq_zero",
   "Real.partialOrder",
   "Nat.rawCast",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "refPackage.X₀₂",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "congrArg",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "refPackage.η",
   "Mathlib.Meta.NormNum.isNat_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "instFiniteRange",
   "Preorder.toLT",
   "rdist_triangle",
   "instHPow",
   "Ring.toSub",
   "AddSubgroup",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero"],
  "name": "entropic_PFR_conjecture",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [inst_4 : AddCommGroup G]\n  [inst_5 : ElementaryAddCommGroup G 2] [inst_6 : Fintype G] [inst_7 : MeasurableSpace G]\n  [inst_8 : MeasurableSingletonClass G] (p : refPackage Ω₀₁ Ω₀₂ G),\n  p.η = 1 / 9 →\n    ∃ H Ω mΩ U,\n      MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n        Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ d[p.X₀₁ # U] + d[p.X₀₂ # U] ≤ 11 * d[p.X₀₁ # p.X₀₂]",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "OrderedCommMonoid.mk",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "left_distrib",
   "Eq"],
  "name": "mul_add",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "Semigroup"],
  "name": "Monoid.toSemigroup",
  "constType": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubNegMonoid.mk",
   "SubNegMonoid.zsmul_zero'",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "instHDiv",
   "LinearOrderedSemifield",
   "PartialOrder.toPreorder",
   "div_lt_div_left",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Iff.mpr",
   "LT.lt.trans",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "div_lt_div_of_lt_left",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → 0 < b → b < a → c / a < c / b",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsRat.casesOn",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "HEq",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Eq.casesOn",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.to_isInt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℤ) → Mathlib.Meta.NormNum.IsRat x x_1 1 → Prop) (x : α)\n  (x_1 : ℤ) (x_2 : Mathlib.Meta.NormNum.IsRat x x_1 1),\n  (∀ (num : ℤ) (inv : Invertible ↑1), motive (↑num * ⅟↑1) num (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑1) num 1)) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.inv_inv",
   "DivisionMonoid.toDivInvMonoid",
   "InvolutiveInv",
   "DivInvMonoid.toInv",
   "InvolutiveInv.mk"],
  "name": "DivisionMonoid.toInvolutiveInv",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → InvolutiveInv G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.card_eq_zero_of_infinite",
   "Set.Elem",
   "Set",
   "instOfNatNat",
   "Nat",
   "Nat.card",
   "Set.Infinite",
   "Set.Infinite.to_subtype",
   "Eq"],
  "name": "Set.Infinite.card_eq_zero",
  "constType": "∀ {α : Type u_1} {s : Set α}, Set.Infinite s → Nat.card ↑s = 0",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Init.Order.Defs._auxLemma.1",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "letFun",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Field", "NormedField"],
  "name": "NormedField.toField",
  "constType": "{α : Type u_5} → [self : NormedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SubNegMonoid.toSub",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toSub",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "mul_lt_mul_of_pos_left",
   "congrArg",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Int"],
  "name": "DivisionRing.zpow",
  "constType": "{K : Type u} → [self : DivisionRing K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "CharP",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toZero",
   "Nat.monoid",
   "CharP.cast_eq_zero_iff",
   "Nat.instDvdNat",
   "AddMonoidWithOne.toAddMonoid",
   "dvd_refl",
   "Dvd.dvd",
   "Nat",
   "Iff.mpr",
   "Eq"],
  "name": "CharP.cast_eq_zero",
  "constType":
  "∀ (R : Type u_1) [inst : AddMonoidWithOne R] (p : ℕ) [inst_1 : CharP R p], ↑p = 0",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_3",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq.match_1",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "div_eq_mul_inv",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "HDiv.hDiv",
   "Nat",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "DivisionRing.toDiv",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "DivisionRing",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "Int.cast_ofNat",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ} {a n' d' : α},\n  Mathlib.Meta.NormNum.IsRat a (Int.ofNat n) d → ↑n = n' → ↑d = d' → a = n' / d'",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4056",
   "autoParam",
   "Eq",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4095",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            autoParam (∀ (x : M), npow 0 x = 1) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), npow (n + 1) x = x * npow n x) _auto✝¹ → Monoid M",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} → [inst : AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasurableSpace",
  "constType": "Type u_7 → Type u_7",
  "constCategory": "Other"},
 {"references": ["Set", "Add", "AddSubsemigroup"],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_4} → [inst : Add M] → AddSubsemigroup M → Set M",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Iff",
   "Nat.cast_injective",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Nat",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "Nat.cast_inj",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toNeg",
   "add_left_neg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "Eq"],
  "name": "AddGroup.toSubtractionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "not_congr",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Nat.cast_ne_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd", "AddSubmonoid", "AddZeroClass", "AddSubsemigroup"],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_4} → [inst : AddZeroClass M] → AddSubmonoid M → AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ c₁ a₂ b₂ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMagma.add_comm",
   "AddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "instHDiv",
   "OfNat.ofNat",
   "LinearOrderedSemifield",
   "PartialOrder.toPreorder",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "CommGroupWithZero.toCommMonoidWithZero",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "HDiv.hDiv",
   "le_div_iff",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "lt_iff_lt_of_le_iff_le"],
  "name": "div_lt_iff",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → (b / c < a ↔ b < a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "Equiv.mk"],
  "name": "Equiv.symm",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "constCategory": "Definition"},
 {"references": ["GroupWithZero", "Inv"],
  "name": "GroupWithZero.toInv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Inv G₀",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "instAddNat",
   "Int.negSucc",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.subNatNat",
   "Int.add.match_1"],
  "name": "Int.add",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedSemiring.toMax",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedSemifield",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedField.toLinearOrderedSemifield.proof_1",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedField.inv_zero",
   "LinearOrderedField.toDiv",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedSemifield.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedField.zpow_neg'",
   "LinearOrderedField.zpow",
   "LinearOrderedField.toInv",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedField.toLinearOrderedSemifield",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LinearOrderedSemifield α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "Semiring.npow",
   "CommMonoid",
   "CommSemiring",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommSemiring.toCommMonoid",
  "constType": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "refPackage",
   "Real.instLTReal",
   "Real.natCast",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "One.toOfNat1",
   "LE.le",
   "Real.instOneReal",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "instHMul",
   "MeasureTheory.MeasureSpace",
   "LT.lt",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "instOfNatNat",
   "Measurable",
   "Nat",
   "MeasurableSpace",
   "instOfNat"],
  "name": "refPackage.mk",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} →\n          [inst_2 : MeasurableSpace G] →\n            (X₀₁ : Ω₀₁ → G) →\n              (X₀₂ : Ω₀₂ → G) → Measurable X₀₁ → Measurable X₀₂ → (η : ℝ) → 0 < η → 8 * η ≤ 1 → refPackage Ω₀₁ Ω₀₂ G",
  "constCategory": "Other"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "Set.preimage",
   "AddHomClass.toFunLike",
   "AddSubgroup.comap.proof_2",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.comap.proof_3",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubgroup.mk",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.comap",
   "AddMonoidHom",
   "AddSubgroup.comap.proof_1",
   "SetLike.coe"],
  "name": "AddSubgroup.comap",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → {N : Type u_7} → [inst_1 : AddGroup N] → (G →+ N) → AddSubgroup N → AddSubgroup G",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "LE.le.trans",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mul_le_mul_of_nonneg_right",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulPosMono",
   "MulZeroClass.toMul"],
  "name": "mul_le_mul",
  "constType":
  "∀ {α : Type u_1} {a b c d : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α]\n  [inst_3 : MulPosMono α], a ≤ b → c ≤ d → 0 ≤ c → 0 ≤ b → a * c ≤ b * d",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "AddSubgroup.add",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x + x_1) = ↑(x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Complex.instOneComplex",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "eq_self",
   "Complex.instZeroComplex",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.exp_zero",
   "NormedField.toNormedCommRing",
   "instDecidableTrue",
   "ite_self",
   "ite_congr",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "HMul.hMul",
   "Complex.log",
   "Complex",
   "Not",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.cpow_zero",
  "constType": "∀ (x : ℂ), x ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Or.symm",
   "LE.le.lt_or_eq",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_or_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedAddCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddMonoidHomClass (M →+ N) M N",
  "constCategory": "Definition"},
 {"references": ["Nat.commSemiring", "inferInstance", "CommSemiring", "Nat"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Real.instCommSemiringReal",
   "Semiring",
   "Real"],
  "name": "Real.semiring",
  "constType": "Semiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "CommMagma",
   "CommMagma.mk",
   "CommSemigroup.mul_comm",
   "CommSemigroup",
   "CommSemigroup.toSemigroup"],
  "name": "CommSemigroup.toCommMagma",
  "constType": "{G : Type u} → [self : CommSemigroup G] → CommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Field.mk",
   "LinearOrderedField.qsmul",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedRing.toNontrivial",
   "LinearOrderedField.inv_zero",
   "CommRing.mk",
   "LinearOrderedField.toDiv",
   "LinearOrderedField.ratCast_mk",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "Field",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedField.toRatCast",
   "LinearOrderedField.qsmul_eq_mul'",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "LinearOrderedField.zpow_neg'"],
  "name": "LinearOrderedField.toField",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff.rfl",
   "Nat.instDvdNat",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "SemigroupWithZero.toZero",
   "zero_dvd_iff",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "CharP",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "id",
   "AddMonoidWithOne.toAddMonoid",
   "CharP.mk",
   "Dvd.dvd",
   "SemigroupWithZero.toSemigroup",
   "AddMonoidWithOne",
   "Nat.commSemiring",
   "Eq.ndrec",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "NonUnitalSemiring.toSemigroupWithZero"],
  "name": "CharP.ofCharZero",
  "constType":
  "∀ (R : Type u_1) [inst : AddMonoidWithOne R] [inst_1 : CharZero R], CharP R 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Membership.mem",
   "OfNat.ofNat",
   "Set",
   "Real",
   "Real.instLEReal",
   "Real.instSupReal",
   "dite",
   "FunLike.coe",
   "Real.log.proof_1",
   "Subtype.le",
   "Set.Ioi",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.expOrderIso",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.decidableEq",
   "RelIso.instRelHomClassRelIso",
   "Set.Elem",
   "RelIso",
   "Real.instPreorderReal",
   "Not",
   "Subtype.mk",
   "OrderIso.symm"],
  "name": "Real.log",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "LinearOrderedCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "OrderedCommMonoid.toCommMonoid",
   "HMul.hMul",
   "OrderedCommMonoid.toPartialOrder",
   "CommMonoid.toMonoid"],
  "name": "LinearOrderedCommMonoidWithZero.mk",
  "constType":
  "{α : Type u_1} →\n  [toLinearOrderedCommMonoid : LinearOrderedCommMonoid α] →\n    [toZero : Zero α] → (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → 0 ≤ 1 → LinearOrderedCommMonoidWithZero α",
  "constCategory": "Other"},
 {"references":
  ["Add.add",
   "Set.add",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "Set.addSemigroup.proof_1",
   "Add",
   "AddSemigroup",
   "Add.mk"],
  "name": "Set.addSemigroup",
  "constType":
  "{α : Type u_2} → [inst : AddSemigroup α] → AddSemigroup (Set α)",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    (Unit → motive Nat.zero Nat.zero) →\n      ((n : ℕ) → motive Nat.zero (Nat.succ n)) →\n        ((n : ℕ) → motive (Nat.succ n) Nat.zero) → ((n m : ℕ) → motive (Nat.succ n) (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Ring", "Nat", "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat",
  "constType": "{α : Type u_1} → [inst : Ring α] → α → ℤ → ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subgroup.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddSubgroup.toSubgroup.proof_2",
   "AddSubgroup.toSubgroup.proof_4",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "RelIso.instRelHomClassRelIso",
   "Submonoid.toAddSubmonoid",
   "AddGroup",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "AddSubgroup",
   "RelIso",
   "Subgroup",
   "AddSubmonoid.mk",
   "AddSubgroup.toSubgroup.proof_5",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Multiplicative.mulOneClass",
   "OrderIso",
   "Submonoid.mk",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoid.toSubmonoid",
   "AddSubgroup.toSubgroup.proof_3",
   "FunLike.coe",
   "Additive.addZeroClass",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Monoid.toMulOneClass",
   "RelHomClass.toFunLike",
   "SetLike.instPartialOrder",
   "Multiplicative",
   "AddSubgroup.neg_mem'",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "Submonoid",
   "Equiv.mk",
   "Submonoid.instCompleteLatticeSubmonoid",
   "AddSubgroup.toSubgroup.proof_1",
   "Group.toDivInvMonoid",
   "AddSubgroup.toSubgroup.proof_6",
   "AddSubgroup.mk",
   "RelIso.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Additive",
   "Subgroup.instSetLikeSubgroup"],
  "name": "AddSubgroup.toSubgroup",
  "constType":
  "{A : Type u_4} → [inst : AddGroup A] → AddSubgroup A ≃o Subgroup (Multiplicative A)",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Div"],
  "name": "DivisionRing.toDiv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Div K",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Monoid", "CommMonoid"],
  "name": "CommMonoid.toMonoid",
  "constType": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "of_eq_true",
   "sub_add_eq_sub_sub_swap",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "add_sub_cancel",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "add_sub_add_right_eq_sub",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] (a b c : G), a + c - (b + c) = a - b",
  "constCategory": "Theorem"},
 {"references": ["DivisionSemiring", "Int"],
  "name": "DivisionSemiring.zpow",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "CancelDenoms.neg_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e t : α}, n * e = t → n * -e = -t",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} → [self : Ring R] → Sub R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "propext",
   "Set",
   "Set.ext_iff",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.GroupTheory.Complement._auxAddLemma.16",
  "constType":
  "∀ {α : Type u} {s t : Set α}, (s = t) = ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Semigroup"],
  "name": "Real.instSemigroupReal",
  "constType": "Semigroup ℝ",
  "constCategory": "Definition"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "DecidablePred",
   "Finset.univ",
   "And",
   "Fintype",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "Finset.filter",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "congrFun"],
  "name": "Subtype.fintype.proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] [inst_1 : Fintype α] (a : α),\n  a ∈ Finset.filter p Finset.univ ↔ p a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Fintype",
   "FiniteRange",
   "Set",
   "FiniteRange.mk",
   "Finite.of_fintype",
   "Subtype.finite",
   "Set.toFinite",
   "Set.instMembershipSet"],
  "name": "instFiniteRange",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} (X : Ω → G) [inst : Fintype G], FiniteRange X",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddHomClass.toFunLike",
   "instHAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Real.normedCommRing",
   "Ring.toSemiring",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "CommRing.toRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_7",
  "constType":
  "∀ (z w : ℝ), 0 = (AddMonoidHom.id ℝ) z * 0 + 0 * (AddMonoidHom.id ℝ) w",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.toNat.proof_2",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Classical.choose",
   "ZeroHom.mk",
   "ZeroHom",
   "dite",
   "Cardinal.partialOrder",
   "Cardinal.toNat.proof_1",
   "Cardinal.linearOrder",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "instOfNatNat",
   "Not",
   "Nat"],
  "name": "Cardinal.toNat",
  "constType": "ZeroHom Cardinal.{v} ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{α : Type u_1} → {ι : Sort u_4} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [inst : Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_1",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "add_le_add_left",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "instTransEq_1",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "zero_le_one",
   "AddMonoid.toZero",
   "CovariantClass",
   "instTransEq",
   "instNatAtLeastTwo",
   "LE",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "Eq.symm",
   "instOfNat"],
  "name": "one_le_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : LE α] [inst_2 : ZeroLEOneClass α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 1 ≤ 2",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "MulZeroOneClass.toMulOneClass",
   "Eq.refl",
   "dite",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Complex.instSemiringComplex",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Complex.instPowComplex",
   "instHPow",
   "Complex.log_zero",
   "NeZero.charZero_one",
   "Eq.trans",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "HPow.hPow",
   "eq_self",
   "Complex.instZeroComplex",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "MulOneClass.toOne",
   "Complex.charZero",
   "One.toOfNat1",
   "Complex.exp_zero",
   "instDecidableTrue",
   "ite_congr",
   "Complex.cpow_def",
   "instHMul",
   "instDecidableFalse",
   "Eq.ndrec",
   "of_eq_true",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "congr",
   "HMul.hMul",
   "one_ne_zero",
   "mul_one",
   "Not",
   "Complex",
   "Complex.log",
   "Complex.exp_log",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.cpow_one",
  "constType": "∀ (x : ℂ), x ^ 1 = x",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = Int.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "Real.instLinearOrderedFieldReal.proof_12",
   "zpowRec",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrder.decidableLE",
   "Monoid.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_5",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Real.linearOrder",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.instInvReal",
   "Real.strictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_11",
   "Real.instLinearOrderedFieldReal.proof_2",
   "Semigroup.mk",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Real.instLinearOrderedFieldReal.proof_13",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.ratCast",
   "Real.instLinearOrderedFieldReal.proof_7",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "DivInvMonoid.div'",
   "Ring.toSemiring",
   "Real.instLinearOrderedFieldReal.proof_4",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.instLinearOrderedFieldReal.proof_10",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "Real.linearOrderedCommRing",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "Real.instLinearOrderedFieldReal.proof_3",
   "LinearOrderedCommRing",
   "Real.instLinearOrderedFieldReal.proof_6",
   "LinearOrderedCommRing.mul_comm",
   "Real.instLinearOrderedFieldReal.proof_9",
   "Real.instLinearOrderedFieldReal.proof_1",
   "LinearOrderedRing.mk",
   "Real.instLinearOrderedFieldReal.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal",
  "constType": "LinearOrderedField ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "AddHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Nat.addMonoid",
   "Finset",
   "Multiset",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "flip",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "MulZeroClass.mul_zero",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "lt_of_mul_lt_mul_left",
   "not_false_eq_true",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "GroupWithZero.toInv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LinearOrderedSemifield",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
   "DivisionSemiring.toGroupWithZero",
   "OrderedSemiring.zeroLEOneClass",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "Iff.intro",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "Not",
   "congrArg",
   "Inv.inv",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "LinearOrderedSemifield.toInv",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "ne_of_gt",
   "Preorder.toLT",
   "Eq.rec",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_cancel",
   "CommGroupWithZero.toDivisionCommMonoid",
   "LT.lt.le",
   "False",
   "One.toOfNat1",
   "inv_inv",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "GroupWithZero.toMonoidWithZero",
   "eq_false",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "inv_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 < a⁻¹ ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "StrictOrderedRing.toNontrivial",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "HMul.hMul",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_1",
  "constType": "∀ (a b c : ℝ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "constCategory": "Other"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "Eq",
   "Ring.toNeg",
   "Mathlib.Meta.NormNum.isInt_neg.match_1",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Int.cast_neg",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.instNegInt",
   "Eq.symm",
   "Int",
   "Int.neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α} {a : α} {a' b : ℤ},\n  f = Neg.neg → Mathlib.Meta.NormNum.IsInt a a' → Int.neg a' = b → Mathlib.Meta.NormNum.IsInt (-a) b",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Quotient",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} → [inst_1 : Ring β] → (abv : β → α) → [inst : IsAbsoluteValue abv] → Type u_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references": ["NonAssocRing", "IntCast"],
  "name": "NonAssocRing.toIntCast",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → IntCast α",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Eq.refl",
   "Eq.symm",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "Ring.toNeg",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "HAdd.hAdd",
   "Ring.toIntCast",
   "Ring",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "Ring.toSemiring",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.mul_comm",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_8",
   "OrderBot",
   "Nat.canonicallyOrderedCommSemiring.proof_12",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.nontrivial",
   "OrderedAddCommMonoid",
   "Nat.eq_zero_of_mul_eq_zero",
   "inferInstance",
   "instLENat",
   "Semiring.npow",
   "Nat.canonicallyOrderedCommSemiring.proof_10",
   "Nat.canonicallyOrderedCommSemiring.proof_3",
   "CommSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Nat",
   "Nat.canonicallyOrderedCommSemiring.proof_7",
   "Nat.linearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.add_le_add_left",
   "Nat.canonicallyOrderedCommSemiring.proof_5",
   "CanonicallyOrderedCommSemiring.mk",
   "Nat.le_add_right",
   "OrderedAddCommMonoid.mk",
   "OrderBot.bot_le",
   "Nat.canonicallyOrderedCommSemiring.proof_11",
   "Nat.canonicallyOrderedCommSemiring.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.canonicallyOrderedCommSemiring.proof_6",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.toOne",
   "Nat.commSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_9",
   "Nat.canonicallyOrderedCommSemiring.proof_1",
   "Nat.orderedSemiring",
   "OrderBot.toBot",
   "Nat.canonicallyOrderedCommSemiring.proof_4",
   "LinearOrderedSemiring",
   "Nontrivial",
   "OrderBot.mk",
   "Nat.orderBot",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Finite",
  "constType": "Sort u_1 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → GroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Real.instAddCommGroupReal",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "Real.metricSpace",
   "Real",
   "Real.normedAddCommGroup.proof_1",
   "Real.norm"],
  "name": "Real.normedAddCommGroup",
  "constType": "NormedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "instLTNat",
   "Eq",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Nat.cast",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, (0 < ↑n) = (0 < n)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Invertible.invOf",
   "MulOneClass.toMul",
   "Monoid",
   "invertibleMul.proof_1",
   "Monoid.toOne",
   "invertibleMul.proof_2",
   "HMul.hMul",
   "Invertible.mk",
   "Monoid.toMulOneClass",
   "Invertible"],
  "name": "invertibleMul",
  "constType":
  "{α : Type u} → [inst : Monoid α] → (a b : α) → [inst_1 : Invertible a] → [inst_2 : Invertible b] → Invertible (a * b)",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Nontrivial"],
  "name": "DivisionSemiring.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.toInv",
   "DivisionSemiring.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegZeroMonoid",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.mk",
  "constType":
  "{G : Type u_2} → [toSubNegMonoid : SubNegMonoid G] → -0 = 0 → SubNegZeroMonoid G",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_1",
   "PartialOrder.toPreorder",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "le_iSup_of_le",
   "OrderHom.mk",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "le_refl",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (i : ℕ), x i ≤ (fun c => ⨆ i, c i) x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubNegZeroMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references":
  ["LE.mk", "_private.Mathlib.Data.Real.Basic.0.Real.le", "Real", "LE"],
  "name": "Real.instLEReal",
  "constType": "LE ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "HEq",
   "instHAdd",
   "eq_of_heq",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int.add",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HAdd.hAdd →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.add x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HAdd.hAdd) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.add x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HAdd.hAdd (↑n) (↑n_1) n n_1 (Int.add n n_1) (_ : HAdd.hAdd = HAdd.hAdd)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.add n n_1 = Int.add n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["Invertible.invOf",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Mathlib.Meta.NormNum.IsRat.rec",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toOne",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Nat",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.casesOn",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} {motive : Mathlib.Meta.NormNum.IsRat a num denom → Prop}\n  (t : Mathlib.Meta.NormNum.IsRat a num denom),\n  (∀ (inv : Invertible ↑denom) (eq : a = ↑num * ⅟↑denom), motive (_ : Mathlib.Meta.NormNum.IsRat a num denom)) →\n    motive t",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u_1} → [inst : Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "IsROrC.toDenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedField.toNormedCommRing",
   "NormedAlgebra",
   "semiOutParam"],
  "name": "IsROrC.toNormedAlgebra",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → NormedAlgebra ℝ K",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": ["Nontrivial", "EuclideanDomain"],
  "name": "EuclideanDomain.toNontrivial",
  "constType": "∀ {R : Type u} [self : EuclideanDomain R], Nontrivial R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder"],
  "name": "Real.instPreorderReal",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_lt_add_iff_right",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_neg_of_lt",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < b → a - b < 0",
  "constCategory": "Theorem"},
 {"references": ["One", "InvOneClass"],
  "name": "InvOneClass.toOne",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → One G",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toOne",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Nat",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} (inv : Invertible ↑denom),\n  a = ↑num * ⅟↑denom → Mathlib.Meta.NormNum.IsRat a num denom",
  "constCategory": "Other"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike.mem_coe",
   "SetLike",
   "propext",
   "Set",
   "SetLike.instMembership",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.SetLike.Basic._auxLemma.3",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Add M] → [inst_1 : Add N] → [self : AddHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "Int.rawCast",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Ring.toNeg",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Nat.addMonoid",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "neg_mul",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "Int.negOfNat",
   "MulOneClass.toOne",
   "instHAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.negSucc",
   "Int.cast",
   "HMul.hMul",
   "congrArg",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b : R}, Int.rawCast (Int.negOfNat 1) * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["DenselyNormedField", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDenselyNormedField",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → DenselyNormedField K",
  "constCategory": "Definition"},
 {"references":
  ["False",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "Preorder",
   "lt_self_iff_false",
   "Eq"],
  "name": "PFR.Main._auxLemma.7",
  "constType": "∀ {α : Type u} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Abs", "Abs.mk", "Sup", "Neg.neg", "Sup.sup", "Neg"],
  "name": "Neg.toHasAbs",
  "constType": "{α : Type u_1} → [inst : Neg α] → [inst : Sup α] → Abs α",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Div"],
  "name": "DivInvMonoid.toDiv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.IsUniform.mk",
   "Eq",
   "ProbabilityTheory.IsUniform.measure_preimage_compl",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasurableSet",
   "Eq.symm",
   "id",
   "Membership.mem",
   "Set.preimage",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "ProbabilityTheory.IdentDistrib",
   "MeasurableSet.singleton",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "ProbabilityTheory.IsUniform.eq_of_mem",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "ProbabilityTheory.IdentDistrib.measure_mem_eq",
   "MeasurableSet.compl",
   "Singleton.singleton",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform.of_identDistrib",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S]\n  {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Set S} {Ω' : Type u_1} [inst_2 : MeasurableSpace Ω'],\n  ProbabilityTheory.IsUniform H X →\n    ∀ {X' : Ω' → S} {μ' : MeasureTheory.Measure Ω'},\n      ProbabilityTheory.IdentDistrib X X' → MeasurableSet H → ProbabilityTheory.IsUniform H X'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_cancel",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveInv", "Inv"],
  "name": "InvolutiveInv.toInv",
  "constType": "{G : Type u_2} → [self : InvolutiveInv G] → Inv G",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "MonoidWithZero",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "GroupWithZero",
   "HMul.hMul",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Int",
   "Inv.inv"],
  "name": "GroupWithZero.mk",
  "constType":
  "{G₀ : Type u} →\n  [toMonoidWithZero : MonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → GroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "NonUnitalNonAssocRing.toMul",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "of_eq_true",
   "Ring",
   "congr",
   "HMul.hMul",
   "congrArg",
   "left_distrib",
   "Eq.trans",
   "congrFun"],
  "name": "CancelDenoms.add_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e1 e2 t1 t2 : α}, n * e1 = t1 → n * e2 = t2 → n * (e1 + e2) = t1 + t2",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set.add",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Set.instEmptyCollectionSet",
   "add_right_injective",
   "Set.Finite",
   "Eq",
   "Set.instMembershipSet",
   "add_left_injective",
   "Function.Injective.injOn",
   "And",
   "Iff",
   "IsRightCancelAdd",
   "Add",
   "IsLeftCancelAdd",
   "Set.finite_image2"],
  "name": "Set.finite_add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsLeftCancelAdd α] [inst_2 : IsRightCancelAdd α] {s t : Set α},\n  Set.Finite (s + t) ↔ Set.Finite s ∧ Set.Finite t ∨ s = ∅ ∨ t = ∅",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Complex.one_cpow",
   "True",
   "Eq",
   "Complex.re",
   "Real.instOneReal",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.one_rpow",
  "constType": "∀ (x : ℝ), 1 ^ x = 1",
  "constCategory": "Theorem"},
 {"references": ["Abs"],
  "name": "Abs.abs",
  "constType": "{α : Type u_1} → [self : Abs α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Real.rpow_zero",
   "OfNat.ofNat",
   "Or",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Real.partialOrder",
   "Real",
   "Real.instLEReal",
   "One.toOfNat1",
   "Or.casesOn",
   "LE.le",
   "True",
   "Real.instOneReal",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.rpow_lt_rpow",
   "Eq.ndrec",
   "of_eq_true",
   "Preorder.toLT",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "le_refl",
   "congr",
   "le_of_lt",
   "congrArg",
   "Eq.trans",
   "eq_or_lt_of_le"],
  "name": "Real.rpow_le_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → x ≤ y → 0 ≤ z → x ^ z ≤ y ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "HAdd.hAdd",
   "Set",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Set.Elem",
   "AddSubgroup.IsComplement.existsUnique",
   "AddSubgroup.IsComplement",
   "Eq.trans",
   "Subtype",
   "id",
   "Mathlib.GroupTheory.Complement._auxAddLemma.1",
   "Membership.mem",
   "funext",
   "Set.add",
   "Prod.snd",
   "Std.Logic._auxLemma.39",
   "instHAdd",
   "Prod.fst",
   "Set.univ",
   "Std.Logic._auxLemma.51",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "And",
   "Set.eq_univ_of_forall",
   "Prod.mk",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "Prod",
   "congrArg",
   "Mathlib.Data.Prod.Basic._auxLemma.2",
   "Subtype.mk",
   "ExistsUnique.exists",
   "exists_prop_congr'"],
  "name": "AddSubgroup.IsComplement.add_eq",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G}, AddSubgroup.IsComplement S T → S + T = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "Add.add",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.toAdd",
   "left_comm",
   "Eq"],
  "name": "add_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + (b + c) = b + (a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Iff",
   "Set.Elem",
   "Set",
   "Finset",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "Nat",
   "Fintype.subtype_card",
   "Fintype.ofFinset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Fintype.card_ofFinset",
  "constType":
  "∀ {α : Type u_1} {p : Set α} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ x ∈ p), Fintype.card ↑p = Finset.card s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "add_nonpos",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "Real.linearOrder",
   "measurableSet_discrete",
   "IsROrC.charZero_isROrC",
   "Iff",
   "Set.Elem",
   "ProbabilityTheory.IsUniform.entropy_eq'",
   "instOfNat",
   "Subtype",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "DivisionRing.toInv",
   "Prod.instMeasurableSpace",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "AddZeroClass.toAdd",
   "NatCast",
   "CommMonoidWithZero.toZero",
   "HEq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Real.instLTReal",
   "LE.le.trans",
   "Mathlib.Tactic.Ring.mul_add",
   "add_lt_of_le_of_neg",
   "Field.toSemifield",
   "LE.le",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "Mathlib.Tactic.Ring.mul_congr",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.isROrC",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "And.casesOn",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Filter.univ_mem'",
   "Real.field",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "Set.instMembershipSet",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "HEq.refl",
   "Eq.mp",
   "Real.instAddGroupReal",
   "ProbabilityTheory.IsUniform.ae_mem",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.IndepFun",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "Pi.instSub",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Linarith.mul_nonpos",
   "Real.log_mul",
   "Set.sub",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "MeasureTheory.MeasureSpace",
   "Real.log_le_log",
   "Eq.casesOn",
   "Bool",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "LT.lt.ne'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "Set.Nonempty",
   "Finite.Set.finite_image2",
   "Real.orderedRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Mathlib.Data.Set.Finite._auxLemma.3",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "le_of_not_gt",
   "HDiv.hDiv",
   "instHSub",
   "HPow.hPow",
   "eq_of_heq",
   "Set.sub_mem_sub",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.isRat_div",
   "Field.toDiv",
   "AddCommGroup",
   "Int",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "Set.toFinite",
   "Filter.mp_mem",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Finset",
   "ProbabilityTheory.IsUniform.of_identDistrib",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Countable",
   "Int.mul",
   "sub_neg_of_lt",
   "Bool.false",
   "Real.instPreorderReal",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instLEReal",
   "Exists.casesOn",
   "Eq",
   "OrderedRing.toRing",
   "ProbabilityTheory.entropy_le_log_card_of_mem",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "rdist",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "setOf",
   "Real.partialOrder",
   "Nat.rawCast",
   "Finite",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "congrArg",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "Iff.rfl",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "le_of_eq",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Preorder.toLT",
   "instHPow",
   "Ring.toSub",
   "LE",
   "Linarith.mul_neg",
   "PFR_conjecture_pos_aux",
   "Real.strictOrderedRing",
   "MeasureTheory.Measure.ae",
   "Eq.symm",
   "Measurable.sub'",
   "funext",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "ProbabilityTheory.IdentDistrib.symm",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Semiring.toOne",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "ProbabilityTheory.independent_copies_two",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "DivisionSemiring.toSemiring",
   "Real.log",
   "Real.semiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Set.Finite.toFinset"],
  "name": "rdist_le_of_isUniform_of_card_add_le",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : MeasurableSpace G] [inst_2 : MeasurableSingletonClass G] {A : Set G}\n  [inst_3 : Finite ↑A] {K : ℝ} [inst_4 : Countable G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A - A)) ≤ K * ↑(Nat.card ↑A) →\n      ∀ {Ω : Type u_2} [inst_5 : MeasureTheory.MeasureSpace Ω]\n        [inst_6 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {U₀ : Ω → G},\n        ProbabilityTheory.IsUniform A U₀ → Measurable U₀ → d[U₀ # U₀] ≤ Real.log K",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "instOfNatNat",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "instAddNat",
   "instHAdd",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_5",
  "constType":
  "∀ (n : ℕ) (x : ℝ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["OrderIso", "RelIso.symm", "LE", "LE.le"],
  "name": "OrderIso.symm",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : LE α] → [inst_1 : LE β] → α ≃o β → β ≃o α",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset.image₂",
   "Finset",
   "Add",
   "Add.mk"],
  "name": "Finset.add",
  "constType":
  "{α : Type u_2} → [inst : DecidableEq α] → [inst : Add α] → Add (Finset α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "LinearOrder.decidableLE",
   "LinearOrder.max_def",
   "Field.toNontrivial",
   "Field.zpow_neg'",
   "Field.zpow",
   "Field.toRatCast",
   "Rat.instLinearOrderedFieldRat.proof_2",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Field.mul_inv_cancel",
   "Field",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Rat.linearOrder",
   "Field.ratCast_mk",
   "LinearOrder",
   "Semiring",
   "StrictOrderedRing.mk",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Field.toInv",
   "Rat.semiring",
   "Rat.field",
   "Rat.instLinearOrderedFieldRat.proof_1",
   "LinearOrder.toOrd",
   "Rat.instLinearOrderedFieldRat.proof_3",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "Field.inv_zero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "Field.qsmul",
   "LinearOrderedRing.mk",
   "Rat.instLinearOrderedFieldRat.proof_4",
   "Field.div_eq_mul_inv"],
  "name": "Rat.instLinearOrderedFieldRat",
  "constType": "LinearOrderedField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "StrictOrderedRing.toPartialOrder",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "LinearOrderedRing",
   "DecidableEq",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedRing : StrictOrderedRing α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "MulPosMono",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toMulPosMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], MulPosMono α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "Subtype.val",
   "AddSubgroup.zero",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Subtype",
   "SetLike.instMembership",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), ↑0 = ↑0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "Nat",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1157", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.mul",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddGroup",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (n : ℕ) (x : G), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Real.exp_pos",
   "Eq.refl",
   "Real.exp",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "HMul.hMul",
   "id"],
  "name": "Real.rpow_pos_of_pos",
  "constType": "∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), 0 < x ^ y",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Set.Subset", "Set", "LE"],
  "name": "Set.instLESet",
  "constType": "{α : Type u_1} → LE (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommMonoidWithZero",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddSubgroup.casesOn",
   "AddGroup",
   "Eq.rec",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddSubsemigroup.casesOn",
   "AddZeroClass",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "instHAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubsemigroup",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Add",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instSetLikeAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (p q : AddSubgroup G), (fun s => s.carrier) p = (fun s => s.carrier) q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "neg_zero",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "neg_neg",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Nat.add",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.cast_negSucc",
   "Nat",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Int.cast_ofNat",
   "Int.cast_zero",
   "Int.cast_neg.match_1",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.negSucc",
   "Int.cast",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Int.cast_neg",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℤ), ↑(-n) = -↑n",
  "constCategory": "Theorem"},
 {"references": ["Irreducible", "Nat.monoid", "Nat"],
  "name": "Nat.Prime",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "DivisionSemiring.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionSemiring.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "pos_and_pos_or_neg_and_neg_of_mul_pos",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing",
   "Iff.mpr",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "Iff",
   "mul_pos_of_neg_of_neg",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Or.elim",
   "StrictOrderedRing.toPartialOrder",
   "and_imp",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "StrictOrderedSemiring.toSemiring",
   "Iff.intro",
   "instHMul",
   "And",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "HMul.hMul",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "mul_pos",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toMulPosMono",
   "OrderedSemiring.toPosMulMono"],
  "name": "mul_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α}, 0 < a * b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "invertibleOne.proof_2",
   "One.toOfNat1",
   "Invertible.mk",
   "invertibleOne.proof_1",
   "Invertible",
   "Monoid.toMulOneClass"],
  "name": "invertibleOne",
  "constType": "{α : Type u} → [inst : Monoid α] → Invertible 1",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "mul_one",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "pow_one",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "And.left",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b : AddSubgroup G) (_x : G),\n  _x ∈ ↑_a.toAddSubmonoid ∧ _x ∈ ↑_b.toAddSubmonoid → _x ∈ ↑_a.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "CommGroupWithZero",
   "Semifield.toCommSemiring",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "Semifield.mul_inv_cancel",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semifield",
   "Semifield.toInv",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Semifield.toNontrivial",
   "CommMonoidWithZero.mk",
   "CommMonoid.mk",
   "Semigroup.mk",
   "CommGroupWithZero.mk",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "Semifield.zpow_zero'",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "mul_div_assoc",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toDiv"],
  "name": "mul_div_assoc'",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * (b / c) = a * b / c",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u_1} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Multiplicative", "Multiplicative.ofAdd", "Equiv.symm"],
  "name": "Multiplicative.toAdd",
  "constType": "{α : Type u} → Multiplicative α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "HEq",
   "eq_of_heq",
   "Subsingleton.allEq",
   "Eq.refl",
   "heq_of_eq",
   "Invertible",
   "Monoid.toMulOneClass",
   "Eq",
   "Invertible.subsingleton",
   "Eq.ndrec",
   "One",
   "HEq.refl",
   "Mul"],
  "name": "Invertible.congr",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "rfl"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat (Nat.rawCast n) n",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedAddCommGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{α : Type u} → [inst : NonUnitalNonAssocRing α] → HasDistribNeg α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Cardinal.isEquivalent"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasureTheory.MeasureSpace",
  "constType": "Type u_6 → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.sSup_le",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)) (a : AddSubgroup G), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Real", "Complex"],
  "name": "Complex.re",
  "constType": "ℂ → ℝ",
  "constCategory": "Definition"},
 {"references": ["AddMonoid.nsmul", "SMul", "SMul.mk", "Nat", "AddMonoid"],
  "name": "AddMonoid.toNatSMul",
  "constType": "{M : Type u_2} → [inst : AddMonoid M] → SMul ℕ M",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "OfNat.ofNat",
   "AddSubgroup.zero_mem",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "Iff.mp",
   "AddGroup",
   "Eq.rec",
   "AddSubgroup.mem_bot",
   "AddSubgroup",
   "Bot.mk",
   "AddSubgroup.instBotAddSubgroup",
   "Eq.symm",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_9",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (S : AddSubgroup G), ∀ _x ∈ ⊥, _x ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instCommSemiringReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "StarRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "starRingOfComm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name":
  "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
  "constType": "StarRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommRing α",
  "constCategory": "Other"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "PosMulMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Complex.instZeroComplex",
   "Complex.cpow_zero",
   "Real",
   "One.toOfNat1",
   "True",
   "Eq",
   "Complex.re",
   "Real.instOneReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.rpow_zero",
  "constType": "∀ (x : ℝ), x ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.out",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "CommMonoid.mul_comm",
   "CommMonoidWithZero",
   "CommSemiring.toCommMonoidWithZero.proof_1",
   "CommSemiring.toCommMonoidWithZero.proof_2",
   "CommMonoid",
   "CommSemiring",
   "AddMonoid.toZero",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "CommMonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalSeminormedRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "PseudoMetricSpace",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalSeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toNonUnitalRing : NonUnitalRing α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NonUnitalSeminormedRing α",
  "constCategory": "Other"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references": ["instHSub", "Set.image2", "Set", "HSub.hSub", "Sub", "Sub.mk"],
  "name": "Set.sub",
  "constType": "{α : Type u_2} → [inst : Sub α] → Sub (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real.instMulReal",
   "AddGroup.toSubtractionMonoid",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.9",
   "Real.pi",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Real.instPowReal",
   "Complex.ofReal_cpow",
   "le_of_lt",
   "Eq.trans",
   "HPow.hPow",
   "Real.partialOrder",
   "Complex.im",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "propext",
   "LT.lt",
   "Complex.cpow_mul",
   "Real.instAddGroupReal",
   "Complex.log",
   "congrArg",
   "congrFun",
   "AddZeroClass.toAdd",
   "Real",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.8",
   "Eq.refl",
   "Complex.ofReal_log",
   "AddMonoid.toAddZeroClass",
   "True",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Complex.ofReal_mul",
   "Complex.instPowComplex",
   "instHPow",
   "AddGroup.toAddCancelMonoid",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Complex.ofReal'",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Real.instLTReal",
   "Complex.ofReal_inj",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.pi_pos",
   "Real.log",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Complex",
   "Real.rpow_nonneg_of_nonneg",
   "NegZeroClass.toZero",
   "Complex.instMulComplex"],
  "name": "Real.rpow_mul",
  "constType": "∀ {x : ℝ}, 0 ≤ x → ∀ (y z : ℝ), x ^ (y * z) = (x ^ y) ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HMul.hMul →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.mul x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HMul.hMul) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.mul x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HMul.hMul (↑n) (↑n_1) n n_1 (Int.mul n n_1) (_ : HMul.hMul = HMul.hMul)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.mul n n_1 = Int.mul n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → CommMagma α",
  "constCategory": "Definition"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toSubNegMonoid : SubNegMonoid G] →\n    (∀ (x : G), - -x = x) → (∀ (a b : G), -(a + b) = -b + -a) → (∀ (a b : G), a + b = 0 → -a = b) → SubtractionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.toAddZeroClass.proof_2",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Function.Injective.addZeroClass",
   "AddSubmonoid.toAddZeroClass.proof_1",
   "Subtype.val",
   "AddSubmonoid.zero",
   "Set",
   "AddSubmonoid.toAddZeroClass.proof_3",
   "AddSubmonoid.add",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Subtype",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.toAddZeroClass",
  "constType":
  "{M : Type u_5} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → AddZeroClass ↥S",
  "constCategory": "Definition"},
 {"references": ["NonUnitalRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNonUnitalRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Eq.refl",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Function.Injective.eq_iff",
   "NonAssocSemiring",
   "RingHom.charZero",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Function.Injective",
   "CharZero",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.cast_inj",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "map_natCast",
   "Eq.symm",
   "CharZero.mk",
   "id"],
  "name": "RingHom.charZero_iff",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {ϕ : R →+* S},\n  Function.Injective ⇑ϕ → (CharZero R ↔ CharZero S)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHPow",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "Real.exp_add",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "HPow.hPow",
   "mul_add",
   "Real.instLTReal",
   "instHAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.normedCommRing",
   "Real.exp",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.instZeroReal",
   "Distrib.leftDistribClass",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "Real.log",
   "of_eq_true",
   "LT.lt",
   "HMul.hMul",
   "congr",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg"],
  "name": "Real.rpow_add",
  "constType": "∀ {x : ℝ}, 0 < x → ∀ (y z : ℝ), x ^ (y + z) = x ^ y * x ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "AddSubgroup.instTopAddSubgroup",
   "Top.top",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Set.mem_univ",
   "SetLike.instMembership"],
  "name": "AddSubgroup.mem_top",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (x : G), x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.toInfSet",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield.zpow_neg'",
   "LinearOrderedSemifield.mul_inv_cancel",
   "CommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Semifield",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.div_eq_mul_inv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedSemifield.inv_zero",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toNontrivial",
   "Semifield.mk",
   "LinearOrderedSemifield.zpow_succ'",
   "LinearOrderedSemifield.zpow_zero'",
   "StrictOrderedCommSemiring.mul_comm"],
  "name": "LinearOrderedSemifield.toSemifield",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → Semifield α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "mul_one",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_one",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * Nat.rawCast 1 = a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "Real",
   "Real.instRingReal",
   "AddGroupWithOne.toAddGroup"],
  "name": "Real.instAddGroupReal",
  "constType": "AddGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "LinearOrderedCommMonoid",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "OrderedCommMonoid",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "OrderedCommMonoid.toPartialOrder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedCommMonoid : OrderedCommMonoid α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["InvOneClass.mk",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid.inv_one",
   "InvOneClass",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "One.toOfNat1",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "instOfNatNat",
   "LinearOrder.decidableEq",
   "Nat",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.instLinearOrderedFieldReal.proof_4",
  "constType": "∀ (x : ℝ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Set.add",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddHomClass",
   "HAdd.hAdd",
   "Set.image_image2_distrib",
   "Set",
   "map_add",
   "FunLike.coe",
   "Set.image",
   "Add",
   "Eq"],
  "name": "Set.image_add",
  "constType":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Add α] [inst_1 : Add β] [inst_2 : AddHomClass F α β] (m : F)\n  {s t : Set α}, ⇑m '' (s + t) = ⇑m '' s + ⇑m '' t",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalCommRing", "NonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalRing",
  "constType": "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
   "Neg.neg",
   "Sub",
   "autoParam",
   "AddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
   "Nat",
   "Nat.succ",
   "Int",
   "Neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Rat",
   "Rat.instLinearOrderedCommRingRat"],
  "name": "Rat.instLinearOrderedRingRat",
  "constType": "LinearOrderedRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), a * b = 1 → a⁻¹ = b",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "SupSet.mk",
   "Lattice.mk",
   "completeLatticeOfInf.proof_8",
   "Sup.mk",
   "Insert.insert",
   "completeLatticeOfInf.proof_12",
   "Preorder.toLE",
   "Inf.mk",
   "Set.instSingletonSet",
   "upperBounds",
   "completeLatticeOfInf.proof_10",
   "completeLatticeOfInf.proof_3",
   "completeLatticeOfInf.proof_7",
   "IsGLB",
   "completeLatticeOfInf.proof_5",
   "setOf",
   "SemilatticeSup.mk",
   "InfSet",
   "Set.instEmptyCollectionSet",
   "completeLatticeOfInf.proof_11",
   "completeLatticeOfInf.proof_2",
   "Set.univ",
   "LE.le",
   "completeLatticeOfInf.proof_6",
   "PartialOrder",
   "InfSet.mk",
   "And",
   "CompleteLattice",
   "completeLatticeOfInf.proof_1",
   "completeLatticeOfInf.proof_9",
   "Bot.mk",
   "PartialOrder.le_antisymm",
   "completeLatticeOfInf.proof_4",
   "Singleton.singleton",
   "Top.mk",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf",
  "constType":
  "(α : Type u_9) → [H1 : PartialOrder α] → [H2 : InfSet α] → (∀ (s : Set α), IsGLB s (sInf s)) → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Distrib",
   "Eq"],
  "name": "Distrib.mk",
  "constType":
  "{R : Type u_1} →\n  [toMul : Mul R] →\n    [toAdd : Add R] →\n      (∀ (a b c : R), a * (b + c) = a * b + a * c) → (∀ (a b c : R), (a + b) * c = a * c + b * c) → Distrib R",
  "constCategory": "Other"},
 {"references":
  ["SubNegMonoid",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_neg'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["instHMul", "Rat", "HMul.hMul", "Mul"],
  "name": "qsmulRec",
  "constType": "{K : Type u_3} → (ℚ → K) → [inst : Mul K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Set.instHasSubsetSet",
   "Set",
   "HSub.hSub",
   "Set.sub",
   "HasSubset.Subset",
   "Set.image2_subset",
   "Sub"],
  "name": "Set.sub_subset_sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s₁ s₂ t₁ t₂ : Set α}, s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ - s₂ ⊆ t₁ - t₂",
  "constCategory": "Theorem"},
 {"references": ["One", "Mul", "Invertible"],
  "name": "Invertible.invOf",
  "constType":
  "{α : Type u} → [inst : Mul α] → [inst_1 : One α] → (a : α) → [self : Invertible a] → α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "instHMul",
   "NormedRing.norm_mul",
   "NormedCommRing",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm",
   "instHMul",
   "mul_assoc",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "Mul.mul",
   "CommSemigroup",
   "left_comm",
   "Eq",
   "CommSemigroup.toSemigroup"],
  "name": "mul_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * (b * c) = b * (a * c)",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "Ring"],
  "name": "NormedRing.toRing",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "instHMul",
   "MulOneClass.toMul",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "mul_inv_rev",
  "constType":
  "∀ {G : Type u_1} [inst : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "DivInvMonoid",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "mul_div_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * b / c = a * (b / c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "False", "propext", "or_false.match_1", "Eq"],
  "name": "or_false",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "IsUnit.div_eq_iff",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Iff",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "div_eq_iff",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c ↔ a = c * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CommSemiring",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Mathlib.Meta.NormNum.IsNat.out",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "add_add_add_comm"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ a₂ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references": ["Rat", "Rat.neg", "Neg", "Neg.mk"],
  "name": "Rat.instNegRat",
  "constType": "Neg ℚ",
  "constCategory": "Definition"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} → [self : Ring R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Real",
   "CommSemiring",
   "Real.commRing"],
  "name": "Real.instCommSemiringReal",
  "constType": "CommSemiring ℝ",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{α : Type u} → (α → α → α) → Inf α",
  "constCategory": "Other"},
 {"references": ["Semifield", "Inv"],
  "name": "Semifield.toInv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "eq_neg_add_iff_add_eq",
   "sub_eq_add_neg",
   "sub_eq_iff_eq_add",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.cast",
   "Nat",
   "Eq.trans",
   "instHSub",
   "add_assoc",
   "Nat.cast_add",
   "Int.cast_ofNat",
   "Int.instAddInt",
   "of_eq_true",
   "Int.negSucc",
   "Int.cast",
   "propext",
   "congr",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "Int.cast_subNatNat",
   "AddZeroClass.toAdd",
   "Nat.add_assoc",
   "Nat.add_comm",
   "Int.cast_add.match_1",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "Nat.add_right_comm",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "NegZeroClass.toNeg",
   "neg_add_rev"],
  "name": "Int.cast_add",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq.le_total",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "IsTotal",
   "Rat.instNegRat",
   "congr",
   "IsTotal.mk",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.instIsTotalRealLeInstLEReal",
  "constType": "IsTotal ℝ fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "Ring.toNonAssocRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.isROrC.proof_5",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Real.decidableEq",
   "Field.toCommRing",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.isROrC.proof_3",
   "Real.isROrC.proof_1",
   "Real.isROrC.proof_9",
   "Real.isROrC.proof_7",
   "Real.isROrC.proof_12",
   "Real.isROrC.proof_10",
   "Real.isROrC.proof_11",
   "Real.isROrC.proof_2",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "Real.isROrC.proof_6",
   "Real.partialOrder",
   "Ring.toSemiring",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Real.isROrC.proof_4",
   "Real.instZeroReal",
   "Real.isROrC.proof_13",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC.mk",
   "Real.isROrC.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC",
  "constType": "IsROrC ℝ",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.4598"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.le",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "NegZeroClass.neg_zero",
   "Eq"],
  "name": "neg_zero",
  "constType": "∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Other"},
 {"references": ["HSMul", "HSMul.mk", "SMul", "SMul.smul"],
  "name": "instHSMul",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references": ["Monoid", "Nat"],
  "name": "Monoid.npow",
  "constType": "{M : Type u} → [self : Monoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → ({a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) → Trans r s t",
  "constCategory": "Other"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references": ["instLENat", "Min", "minOfLe", "Nat", "Nat.decLe"],
  "name": "instMinNat",
  "constType": "Min ℕ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Int.negSucc",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_9",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddHomClass.toFunLike",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "AddGroup",
   "Function.Injective",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Subtype.coe_injective",
   "AddSubgroup.subtype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "AddMonoidHom"],
  "name": "AddSubgroup.subtype_injective",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), Function.Injective ⇑(AddSubgroup.subtype H)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semifield.zpow_zero'",
   "DivisionSemiring",
   "Semifield.toNontrivial",
   "Semifield.toCommSemiring",
   "DivisionSemiring.mk",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.mul_inv_cancel",
   "Semifield.zpow_neg'",
   "Semifield.zpow",
   "Semifield.toDiv",
   "Semifield.toInv",
   "Semifield",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references": ["DivisionMonoid", "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvMonoid",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "Nat"],
  "name": "Mathlib.Meta.NormNum.IsNat",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → α → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.zero_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["SeminormedRing", "Ring"],
  "name": "SeminormedRing.toRing",
  "constType": "{α : Type u_5} → [self : SeminormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_one",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Int.cast_add",
   "Invertible",
   "MulZeroClass.toMul",
   "Iff.mpr",
   "Eq",
   "Semiring.toNatCast",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat",
   "mul_inv_rev",
   "Eq.trans",
   "GroupWithZero.toInv",
   "Ne",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionSemiring.toGroupWithZero",
   "Nat.cast_ne_zero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toMulZeroClass",
   "DivisionRing.toInv",
   "Int.cast_ofNat",
   "DivInvMonoid.toInv",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Inv.inv",
   "Int.ofNat",
   "DivisionRing.toDivisionSemiring",
   "instOfNatInt",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "GroupWithZero.toDivisionMonoid",
   "True",
   "Ring.toNonAssocRing",
   "invertibleOfNonzero",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "InvolutiveInv.toInv",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "Nat.succ",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Mathlib.Meta.NormNum.IsRat",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "inv_inv",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "invOf_eq_inv",
   "Semiring.toOne",
   "Eq.ndrec",
   "CharZero",
   "instNatCastInt",
   "letFun",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul"],
  "name": "Mathlib.Meta.NormNum.isRat_inv_pos",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] [inst_1 : CharZero α] {a : α} {n d : ℕ},\n  Mathlib.Meta.NormNum.IsRat a (Int.ofNat (Nat.succ n)) d → Mathlib.Meta.NormNum.IsRat a⁻¹ (Int.ofNat d) (Nat.succ n)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubgroup.map.proof_1",
   "AddSubsemigroup.mk",
   "AddHomClass.toFunLike",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddSubmonoid.map",
   "AddSubgroup.map.proof_3",
   "AddGroup",
   "AddSubgroup.map.proof_2",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubgroup.mk",
   "Set.image",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddMonoidHom",
   "SetLike.coe"],
  "name": "AddSubgroup.map",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → {N : Type u_5} → [inst_1 : AddGroup N] → (G →+ N) → AddSubgroup G → AddSubgroup N",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "eq_of_heq",
   "Ring.toIntCast",
   "Ring",
   "Eq.refl",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isRat.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℤ) → Mathlib.Meta.NormNum.IsInt x x_1 → Prop) (x : α)\n  (x_1 : ℤ) (x_2 : Mathlib.Meta.NormNum.IsInt x x_1),\n  (∀ (n : ℤ), motive (↑n) n (_ : Mathlib.Meta.NormNum.IsInt (↑n) n)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.zsmul",
   "instHSMul",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Int",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℤ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : FunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "MetricSpace"],
  "name": "NormedRing.toMetricSpace",
  "constType": "{α : Type u_5} → [self : NormedRing α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "add_lt_add_left",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "instTransEq_1",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "instTransLtToLTLeToLE",
   "add_zero",
   "AddZeroClass"],
  "name": "add_lt_of_le_of_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, b ≤ c → a < 0 → b + a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "CommSemiring.mk",
   "Field.toSemifield.proof_1",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Ring.toSemiring",
   "Semifield",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Semifield.mk",
   "Field.toDiv",
   "Field.div_eq_mul_inv"],
  "name": "Field.toSemifield",
  "constType": "{K : Type u_3} → [inst : Field K] → Semifield K",
  "constCategory": "Definition"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Monoid.toNatPow",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₃ b c : R} (a₁ : R) (a₂ : ℕ), a₃ * b = c → a₁ ^ a₂ * a₃ * b = a₁ ^ a₂ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.negSucc n) a = (LinearOrderedSemifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedCommRing α] → LinearOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Set.add",
   "DecidableEq",
   "instHAdd",
   "Finset.toSet",
   "Set",
   "HAdd.hAdd",
   "Finset.coe_image₂",
   "Finset",
   "Add",
   "Finset.add",
   "Eq"],
  "name": "Finset.coe_add",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] (s t : Finset α), ↑(s + t) = ↑s + ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "MulPosMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toZero",
   "ZeroHom.mk",
   "AddMonoidHom.id.proof_2",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.id.proof_1"],
  "name": "AddMonoidHom.id",
  "constType": "(M : Type u_9) → [inst : AddZeroClass M] → M →+ M",
  "constCategory": "Definition"},
 {"references":
  ["DenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.mk",
   "Real.denselyNormedField.proof_1"],
  "name": "Real.denselyNormedField",
  "constType": "DenselyNormedField ℝ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "Int"],
  "name": "LinearOrderedField.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "OrderedRing.toPartialOrder",
   "OrderedRing.toRing",
   "OrderedRing.toOrderedSemiring.proof_1",
   "Semiring",
   "OrderedRing",
   "OrderedRing.add_le_add_left",
   "OrderedSemiring.mk",
   "OrderedRing.toOrderedSemiring.proof_2",
   "Ring.toSemiring",
   "OrderedRing.zero_le_one"],
  "name": "OrderedRing.toOrderedSemiring",
  "constType": "{α : Type u} → [inst : OrderedRing α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [inst : Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "eq_true",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "True",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), (0 ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "Invertible",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "inv_mul_cancel",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "Invertible.mk",
   "MonoidWithZero.toZero",
   "mul_inv_cancel",
   "Inv.inv",
   "GroupWithZero.toInv"],
  "name": "invertibleOfNonzero",
  "constType":
  "{α : Type u} → [inst : GroupWithZero α] → {a : α} → a ≠ 0 → Invertible a",
  "constCategory": "Definition"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.toAddGroup.proof_1",
   "AddSubgroup.toAddGroup.proof_6",
   "AddSubgroup.toAddGroup.proof_3",
   "Subtype.val",
   "AddSubgroup.zero",
   "AddSubgroup.toAddGroup.proof_4",
   "SetLike.instMembership",
   "Function.Injective.addGroup",
   "AddSubgroup.toAddGroup.proof_7",
   "AddSubgroup.zsmul",
   "AddGroup",
   "AddSubgroup.nsmul",
   "AddSubgroup.toAddGroup.proof_5",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.neg",
   "AddSubgroup.sub",
   "Subtype",
   "AddSubgroup.add",
   "AddSubgroup.toAddGroup.proof_2"],
  "name": "AddSubgroup.toAddGroup",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → (H : AddSubgroup G) → AddGroup ↥H",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references": ["Int.cast", "Ring.toIntCast", "Ring", "Int"],
  "name": "Int.rawCast",
  "constType": "{α : Type u_1} → [inst : Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionSemiring",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_1",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionRing.mul_inv_cancel",
   "DivisionRing",
   "DivisionRing.div_eq_mul_inv",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "DivisionSemiring",
   "DivisionRing.zpow_zero'",
   "DivisionSemiring.mk",
   "DivisionRing.inv_zero",
   "Ring.toSemiring",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toDiv",
   "DivisionRing.toInv"],
  "name": "DivisionRing.toDivisionSemiring",
  "constType": "{α : Type u_1} → [inst : DivisionRing α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.sub_eq_add_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "of_eq_true",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom.id",
   "AddMonoidHom",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_8",
  "constType": "∀ (z : ℝ), (AddMonoidHom.id ℝ) z = (AddMonoidHom.id ℝ) z",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Set",
   "Set.singleton_prod_singleton",
   "MeasurableSet.singleton",
   "Prod.instMeasurableSpace",
   "Eq",
   "MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Prod.instMeasurableSingletonClass.match_1",
   "Prod.mk",
   "Eq.rec",
   "SProd.sprod",
   "MeasurableSet",
   "MeasurableSet.prod",
   "Prod",
   "Singleton.singleton",
   "MeasurableSpace",
   "MeasurableSingletonClass.mk"],
  "name": "Prod.instMeasurableSingletonClass",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [inst : MeasurableSingletonClass α]\n  [inst : MeasurableSingletonClass β], MeasurableSingletonClass (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "instZeroAddMonoidHom",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "Iff.symm",
   "And",
   "Iff",
   "and_iff_left",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_13",
  "constType": "∀ {z w : ℝ}, z ≤ w ↔ z ≤ w ∧ 0 z = 0 z",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.827"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.add",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "Nat",
   "Nat.decLe",
   "Nat.strictOrderedSemiring"],
  "name": "Nat.orderedSemiring",
  "constType": "OrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Set.subtractionMonoid.proof_9",
   "Set.subtractionMonoid.proof_1",
   "AddMonoid.nsmul",
   "SMul",
   "Set",
   "Sub",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.addMonoid",
   "SubtractionMonoid.mk",
   "Sub.mk",
   "zsmulRec",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "InvolutiveNeg",
   "AddMonoid.toAddSemigroup",
   "Set.subtractionMonoid.proof_4",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "Set.subtractionMonoid.proof_8",
   "Set.sub",
   "Sub.sub",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Set.subtractionMonoid.proof_6",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "AddMonoid",
   "AddMonoid.mk",
   "Set.addSemigroup",
   "Set.subtractionMonoid.proof_7",
   "Set.subtractionMonoid.proof_3",
   "Set.ZSMul",
   "SubtractionMonoid.toSubNegMonoid",
   "Set.subtractionMonoid.proof_11",
   "SubNegMonoid.toAddMonoid",
   "Set.subtractionMonoid.proof_2",
   "Set.subtractionMonoid.proof_10",
   "Set.subtractionMonoid.proof_12",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int",
   "Set.addZeroClass",
   "Set.subtractionMonoid.proof_5"],
  "name": "Set.subtractionMonoid",
  "constType":
  "{α : Type u_2} → [inst : SubtractionMonoid α] → SubtractionMonoid (Set α)",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} → [self : RelHomClass F r s] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddAction.proof_2",
   "AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddAction.mk",
   "AddMonoid.toAddZeroClass",
   "AddAction",
   "AddMonoid.toAddAction.proof_1",
   "AddMonoid",
   "VAdd.mk"],
  "name": "AddMonoid.toAddAction",
  "constType": "(M : Type u_1) → [inst : AddMonoid M] → AddAction M M",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "Commute.eq",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "True",
   "Commute",
   "Semigroup",
   "Eq"],
  "name": "Commute.right_comm",
  "constType":
  "∀ {S : Type u_2} [inst : Semigroup S] {b c : S}, Commute b c → ∀ (a : S), a * b * c = a * c * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalNonAssocCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NormedRing", "NormedCommRing"],
  "name": "NormedCommRing.toNormedRing",
  "constType": "{α : Type u_5} → [self : NormedCommRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_2",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["Lattice.toInf",
   "LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLattice.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice.mk",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left"],
  "name": "instDistribLattice",
  "constType": "{α : Type u} → [inst : LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Nat.strictMono_cast",
   "Nat.linearOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "StrictMono.lt_iff_lt",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_lt",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, ↑m < ↑n ↔ m < n",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "HEq",
   "Real.natCast",
   "Iff.rfl",
   "Real",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "autoParam",
   "True",
   "Set.toFinite",
   "Eq",
   "Mathlib.Data.Set.Finite._auxLemma.3",
   "MeasureTheory.Measure",
   "inferInstance",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "Set.Elem",
   "Finset.toSet",
   "Finset",
   "Measurable",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Subtype",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "eq_of_heq",
   "Finite",
   "Finset.instMembershipFinset",
   "Set.Finite.coe_toFinset",
   "ProbabilityTheory.IsUniform.entropy_eq",
   "Set.instMembershipSet",
   "Countable",
   "Real.log",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "propext",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "Eq.casesOn",
   "congrArg",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "Set.Finite.toFinset",
   "congrFun"],
  "name": "ProbabilityTheory.IsUniform.entropy_eq'",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {H : Set S} [inst_2 : Finite ↑H] {X : Ω → S} {μ : MeasureTheory.Measure Ω}\n  [inst_3 : MeasureTheory.IsProbabilityMeasure μ],\n  ProbabilityTheory.IsUniform H X → Measurable X → H[X ; μ] = Real.log ↑(Nat.card ↑H)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHDiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedField.toDiv",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["IsROrC.toNormedAlgebra",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "NormedAlgebra.toAlgebra",
   "Real",
   "Real.normedField",
   "DenselyNormedField.toNormedField",
   "RingHom.charZero_iff",
   "IsROrC",
   "RingHom.injective",
   "NormedField.toField",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "Iff.mp",
   "Real.instCommSemiringReal",
   "Real.strictOrderedSemiring",
   "NormedRing.toRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsROrC.toDenselyNormedField",
   "Ring.toAddGroupWithOne",
   "algebraMap",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Real.instDivisionRingReal",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "StrictOrderedSemiring.to_charZero",
   "CharZero",
   "Field.toEuclideanDomain",
   "Semifield.toDivisionSemiring",
   "EuclideanDomain.toNontrivial"],
  "name": "IsROrC.charZero_isROrC",
  "constType": "∀ {K : Type u_1} [inst : IsROrC K], CharZero K",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} (motive : Mathlib.Meta.NormNum.IsNat a 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a 0), (∀ (e : a = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat a 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "eq_true",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder",
   "congrFun"],
  "name": "Linarith.le_of_le_of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a ≤ 0 → b = 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "Nat.cast_le",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.140",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "Real",
   "autoParam",
   "ProbabilityTheory.measureEntropy",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.entropy",
  "constType":
  "{Ω : Type uΩ} →\n  {S : Type uS} →\n    [mΩ : MeasurableSpace Ω] → [inst : MeasurableSpace S] → (Ω → S) → autoParam (MeasureTheory.Measure Ω) _auto✝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Real",
   "Lattice",
   "Real.instDistribLatticeReal"],
  "name": "Real.lattice",
  "constType": "Lattice ℝ",
  "constCategory": "Definition"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_3",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + 0 = a",
  "constCategory": "Theorem"}]
