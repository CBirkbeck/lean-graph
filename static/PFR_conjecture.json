[{"references": ["Quot", "Quot.mk", "Eq"],
  "name": "Quot.sound",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "constCategory": "Axiom"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.add_zero",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.im",
   "instHSub",
   "instHMul",
   "instHAdd",
   "Complex.mk",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Real.instSubReal",
   "Real",
   "HSub.hSub",
   "HMul.hMul",
   "Complex",
   "Mul",
   "Complex.re",
   "Mul.mk"],
  "name": "Complex.instMulComplex",
  "constType": "Mul ℂ",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Set",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_4",
  "constType": "∀ {α : Type u_1} (a : Set α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Function.LeftInverse", "Function.RightInverse"],
  "name": "Equiv.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    (toFun : α → β) → (invFun : β → α) → Function.LeftInverse invFun toFun → Function.RightInverse invFun toFun → α ≃ β",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "Prod.snd",
   "SProd.sprod",
   "measurable_fst",
   "Set",
   "MeasurableSet",
   "Prod",
   "Prod.fst",
   "MeasurableSet.inter",
   "MeasurableSpace",
   "measurable_snd",
   "Prod.instMeasurableSpace"],
  "name": "MeasurableSet.prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {s : Set α} {t : Set β},\n  MeasurableSet s → MeasurableSet t → MeasurableSet (s ×ˢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroClass.mul_zero",
   "Cardinal.partialOrder",
   "Exists.casesOn",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "Cardinal.canLiftCardinalNat",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Cardinal.toNat_apply_of_aleph0_le",
   "Nat",
   "Ne",
   "eq_or_ne",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "ZeroHom",
   "Or.casesOn",
   "Cardinal.instMulCardinal",
   "Cardinal.instZeroCardinal",
   "And",
   "instHMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Cardinal.toNat_cast",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Exists",
   "ZeroHom.zeroHomClass",
   "CanLift.prf",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "Nat.cast_mul",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Cardinal.toNat",
   "Cardinal.aleph0",
   "ZeroHomClass.toFunLike",
   "Preorder.toLT",
   "Cardinal.aleph0_le_mul_iff'",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Eq.symm",
   "Cardinal.canonicallyOrderedCommSemiring",
   "id",
   "lt_or_le",
   "Nat.linearOrderedCommMonoidWithZero",
   "Or.inr",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Cardinal.linearOrder",
   "LE.le",
   "Cardinal.instLECardinal",
   "Eq.ndrec",
   "Or.inl",
   "Cardinal.instNatCastCardinal",
   "Cardinal.zero_toNat",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Cardinal",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "instMulNat",
   "Nat.semiring"],
  "name": "Cardinal.toNat_mul",
  "constType":
  "∀ (x y : Cardinal.{u_1}), Cardinal.toNat (x * y) = Cardinal.toNat x * Cardinal.toNat y",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "div_eq_mul_inv",
   "DivInvMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "Eq.mpr",
   "one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "HDiv.hDiv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "id"],
  "name": "inv_eq_one_div",
  "constType": "∀ {G : Type u_3} [inst : DivInvMonoid G] (x : G), x⁻¹ = 1 / x",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemigroup"],
  "name": "Real.instCommSemigroupReal",
  "constType": "CommSemigroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHasEquiv",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Real.ext_cauchy_iff",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.equiv",
   "Iff",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Iff.trans",
   "HasEquiv.Equiv",
   "Rat.instLinearOrderedFieldRat",
   "CauSeq.Completion.mk_eq",
   "Real.cauchy"],
  "name": "Real.mk_eq",
  "constType": "∀ {f g : CauSeq ℚ abs}, Real.mk f = Real.mk g ↔ f ≈ g",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "Nat.cast_le",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "PFR.Main._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "AddSemigroup.add_assoc",
   "AddSemigroup.mk",
   "Function.Injective",
   "AddSemigroup.toAdd",
   "Function.Injective.addSemigroup",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommSemigroup.mk",
   "Add",
   "Function.Injective.addCommSemigroup.proof_1",
   "AddSemigroup",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "Function.Injective.addCommSemigroup",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : AddCommSemigroup M₂] →\n        (f : M₁ → M₂) → Function.Injective f → (∀ (x y : M₁), f (x + y) = f x + f y) → AddCommSemigroup M₁",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "AddSubsemigroup",
  "constType": "(M : Type u_4) → [inst : Add M] → Type u_4",
  "constCategory": "Other"},
 {"references": ["Complex.ofReal'", "Real", "Complex.exp", "Complex.re"],
  "name": "Real.exp",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instMulCardinal",
   "instHMul",
   "Equiv.prodCongr",
   "Cardinal.mk_congr",
   "Cardinal",
   "HMul.hMul",
   "Equiv.ulift",
   "Prod",
   "Cardinal.mk",
   "ULift",
   "Cardinal.lift",
   "Eq",
   "Equiv.symm"],
  "name": "Cardinal.mk_prod",
  "constType":
  "∀ (α : Type u) (β : Type v),\n  Cardinal.mk (α × β) = Cardinal.lift.{v, u} (Cardinal.mk α) * Cardinal.lift.{u, v} (Cardinal.mk β)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "Set.univ",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "And",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Iff",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image_univ",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f '' Set.univ = Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_comm",
   "True",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.one_mul",
   "HMul.hMul",
   "Int.add_mul",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.instCommRingInt.proof_6",
  "constType": "∀ (m : ℕ) (n : ℤ), (↑m + 1) * n = n + ↑m * n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Ne",
   "OfNat.ofNat",
   "False",
   "Finset.sum",
   "Finset.instMembershipFinset",
   "AddCommMonoid.toAddMonoid",
   "Finset.sum_const_zero",
   "rfl",
   "Eq",
   "Finset.sum_eq_single_of_mem",
   "Zero.toOfNat0",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "Finset",
   "Not",
   "by_cases",
   "Eq.symm",
   "Finset.sum_congr",
   "Eq.trans",
   "AddCommMonoid"],
  "name": "Finset.sum_eq_single",
  "constType":
  "∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] {s : Finset α} {f : α → β} (a : α),\n  (∀ b ∈ s, b ≠ a → f b = 0) → (a ∉ s → f a = 0) → (Finset.sum s fun x => f x) = f a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "HMul.hMul",
   "HasDistribNeg",
   "Neg.neg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mk",
  "constType":
  "{α : Type u_1} →\n  [inst : Mul α] →\n    [toInvolutiveNeg : InvolutiveNeg α] →\n      (∀ (x y : α), -x * y = -(x * y)) → (∀ (x y : α), x * -y = -(x * y)) → HasDistribNeg α",
  "constCategory": "Other"},
 {"references":
  ["Preorder.toLT", "LT.lt", "le_of_lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LT.lt.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not"],
  "name": "decide_eq_false.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → ¬p → Prop) (x : Decidable p) (x_1 : ¬p),\n  (∀ (h₁ : p) (h₂ : ¬p), motive (isTrue h₁) h₂) → (∀ (h x : ¬p), motive (isFalse h) x) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid",
   "AddAction.orbit",
   "AddGroup",
   "AddAction.orbitRel.proof_1",
   "Set",
   "Setoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "Set.instMembershipSet"],
  "name": "AddAction.orbitRel",
  "constType":
  "(G : Type u_1) → (α : Type u_2) → [inst : AddGroup G] → [inst : AddAction G α] → Setoid α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.inv_zero",
  "constType": "∀ {K : Type u} [self : DivisionRing K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "AddSubgroup.instBotAddSubgroup.proof_2",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "AddGroup",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "Bot.mk",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddSubgroup.instBotAddSubgroup.proof_1"],
  "name": "AddSubgroup.instBotAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Bot (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "AEMeasurable.congr",
   "Filter.EventuallyEq",
   "MeasureTheory.Measure.map_congr",
   "ProbabilityTheory.IdentDistrib",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace",
   "AEMeasurable",
   "ProbabilityTheory.IdentDistrib.mk"],
  "name": "ProbabilityTheory.IdentDistrib.of_ae_eq",
  "constType":
  "∀ {α : Type u_1} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace γ] {μ : MeasureTheory.Measure α}\n  {f g : α → γ}, AEMeasurable f → f =ᶠ[MeasureTheory.Measure.ae μ] g → ProbabilityTheory.IdentDistrib f g",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "exists_nat_pow_near",
   "HAdd.hAdd",
   "OmegaCompletePartialOrder.toPartialOrder",
   "IsPGroup",
   "Exists.intro",
   "Exists.casesOn",
   "instLTNat",
   "Iff.mpr",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Sylow.exists_subgroup_le_card_pow_prime_of_le_card",
   "Nat.Prime",
   "instLENat",
   "instHPow",
   "Nat.one_le_iff_ne_zero",
   "Nat.monoid",
   "Subgroup",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Group",
   "instArchimedeanNatToOrderedAddCommMonoidOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Nat",
   "And.casesOn",
   "Nat.linearOrderedSemiring",
   "Subtype",
   "id",
   "Nat.strictOrderedSemiring",
   "Nat.Prime.one_lt",
   "Membership.mem",
   "HPow.hPow",
   "Subgroup.instCompleteLatticeSubgroup",
   "Ne",
   "instAddNat",
   "instHAdd",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "LE.le.trans",
   "Nat.canonicallyOrderedCommSemiring",
   "Monoid.toMulOneClass",
   "LE.le",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "And",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "Eq.mp",
   "congr",
   "HMul.hMul",
   "pow_succ",
   "And.intro",
   "instMulNat",
   "congrArg",
   "Nat.card",
   "congrFun",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Sylow.exists_subgroup_le_card_le",
  "constType":
  "∀ {G : Type u} [inst : Group G] {k p : ℕ},\n  Nat.Prime p →\n    IsPGroup p G → ∀ {H : Subgroup G}, k ≤ Nat.card ↥H → k ≠ 0 → ∃ H' ≤ H, Nat.card ↥H' ≤ k ∧ k < p * Nat.card ↥H'",
  "constCategory": "Theorem"},
 {"references": ["AddRightCancelMonoid", "AddRightCancelSemigroup"],
  "name": "AddRightCancelMonoid.toAddRightCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddRightCancelMonoid M] → AddRightCancelSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.PFR.ForMathlib.Entropy.Measure._hyg.98",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "ent_of_diff_le",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Trans.trans",
   "instDecidableEqFin",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Mathlib.Meta.NormNum.isRat_add",
   "Nat.cast_zero",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "IsROrC.charZero_isROrC",
   "Nat.cast",
   "Nat.lt_of_succ_lt_succ",
   "Bool.true",
   "AddTorsor.nonempty",
   "HDiv.hDiv",
   "addGroupIsAddTorsor",
   "instOfNat",
   "Fin.mk",
   "instHSub",
   "HPow.hPow",
   "instHDiv",
   "List.pmap",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Real.instRingReal",
   "DivisionRing.toInv",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "And",
   "Fin.instAddMonoidWithOne",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Mathlib.Meta.NormNum.IsRat.den_nz",
   "congr",
   "instTransEq",
   "instNatAtLeastTwo",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "List.pmap.proof_4",
   "AddCommGroup",
   "Int",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Fin",
   "congrFun",
   "Inv.inv",
   "Exists",
   "CommMonoidWithZero.toZero",
   "HEq",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "Mathlib.Tactic.Ring.sub_congr",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "Mathlib.Tactic.Ring.sub_pf",
   "MeasureTheory.Measure",
   "AddMonoidWithOne.toNatCast",
   "Fintype.elems",
   "Finset",
   "Monoid.toNatPow",
   "Measurable",
   "List.nil",
   "Matrix.vecHead",
   "Mathlib.Tactic.Ring.inv_single",
   "Nat.succ",
   "Mathlib.Meta.NormNum.isRat_mul",
   "List.finRange.proof_1",
   "List.cons",
   "NonUnitalNonAssocRing.toMul",
   "Matrix.vecTail",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "List.Mem.tail",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Matrix.vecEmpty",
   "LE.le",
   "ProbabilityTheory.iIndepFun.indepFun_prod_mk",
   "Real.instDivisionRingReal",
   "Countable",
   "CommRing.toCommSemiring",
   "Int.mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsRat.of_raw",
   "Mathlib.Tactic.Ring.one_mul",
   "letFun",
   "List.Mem.head",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "List.pmap.proof_3",
   "Real.instSubReal",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "autoParam",
   "Exists.casesOn",
   "instLTNat",
   "Eq",
   "Mathlib.Tactic.Ring.div_pf",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "FiniteRange",
   "rdist",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "List.finRange",
   "Matrix.cons_val_succ'",
   "List.Mem.casesOn",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "Nat.cast_one",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.514",
   "Ne",
   "Matrix.tail_cons",
   "Nat.rawCast",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "Fin.fintype",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "ProbabilityTheory.IdentDistrib",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Mathlib.Tactic.Ring.div_congr",
   "ProbabilityTheory.independent_copies3_nondep_finiteRange",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instTransEq_1",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "Real.orderedAddCommMonoid",
   "Eq.mp",
   "ProbabilityTheory.iIndepFun.indepFun",
   "Real.instAddGroupReal",
   "Fin.instOfNatFin",
   "Not",
   "Matrix.vecCons",
   "congrArg",
   "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
   "ProbabilityTheory.IndepFun",
   "Int.ofNat",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "Real.natCast",
   "of_decide_eq_true",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "MeasurableSub₂",
   "Ring.toNonAssocRing",
   "LinearOrderedField.toDiv",
   "Zero.toOfNat0",
   "instDecidableNot",
   "instHPow",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Rat.rawCast",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Fin.instCommRing",
   "id",
   "Membership.mem",
   "NeZero.succ",
   "Fintype.complete",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "sub_le_sub_right",
   "instHAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "List.Mem",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "List",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "ProbabilityTheory.iIndepFun",
   "Bool",
   "List.noConfusion"],
  "name": "rdist_triangle",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {Ω'' : Type u_3} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [mΩ'' : MeasurableSpace Ω'']\n  {μ'' : MeasureTheory.Measure Ω''} [hG : MeasurableSpace G] [inst : MeasurableSingletonClass G] [inst : AddCommGroup G]\n  [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G] {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G},\n  Measurable X →\n    Measurable Y →\n      Measurable Z →\n        ∀ [hμ : MeasureTheory.IsProbabilityMeasure μ] [hμ' : MeasureTheory.IsProbabilityMeasure μ']\n          [hμ'' : MeasureTheory.IsProbabilityMeasure μ''] [inst_3 : FiniteRange X] [inst_4 : FiniteRange Y]\n          [inst_5 : FiniteRange Z], d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ'']",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.npow",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_succ",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (n : ℕ) (x : α),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = x * CanonicallyOrderedCommSemiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Function.Injective",
   "CharZero",
   "CharZero.cast_injective",
   "Nat"],
  "name": "Nat.cast_injective",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R], Function.Injective Nat.cast",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Complex.exp_ne_zero",
   "Monoid.toOne",
   "Complex.instNegComplex",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Complex.instInvComplex",
   "AddMonoid.toAddZeroClass",
   "True",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Complex.exp_add",
   "Eq",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Complex.instSemiringComplex",
   "add_right_neg",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Complex.instField",
   "AddMonoid.toZero",
   "Eq.symm",
   "mul_inv_cancel",
   "Eq.trans",
   "Complex.instOneComplex",
   "GroupWithZero.toInv",
   "id",
   "eq_self",
   "DivisionSemiring.toGroupWithZero",
   "instHAdd",
   "IsDomain.toCancelMonoidWithZero",
   "Field.toSemifield",
   "One.toOfNat1",
   "Neg.neg",
   "Complex.instAddComplex",
   "Complex.exp_zero",
   "GroupWithZero.toMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "mul_right_inj'",
   "Field.isDomain",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Complex",
   "congrArg",
   "CancelMonoidWithZero.toMonoidWithZero",
   "Complex.instMulComplex",
   "Complex.exp",
   "Inv.inv"],
  "name": "Complex.exp_neg",
  "constType": "∀ (x : ℂ), Complex.exp (-x) = (Complex.exp x)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompletelyDistribLattice",
   "iSup",
   "CompleteLattice.toSupSet",
   "Eq"],
  "name": "CompletelyDistribLattice.mk",
  "constType":
  "{α : Type u} →\n  [toCompleteLattice : CompleteLattice α] →\n    (∀ {ι : Type u} {κ : ι → Type u} (f : (a : ι) → κ a → α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)) →\n      CompletelyDistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Int.zero_lt_one",
   "Semiring.toOne",
   "DistribLattice.toLattice",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "le_of_lt",
   "Int.instLinearOrderInt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int.instCommRingInt"],
  "name": "Int.linearOrderedCommRing.proof_2",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["CommGroupWithZero", "Int"],
  "name": "CommGroupWithZero.zpow",
  "constType": "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → ℤ → G₀ → G₀",
  "constCategory": "Definition"},
 {"references": ["Sub", "Int", "Int.sub", "Sub.mk"],
  "name": "Int.instSubInt",
  "constType": "Sub ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Exists", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.Nonempty",
  "constType": "{α : Type u_1} → Finset α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Function.minimalPeriod",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Nat",
   "AddMonoid.toAddZeroClass",
   "AddMonoid"],
  "name": "addOrderOf",
  "constType": "{G : Type u_1} → [inst : AddMonoid G] → G → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "PseudoMetricSpace.toDist",
   "Real",
   "MetricSpace.toPseudoMetricSpace",
   "Complex",
   "Complex.instNormedAddCommGroupComplex",
   "rfl",
   "Eq",
   "Dist.dist"],
  "name": "Complex.instNormedFieldComplex.proof_1",
  "constType": "∀ (x x_1 : ℂ), dist x x_1 = dist x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyLinearOrderedSemifield",
   "Real.instLinearOrderedFieldReal",
   "Real",
   "Nonneg.canonicallyLinearOrderedSemifield",
   "NNReal"],
  "name": "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
  "constType": "CanonicallyLinearOrderedSemifield NNReal",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Iff",
   "Iff.rfl",
   "Set",
   "SetLike.instMembership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.mem_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Trans.mk", "Eq"],
  "name": "instTransEq_1",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (r : α → β → Sort u) → Trans r Eq r",
  "constCategory": "Definition"},
 {"references":
  ["Prod.mk.inj_iff",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "propext",
   "Prod.mk",
   "Eq.refl",
   "Prod",
   "Prod.fst",
   "id",
   "Eq"],
  "name": "Prod.ext_iff",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p = q ↔ p.1 = q.1 ∧ p.2 = q.2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set.Elem",
   "Subtype.val",
   "Function.Embedding.mk",
   "Set",
   "HasSubset.Subset",
   "Function.Embedding",
   "Set.embeddingOfSubset.proof_2",
   "Subtype.mk",
   "Set.embeddingOfSubset.proof_1",
   "Set.instMembershipSet"],
  "name": "Set.embeddingOfSubset",
  "constType": "{α : Type u_1} → (s t : Set α) → s ⊆ t → ↑s ↪ ↑t",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.toDiv",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["IsUnit.inv_mul_cancel_right",
   "MulOneClass.toMul",
   "instHDiv",
   "div_eq_mul_inv",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "IsUnit.div_mul_cancel",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {b : α}, IsUnit b → ∀ (a : α), a / b * b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.npow",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Semiring.npow_zero",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_11",
  "constType": "∀ (x : ℕ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "constCategory": "Other"},
 {"references": [],
  "name": "Max",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.inv_zero",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Set.add",
   "instHAdd",
   "Iff.rfl",
   "HAdd.hAdd",
   "Set",
   "Add",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α} {a : α}, a ∈ s + t ↔ ∃ x y, x ∈ s ∧ y ∈ t ∧ x + y = a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Or",
   "Nat.below",
   "instAddNat",
   "Or.inr",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "LE.le",
   "instLTNat",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.eq_or_lt_of_le.match_2",
   "instLENat",
   "Nat.zero",
   "Or.inl",
   "Nat.eq_or_lt_of_le.match_1",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "LT.lt",
   "PUnit",
   "letFun",
   "instOfNatNat",
   "Nat",
   "Nat.zero_le",
   "absurd",
   "Nat.succ"],
  "name": "Nat.eq_or_lt_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n = m ∨ n < m",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "And.right",
   "IsGLB",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "InfSet",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "completeLatticeOfInf.proof_7",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α],\n  (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (s : Set α), ∀ a ∈ s, a ≤ sInf (upperBounds s)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Classical.propDecidable",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_or_eq_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Real.linearOrderedCommRing",
   "Real",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "Real.instLinearOrderedSemiringReal",
  "constType": "LinearOrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Monoid.npow",
   "Eq"],
  "name": "Monoid.npow_succ",
  "constType":
  "∀ {M : Type u} [self : Monoid M] (n : ℕ) (x : M), Monoid.npow (n + 1) x = x * Monoid.npow n x",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "StrictMono",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "DecidableEq",
   "Set.toFinset",
   "Finset.image",
   "Set",
   "Set.fintypeImage.proof_1",
   "Set.image",
   "Fintype.ofFinset"],
  "name": "Set.fintypeImage",
  "constType":
  "{α : Type u} →\n  {β : Type v} → [inst : DecidableEq β] → (s : Set α) → (f : α → β) → [inst : Fintype ↑s] → Fintype ↑(f '' s)",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "Div"],
  "name": "CommGroupWithZero.toDiv",
  "constType": "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references":
  ["Real.one_le_pi_div_two",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Real.natCast",
   "Real.instLEReal",
   "GroupWithZero.toDivisionMonoid",
   "Real",
   "Real.isROrC",
   "Eq.refl",
   "Real.pi",
   "Nat.cast_zero",
   "Preorder.toLE",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "Eq.mpr",
   "IsROrC.charZero_isROrC",
   "AddMonoidWithOne.toNatCast",
   "Iff.mp",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "div_self",
   "HDiv.hDiv",
   "Nat",
   "CharZero.NeZero.two",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHDiv",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Real.instLTReal",
   "two_ne_zero'",
   "One.toOfNat1",
   "Real.instRingReal",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Real.orderedSemiring",
   "LE.le",
   "GroupWithZero.toDiv",
   "Real.instZeroReal",
   "InvOneClass.toOne",
   "eq_true",
   "Eq.ndrec",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "Bool.false",
   "LT.lt",
   "letFun",
   "instNatAtLeastTwo",
   "div_le_div_right",
   "Semifield.toDivisionSemiring",
   "Bool",
   "DivisionMonoid.toDivInvOneMonoid"],
  "name": "Real.two_le_pi",
  "constType": "2 ≤ Real.pi",
  "constCategory": "Theorem"},
 {"references": ["SeminormedRing", "SeminormedCommRing"],
  "name": "SeminormedCommRing.toSeminormedRing",
  "constType":
  "{α : Type u_5} → [self : SeminormedCommRing α] → SeminormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Nat.linearOrder.proof_1",
   "Nat.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instMaxNat",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "Nat.linearOrder.proof_3",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Nat.linearOrder.proof_2",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.linearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Membership.mem",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "Set",
   "Real.exp_pos",
   "Real.expOrderIso.proof_1",
   "Subtype.le",
   "Set.Ioi",
   "Real.exp",
   "_private.Mathlib.Data.Real.Basic.0.Real.lt",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.linearOrder",
   "Set.codRestrict",
   "Real.expOrderIso.proof_2",
   "Set.Elem",
   "Real.instPreorderReal",
   "StrictMono.orderIsoOfSurjective",
   "Subtype.preorder"],
  "name": "Real.expOrderIso",
  "constType": "ℝ ≃o ↑(Set.Ioi 0)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_1",
  "constType":
  "∀ (M : Type u_1) [inst : AddZeroClass M], (fun x => x) 0 = (fun x => x) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "CommSemigroup.mk",
   "CommMonoid",
   "CommMonoid.mul_comm",
   "CommMonoid.toMonoid",
   "CommSemigroup"],
  "name": "CommMonoid.toCommSemigroup",
  "constType": "{M : Type u} → [self : CommMonoid M] → CommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["RingEquiv.map_add'",
   "RingEquiv.map_mul'",
   "Equiv.toFun",
   "Equiv.invFun",
   "RingEquivClass",
   "RingEquiv.instRingEquivClassRingEquiv.proof_2",
   "RingEquiv",
   "Add",
   "Mul",
   "MulEquivClass.mk",
   "RingEquivClass.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_3",
   "RingEquiv.toEquiv",
   "EquivLike.mk",
   "RingEquiv.instRingEquivClassRingEquiv.proof_1"],
  "name": "RingEquiv.instRingEquivClassRingEquiv",
  "constType":
  "{R : Type u_4} →\n  {S : Type u_5} →\n    [inst : Mul R] → [inst_1 : Mul S] → [inst_2 : Add R] → [inst_3 : Add S] → RingEquivClass (R ≃+* S) R S",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["outParam", "SetLike", "Function.Injective", "Set", "SetLike.coe"],
  "name": "SetLike.coe_injective'",
  "constType":
  "∀ {A : Type u_1} {B : outParam (Type u_2)} [self : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "OfNat.ofNat",
   "instHSMul",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "Multiplicative.toAdd",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "pow_one",
   "Eq",
   "Eq.mpr",
   "Nat.Prime",
   "RelIso",
   "HSMul.hSMul",
   "Subgroup",
   "Nat",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.trans",
   "Subtype",
   "HPow.hPow",
   "Ne",
   "Or",
   "eq_or_ne",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Or.casesOn",
   "pow_zero",
   "RelHomClass.toFunLike",
   "instHMul",
   "And",
   "addOrderOf_nsmul_eq_zero",
   "Multiplicative",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "LT.lt",
   "Eq.mp",
   "And.intro",
   "AddCommGroup",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "OrderIso.symm",
   "addOrderOf",
   "congrFun",
   "Group.toDivisionMonoid",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OmegaCompletePartialOrder.toPartialOrder",
   "IsPGroup",
   "Exists.intro",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Zero.toOfNat0",
   "RelIso.instRelHomClassRelIso",
   "instLENat",
   "instHPow",
   "AddMonoid.toZero",
   "AddSubgroup",
   "Nat.monoid",
   "Sylow.exists_subgroup_le_card_le",
   "Monoid.toNatPow",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "AddSubgroup.toSubgroup",
   "ElementaryAddCommGroup.orderOf_of_ne",
   "id",
   "Subgroup.instCompleteLatticeSubgroup",
   "Membership.mem",
   "eq_self",
   "One.toOfNat1",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "instOneMultiplicative",
   "AddMonoid.toNatSMul",
   "Equiv.instFunLikeEquiv",
   "SetLike.instPartialOrder",
   "InvOneClass.toOne",
   "Eq.ndrec",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "Group.toDivInvMonoid",
   "instMulNat",
   "ElementaryAddCommGroup",
   "Nat.card",
   "NegZeroClass.toZero",
   "Subgroup.instSetLikeSubgroup"],
  "name": "ElementaryAddCommGroup.exists_subgroup_subset_card_le",
  "constType":
  "∀ {G : Type u_1} {p : ℕ},\n  Nat.Prime p →\n    ∀ [inst : AddCommGroup G] [h : ElementaryAddCommGroup G p] {k : ℕ} (H : AddSubgroup G),\n      k ≤ Nat.card ↥H → k ≠ 0 → ∃ H', Nat.card ↥H' ≤ k ∧ k < p * Nat.card ↥H' ∧ H' ≤ H",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "SemiconjBy.zero_left",
   "MulZeroClass.toMul",
   "Commute"],
  "name": "Commute.zero_left",
  "constType":
  "∀ {G₀ : Type u_3} [inst : MulZeroClass G₀] (a : G₀), Commute 0 a",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Sup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "mul_neg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "InvolutiveNeg.toNeg",
   "Ring.toSub",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "Eq.trans",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "congr",
   "congrArg",
   "left_distrib"],
  "name": "CancelDenoms.sub_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e1 e2 t1 t2 : α}, n * e1 = t1 → n * e2 = t2 → n * (e1 - e2) = t1 - t2",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "Mathlib.Meta.NormNum.IsRat",
   "HMul.hMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Nat",
   "Int",
   "DivisionRing.toInv",
   "Ring.toNonAssocRing",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.isRat_div.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α]\n  (motive : (x x_1 : α) → (x_2 : ℤ) → (x_3 : ℕ) → Mathlib.Meta.NormNum.IsRat (x * x_1⁻¹) x_2 x_3 → Prop) (x x_1 : α)\n  (x_2 : ℤ) (x_3 : ℕ) (x_4 : Mathlib.Meta.NormNum.IsRat (x * x_1⁻¹) x_2 x_3),\n  (∀ (x x_5 : α) (x_6 : ℤ) (x_7 : ℕ) (h : Mathlib.Meta.NormNum.IsRat (x * x_5⁻¹) x_6 x_7), motive x x_5 x_6 x_7 h) →\n    motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsRat.casesOn",
   "Invertible.invOf",
   "NonUnitalNonAssocRing.toMul",
   "HEq",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Ring.toNeg",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Int",
   "Int.neg"],
  "name": "Mathlib.Meta.NormNum.isRat_neg.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α) →\n      (x_1 : α) →\n        (x_2 x_3 : ℤ) → (x_4 : ℕ) → x = Neg.neg → Mathlib.Meta.NormNum.IsRat x_1 x_2 x_4 → Int.neg x_2 = x_3 → Prop)\n  (x : α → α) (x_1 : α) (x_2 x_3 : ℤ) (x_4 : ℕ) (x_5 : x = Neg.neg) (x_6 : Mathlib.Meta.NormNum.IsRat x_1 x_2 x_4)\n  (x_7 : Int.neg x_2 = x_3),\n  (∀ (num : ℤ) (denom : ℕ) (h : Invertible ↑denom),\n      motive Neg.neg (↑num * ⅟↑denom) num (Int.neg num) denom (_ : Neg.neg = Neg.neg)\n        (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑denom) num denom) (_ : Int.neg num = Int.neg num)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "inferInstance",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid"],
  "name": "Real.instAddCommMonoidReal",
  "constType": "AddCommMonoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "ProbabilityTheory.IsUniform.mk",
   "BooleanAlgebra.toHasCompl",
   "Exists.casesOn",
   "True",
   "ProbabilityTheory.IsUniform.measure_preimage_compl",
   "iff_self",
   "Eq",
   "Set.preimage_image_eq",
   "Zero.toOfNat0",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "MeasureTheory.OuterMeasure.measureOf",
   "Finset.image",
   "Finset.toSet",
   "Finset",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Set.image",
   "Finset.coe_image",
   "And.casesOn",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "Set.preimage",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Function.comp",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Finset.instMembershipFinset",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Function.Injective.eq_iff",
   "Set.instMembershipSet",
   "And",
   "eq_true",
   "ProbabilityTheory.IsUniform.eq_of_mem",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "of_eq_true",
   "Function.Injective",
   "DecidableEq",
   "MeasureTheory.Measure.toOuterMeasure",
   "propext",
   "letFun",
   "Eq.mp",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "congrFun"],
  "name": "ProbabilityTheory.IsUniform.comp",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] {X : Ω → S} {μ : MeasureTheory.Measure Ω}\n  [inst : DecidableEq T] {H : Finset S},\n  ProbabilityTheory.IsUniform (↑H) X →\n    ∀ {f : S → T}, Function.Injective f → ProbabilityTheory.IsUniform (↑(Finset.image f H)) (f ∘ X)",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisConnection",
   "Preorder",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "GaloisInsertion.mk",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {l : α → β} →\n          {u : β → α} →\n            (choice : (x : α) → u (l x) ≤ x → β) →\n              GaloisConnection l u →\n                (∀ (x : β), x ≤ l (u x)) → (∀ (a : α) (h : u (l a) ≤ a), choice a h = l a) → GaloisInsertion l u",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "CauSeq.Completion.instIntCastCauchy",
   "CauSeq.Completion.instAddCauchy",
   "CauSeq.Completion.Cauchy.commRing.proof_9",
   "CauSeq.Completion.Cauchy.commRing.proof_1",
   "CauSeq.Completion.Cauchy.commRing.proof_3",
   "CauSeq.Completion.instNegCauchy",
   "CauSeq.Completion.instNatCastCauchy",
   "CauSeq.Completion.instOneCauchy",
   "CommRing",
   "AddGroupWithOne.toAddGroup",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "CauSeq.Completion.Cauchy.commRing.proof_5",
   "LinearOrderedField",
   "CauSeq.Completion.instSMulCauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.Cauchy.commRing.proof_8",
   "CauSeq.instCommRingCauSeqToRing",
   "CauSeq.Completion.instMulCauchy",
   "Nat",
   "CauSeq.Completion.instSubCauchy",
   "CauSeq.Completion.Cauchy.commRing.proof_6",
   "CauSeq.Completion.Cauchy.commRing.proof_13",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "CauSeq.Completion.Cauchy.commRing.proof_14",
   "CauSeq.Completion.Cauchy.commRing.proof_10",
   "CauSeq.Completion.instPowCauchyNat",
   "AddMonoidWithOne.toAddMonoid",
   "CauSeq.Completion.Cauchy.commRing.proof_4",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "SubNegMonoid.SMulInt",
   "CauSeq.Completion.Cauchy.commRing.proof_7",
   "AddGroup.toSubNegMonoid",
   "CauSeq.Completion.instZeroCauchy",
   "AddMonoid.toNatSMul",
   "CommRing.toCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "CommRing.toRing",
   "CauSeq.Completion.Cauchy.commRing.proof_11",
   "CauSeq.Completion.mk",
   "CauSeq.Completion.Cauchy.commRing.proof_2",
   "Function.Surjective.commRing",
   "Int",
   "CauSeq.Completion.Cauchy.commRing.proof_12"],
  "name": "CauSeq.Completion.Cauchy.commRing",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : CommRing β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → CommRing (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Eq.mpr",
   "Set.Finite.image",
   "Eq.ndrec",
   "FiniteRange",
   "Set",
   "Function.comp",
   "FiniteRange.finite",
   "FiniteRange.mk",
   "Eq.refl",
   "Set.image",
   "Set.range_comp",
   "Set.Finite",
   "Eq",
   "id"],
  "name": "instFiniteRangeComp",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} {H : Type u_3} (X : Ω → G) (f : G → H) [hX : FiniteRange X], FiniteRange (f ∘ X)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "GeneralizedBooleanAlgebra.toOrderBot",
   "GeneralizedCoheytingAlgebra.mk",
   "GeneralizedBooleanAlgebra.toSDiff",
   "SemilatticeInf.toPartialOrder",
   "SDiff.sdiff",
   "OrderBot",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_2",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra.proof_1",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "SDiff.mk",
   "GeneralizedCoheytingAlgebra",
   "GeneralizedBooleanAlgebra",
   "GeneralizedBooleanAlgebra.toDistribLattice",
   "OrderBot.mk",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "GeneralizedBooleanAlgebra.toBot"],
  "name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{α : Type u} → [inst : GeneralizedBooleanAlgebra α] → GeneralizedCoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "True",
   "Preorder.toLE",
   "max_def",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_left",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "upperBounds",
   "IsGLB",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "InfSet",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "completeLatticeOfInf.proof_9",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α],\n  (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LE.mk",
   "instHasEquiv",
   "Or",
   "DivisionRing.toRing",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_4",
   "CauSeq",
   "Preorder",
   "LT.mk",
   "Abs.abs",
   "Preorder.mk",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_3",
   "LinearOrderedField.toField",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "LT.lt",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_2",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → Preorder (CauSeq α abs)",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Set", "MeasurableSet", "LE", "MeasurableSpace"],
  "name": "MeasurableSpace.instLEMeasurableSpace",
  "constType": "{α : Type u_1} → LE (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Eq.rec",
   "AddMonoidHom.toZeroHom",
   "Eq.symm",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.casesOn",
   "FunLike.coe_injective'"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f g : M →+ N),\n  (fun f => f.toFun) f = (fun f => f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["InfSet", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toInfSet",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Image._auxLemma.4",
   "congr",
   "Singleton.singleton",
   "Set.image",
   "Std.Logic._auxLemma.41",
   "congrArg",
   "Eq.trans"],
  "name": "Set.image_singleton",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α}, f '' {a} = {f a}",
  "constCategory": "Theorem"},
 {"references": ["maxOfLe", "instLENat", "Max", "Nat", "Nat.decLe"],
  "name": "Nat.instMaxNat",
  "constType": "Max ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "add_comm",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMagma.toAdd",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "setOf",
   "PartialOrder.toPreorder",
   "InfSet.sInf",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ConditionallyCompleteLattice.toInfSet",
   "LE.le",
   "Inv",
   "Inv.mk",
   "Preorder.toLE",
   "ENNReal.instCompleteLinearOrderENNReal",
   "instHMul",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "HMul.hMul",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "OrderedSemiring.toPartialOrder"],
  "name": "ENNReal.instInvENNReal",
  "constType": "Inv ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Eq.mp",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mul_le_mul_of_nonneg_right",
   "Preorder",
   "congrArg",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "MulPosMono"],
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : MulPosMono α],\n  a ≤ 0 → 0 ≤ b → a * b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "lt_of_lt_of_le.match_2",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "instNontrivial",
   "Real.instRingReal",
   "Nontrivial"],
  "name": "Real.nontrivial",
  "constType": "Nontrivial ℝ",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddRightCancelMonoid"],
  "name": "AddRightCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["not_lt_zero'",
   "Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "letFun",
   "LinearOrderedCommMonoidWithZero.toZero",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "Eq"],
  "name": "ne_zero_of_lt",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : LinearOrderedCommMonoidWithZero α], b < a → a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "IsLeftCancelAdd", "Eq"],
  "name": "IsLeftCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = a + c → b = c) → IsLeftCancelAdd G",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
  "constType":
  "{M : Type u} → [self : AddLeftCancelMonoid M] → AddLeftCancelSemigroup M",
  "constCategory": "Definition"},
 {"references": ["UniformSpace", "TopologicalSpace"],
  "name": "UniformSpace.toTopologicalSpace",
  "constType": "{α : Type u} → [self : UniformSpace α] → TopologicalSpace α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Quot",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort u",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.equiv",
   "Setoid.r",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "Real.casesOn",
   "CauSeq.Completion.Cauchy",
   "Quot.induction_on",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ind_mk",
  "constType":
  "∀ {C : ℝ → Prop} (x : ℝ), (∀ (y : CauSeq ℚ abs), C (Real.mk y)) → C x",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Archimedean.mk",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "mul_assoc",
   "Nat.cast",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.neg_congr",
   "HSMul.hSMul",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Mul.toSMul",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "AddMonoidWithOne.toOne",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "sub_nonpos_of_le",
   "instOfNatInt",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddMonoidWithOne.toNatCast",
   "Int.add_one_le_iff",
   "AddMonoid.toAddSemigroup",
   "Nat.mul_le_mul_left",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "zero_lt_one",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Eq.ndrec",
   "instNatCastInt",
   "NegZeroClass.toNeg",
   "Int.instAddMonoidInt",
   "Mathlib.Tactic.Ring.atom_pf",
   "MulOneClass.toMul",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "Nat.linearOrder",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "OrderedAddCommMonoid.toPartialOrder",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_neg_of_pos",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Zify._auxLemma.3",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Int.instAddGroupInt",
   "Mathlib.Tactic.Ring.of_eq",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "mul_one",
   "congrArg",
   "Archimedean",
   "Int.instLEInt",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Int.linearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "Nat.semigroup",
   "one_mul",
   "Preorder.toLT",
   "instHPow",
   "AddMonoid.toZero",
   "instOfNatNat",
   "smul_eq_mul",
   "NeZero.charZero_one",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "AddMonoid.toNatSMul",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "StrictOrderedSemiring.to_charZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "Int.instSemiringInt",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "instMulNat",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "instArchimedeanNatToOrderedAddCommMonoidOrderedSemiring",
  "constType": "Archimedean ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Tactic.Ring.pow_zero",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.Prime",
   "Nat.cast",
   "Subgroup.instFintypeSubtypeMemSubgroupInstMembershipInstSetLikeSubgroup",
   "Mathlib.Tactic.Ring.neg_congr",
   "Subgroup",
   "Mathlib.Tactic.Ring.pow_add",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Linarith.lt_of_lt_of_eq",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Subtype",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "instHSub",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "pow_dvd_pow",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Nat.cast_pow",
   "Int",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Exists",
   "sub_nonpos_of_le",
   "instOfNatInt",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "IsPGroup",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "Sylow.exists_subgroup_card_pow_prime",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "zero_lt_one",
   "Group",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "nonempty_fintype",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Not.intro",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Nonempty.intro",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "Fact.mk",
   "instNatCastInt",
   "pow_le_pow_iff_right",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "NegZeroClass.toNeg",
   "Int.instAddMonoidInt",
   "Mathlib.Tactic.Ring.atom_pf",
   "Subgroup.instSetLikeSubgroup",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Nat.one_le_pow",
   "Exists.casesOn",
   "Preorder.toLE",
   "Nonempty",
   "SetLike.instMembership",
   "Nonempty.casesOn",
   "Eq",
   "Nat.card_eq_fintype_card",
   "Eq.mpr",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Zify._auxLemma.1",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "IsPGroup.exists_card_eq",
   "Nat.Prime.pos",
   "neg_neg_of_pos",
   "Classical.propDecidable",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Finite",
   "Int.instCommSemiringInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Int.instAddGroupInt",
   "Mathlib.Tactic.Ring.of_eq",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "congrArg",
   "Fact",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "LinearOrderedRing.toStrictOrderedRing",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Nat.instDvdNat",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Int.linearOrderedCommRing",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "AddMonoid.toZero",
   "Nat.monoid",
   "instOfNatNat",
   "NeZero.charZero_one",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "id",
   "Nat.Prime.one_lt",
   "Membership.mem",
   "funext",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Dvd.dvd",
   "Fintype.card",
   "Mathlib.Tactic.Ring.single_pow",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "Int.instSemiringInt",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Nat.card",
   "NegZeroClass.toZero",
   "Nat.finite_of_card_ne_zero"],
  "name": "Sylow.exists_subgroup_card_pow_prime_of_le_card",
  "constType":
  "∀ {G : Type u} [inst : Group G] {n p : ℕ}, Nat.Prime p → IsPGroup p G → p ^ n ≤ Nat.card G → ∃ H, Nat.card ↥H = p ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.ne_of_lt",
   "Nat.zero_lt_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.linearOrderedCommSemiring.proof_5",
  "constType": "Nontrivial ℕ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MetricSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "Iff", "Iff.rfl", "True", "Eq"],
  "name": "iff_self",
  "constType": "∀ (p : Prop), (p ↔ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id.proof_1",
   "RingHom",
   "RingHom.id.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "OneHom.mk",
   "MonoidHom.mk",
   "RingHom.id.proof_4",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.id.proof_2",
   "NonAssocSemiring",
   "id"],
  "name": "RingHom.id",
  "constType": "(α : Type u_5) → [inst : NonAssocSemiring α] → α →+* α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield",
   "Semifield.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HDiv",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "OfNat.ofNat",
   "Semiring",
   "Eq.refl",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Eq.mp",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nat",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] (k : ℕ) (b c : α), c * (↑k * b) = 1 → c * ↑k * b = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Function.Injective", "Exists.intro", "Nat", "Exists.casesOn"],
  "name": "Function.Injective.countable.match_1",
  "constType":
  "∀ {β : Sort u_1} (motive : (∃ f, Function.Injective f) → Prop) (x : ∃ f, Function.Injective f),\n  (∀ (g : β → ℕ) (hg : Function.Injective g), motive (_ : ∃ f, Function.Injective f)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
   "Sub",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "AddMonoidWithOne",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddGroupWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toIntCast : IntCast R] →\n    [toAddMonoidWithOne : AddMonoidWithOne R] →\n      [toNeg : Neg R] →\n        [toSub : Sub R] →\n          autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n            (zsmul : ℤ → R → R) →\n              autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                  autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                    (∀ (a : R), -a + a = 0) →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → AddGroupWithOne R",
  "constCategory": "Other"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "forall_congr'",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∀ (a : α), q a)",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.instMembershipFinset",
   "HasSubset",
   "HasSubset.mk"],
  "name": "Finset.instHasSubsetFinset",
  "constType": "{α : Type u_1} → HasSubset (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivisionMonoid.toDivInvOneMonoid.proof_1",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.zpow_neg'",
   "DivInvMonoid.zpow",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [inst : DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references": ["Field", "Div"],
  "name": "Field.toDiv",
  "constType": "{K : Type u} → [self : Field K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "Exists",
   "funext",
   "Prod.snd",
   "Prod.mk.injEq",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Mathlib.Data.Set.Prod._auxLemma.1",
   "Set",
   "Prod.fst",
   "Mathlib.Data.Set.Prod._auxLemma.9",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Prod._auxLemma.8",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Iff",
   "Prod.casesOn",
   "of_eq_true",
   "Prod.mk",
   "SProd.sprod",
   "congr",
   "Prod",
   "Singleton.singleton",
   "Set.image",
   "Std.Logic._auxLemma.41",
   "congrArg",
   "Eq.trans"],
  "name": "Set.prod_singleton",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {b : β}, s ×ˢ {b} = (fun a => (a, b)) '' s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrder.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "List.cons",
   "List.brecOn",
   "List.below",
   "List.length.match_1",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "PProd",
   "PProd.fst",
   "List.rec",
   "List",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat"],
  "name": "List.length",
  "constType": "{α : Type u_1} → List α → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Iff",
   "neg_zero",
   "InvolutiveNeg.toNeg",
   "Function.Injective.eq_iff'",
   "neg_injective",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "neg_eq_zero",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, -a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references": ["Max", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMax",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedAddCommGroup",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1612",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Dist.dist",
   "Norm",
   "MetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "AddCommGroup"],
  "name": "NormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} →\n  [toNorm : Norm E] →\n    [toAddCommGroup : AddCommGroup E] →\n      [toMetricSpace : MetricSpace E] → autoParam (∀ (x y : E), dist x y = ‖x - y‖) _auto✝ → NormedAddCommGroup E",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "Zero.mk",
   "instZeroAddMonoidHom.proof_1",
   "instZeroAddMonoidHom.proof_2",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom"],
  "name": "instZeroAddMonoidHom",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → Zero (M →+ N)",
  "constCategory": "Definition"},
 {"references":
  ["StarMul",
   "starMulOfComm.proof_2",
   "MulOneClass.toMul",
   "Star.mk",
   "CommMonoid",
   "InvolutiveStar.mk",
   "CommMonoid.toMonoid",
   "starMulOfComm.proof_1",
   "Monoid.toMulOneClass",
   "StarMul.mk",
   "id"],
  "name": "starMulOfComm",
  "constType": "{R : Type u_1} → [inst : CommMonoid R] → StarMul R",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "Set.iInter_congr_Prop",
   "Set",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "of_eq_true",
   "iInf",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Set.iInter",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid",
   "Submonoid.coe_iInf",
   "congrArg",
   "Eq.trans",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instInfSetSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)), ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toSubmonoid)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "SeminormedRing.norm_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_13",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "NonAssocRing"],
  "name": "NonAssocRing.toNatCast",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderHom",
   "Nat",
   "Preorder",
   "Nat.strictOrderedSemiring"],
  "name": "OmegaCompletePartialOrder.Chain",
  "constType": "(α : Type u) → [inst : Preorder α] → Type u",
  "constCategory": "Definition"},
 {"references":
  ["IsUnit.map",
   "IsUnit.ne_zero",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "IsUnit.mk0",
   "MonoidHomClass.toMulHomClass",
   "MonoidWithZeroHomClass",
   "MulHomClass.toFunLike",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "FunLike.coe",
   "MulZeroOneClass.toZero",
   "Monoid.toMulOneClass",
   "GroupWithZero.toMonoidWithZero",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "MonoidWithZero.toMonoid",
   "Eq.rec",
   "GroupWithZero",
   "map_zero",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "MonoidWithZeroHomClass.toZeroHomClass",
   "MonoidWithZero"],
  "name": "map_ne_zero",
  "constType":
  "∀ {M₀ : Type u_2} {G₀ : Type u_3} {F : Type u_6} [inst : MonoidWithZero M₀] [inst_1 : GroupWithZero G₀]\n  [inst_2 : Nontrivial M₀] [inst_3 : MonoidWithZeroHomClass F G₀ M₀] (f : F) {a : G₀}, f a ≠ 0 ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Prod.snd",
   "setOf",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.prod",
  "constType": "{α : Type u_1} → {β : Type u_2} → Set α → Set β → Set (α × β)",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.le_total.match_1",
  "constType":
  "∀ (m n : ℕ) (motive : m < n ∨ m ≥ n → Prop) (x : m < n ∨ m ≥ n),\n  (∀ (h : m < n), motive (_ : m < n ∨ m ≥ n)) → (∀ (h : m ≥ n), motive (_ : m < n ∨ m ≥ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "Distrib.rightDistribClass",
   "npowRec",
   "Nat.cast_zero",
   "Semiring.toNatCast",
   "Real.instOneReal",
   "mul_assoc",
   "Nat.cast",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Real.cauchy_one",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.ofCauchy",
   "Rat.field",
   "Nat.cast_add",
   "CauSeq.Completion.instZeroCauchy",
   "NatCast.natCast",
   "CauSeq.Completion.Cauchy.ring",
   "AddMonoidWithOne.toOne",
   "congr",
   "Rat.instLinearOrderedFieldRat",
   "Int",
   "congrFun",
   "Mul.mk",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Real",
   "Eq.refl",
   "CauSeq.Completion.instNatCastCauchy",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.mk",
   "True",
   "Abs.abs",
   "Rat.instSupRat",
   "zero_add",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "CauSeq.Completion.instMulCauchy",
   "CauSeq.Completion.Cauchy.field",
   "Neg.toHasAbs",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "Real.cauchy_add",
   "One.mk",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "Distrib.leftDistribClass",
   "Rat.divisionRing",
   "Ring.toAddCommGroup",
   "CauSeq.Completion.Cauchy.commRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy",
   "Semiring.mk",
   "MulZeroOneClass.toMulOneClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instMulReal",
   "nsmulRec",
   "MulZeroClass.mul_zero",
   "Eq",
   "Real.cauchy_zero",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "Add.mk",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "IntCast.mk",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Int.negSucc",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "mul_one",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IntCast.intCast",
   "Neg.mk",
   "CauSeq.Completion.instAddCauchy",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "CauSeq.Completion.instNegCauchy",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CauSeq.Completion.instOneCauchy",
   "NatCast.mk",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Rat.commRing",
   "one_mul",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.cast_negSucc",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_neg",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "AddGroupWithOne.toNeg",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "SubtractionMonoid.toSubNegMonoid",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "neg_add_rev"],
  "name": "Real.commRing.proof_24",
  "constType": "∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "le_sub_iff_add_le",
   "Real.instAddMonoidReal",
   "Or.resolve_right",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "HDiv.hDiv",
   "CauSeq.lt_trans",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instHSub",
   "add_comm",
   "Or",
   "instHDiv",
   "instDistribLattice",
   "CauSeq.instSubCauSeq",
   "sub_lt_self",
   "Real.instRingReal",
   "Real.instAddCommSemigroupReal",
   "Real.instSupSetReal",
   "AddCommMagma.toAdd",
   "CommGroupWithZero.toCommMonoidWithZero",
   "And",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Real.instConditionallyCompleteLinearOrderReal",
   "instNatAtLeastTwo",
   "And.intro",
   "Field.toDivisionRing",
   "OrderedCancelAddCommMonoid.toContravariantClassRight",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CauSeq.exists_gt",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Subtype.val",
   "Set",
   "Real",
   "IsCauSeq",
   "sub_right_comm",
   "LinearOrderedField.toLinearOrderedCommRing",
   "GE.ge",
   "Real.orderedCancelAddCommMonoid",
   "Eq.refl",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Abs.abs",
   "CauSeq.sub_apply",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Real.instAddCommGroupReal",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "Real.instLinearOrderedRingReal",
   "CauSeq",
   "LE.le",
   "CauSeq.equiv",
   "lt_add_iff_pos_left",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "letFun",
   "CauSeq.lt_total",
   "HasEquiv.Equiv",
   "Real.orderedAddCommGroup",
   "CauSeq.const_lt",
   "sub_sub",
   "add_halves",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instSupReal",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "Ring.toNeg",
   "ConditionallyCompleteLattice.toSupSet",
   "Nat",
   "And.casesOn",
   "CauSeq.exists_lt",
   "StrictOrderedRing.toPartialOrder",
   "setOf",
   "Real.partialOrder",
   "Set.instMembershipSet",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Or.resolve_left",
   "DistribLattice.toLattice",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.instAddGroupReal",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "half_pos",
   "StrictOrderedRing.toRing",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "instHasEquiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "Exists.imp",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "instLENat",
   "Preorder.toLT",
   "le_csSup",
   "Ring.toSub",
   "instOfNatNat",
   "csSup_le",
   "Eq.symm",
   "id",
   "Membership.mem",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "HSub.hSub",
   "SupSet.sSup",
   "AddGroup.toSubNegMonoid",
   "StrictOrderedSemiring.toSemiring",
   "CauSeq.const_apply",
   "GT.gt",
   "LinearOrderedSemifield.toDiv",
   "LinearOrderedField.toField",
   "LE.le.not_lt",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid"],
  "name": "Real.cauSeq_converges",
  "constType": "∀ (f : CauSeq ℝ abs), ∃ x, f ≈ CauSeq.const abs x",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.mk",
   "Eq",
   "Quot.sound"],
  "name": "Quotient.sound",
  "constType": "∀ {α : Sort u} {s : Setoid α} {a b : α}, a ≈ b → ⟦a⟧ = ⟦b⟧",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "AddSubmonoidClass",
   "SetLike",
   "AddSubgroupClass",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass"],
  "name": "AddSubgroupClass.toAddSubmonoidClass",
  "constType":
  "∀ {S : Type u_5} {G : Type u_6} [inst : SubNegMonoid G] [inst_1 : SetLike S G] [self : AddSubgroupClass S G],\n  AddSubmonoidClass S G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Function.isFixedPt_id",
   "Function.IsPeriodicPt",
   "instOfNatNat",
   "Nat"],
  "name": "Function.isPeriodicPt_zero",
  "constType":
  "∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toMul",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasurableSpace.comap",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "instHMul",
   "Eq.mpr",
   "ProbabilityTheory.Indep_iff",
   "ProbabilityTheory.IndepFun_iff_Indep",
   "Eq.ndrec",
   "ProbabilityTheory.Indep",
   "Iff",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "propext",
   "MeasurableSet",
   "HMul.hMul",
   "MeasurableSpace",
   "id",
   "ProbabilityTheory.IndepFun",
   "Set.instInterSet"],
  "name": "ProbabilityTheory.IndepFun_iff",
  "constType":
  "∀ {Ω : Type u_1} {β : Type u_6} {γ : Type u_7} [inst : MeasurableSpace Ω] [mβ : MeasurableSpace β]\n  [mγ : MeasurableSpace γ] (f : Ω → β) (g : Ω → γ) (μ : MeasureTheory.Measure Ω),\n  ProbabilityTheory.IndepFun f g ↔\n    ∀ (t1 t2 : Set Ω), MeasurableSet t1 → MeasurableSet t2 → ↑↑μ (t1 ∩ t2) = ↑↑μ t1 * ↑↑μ t2",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nat.gt_of_not_le",
   "instLENat",
   "Iff.mp",
   "Nat.not_le_of_gt",
   "LT.lt",
   "Not",
   "Nat",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_not_ge",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Top.top",
   "DiscreteMeasurableSpace",
   "Set",
   "DiscreteMeasurableSpace.mk",
   "CompleteLattice.toTop",
   "MeasurableSpace.measurableSet_top",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "MeasurableSpace"],
  "name":
  "instDiscreteMeasurableSpaceTopMeasurableSpaceToTopInstCompleteLatticeMeasurableSpace",
  "constType": "∀ {α : Type u_1}, DiscreteMeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.mul_zero",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["ENNReal", "Real", "Real.toNNReal", "ENNReal.ofNNReal"],
  "name": "ENNReal.ofReal",
  "constType": "ℝ → ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["upperBounds_empty",
   "OrderDual.instPreorder",
   "EmptyCollection.emptyCollection",
   "Set",
   "lowerBounds",
   "OrderDual",
   "Set.instEmptyCollectionSet",
   "Preorder",
   "Set.univ",
   "Eq"],
  "name": "lowerBounds_empty",
  "constType": "∀ {α : Type u} [inst : Preorder α], lowerBounds ∅ = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "Equiv",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "AddSubsemigroup.mk",
   "Iff.rfl",
   "Multiplicative.toAdd",
   "Set",
   "Eq.refl",
   "Submonoid.casesOn",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "Iff",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "Submonoid.mk",
   "Membership.mem",
   "Submonoid.one_mem'",
   "Submonoid.instSetLikeSubmonoid",
   "Set.preimage",
   "MulOneClass.toOne",
   "Subsemigroup",
   "AddSubmonoid.toAddSubsemigroup",
   "One.toOfNat1",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "LE.le",
   "AddSubmonoid",
   "Multiplicative.ofAdd",
   "AddSubsemigroup",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "Multiplicative",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Subsemigroup.mul_mem'",
   "Equiv.mk",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubsemigroup.carrier",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid.proof_6",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] {a b : AddSubmonoid A},\n  {\n          toFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ :\n                      ∀ {a b : Multiplicative A},\n                        a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                          b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                            Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : A},\n                        a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid A),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : A},\n                                  a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : Multiplicative A},\n                                    a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                        Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Submonoid (Multiplicative A)),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : Multiplicative A},\n                                  a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : A},\n                                    a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ :\n                      ∀ {a b : Multiplicative A},\n                        a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                          b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                            Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : A},\n                        a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid A),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : A},\n                                  a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : Multiplicative A},\n                                    a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                        Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Submonoid (Multiplicative A)),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : Multiplicative A},\n                                  a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : A},\n                                    a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x) }\n        b ↔\n    {\n          toFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ :\n                      ∀ {a b : Multiplicative A},\n                        a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                          b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                            Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : A},\n                        a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid A),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : A},\n                                  a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : Multiplicative A},\n                                    a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                        Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Submonoid (Multiplicative A)),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : Multiplicative A},\n                                  a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : A},\n                                    a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ :\n                      ∀ {a b : Multiplicative A},\n                        a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                          b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                            Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : A},\n                        a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid A),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : A},\n                                  a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : Multiplicative A},\n                                    a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                        Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Submonoid (Multiplicative A)),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : Multiplicative A},\n                                  a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                    b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                                      Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : A},\n                                    a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S →\n                                      b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x) }\n        b",
  "constCategory": "Theorem"},
 {"references": ["Not", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_not_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x ≤ x_1 → ¬x_1 ≤ x → Prop) (x x_1 : α) (x_2 : x ≤ x_1)\n  (x_3 : ¬x_1 ≤ x), (∀ (_a _b : α) (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive _a _b hab hba) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCancelAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Iff.rfl",
   "Eq.refl",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike",
   "Eq",
   "RelIso.instRelHomClassRelIso",
   "Eq.mpr",
   "Iff",
   "RelIso.toEquiv",
   "Eq.ndrec",
   "propext",
   "RelIso",
   "RelIso.map_rel_iff",
   "Eq.symm",
   "Equiv.symm",
   "id"],
  "name": "RelIso.symm.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (f : r ≃r s) (a b : β),\n  r (f.symm a) (f.symm b) ↔ s a b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "Set",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform",
  "constType":
  "{Ω : Type uΩ} →\n  {S : Type uS} → [mΩ : MeasurableSpace Ω] → Set S → (Ω → S) → autoParam (MeasureTheory.Measure Ω) _auto✝ → Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHom.zeroHomClass",
   "Cardinal.partialOrder",
   "ZeroHom",
   "FunLike.coe",
   "LE.le",
   "LE.le.trans_lt",
   "Iff.mpr",
   "Cardinal.instLECardinal",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Cardinal.toNat_le_iff_le_of_lt_aleph0",
   "Cardinal.aleph0",
   "instLENat",
   "Preorder.toLT",
   "ZeroHomClass.toFunLike",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat"],
  "name": "Cardinal.toNat_le_of_le_of_lt_aleph0",
  "constType":
  "∀ {c d : Cardinal.{u_1}}, d < Cardinal.aleph0 → c ≤ d → Cardinal.toNat c ≤ Cardinal.toNat d",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Fintype.Basic._auxLemma.2",
   "Subsingleton.intro",
   "implies_true",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Eq",
   "eq_true",
   "Fintype",
   "Fintype.mk",
   "Eq.ndrec",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Eq.rec",
   "Subsingleton",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans",
   "Fintype.subsingleton.match_1"],
  "name": "Fintype.subsingleton",
  "constType": "∀ (α : Type u_4), Subsingleton (Fintype α)",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.le.step",
   "Nat.le",
   "Nat.below",
   "Nat.brecOn",
   "instLENat",
   "PUnit",
   "Nat",
   "Nat.succ",
   "LE.le",
   "Nat.le_trans.match_1"],
  "name": "Nat.le_trans",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Set.instIsTransSetSubsetInstHasSubsetSet",
   "OfNat.ofNat",
   "add_nonpos",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "neg_le_abs_self",
   "Real.instOneReal",
   "Semiring.toNatCast",
   "Linarith.le_of_le_of_eq",
   "inferInstance",
   "measurableSet_discrete",
   "Real.linearOrder",
   "IsROrC.charZero_isROrC",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Finset.toSet",
   "Real.instPowReal",
   "refPackage.mk",
   "AddTorsor.nonempty",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "addGroupIsAddTorsor",
   "ProbabilityTheory.IsUniform.measureReal_preimage_sub",
   "ProbabilityTheory.IsUniform.entropy_eq'",
   "instOfNat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Subtype",
   "Finset.filter_congr_decidable",
   "Nat.strictOrderedSemiring",
   "instHDiv",
   "Set.image2",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "instDistribLattice",
   "AddCommMagma.toAdd",
   "PFR.Main._auxLemma.4",
   "DivisionRing.toInv",
   "Mathlib.Tactic.RPowRing.atom_pf",
   "NatCast.natCast",
   "Prod.instMeasurableSpace",
   "PartialOrder",
   "refPackage.X₀₁",
   "Set.subtractionMonoid",
   "instFiniteRangeHSubForAllInstHSubInstSubToSubToSubNegAddMonoid",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Set.image2_add",
   "False.elim",
   "propext",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "instNatAtLeastTwo",
   "AddSubgroup.toAddCommGroup",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Set.inter_subset_left",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "DivisionRing.toDivisionSemiring",
   "HEq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "CharP.cast_eq_zero",
   "Mathlib.Tactic.RPowRing.mul_pf_left",
   "Eq.refl",
   "Int.rawCast",
   "Subtype.fintype",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddSubgroup.sub_mem",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "ProbabilityTheory.exists_isUniform_measureSpace",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "OrderedRing.toOrderedSemiring",
   "Measurable",
   "Lattice.toSemilatticeSup",
   "Decidable.byContradiction",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Nat.linearOrderedCommMonoidWithZero",
   "Real.instLTReal",
   "Top.top",
   "entropic_PFR_conjecture",
   "LE.le.trans",
   "Mathlib.Meta.NormNum.isRat_lt_true",
   "Mathlib.Tactic.Ring.mul_add",
   "Field.toSemifield",
   "add_lt_of_le_of_neg",
   "AddSubgroup.instFintypeSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "Neg.neg",
   "LE.le",
   "OrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup.sub_eq_add",
   "ElementaryAddCommGroup",
   "Set.instInterSet",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Nat.card_eq_fintype_card",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "FiniteRange",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "le_trans",
   "Sub.sub",
   "Nat.card_mono",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.trans",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Real.field",
   "Set.sub_subset_sub",
   "Lattice.toSemilatticeInf",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "instNontrivial",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Set.Finite.coe_toFinset",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "Set.instMembershipSet",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.exp_log",
   "Mathlib.Tactic.Ring.neg_mul",
   "True.intro",
   "Finset.univ",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "mul_one",
   "Singleton.singleton",
   "mul_pos",
   "MeasurableSingletonClass.mk",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.prob_ge_exp_neg_entropy'",
   "ProbabilityTheory.IndepFun",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Pi.instSub",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "Set.fintypeEmpty",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Mathlib.Tactic.RPowRing.pow_congr",
   "Set.instSingletonSet",
   "Linarith.mul_nonpos",
   "AddMonoid.toZero",
   "Real.rpow_def_of_pos",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Set.sub",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "le_div_iff",
   "id",
   "sub_eq_zero_of_eq",
   "eq_self",
   "Membership.mem",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "refPackage",
   "HasSubset.Subset.trans",
   "AddMonoidWithOne.toAddMonoid",
   "SemilatticeInf.toPartialOrder",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Set.not_nonempty_iff_eq_empty",
   "Mathlib.Meta.NormNum.IsRat.neg_to_eq",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Set.Finite",
   "Measurable.comp",
   "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "MeasureTheory.MeasureSpace",
   "Eq.casesOn",
   "Bool",
   "instMulNat",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2",
   "OrderedSemiring.toPartialOrder",
   "add_sub_assoc",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "EmptyCollection.emptyCollection",
   "Nat.cast_pos",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Set.Nonempty",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Finite.Set.finite_image2",
   "instDiscreteMeasurableSpaceTopMeasurableSpaceToTopInstCompleteLatticeMeasurableSpace",
   "Real.exp_monotone",
   "Mathlib.Meta.NormNum.isRat_add",
   "Iff.mpr",
   "Nat.cast_zero",
   "Real.orderedRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "trivial",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Finite.Set.finite_inter_of_left",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_not_gt",
   "Real.strictOrderedSemiring",
   "Bool.true",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HDiv.hDiv",
   "Set.inter_subset_right",
   "instHSub",
   "HPow.hPow",
   "Set.add",
   "eq_of_heq",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.instRingReal",
   "MeasureTheory.Measure.real",
   "le_abs_self",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Real.rpow_pos_of_pos",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Set.Finite.toFinset_setOf",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Set.add_subset_add_left",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Meta.NormNum.isRat_neg",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Field.toDiv",
   "AddCommGroup",
   "OrderedSemiring.toPosMulMono",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "Int",
   "Finite.of_fintype",
   "SetLike.coe",
   "Inv.inv",
   "true_and",
   "Exists",
   "rdist_le_of_isUniform_of_card_add_le",
   "Real",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semiring.toMonoidWithZero",
   "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
   "Fintype.card_ofFinset",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "Set.toFinite",
   "True",
   "Real.one_rpow",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.RPowRing.atom_pow_pf",
   "AddMonoid.toAddSemigroup",
   "one_pos",
   "Finset",
   "Finset.filter",
   "CancelDenoms.add_subst",
   "ProbabilityTheory.IsUniform.of_identDistrib",
   "Neg.toHasAbs",
   "Mathlib.Meta.NormNum.isRat_mul",
   "PFR.Main._auxLemma.7",
   "Mathlib.Tactic.RPowRing.pow_pf",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "lt_of_lt_of_le",
   "Real.nontrivial",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Countable",
   "sub_neg_of_lt",
   "Set.instHasSubsetSet",
   "Int.mul",
   "Bool.false",
   "CompleteLattice.toTop",
   "Real.instPreorderReal",
   "Prod",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "MulZeroOneClass.toMulOneClass",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real.commRing",
   "Inter.inter",
   "diff_ent_le_rdist",
   "Set.image2_congr",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Eq",
   "OrderedRing.toRing",
   "measurable_id'",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Fintype",
   "Eq.mpr",
   "Ring.toNeg",
   "rdist",
   "Nat",
   "Real.exp_add",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "setOf",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Classical.propDecidable",
   "Nat.rawCast",
   "Finite",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "DistribLattice.toLattice",
   "Set.exists_subset_add_sub",
   "instHMul",
   "refPackage.X₀₂",
   "mul_le_mul_of_nonneg_left",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "Mathlib.Meta.NormNum.isInt_neg",
   "Not",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "Set.image2_sub",
   "congrArg",
   "Finset.card",
   "Zero",
   "Finset.Nonempty",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "refPackage.η",
   "Mathlib.Meta.NormNum.isNat_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "Nat.card_pos",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "instLENat",
   "one_mul",
   "instFiniteRange",
   "Subtype.fintype.proof_1",
   "instHPow",
   "Preorder.toLT",
   "AddSubgroup",
   "Ring.toSub",
   "LE",
   "Linarith.mul_neg",
   "CancelDenoms.neg_subst",
   "add_sub_add_right_eq_sub",
   "PFR_conjecture_pos_aux",
   "add_lt_of_neg_of_le",
   "Real.strictOrderedRing",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "funext",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Set.preimage",
   "lt_of_le_of_lt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "ProbabilityTheory.IdentDistrib.symm",
   "Fintype.card",
   "Mathlib.Meta.NormNum.isRat_eq_true",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Real.exp",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Mathlib.Meta.NormNum.isRat_le_true",
   "DivisionSemiring.toSemiring",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "ProbabilityTheory.independent_copies_two",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "PFR.Main._auxLemma.8",
   "Real.log",
   "Mathlib.Tactic.RPowRing.mul_pf_right",
   "CharP.ofCharZero",
   "Measurable.sub",
   "LinearOrderedField.toField",
   "SubtractionMonoid.toSubNegMonoid",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Set.Finite.toFinset",
   "Nat.semiring"],
  "name": "PFR_conjecture_aux",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ} [inst_2 : Countable G]\n  [inst_3 : ElementaryAddCommGroup G 2] [inst_4 : Fintype G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) →\n      ∃ H c,\n        ↑(Nat.card ↑c) ≤ K ^ (13 / 2) * ↑(Nat.card ↑A) ^ (1 / 2) * ↑(Nat.card ↑↑H) ^ (-1 / 2) ∧\n          ↑(Nat.card ↥H) ≤ K ^ 11 * ↑(Nat.card ↑A) ∧ ↑(Nat.card ↑A) ≤ K ^ 11 * ↑(Nat.card ↥H) ∧ A ⊆ c + ↑H",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddSubgroup.instInfSetAddSubgroup.proof_1",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.copy",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "AddGroup",
   "iInf",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "Set.iInter",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubsemigroup.carrier",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfSetAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)),\n  0 ∈\n    (AddSubmonoid.copy (⨅ S ∈ s, S.toAddSubmonoid) (⋂ S ∈ s, ↑S)\n          (_ : ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toAddSubmonoid))).toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Invertible.invOf",
   "One",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible",
   "Eq"],
  "name": "Invertible.mul_invOf_self",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] {a : α} [self : Invertible a], a * ⅟a = 1",
  "constCategory": "Definition"},
 {"references": ["And", "And.intro", "And.casesOn"],
  "name": "And.symm.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∧ b → Prop) (x : a ∧ b), (∀ (ha : a) (hb : b), motive (_ : a ∧ b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "div_eq_inv_mul",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "EmptyCollection.emptyCollection",
   "Trans.trans",
   "Semifield.toCommGroupWithZero",
   "MeasureTheory.IsProbabilityMeasure",
   "And.left",
   "iff_false",
   "Iff.mpr",
   "Real.instOneReal",
   "Mathlib.Tactic.Ring.inv_mul",
   "SubNegMonoid.toSub",
   "BooleanAlgebra.toBiheytingAlgebra",
   "measurableSet_discrete",
   "IsROrC.charZero_isROrC",
   "And.right",
   "Iff",
   "Nat.cast",
   "Set.iUnion",
   "Set.Elem",
   "Finset.toSet",
   "HSMul.hSMul",
   "AddTorsor.nonempty",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "addGroupIsAddTorsor",
   "Set.disjoint_iff_inter_eq_empty",
   "InvOneClass.toInv",
   "Finset.Subtype.fintype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Subtype",
   "Mathlib.Data.Set.Basic._auxLemma.25",
   "HPow.hPow",
   "instHSub",
   "Std.Logic._auxLemma.37",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "instHDiv",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Finset.subset_univ",
   "PFR.Main._auxLemma.1",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MeasureTheory.Measure.real",
   "Real.normedCommRing",
   "implies_congr_ctx",
   "DivisionRing.toInv",
   "Decidable.of_not_not",
   "And",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "congr",
   "instTransEq",
   "GeneralizedCoheytingAlgebra.toLattice",
   "AddCommGroup",
   "DivisionMonoid.toDivInvOneMonoid",
   "MeasurableSpace",
   "Finite.of_fintype",
   "Inv.inv",
   "congrFun",
   "NatCast",
   "CommMonoidWithZero.toZero",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Fintype.card_ofFinset",
   "HDiv",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "True",
   "iff_self",
   "Set.ext",
   "ProbabilityTheory.IsUniform.measureReal_preimage_of_mem",
   "Eq.rec",
   "Finset",
   "Decidable",
   "Monoid.toNatPow",
   "Measurable",
   "Mathlib.Tactic.Ring.inv_single",
   "absurd",
   "CommGroupWithZero.toDivisionCommMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "FinsetCoe.fintype",
   "ProbabilityTheory.IsUniform.measureReal_preimage_of_nmem",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Finset.sum",
   "Mathlib.Tactic.Ring.mul_add",
   "Disjoint",
   "implies_true",
   "Mathlib.Tactic.Ring.inv_congr",
   "One.toOfNat1",
   "Finset.sum_const",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Real.instDivisionRingReal",
   "NormedCommRing.toSeminormedCommRing",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "Mathlib.Tactic.Ring.one_mul",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "ProbabilityTheory.IndepFun.measureReal_inter_preimage_eq_mul",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.instAddCommMonoidReal",
   "and_self",
   "Set.instInterSet",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Real.isROrC",
   "MulZeroClass.mul_zero",
   "Inter.inter",
   "Finset.sum_subset",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "MeasurableSingletonClass",
   "Nat.card_eq_fintype_card",
   "Semiring.toNonAssocSemiring",
   "Fintype",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Real.instCommSemiringReal",
   "DivisionCommMonoid.toDivisionMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "nsmul_eq_mul",
   "Finset.coe_inter",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Fintype.card_coe",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Nat",
   "mul_inv_rev",
   "Finset.sum_congr",
   "not_false_eq_true",
   "Eq.trans",
   "Fintype.sum_congr",
   "Finite.to_countable",
   "MeasureTheory.measure_ne_top",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Ne",
   "Lattice.toSemilatticeInf",
   "Nat.rawCast",
   "Classical.propDecidable",
   "Std.Logic._auxLemma.32",
   "Mathlib.Data.Finset.Basic._auxLemma.90",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "Std.Logic._auxLemma.23",
   "BiheytingAlgebra.toHeytingAlgebra",
   "NonUnitalNonAssocSemiring.toDistrib",
   "DivInvMonoid.toInv",
   "Set.instMembershipSet",
   "PFR.Main._auxLemma.2",
   "instHMul",
   "Finset.univ",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.mp",
   "mul_one",
   "Singleton.singleton",
   "Not",
   "congrArg",
   "ProbabilityTheory.IndepFun",
   "Int.ofNat",
   "Finset.card",
   "LinearOrderedSemifield.toSemifield",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "DivisionRing.toRing",
   "Real.natCast",
   "MeasureTheory.measureReal_iUnion_fintype",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "MeasurableSet.inter",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Zero.toOfNat0",
   "outParam",
   "Set.instSingletonSet",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "forall_congr",
   "instHPow",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "Fintype.ofFinset",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "Decidable.not_or_of_imp",
   "False",
   "Set.preimage",
   "instHAdd",
   "Std.Logic._auxLemma.22",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "SemilatticeInf.toPartialOrder",
   "Fintype.card",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "HeytingAlgebra.toOrderBot",
   "AddMonoid.toNatSMul",
   "Real.instZeroReal",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "eq_false",
   "Real.semiring",
   "MeasureTheory.MeasureSpace",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "Finset.instInterFinset",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Classical.or_iff_not_imp_left",
   "Nat.card",
   "NegZeroClass.toZero",
   "ProbabilityTheory.IsUniform"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_sub_zero",
  "constType":
  "∀ {G : Type u_1} {Ω : Type u_2} [inst : AddCommGroup G] [inst_1 : Fintype G] [inst_2 : MeasurableSpace G]\n  [inst_3 : MeasurableSingletonClass G] {A B : Finset G} [inst_4 : MeasureTheory.MeasureSpace Ω]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {U V : Ω → G},\n  ProbabilityTheory.IsUniform (↑A) U →\n    Measurable U →\n      ProbabilityTheory.IsUniform (↑B) V →\n        Measurable V →\n          ProbabilityTheory.IndepFun U V →\n            MeasureTheory.volume.real ((U - V) ⁻¹' {0}) =\n              ↑(Nat.card ↑(↑A ∩ ↑B)) / (↑(Nat.card { x // x ∈ A }) * ↑(Nat.card { x // x ∈ B }))",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Submonoid.instSetLikeSubmonoid",
   "Set",
   "completeLatticeOfInf",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "LE.le",
   "Subgroup.instInfSetSubgroup",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "SetLike.instPartialOrder",
   "And",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "Subgroup.toSubmonoid",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "And.intro",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (_a _b _c : Subgroup G),\n  _a ≤ _b → _a ≤ _c → ∀ _x ∈ _a, _x ∈ ↑_b.toSubmonoid ∧ _x ∈ ↑_c.toSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHSMul",
   "Complex.instNegComplex",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "Complex.addCommGroup.proof_7",
   "Complex.addCommGroup.proof_4",
   "Sub.mk",
   "Zero.toOfNat0",
   "Complex.addCommGroup.proof_10",
   "HSMul.hSMul",
   "Complex.addCommGroup.proof_3",
   "Sub.sub",
   "Complex.addCommGroup.proof_6",
   "Complex.addCommGroup.proof_9",
   "Complex.addCommGroup.proof_1",
   "Nat",
   "Complex.addCommGroup.proof_8",
   "Add.mk",
   "AddCommGroup.mk",
   "Complex.instSubComplex",
   "Complex.instZeroComplex",
   "AddSemigroup.mk",
   "instHAdd",
   "Complex.instSMulRealComplex",
   "Complex.addCommGroup.proof_5",
   "AddGroup.mk",
   "Neg.neg",
   "Complex.instAddComplex",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "SubNegMonoid.mk",
   "AddMonoid.mk",
   "AddMonoid.toNatSMul",
   "Real.instAddGroupReal",
   "Zero.mk",
   "Complex",
   "AddCommGroup",
   "Complex.addCommGroup.proof_11",
   "Int",
   "Complex.addCommGroup.proof_2",
   "Neg.mk"],
  "name": "Complex.addCommGroup",
  "constType": "AddCommGroup ℂ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instAddMonoidReal",
   "Nat.cast_zero",
   "Eq",
   "Real.instOneReal",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Nat.cast",
   "Nat",
   "AddMonoidWithOne.mk",
   "Eq.trans",
   "AddMonoidWithOne.natCast_succ",
   "Nat.cast_one",
   "Complex.instOneComplex",
   "add_comm",
   "Real.instRingReal",
   "Real.instAddCommSemigroupReal",
   "Real.intCast",
   "AddCommMagma.toAdd",
   "Nat.cast_add",
   "NatCast.natCast",
   "Complex.im",
   "IntCast.mk",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "Int.negSucc",
   "congr",
   "congrArg",
   "add_zero",
   "Int",
   "IntCast.intCast",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real.natCast",
   "AddGroupWithOne.toIntCast",
   "Real",
   "Eq.refl",
   "Mathlib.Algebra.Group.Basic._auxLemma.18",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NatCast.mk",
   "True",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Int.cast_negSucc",
   "Complex.ext",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "Complex.addCommGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "One.mk",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.mk",
   "SubtractionMonoid.toSubNegMonoid",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "Complex",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "Complex.Complex.addGroupWithOne.proof_9",
  "constType": "∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Finset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.instMembershipFinset",
   "True",
   "Subtype",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.133",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) (x : { x // x ∈ s }), (x ∈ Finset.attach s) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.add_le_add_left",
  "constType":
  "∀ {α : Type u_3} [self : OrderedAddCommMonoid α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.mk",
  "constType": "{α : Sort u} → (α → α → Sort v) → HasEquiv α",
  "constCategory": "Other"},
 {"references":
  ["Int.decLe",
   "LE.mk",
   "Int.le_refl",
   "LinearOrder",
   "Int.instLinearOrderInt.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Int.instLinearOrderInt.proof_2",
   "Int.decLt",
   "Int.instMaxInt",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Int.instLTInt",
   "Preorder.mk",
   "Int.le_trans",
   "Int.lt_iff_le_not_le",
   "Int.instLinearOrderInt.proof_3",
   "inferInstance",
   "Int.le_antisymm",
   "Int.instDecidableEqInt",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Int.instMinInt",
   "LinearOrder.mk",
   "instOrdInt",
   "Int.le_total",
   "Int",
   "Int.instLEInt",
   "DecidableRel"],
  "name": "Int.instLinearOrderInt",
  "constType": "LinearOrder ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.ofRat",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → β → CauSeq.Completion.Cauchy abv",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Equiv.toFun", "Function.LeftInverse", "Equiv.invFun"],
  "name": "Equiv.left_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.LeftInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommSemiring : LinearOrderedCommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → LinearOrderedSemifield α",
  "constCategory": "Other"},
 {"references": ["MeasureTheory.Measure", "MeasurableSpace"],
  "name": "MeasureTheory.SigmaFinite",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Function.Injective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "FunLike.coe_injective'"],
  "name": "Equiv.coe_fn_injective",
  "constType": "∀ {α : Sort u} {β : Sort v}, Function.Injective fun e => ⇑e",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "Finset.sum",
   "AddMonoidHom.mulLeft",
   "Finset",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "map_sum",
   "AddMonoidHom",
   "Eq"],
  "name": "Finset.mul_sum",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Finset α} {b : β} {f : α → β} [inst : NonUnitalNonAssocSemiring β],\n  (b * Finset.sum s fun x => f x) = Finset.sum s fun x => b * f x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "inferInstance",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_10",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "RelEmbedding",
   "FunLike.mk",
   "Eq.refl",
   "RelEmbedding.toEmbedding",
   "FunLike.coe",
   "RelEmbedding.mk",
   "RelEmbedding.casesOn",
   "Iff.mpr",
   "Eq",
   "Eq.ndrec",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Function.Embedding.toFun",
   "Function.Embedding.casesOn",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "RelEmbedding.map_rel_iff'",
   "Function.Embedding"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {r : α → α → Prop} {s : β → β → Prop} (f : r ↪r s) (a b : α), r a b → s (f a) (f b)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
   "AddMonoid.nsmul",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
   "AddCancelCommMonoid.mk",
   "AddCommMonoid.toAddMonoid",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddLeftCancelMonoid.mk",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_3",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : OrderedCancelAddCommMonoid α] → AddCancelCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Cardinal.map.proof_1",
   "Cardinal",
   "Cardinal.isEquivalent",
   "Quotient.map"],
  "name": "Cardinal.map",
  "constType":
  "(f : Type u → Type v) → ((α β : Type u) → α ≃ β → f α ≃ f β) → Cardinal.{u} → Cardinal.{v}",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "left_inv_eq_right_inv",
   "HMul.hMul",
   "inv_mul_self",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {a b : G}, a * b = 1 → a⁻¹ = b",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "AddMonoid"],
  "name": "DistribMulAction",
  "constType":
  "(M : Type u_10) → (A : Type u_11) → [inst : Monoid M] → [inst : AddMonoid A] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instBotAddSubgroup.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G], 0 ∈ ⊥.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "Semifield.toCommGroupWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "mul_comm",
   "Field.toCommRing",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_assoc",
   "one_mul",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "DivisionCommMonoid.toDivisionMonoid",
   "Field",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "id",
   "instHDiv",
   "NonUnitalNonAssocRing.toMul",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Field.toSemifield",
   "One.toOfNat1",
   "CommMagma.toMul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "mul_div_left_comm",
   "Eq.ndrec",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Semifield.toDivisionSemiring",
   "Field.toDiv"],
  "name": "CancelDenoms.div_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Field α] {n1 n2 k e1 e2 t1 : α}, n1 * e1 = t1 → n2 / e2 = 1 → n1 * n2 = k → k * (e1 / e2) = t1",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Nat.cast",
   "IntCast.mk",
   "instNatCastInt",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "IntCast.intCast"],
  "name": "Real.commRing.proof_23",
  "constType": "∀ (n : ℕ), IntCast.intCast ↑n = IntCast.intCast ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "CauSeq.neg_equiv_neg",
   "CauSeq.instNegCauSeq",
   "Neg.neg",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "Quotient.map",
   "Neg",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Neg.mk"],
  "name": "CauSeq.Completion.instNegCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Neg (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Contravariant",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "Set.Elem",
   "Set",
   "Finset",
   "Set.instEmptyCollectionSet",
   "Fintype.ofFinset",
   "Set.fintypeEmpty.proof_1"],
  "name": "Set.fintypeEmpty",
  "constType": "{α : Type u} → Fintype ↑∅",
  "constCategory": "Definition"},
 {"references": ["CanonicallyOrderedCommSemiring", "Mul"],
  "name": "CanonicallyOrderedCommSemiring.toMul",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SeminormedRing",
   "PseudoMetricSpace.toDist",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "SeminormedRing.toPseudoMetricSpace",
   "Norm.norm",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : SeminormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Monotone.mem_lowerBounds_image",
   "And.left",
   "GaloisConnection.monotone_u",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image",
   "GaloisInsertion.isGLB_of_u_image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), u (l (sInf (u '' s))) ≤ sInf (u '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "sub_neg_eq_add",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), a - -b = a + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "CompleteLattice.toInfSet",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_15",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)) (a : AddSubmonoid M), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.mk",
  "constType": "{α : Type u} → α → Bot α",
  "constCategory": "Other"},
 {"references":
  ["SetLike", "Set", "SetLike.coe_injective", "SetLike.coe", "Eq"],
  "name": "SetLike.ext'",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, ↑p = ↑q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "Quotient.liftOn₂",
   "Iff.rfl",
   "LT.lt",
   "Cardinal",
   "Not",
   "Function.Embedding",
   "Cardinal.instLECardinal.proof_1",
   "LT.mk",
   "Cardinal.isEquivalent",
   "Nonempty"],
  "name": "Cardinal.partialOrder.proof_3",
  "constType": "∀ (a b : Cardinal.{u_1}), a < b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Set.prod_univ",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.univ",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.MeasureTheory.Constructions.Prod.Basic._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α}, Prod.fst ⁻¹' s = s ×ˢ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Classical.choice",
   "Classical.indefiniteDescription.proof_1",
   "Subtype"],
  "name": "Classical.indefiniteDescription",
  "constType": "{α : Sort u} → (p : α → Prop) → (∃ x, p x) → { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "one_mul",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "invertibleOne.proof_2",
  "constType": "∀ {α : Type u_1} [inst : Monoid α], 1 * 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "congrArg",
   "Eq.symm",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "one_add_one_eq_two",
  "constType": "∀ {α : Type u_1} [inst : AddMonoidWithOne α], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "of_eq_true",
   "Nat.add_assoc.match_1",
   "PUnit",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.mul_assoc",
  "constType": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommMonoid.mk",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.add_comm",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMonoidWithOne",
   "AddCommMonoid"],
  "name": "AddCommMonoidWithOne.toAddCommMonoid",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddCommMonoid R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembershipSet",
  "constType": "{α : Type u_1} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "Nat.lt_iff_le_not_le.match_1",
   "LT.lt",
   "Not",
   "Nat.le_of_lt",
   "And.intro",
   "Nat",
   "Nat.lt_of_not_ge",
   "LE.le",
   "instLTNat"],
  "name": "Nat.lt_iff_le_not_le",
  "constType": "∀ {m n : ℕ}, m < n ↔ m ≤ n ∧ ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.toInfSet",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_8",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)) (a : AddSubgroup G), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Fin.ext",
   "Eq.refl",
   "Cardinal.partialOrder",
   "Cardinal.lift_mk_fin",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "Order.succ_le_iff",
   "Eq.mpr",
   "Cardinal.aleph0",
   "Nat.cast",
   "Iff.mp",
   "Function.Embedding.mk",
   "Preorder.toLT",
   "Function.Embedding",
   "Nat",
   "Cardinal.mk",
   "Eq.symm",
   "_private.Mathlib.SetTheory.Cardinal.Basic.0.Cardinal.aleph0._eq_1",
   "Nat.succ",
   "id",
   "Order.succ",
   "Fin.val",
   "Cardinal.nat_succ",
   "Cardinal.lift_mk_le",
   "Cardinal.instSuccOrderCardinalToPreorderPartialOrder",
   "LE.le",
   "Cardinal.instLECardinal",
   "Nonempty.intro",
   "Cardinal.instNatCastCardinal",
   "Eq.ndrec",
   "Cardinal.instNoMaxOrderCardinalToLTToPreorderPartialOrder",
   "propext",
   "LT.lt",
   "Cardinal",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.nat_lt_aleph0",
  "constType": "∀ (n : ℕ), ↑n < Cardinal.aleph0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "HEq",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.noConfusion",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.ndrec",
   "HEq.refl",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.casesOn",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat",
   "Eq.propIntro"],
  "name": "Real.ofCauchy.injEq",
  "constType":
  "∀ (cauchy cauchy_1 : CauSeq.Completion.Cauchy abs),\n  ({ cauchy := cauchy } = { cauchy := cauchy_1 }) = (cauchy = cauchy_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "Subtype"],
  "name": "PosMulStrictMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.407",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommGroup",
   "OfNat.ofNat",
   "IsCancelAdd.toIsLeftCancelAdd",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "neg_neg_iff_pos",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Zero.toOfNat0",
   "AddCancelMonoid.toIsCancelAdd",
   "Preorder.toLT",
   "LT.lt",
   "AddGroup.toAddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.mk",
   "OfNat.ofNat",
   "AddGroupWithOne.toSub",
   "Complex.commRing.proof_6",
   "AddGroupWithOne.toIntCast",
   "npowRec",
   "AddGroupWithOne.zsmul",
   "NonUnitalNonAssocSemiring.mk",
   "CommRing",
   "CommRing.mk",
   "AddGroupWithOne.intCast_ofNat",
   "Complex.Complex.addGroupWithOne",
   "AddGroupWithOne.intCast_negSucc",
   "AddCommMonoid.mk",
   "AddMonoidWithOne.toNatCast",
   "Complex.commRing.proof_13",
   "AddGroupWithOne",
   "Complex.commRing.proof_8",
   "Complex.commRing.proof_1",
   "Complex.commRing.proof_9",
   "AddGroupWithOne.add_left_neg",
   "Complex.instOneComplex",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Complex.commRing.proof_5",
   "AddGroupWithOne.zsmul_succ'",
   "AddMonoidWithOne.toAddMonoid",
   "One.mk",
   "AddGroupWithOne.toNeg",
   "One.toOfNat1",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "Complex.commRing.proof_3",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "Complex.commRing.proof_7",
   "NonUnitalSemiring.mk",
   "Complex.commRing.proof_12",
   "HMul.hMul",
   "Complex",
   "Complex.commRing.proof_4",
   "Complex.commRing.proof_2",
   "Ring.mk",
   "Complex.commRing.proof_11",
   "Complex.commRing.proof_10",
   "Complex.instMulComplex",
   "AddGroupWithOne.sub_eq_add_neg",
   "Mul.mk"],
  "name": "Complex.commRing",
  "constType": "CommRing ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Iff",
   "Function.Injective",
   "Function.comp",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "EquivLike.comp_injective",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.comp_injective",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {γ : Sort w} (f : α → β) (e : β ≃ γ), Function.Injective (⇑e ∘ f) ↔ Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "ne_of_lt",
   "MeasureTheory.IsFiniteMeasure",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace",
   "MeasureTheory.measure_lt_top"],
  "name": "MeasureTheory.measure_ne_top",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ]\n  (s : Set α), ↑↑μ s ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Top", "Top.top", "OrderTop", "LE", "LE.le"],
  "name": "OrderTop.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toTop : Top α] → (∀ (a : α), a ≤ ⊤) → OrderTop α",
  "constCategory": "Other"},
 {"references": ["Mul", "Distrib"],
  "name": "Distrib.toMul",
  "constType": "{R : Type u_1} → [self : Distrib R] → Mul R",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "IsGLB",
   "PartialOrder.toPreorder",
   "isGLB_sInf",
   "CompleteLattice",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "isGLB_iInf",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α}, IsGLB (Set.range f) (⨅ j, f j)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Equiv",
   "CompleteSemilatticeInf.toPartialOrder",
   "MulOneClass.toMul",
   "AddSubsemigroup.mk",
   "PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.toAddSubmonoid.proof_1",
   "Preorder.toLE",
   "Additive.toMul",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Submonoid.toAddSubmonoid.proof_4",
   "OrderIso",
   "Submonoid.mk",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.one_mem'",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "Submonoid.toAddSubmonoid.proof_3",
   "Submonoid.toAddSubmonoid.proof_6",
   "FunLike.coe",
   "Additive.ofMul",
   "Additive.addZeroClass",
   "LE.le",
   "AddSubmonoid",
   "Submonoid.toAddSubmonoid.proof_2",
   "Equiv.instFunLikeEquiv",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Submonoid.toAddSubmonoid.proof_5",
   "Equiv.mk",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "RelIso.mk",
   "Additive",
   "SetLike.coe"],
  "name": "Submonoid.toAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → Submonoid M ≃o AddSubmonoid (Additive M)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Set.addMonoid.proof_1",
   "Set.addMonoid.proof_3",
   "SMul",
   "Set.add",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "nsmulRec",
   "AddMonoid.toAddZeroClass",
   "Set.addMonoid.proof_4",
   "AddSemigroup",
   "AddMonoid",
   "AddMonoid.mk",
   "Set.addSemigroup",
   "AddZeroClass.toZero",
   "Add.add",
   "Set.NSMul",
   "AddMonoid.toAddSemigroup",
   "Set.addMonoid.proof_5",
   "AddMonoid.toZero",
   "Nat",
   "AddZeroClass",
   "Set.addMonoid.proof_2",
   "Set.addZeroClass",
   "Add.mk"],
  "name": "Set.addMonoid",
  "constType": "{α : Type u_2} → [inst : AddMonoid α] → AddMonoid (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["funext", "IsSymmOp.symm_op", "flip", "Eq.symm", "IsSymmOp", "Eq"],
  "name": "IsSymmOp.flip_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (op : α → α → β) [inst : IsSymmOp α β op], flip op = op",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toCompleteSemilatticeSup",
   "le_sSup",
   "iSup",
   "Exists.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "rfl",
   "CompleteLattice.toSupSet",
   "Preorder.toLE",
   "Eq"],
  "name": "le_iSup",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] (f : ι → α) (i : ι), f i ≤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_1",
   "AddCommMonoid.mk",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid.proof_2",
   "SubNegMonoid.toAddMonoid",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "AddCommGroup.toAddGroup",
   "OrderedAddCommGroup.add_le_add_left",
   "AddGroup.toSubNegMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [inst : OrderedAddCommGroup α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Min", "LE", "Min.mk", "LE.le", "ite", "DecidableRel"],
  "name": "minOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MeasureTheory.isFiniteMeasure_sFiniteSeq",
   "MeasureTheory.Measure.map_sum",
   "MeasureTheory.Measure.map",
   "MeasureTheory.sFiniteSeq",
   "MeasureTheory.isFiniteMeasureZero",
   "MeasureTheory.Measure.map_of_not_aemeasurable",
   "Classical.propDecidable",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "dite",
   "MeasureTheory.SFinite",
   "instCountableNat",
   "MeasureTheory.instSFiniteSum",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "inferInstance",
   "Eq.mpr",
   "Eq.ndrec",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "MeasureTheory.Measure.instZero",
   "Eq.mp",
   "Not",
   "Nat",
   "Eq.symm",
   "MeasurableSpace",
   "MeasureTheory.Measure.sum",
   "MeasureTheory.sum_sFiniteSeq",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "AEMeasurable",
   "id"],
  "name": "MeasureTheory.Measure.instSFiniteMap",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] (μ : MeasureTheory.Measure α)\n  (f : α → β) [inst_1 : MeasureTheory.SFinite μ], MeasureTheory.SFinite (MeasureTheory.Measure.map f μ)",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Classical.choose_spec",
   "And",
   "Classical.choose",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "Set.image",
   "And.left",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Equiv.Set.imageOfInjOn.proof_3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (p : ↑(f '' s)), Classical.choose (_ : ↑p ∈ f '' s) ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "StrictOrderedCommSemiring",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring",
   "ite",
   "Ord",
   "Eq",
   "Ord.compare",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toStrictOrderedCommSemiring : StrictOrderedCommSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "PartialOrder"],
  "name": "OrderedAddCommGroup.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.gt_of_not_le.match_1",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "absurd",
   "instLTNat",
   "LE.le",
   "GT.gt"],
  "name": "Nat.gt_of_not_le",
  "constType": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "one_div",
   "One.toOfNat1",
   "IsUnit.mul_inv_cancel_right",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "DivInvMonoid.toInv",
   "Eq",
   "DivisionMonoid",
   "InvOneClass.toOne",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Eq.trans",
   "Inv.inv",
   "congrFun",
   "DivInvMonoid.toDiv"],
  "name": "IsUnit.mul_mul_div",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {b : α} (a : α), IsUnit b → a * b * (1 / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.toInv",
   "Field.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.div_eq_mul_inv",
  "constType": "∀ {K : Type u} [self : Field K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddCommMonoid",
   "Eq.refl",
   "dite",
   "sub_eq_add_neg",
   "two_nsmul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddGroup.toAddCancelMonoid",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "ElementaryAddCommGroup.orderOf_of_ne",
   "id",
   "eq_self",
   "instHSub",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "Classical.propDecidable",
   "HSub.hSub",
   "Neg.neg",
   "add_eq_zero_iff_neg_eq",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toNatSMul",
   "add_right_inj",
   "addOrderOf_nsmul_eq_zero",
   "Eq.ndrec",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "propext",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "Not",
   "ElementaryAddCommGroup",
   "AddCommGroup",
   "add_zero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "addOrderOf",
   "congrFun"],
  "name": "ElementaryAddCommGroup.sub_eq_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] [elem : ElementaryAddCommGroup G 2] (x y : G), x - y = x + y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InvOneClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.image2",
   "funext",
   "Mathlib.Logic.Basic._auxLemma.32",
   "Std.Logic._auxLemma.39",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "congr",
   "Set.image",
   "congrArg",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image2_image_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : Set α} {t : Set β} (f : α → γ → δ) (g : β → γ),\n  Set.image2 f s (g '' t) = Set.image2 (fun a b => f a (g b)) s t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true",
   "Finset.toSet",
   "Finset",
   "Finset.finite_toSet",
   "True",
   "Set.Finite",
   "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.22",
  "constType": "∀ {α : Type u} (s : Finset α), Set.Finite ↑s = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "DivInvMonoid.toMonoid",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "True",
   "CommMonoid.toCommSemigroup",
   "Eq",
   "DivInvMonoid.toInv",
   "mul_comm",
   "instHMul",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "DivisionCommMonoid.toDivisionMonoid",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionCommMonoid.toCommMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "HMul.hMul",
   "mul_inv_rev",
   "congrArg",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Eq.trans",
   "congrFun",
   "Inv.inv"],
  "name": "mul_inv",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b : α), (a * b)⁻¹ = a⁻¹ * b⁻¹",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "Add", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b c : G), a + b + c = a + (b + c)) → AddSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Real", "LT", "LT.mk", "_private.Mathlib.Data.Real.Basic.0.Real.lt"],
  "name": "Real.instLTReal",
  "constType": "LT ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Infinite",
  "constType": "Sort u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "neg_eq_of_add_eq_zero_right",
   "Exists",
   "Set.zero",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Set",
   "Set.Nonempty",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "Exists.casesOn",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff",
   "Eq.subst",
   "Set.singleton_zero",
   "neg_eq_of_add_eq_zero_left",
   "And.casesOn",
   "eq_neg_of_add_eq_zero_left",
   "Set.eq_singleton_iff_unique_mem",
   "Eq.symm",
   "Set.singleton_add_singleton",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "Set.Nonempty.of_image2_right",
   "Set.add",
   "Set.zero_nonempty",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "eq_neg_of_add_eq_zero_right",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Eq.ndrec",
   "Set.mem_image2_of_mem",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "Singleton.singleton",
   "And.intro",
   "Set.Nonempty.of_image2_left",
   "NegZeroClass.toZero",
   "Eq.subset"],
  "name": "Set.add_eq_zero_iff",
  "constType":
  "∀ {α : Type u_2} [inst : SubtractionMonoid α] {s t : Set α}, s + t = 0 ↔ ∃ a b, s = {a} ∧ t = {b} ∧ a + b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "Decidable.byCases"],
  "name": "Decidable.em",
  "constType": "∀ (p : Prop) [inst : Decidable p], p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.add.match_1",
  "constType":
  "(motive : ℤ → ℤ → Sort u_1) →\n  (m n : ℤ) →\n    ((m n : ℕ) → motive (Int.ofNat m) (Int.ofNat n)) →\n      ((m n : ℕ) → motive (Int.ofNat m) (Int.negSucc n)) →\n        ((m n : ℕ) → motive (Int.negSucc m) (Int.ofNat n)) →\n          ((m n : ℕ) → motive (Int.negSucc m) (Int.negSucc n)) → motive m n",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "AddZeroClass.zero_add",
   "AddMonoid.toAddZeroClass",
   "Set.addZeroClass",
   "AddMonoid",
   "Eq"],
  "name": "Set.addMonoid.proof_2",
  "constType": "∀ {α : Type u_1} [inst : AddMonoid α] (a : Set α), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "Set.toFinset",
   "Set",
   "Finset",
   "Set.Finite.toFinset_eq_toFinset",
   "Finite.of_fintype",
   "Set.Finite.toFinset",
   "Set.toFinite",
   "Eq"],
  "name": "Set.toFinite_toFinset",
  "constType":
  "∀ {α : Type u} (s : Set α) [inst : Fintype ↑s], Set.Finite.toFinset (_ : Set.Finite s) = Set.toFinset s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.mul_comm",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Cardinal.canonicallyOrderedCommSemiring.proof_5",
   "CanonicallyOrderedCommSemiring",
   "Cardinal.partialOrder",
   "Cardinal.canonicallyOrderedCommSemiring.proof_12",
   "Preorder.toLE",
   "Cardinal.canonicallyOrderedCommSemiring.proof_8",
   "Semiring.toNatCast",
   "Cardinal.canonicallyOrderedCommSemiring.proof_9",
   "Cardinal.canonicallyOrderedCommSemiring.proof_1",
   "Zero.toOfNat0",
   "Cardinal.canonicallyOrderedCommSemiring.proof_6",
   "Cardinal.canonicallyOrderedCommSemiring.proof_3",
   "Semiring.npow",
   "Cardinal.commSemiring",
   "CommSemiring",
   "Cardinal.canonicallyOrderedCommSemiring.proof_14",
   "Cardinal.canonicallyOrderedCommSemiring.proof_10",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Cardinal.canonicallyOrderedCommSemiring.proof_4",
   "OrderedAddCommMonoid.toPartialOrder",
   "Cardinal.zero_le",
   "Cardinal.canonicallyOrderedCommSemiring.proof_7",
   "CanonicallyOrderedCommSemiring.mk",
   "OrderedAddCommMonoid.mk",
   "Cardinal.canonicallyOrderedCommSemiring.proof_13",
   "NonUnitalNonAssocSemiring.toMul",
   "Cardinal.canonicallyOrderedCommSemiring.proof_11",
   "Cardinal.canonicallyOrderedCommSemiring.proof_2",
   "PartialOrder",
   "Cardinal.instZeroCardinal",
   "Semiring.toOne",
   "Cardinal.canonicallyOrderedCommSemiring.proof_15",
   "Cardinal",
   "PartialOrder.le_antisymm",
   "Bot.mk",
   "OrderBot.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Cardinal.canonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": ["HasQuotient.quotient'", "outParam", "HasQuotient"],
  "name": "HasQuotient.Quotient",
  "constType":
  "(A : outParam (Type u)) → {B : Type v} → [inst : HasQuotient A B] → B → Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.mk",
  "constType": "{α : Type u} → (α → α → Prop) → HasSubset α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Nat.zero_add",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.mul_one",
  "constType": "∀ (n : ℕ), n * 1 = n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "instHPow",
   "instNatPowNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_succ",
  "constType": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "Group",
   "Group.toDivInvMonoid",
   "mul_right_inv",
   "Eq.symm",
   "Inv.inv",
   "id"],
  "name": "mul_inv_cancel_left",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a b : G), a * (a⁻¹ * b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "Real",
   "GE.ge",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "Preorder.toLE",
   "Nonempty",
   "Filter.HasBasis.cauchySeq_iff'",
   "GT.gt",
   "Dist.dist",
   "SemilatticeSup",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "Iff",
   "LT.lt",
   "Prod",
   "Metric.uniformity_basis_dist",
   "SemilatticeSup.toPartialOrder",
   "PseudoMetricSpace"],
  "name": "Metric.cauchySeq_iff'",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, dist (u n) (u N) < ε",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedSemifield.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.intCast",
   "Real.ofCauchy",
   "rfl",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Int",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_intCast",
  "constType": "∀ (z : ℤ), { cauchy := ↑z } = ↑z",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "neg_eq_zero_sub",
   "Neg.neg",
   "Eq.symm",
   "Eq"],
  "name": "zero_sub",
  "constType": "∀ {G : Type u_3} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "Nontrivial"],
  "name": "StrictOrderedRing.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid.mk",
   "Subsemigroup.carrier",
   "Membership.mem",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Set",
   "Subsemigroup",
   "Submonoid",
   "One.toOfNat1",
   "Submonoid.rec",
   "Set.instMembershipSet"],
  "name": "Submonoid.casesOn",
  "constType":
  "{M : Type u_4} →\n  [inst : MulOneClass M] →\n    {motive : Submonoid M → Sort u} →\n      (t : Submonoid M) →\n        ((toSubsemigroup : Subsemigroup M) →\n            (one_mem' : 1 ∈ toSubsemigroup.carrier) →\n              motive { toSubsemigroup := toSubsemigroup, one_mem' := one_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "Set.preimage",
   "AddSubgroup.zero_mem",
   "AddSubgroup.op.proof_1",
   "AddOpposite.addGroup",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubgroup.op.proof_2",
   "AddGroup",
   "AddOpposite.unop",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddOpposite",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.op",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → AddSubgroup G → AddSubgroup Gᵃᵒᵖ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "Field.toSemifield",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.zpow",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Nat",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.field.proof_4",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℕ) (a : CauSeq.Completion.Cauchy abv),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "sub_pos",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddGroup",
   "propext",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Ring.Defs._auxLemma.5",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α},\n  (0 < a - b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "RelIso.toEquiv",
   "RelEmbedding",
   "Equiv.coe_fn_injective",
   "RelIso.toRelEmbedding",
   "RelIso.map_rel_iff'",
   "Function.Injective.comp",
   "FunLike.mk",
   "RelIso",
   "FunLike.coe",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "RelIso.toEquiv_injective",
   "Iff.mpr",
   "Equiv.instFunLikeEquiv",
   "RelHomClass.toFunLike"],
  "name": "RelIso.instRelHomClassRelIso.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {r : α → α → Prop} {s : β → β → Prop} (f : r ≃r s) (x x_1 : α),\n  r x x_1 → s (f x) (f x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.mk_eq_zero_iff",
   "Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "propext",
   "Cardinal",
   "Cardinal.mk",
   "IsEmpty",
   "Eq"],
  "name": "Mathlib.SetTheory.Cardinal.Finite._auxLemma.2",
  "constType": "∀ {α : Type u}, (Cardinal.mk α = 0) = IsEmpty α",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "NeZero.one",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "left_ne_zero_of_mul",
   "ne_zero_of_eq_one",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "Nontrivial"],
  "name": "left_ne_zero_of_mul_eq_one",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀] {a b : M₀}, a * b = 1 → a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Int"],
  "name": "GroupWithZero.zpow",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → ℤ → G₀ → G₀",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_trans.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x < x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x < x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a < _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "Subtype.val", "Subtype.ext", "Subtype"],
  "name": "Subtype.coe_injective",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop}, Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalCommSemiring.mk",
  "constType":
  "{α : Type u} → [toNonUnitalSemiring : NonUnitalSemiring α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommSemiring α",
  "constCategory": "Other"},
 {"references": ["Norm", "Real"],
  "name": "Norm.norm",
  "constType": "{E : Type u_9} → [self : Norm E] → E → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.gcd.proof_1",
   "measure",
   "WellFoundedRelation.rel",
   "_private.Init.Data.Nat.Gcd.0.Nat.gcdF",
   "Nat",
   "WellFounded.fix",
   "id"],
  "name": "Nat.gcd",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "instHMul",
   "MulOneClass.toMul",
   "Iff",
   "DivInvOneMonoid.toInvOneClass",
   "IsUnit.unit'",
   "Units.mul_inv_eq_iff_eq_mul",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Inv.inv",
   "Eq"],
  "name": "IsUnit.mul_inv_eq_iff_eq_mul",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit b → (a * b⁻¹ = c ↔ a = c * b)",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod.rec", "Prod"],
  "name": "Prod.casesOn",
  "constType":
  "{α : Type u} →\n  {β : Type v} → {motive : α × β → Sort u_1} → (t : α × β) → ((fst : α) → (snd : β) → motive (fst, snd)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "And",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "PartialOrder.lift",
   "Not",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Preorder.lt_iff_le_not_le",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder.proof_3",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] (a b : A), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Real.log_lt_log",
   "Eq.mpr",
   "ne_of_gt",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "instHPow",
   "Real.strictOrderedSemiring",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "lt_trans",
   "Eq.symm",
   "id",
   "Real.exp_lt_exp",
   "HPow.hPow",
   "Or",
   "le_iff_eq_or_lt",
   "Real.partialOrder",
   "Real.instLTReal",
   "Real.zero_rpow",
   "Or.inr",
   "Or.casesOn",
   "LE.le",
   "Real.exp",
   "Real.instZeroReal",
   "instHMul",
   "Real.rpow_pos_of_pos",
   "Real.log",
   "Eq.ndrec",
   "Or.inl",
   "propext",
   "LT.lt",
   "Eq.mp",
   "Real.instPreorderReal",
   "mul_lt_mul_of_pos_right",
   "HMul.hMul"],
  "name": "Real.rpow_lt_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → x < y → 0 < z → x ^ z < y ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.zero_mul",
  "constType":
  "∀ {M₀ : Type u_4} [self : CommMonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Nat.ble",
   "instLENat",
   "propext",
   "Bool.true",
   "Bool",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "LE.le",
   "Eq"],
  "name": "Nat.ble_eq",
  "constType": "∀ {x y : ℕ}, (Nat.ble x y = true) = (x ≤ y)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Pi.instSub",
   "inferInstance",
   "SubNegMonoid.toSub",
   "prod",
   "Prod.snd",
   "FiniteRange",
   "AddGroup",
   "Function.comp",
   "instFiniteRangeProdProd",
   "HSub.hSub",
   "letFun",
   "instFiniteRangeComp",
   "Prod",
   "Prod.fst",
   "AddGroup.toSubNegMonoid"],
  "name": "instFiniteRangeHSubForAllInstHSubInstSubToSubToSubNegAddMonoid",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} (X Y : Ω → G) [inst : AddGroup G] [hX : FiniteRange X] [hY : FiniteRange Y],\n  FiniteRange (X - Y)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLE",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "MeasurableSpace.GenerateMeasurable",
   "Set",
   "Set.instEmptyCollectionSet"],
  "name": "MeasurableSpace.GenerateMeasurable.empty",
  "constType":
  "∀ {α : Type u_1} {s : Set (Set α)}, MeasurableSpace.GenerateMeasurable s ∅",
  "constCategory": "Other"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.702",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.702",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references": [],
  "name": "IsCommutative",
  "constType": "(α : Type u) → (α → α → α) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Complex.ofReal'",
   "OfNat.ofNat",
   "One",
   "Real",
   "One.mk",
   "One.toOfNat1",
   "Complex",
   "Real.instOneReal"],
  "name": "Complex.instOneComplex",
  "constType": "One ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N], (fun x => 0) 0 = (fun x => 0) 0",
  "constCategory": "Theorem"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Covariant M N μ r → CovariantClass M N μ r",
  "constCategory": "Other"},
 {"references": ["Iff", "Decidable", "decidable_of_decidable_of_iff"],
  "name": "decidable_of_iff",
  "constType":
  "{b : Prop} → (a : Prop) → (a ↔ b) → [inst : Decidable a] → Decidable b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.subtype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.toAddGroup",
   "SetLike.instMembership",
   "Subtype",
   "AddSubgroup.comap"],
  "name": "AddSubgroup.addSubgroupOf",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → AddSubgroup G → (K : AddSubgroup G) → AddSubgroup ↥K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "RelIso",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "abs_of_nonneg",
   "True",
   "Abs.abs",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Iff",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "LinearOrderedAddCommGroup",
   "Neg.toHasAbs",
   "Or",
   "instDistribLattice",
   "eq_or_eq_neg_of_abs_eq",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Or.casesOn",
   "LE.le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "of_eq_true",
   "abs_neg",
   "congrArg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrFun",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_eq",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, 0 ≤ b → (|a| = b ↔ a = b ∨ a = -b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CauSeq.Completion.Cauchy.divisionRing.proof_11",
   "CauSeq.Completion.Cauchy.divisionRing.proof_2",
   "zpowRec",
   "DivisionRing.mk",
   "DivisionRing.toDivisionSemiring",
   "Monoid.mk",
   "DivisionRing.toRing",
   "CauSeq.Completion.Cauchy.divisionRing.proof_5",
   "DivisionRing.toRatCast",
   "CauSeq.Completion.Cauchy.divisionRing.proof_7",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "CauSeq.Completion.inv_zero",
   "Semiring.npow",
   "Div.mk",
   "CauSeq.Completion.Cauchy.divisionRing.proof_3",
   "CauSeq.Completion.Cauchy.divisionRing.proof_10",
   "Rat.cast",
   "CauSeq.Completion.ofRat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.instInvCauchyToRing",
   "CauSeq.Completion.Cauchy.divisionRing.proof_12",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Semigroup.mk",
   "CauSeq.Completion.Cauchy.divisionRing.proof_8",
   "DivisionRing",
   "RatCast.mk",
   "qsmulRec",
   "Rat",
   "NonUnitalNonAssocSemiring.toMul",
   "DivInvMonoid.div'",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "CauSeq.Completion.Cauchy.ring",
   "CauSeq.Completion.Cauchy.divisionRing.proof_4",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing.proof_9",
   "CauSeq.Completion.Cauchy.divisionRing.proof_1",
   "CauSeq.Completion.mul_inv_cancel",
   "CauSeq.Completion.Cauchy",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CauSeq.Completion.Cauchy.divisionRing.proof_6"],
  "name": "CauSeq.Completion.Cauchy.divisionRing",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : DivisionRing β] →\n        {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → DivisionRing (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "OrderedRing",
   "Int.linearOrderedCommRing",
   "Int.cast_le",
   "LE.le",
   "Preorder.toLE",
   "OrderedRing.toPartialOrder",
   "OrderedRing.toRing",
   "Iff.symm",
   "Int.cast",
   "Ring.toIntCast",
   "StrictMono",
   "Nontrivial",
   "strictMono_of_le_iff_le",
   "Int",
   "Int.instLEInt"],
  "name": "Int.cast_strictMono",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedRing α] [inst_1 : Nontrivial α], StrictMono fun x => ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddCommMonoid"],
  "name": "AddCommMonoid.add_comm",
  "constType":
  "∀ {M : Type u} [self : AddCommMonoid M] (a b : M), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "Set", "Subtype", "Set.instMembershipSet"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Set.iUnion", "MeasurableSpace.GenerateMeasurable", "Set", "Nat"],
  "name": "MeasurableSpace.GenerateMeasurable.iUnion",
  "constType":
  "∀ {α : Type u_1} {s : Set (Set α)} (f : ℕ → Set α),\n  (∀ (n : ℕ), MeasurableSpace.GenerateMeasurable s (f n)) → MeasurableSpace.GenerateMeasurable s (⋃ i, f i)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "InfSet",
   "AddSubgroup.instInfSetAddSubgroup.proof_3",
   "AddSubgroup.toAddSubmonoid",
   "AddSubgroup.instInfSetAddSubgroup.proof_1",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.copy",
   "AddSubgroup.instInfSetAddSubgroup.proof_2",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "InfSet.mk",
   "AddGroup",
   "iInf",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "Set.iInter",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfSetAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → InfSet (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "BooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "OfNat.ofNat",
   "eq_zero_of_zero_dvd",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero.toMulZeroClass",
   "True",
   "MulZeroClass.toMul",
   "SemigroupWithZero",
   "Eq",
   "Iff.intro",
   "SemigroupWithZero.toSemigroup",
   "Zero.toOfNat0",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "zero_dvd_iff",
  "constType":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.out"],
  "name": "Quotient.out",
  "constType": "{α : Sort u_1} → [s : Setoid α] → Quotient s → α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHSMul",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "AddMonoid.toNatSMul",
   "OrderedAddCommMonoid",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Nat",
   "Archimedean",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Archimedean.mk",
  "constType":
  "∀ {α : Type u_2} [inst : OrderedAddCommMonoid α], (∀ (x : α) {y : α}, 0 < y → ∃ n, x ≤ n • y) → Archimedean α",
  "constCategory": "Other"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.sInf",
  "constType": "{α : Type u_9} → [self : InfSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Set",
   "ProbabilityTheory.FiniteSupport.mk",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "ProbabilityTheory.FiniteSupport.rec",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "ProbabilityTheory.FiniteSupport",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Finset.toSet",
   "Finset",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.FiniteSupport.casesOn",
  "constType":
  "{S : Type u_2} →\n  [inst : MeasurableSpace S] →\n    {μ : MeasureTheory.Measure S} →\n      {motive : ProbabilityTheory.FiniteSupport → Sort u} →\n        (t : ProbabilityTheory.FiniteSupport) →\n          ((finite : ∃ A, ↑↑μ (↑A)ᶜ = 0) → motive (_ : ProbabilityTheory.FiniteSupport)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "instLTNat",
   "Nat.cast_zero",
   "True",
   "Preorder.toLE",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "NeZero",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Eq.trans",
   "AddCommMonoid.toAddCommSemigroup",
   "Nat.strictOrderedSemiring",
   "False",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.5",
   "LE.le",
   "PartialOrder",
   "Mathlib.Order.Basic._auxLemma.2",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Nat.zero",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "CovariantClass",
   "congr",
   "congrArg",
   "AddCommMonoidWithOne",
   "Nat.casesOn",
   "Std.Data.Nat.Lemmas._auxLemma.6"],
  "name": "Nat.cast_pos'",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → [self : Trans r s t] → {a : α} → {b : β} → {c : γ} → r a b → s b c → t a c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "HasSubset.Subset",
   "Set.instLESet",
   "LE.le",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "inferInstance",
   "BooleanAlgebra.toBiheytingAlgebra",
   "instIsTransLeToLE",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "letFun",
   "GeneralizedCoheytingAlgebra.toLattice",
   "IsTrans",
   "BiheytingAlgebra.toCoheytingAlgebra"],
  "name": "Set.instIsTransSetSubsetInstHasSubsetSet",
  "constType": "∀ {α : Type u}, IsTrans (Set α) fun x x_1 => x ⊆ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "instTransEq",
   "add_lt_add_left",
   "add_zero",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "lt_add_of_pos_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a < a + b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Prod.exists.match_2",
   "Prod.mk",
   "Prod",
   "Exists.intro",
   "Prod.exists.match_1"],
  "name": "Prod.exists",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) ↔ ∃ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Eq.symm",
   "LE.le",
   "Preorder.toLE",
   "Or.elim",
   "le_total",
   "Eq"],
  "name": "lt_trichotomy",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a = b ∨ b < a",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveNeg", "Neg.neg", "Neg", "Eq"],
  "name": "InvolutiveNeg.mk",
  "constType":
  "{A : Type u_2} → [toNeg : Neg A] → (∀ (x : A), - -x = x) → InvolutiveNeg A",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "zero_add",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.symm",
   "AddZeroClass",
   "Eq"],
  "name": "instZeroAddMonoidHom.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass N], M → M → 0 = 0 + 0",
  "constCategory": "Theorem"},
 {"references": ["DivisionSemiring", "Inv"],
  "name": "DivisionSemiring.toInv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_right_comm",
  "constType": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "constCategory": "Theorem"},
 {"references": ["congrArg₂", "Eq"],
  "name": "congr_arg₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.toMeasurableSpace",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelSemigroup.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelSemigroup.add_right_cancel",
  "constType":
  "∀ {G : Type u} [self : AddRightCancelSemigroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["Subgroup.map.proof_2",
   "Subgroup.mk",
   "Submonoid.mk",
   "MulOneClass.toMul",
   "MonoidHomClass.toMulHomClass",
   "MonoidHom.monoidHomClass",
   "MulHomClass.toFunLike",
   "MonoidHom",
   "FunLike.coe",
   "Submonoid.map",
   "Subgroup.map.proof_3",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Subgroup.toSubmonoid",
   "Subsemigroup.mk",
   "Subgroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid",
   "Set.image",
   "Subgroup.map.proof_1",
   "Subgroup.instSetLikeSubgroup",
   "SetLike.coe"],
  "name": "Subgroup.map",
  "constType":
  "{G : Type u_1} → [inst : Group G] → {N : Type u_5} → [inst_1 : Group N] → (G →* N) → Subgroup G → Subgroup N",
  "constCategory": "Definition"},
 {"references":
  ["wrapped._@.Mathlib.Topology.Algebra.InfiniteSum.Basic._hyg.106",
   "TopologicalSpace",
   "AddCommMonoid"],
  "name": "tsum",
  "constType":
  "{α : Type u_5} → [inst : AddCommMonoid α] → [inst : TopologicalSpace α] → {β : Type u_6} → (β → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "MeasureTheory.Measure.map",
   "ProbabilityTheory.IdentDistrib.aemeasurable_fst",
   "ProbabilityTheory.IdentDistrib.aemeasurable_snd",
   "ProbabilityTheory.IdentDistrib",
   "Eq.symm",
   "MeasurableSpace",
   "ProbabilityTheory.IdentDistrib.mk"],
  "name": "ProbabilityTheory.IdentDistrib.symm",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ},\n  ProbabilityTheory.IdentDistrib f g → ProbabilityTheory.IdentDistrib g f",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.ext.match_1", "Subtype.val", "rfl", "Subtype.mk", "Subtype", "Eq"],
  "name": "Subtype.ext",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Norm.norm",
   "Semifield.toDivisionSemiring",
   "NormedSpace.toModule"],
  "name": "NormedSpace.norm_smul_le",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NormedField α] [inst_1 : SeminormedAddCommGroup β] [self : NormedSpace α β]\n  (a : α) (b : β), ‖a • b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references":
  ["AddOpposite.unop",
   "instHAdd",
   "HAdd.hAdd",
   "AddOpposite",
   "VAdd",
   "Add",
   "VAdd.mk"],
  "name": "Add.toHasOppositeVAdd",
  "constType": "(α : Type u_1) → [inst : Add α] → VAdd αᵃᵒᵖ α",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "Iff",
   "Real.instLTReal",
   "LT.lt",
   "Real",
   "Real.instPreorderReal",
   "StrictMono.lt_iff_lt",
   "Real.exp",
   "Real.exp_strictMono"],
  "name": "Real.exp_lt_exp",
  "constType": "∀ {x y : ℝ}, Real.exp x < Real.exp y ↔ x < y",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "NeZero.mk",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat"],
  "name": "NeZero.succ",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ContravariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_6",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real",
   "Real.instAddMonoidReal",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Real.normedCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "AddZeroClass.toZero",
   "of_eq_true",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "congrFun"],
  "name": "Real.isROrC.proof_12",
  "constType": "ℝ → 0 * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.add.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.add",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Inf", "Lattice"],
  "name": "Lattice.toInf",
  "constType": "{α : Type u} → [self : Lattice α] → Inf α",
  "constCategory": "Definition"},
 {"references": ["Quot.lift", "Quot", "Eq"],
  "name": "Quot.liftOn",
  "constType":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec",
   "Exists",
   "CompleteSemilatticeInf.toPartialOrder",
   "not_lt",
   "Classical.choose",
   "PartialOrder.toPreorder",
   "le_iInf",
   "not_le_of_lt",
   "GE.ge",
   "dite",
   "CompleteLinearOrder",
   "le_iSup",
   "iSup",
   "Mathlib.Init.Order.Defs._auxLemma.2",
   "Exists.casesOn",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.5",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Iff.mp",
   "forall_congr",
   "Preorder.toLT",
   "lt_irrefl",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.3",
   "le_trans",
   "lt_of_not_le",
   "le_of_lt",
   "And.casesOn",
   "iInf_le",
   "Mathlib.Order.CompleteBooleanAlgebra._auxLemma.2",
   "Eq.trans",
   "CompleteLattice.toSupSet",
   "id",
   "lt_iSup_iff",
   "Or",
   "le_of_not_lt",
   "False",
   "CompleteLinearOrder.toLinearOrder",
   "Classical.propDecidable",
   "lt_of_lt_of_le",
   "LE.le",
   "Or.resolve_left",
   "And",
   "CompleteLinearOrder.toCompletelyDistribLattice.match_1",
   "iInf",
   "CompleteLattice.toInfSet",
   "LT.lt",
   "Eq.mp",
   "letFun",
   "CompleteLinearOrder.toCompleteLattice",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "le_iInf_iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "congrArg"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CompleteLinearOrder α] {α_1 : Type u_1} {β : α_1 → Type u_1} (g : (a : α_1) → β a → α),\n  ⨅ a, ⨆ b, g a b = ⨆ g_1, ⨅ a, g a (g_1 a)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommMonoid",
   "CommSemiring",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.mk",
   "CommMonoid.mul_comm"],
  "name": "CommSemiring.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [inst : CommSemiring α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.zero_add",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Nat.cast_add",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.add a' b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "BiheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Complex.addCommGroup",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "AddCommGroup.toAddGroup",
   "Complex",
   "SubNegMonoid.zsmul_neg'",
   "Nat",
   "Nat.succ",
   "Int",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "Complex.Complex.addGroupWithOne.proof_6",
  "constType":
  "∀ (n : ℕ) (a : ℂ), SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp",
   "Iff",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "decidable_of_decidable_of_iff.proof_1"],
  "name": "decidable_of_decidable_of_iff",
  "constType": "{p q : Prop} → [inst : Decidable p] → (p ↔ q) → Decidable q",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.casesOn",
   "Int.ofNat",
   "Int.instMulInt",
   "Int.ofNat_mul_negOfNat",
   "Int.negOfNat",
   "Int.negSucc_mul_negOfNat",
   "Eq.refl",
   "Int.negOfNat_mul_negSucc",
   "True",
   "Int.negOfNat_mul_ofNat",
   "Eq",
   "instHMul",
   "Nat.mul_assoc",
   "Eq.ndrec",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.mul_assoc",
  "constType": "∀ (a b c : ℤ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Prod.snd",
   "DiscreteMeasurableSpace",
   "HSub.hSub",
   "measurable_discrete",
   "MeasurableSub₂.mk",
   "Prod",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "DiscreteMeasurableSpace.toMeasurableSub₂",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : Sub α] [inst_2 : DiscreteMeasurableSpace (α × α)],\n  MeasurableSub₂ α",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "le_not_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 : α) → x < x_1 → Prop) (x x_1 : α) (x_2 : x < x_1),\n  (∀ (_a _b : α) (hab : _a < _b), motive _a _b hab) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Set.preimage",
   "Set",
   "Filter.mem_of_superset",
   "HasSubset.Subset",
   "Filter",
   "Set.preimage_mono",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (m : α → β) (f : Filter α) {x y : Set β},\n  x ∈ Set.preimage m ⁻¹' f.sets → x ⊆ y → m ⁻¹' y ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "inferInstance",
   "Real",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Real.orderedSemiring"],
  "name": "Real.orderedAddCommMonoid",
  "constType": "OrderedAddCommMonoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.mul_one",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["Or", "Real.instLTReal", "LT.lt", "Real", "Eq"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.4598",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSingletonClass",
   "Finset.toSet",
   "MeasurableSet",
   "Finset",
   "Finset.finite_toSet",
   "Set.Finite.measurableSet",
   "MeasurableSpace"],
  "name": "Finset.measurableSet",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] (s : Finset α), MeasurableSet ↑s",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive t",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Div"],
  "name": "DivisionSemiring.toDiv",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "rfl",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.zero",
   "Eq.rec",
   "Bool.true",
   "letFun",
   "PUnit",
   "Nat.eq_of_beq_eq_true.match_1",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ"],
  "name": "Nat.eq_of_beq_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = true → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalCommRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Multiset.card_le_of_le",
   "instLENat",
   "PartialOrder.toPreorder",
   "Function.comp",
   "Multiset",
   "Finset",
   "Finset.val",
   "HasSubset.Subset",
   "Finset.val_le_iff",
   "Nat",
   "Finset.instHasSubsetFinset",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name": "Finset.card_le_of_subset",
  "constType":
  "∀ {α : Type u_1} {s t : Finset α}, s ⊆ t → Finset.card s ≤ Finset.card t",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_right",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_trans",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_of_right_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, b ≤ c → a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_12",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMagma",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "left_ne_zero_of_mul_eq_one",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "inv_mul_cancel_left₀",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero.toNontrivial",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "mul_one",
   "Eq.symm",
   "Inv.inv",
   "GroupWithZero.toInv",
   "id"],
  "name": "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b : G₀}, a * b = 1 → a⁻¹ = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSMul",
   "AddSubgroup.nsmul",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Nat",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℕ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Eq",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "Real.cauchy_add",
   "AddSemigroup.toAdd",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Real.cauchy"],
  "name": "Real.commRing.proof_10",
  "constType": "∀ (a : ℝ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "EquivLike.toEmbeddingLike.proof_1",
   "EmbeddingLike.mk",
   "FunLike.mk",
   "EmbeddingLike",
   "EquivLike.toEmbeddingLike.proof_2"],
  "name": "EquivLike.toEmbeddingLike",
  "constType":
  "{E : Sort u_1} → {α : Sort u_3} → {β : Sort u_4} → [iE : EquivLike E α β] → EmbeddingLike E α β",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "Semiring.toOne",
   "zpowRec",
   "Rat.commRing",
   "Rat.instInvRat",
   "Rat",
   "CommRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.field.proof_3",
  "constType":
  "∀ (n : ℕ) (a : ℚ), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Infinite",
   "Finite",
   "Cardinal.partialOrder",
   "Cardinal.linearOrder",
   "LE.le",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.61",
   "Cardinal.instLECardinal",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.60",
   "Iff",
   "Cardinal.aleph0",
   "of_eq_true",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "Mathlib.Data.Finite.Defs._auxLemma.2",
   "LinearOrder.toPartialOrder",
   "Not",
   "Cardinal.mk",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Cardinal.mk_lt_aleph0_iff",
  "constType": "∀ {α : Type u}, Cardinal.mk α < Cardinal.aleph0 ↔ Finite α",
  "constCategory": "Theorem"},
 {"references": ["measurable_id", "Measurable", "MeasurableSpace"],
  "name": "measurable_id'",
  "constType":
  "∀ {α : Type u_1} {x : MeasurableSpace α}, Measurable fun a => a",
  "constCategory": "Theorem"},
 {"references": ["OrderedRing", "Ring"],
  "name": "OrderedRing.toRing",
  "constType": "{α : Type u} → [self : OrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HSub.hSub",
   "zero_sub",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "neg_neg",
   "SubtractionMonoid",
   "SubNegMonoid.sub_eq_add_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "congr",
   "Eq.symm",
   "congrArg",
   "neg_sub",
   "Eq.trans",
   "SubNegMonoid.zsmul_zero'",
   "id"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : SubtractionMonoid α], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHasEquiv",
   "HEq",
   "HAdd.hAdd",
   "CauSeq.LimZero",
   "Eq.refl",
   "sub_add_sub_cancel",
   "AddMonoid.toAddZeroClass",
   "Ring.toNonAssocRing",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "SubNegMonoid.toSub",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Eq.mpr",
   "Ring",
   "CauSeq.ring",
   "AddCommGroup.toAddGroup",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.mul_limZero_right",
   "CauSeq.instMulCauSeq",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "instHAdd",
   "sub_mul",
   "CauSeq.instSubCauSeq",
   "eq_of_heq",
   "HSub.hSub",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "CauSeq",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CauSeq.instAddCauSeq",
   "CauSeq.mul_limZero_left",
   "AddGroup.toSubNegMonoid",
   "CauSeq.equiv",
   "CauSeq.addGroup",
   "instHMul",
   "mul_sub",
   "Eq.ndrec",
   "HEq.refl",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.add_limZero",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "Eq.casesOn",
   "HasEquiv.Equiv"],
  "name": "CauSeq.mul_equiv_mul",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrderedField α] [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {f1 f2 g1 g2 : CauSeq β abv}, f1 ≈ f2 → g1 ≈ g2 → f1 * g1 ≈ f2 * g2",
  "constCategory": "Theorem"},
 {"references": ["OrderTop", "LE", "BoundedOrder"],
  "name": "BoundedOrder.toOrderTop",
  "constType":
  "{α : Type u} → [inst : LE α] → [self : BoundedOrder α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "one_nsmul",
   "OfNat.ofNat",
   "instHSMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "succ_nsmul",
   "Eq",
   "AddMonoid.toNatSMul",
   "Eq.mpr",
   "Eq.ndrec",
   "HSMul.hSMul",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "two_nsmul",
  "constType": "∀ {M : Type u} [inst : AddMonoid M] (a : M), 2 • a = a + a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NormedCommRing",
   "NormedCommRing.toNormedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : NormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mul_smul",
  "constType":
  "∀ {α : Type u_10} {β : Type u_11} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), (x * y) • b = x • y • b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module",
   "DistribMulAction",
   "AddCommMonoid"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} →\n  {M : Type v} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [self : Module R M] → DistribMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Prod.snd",
   "Set.univ_prod",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Prod",
   "Set.univ",
   "Eq.symm",
   "Eq"],
  "name": "PFR.Mathlib.Probability.Independence.Basic._auxLemma.10",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {t : Set β}, Prod.snd ⁻¹' t = Set.univ ×ˢ t",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommGroup",
   "inferInstance",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Real",
   "Real.strictOrderedRing"],
  "name": "Real.orderedAddCommGroup",
  "constType": "OrderedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "instHMul",
   "Finset.instSProd",
   "SProd.sprod",
   "Finset",
   "HMul.hMul",
   "Finset.val",
   "Prod",
   "instMulNat",
   "Nat",
   "Eq",
   "Multiset.card_product"],
  "name": "Finset.card_product",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Finset α) (t : Finset β), Finset.card (s ×ˢ t) = Finset.card s * Finset.card t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subgroup.toGroup",
   "IsPGroup.of_injective",
   "Subgroup",
   "IsPGroup",
   "Group",
   "Subtype.coe_injective",
   "Nat",
   "SetLike.instMembership",
   "Subtype",
   "Subgroup.subtype",
   "Subgroup.instSetLikeSubgroup"],
  "name": "IsPGroup.to_subgroup",
  "constType":
  "∀ {p : ℕ} {G : Type u_1} [inst : Group G], IsPGroup p G → ∀ (H : Subgroup G), IsPGroup p ↥H",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "AbsoluteValue",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "Real.arcsin_zero",
   "Real.instAddMonoidReal",
   "Real.instSupReal",
   "Real.decidableLE",
   "Real.pi",
   "Preorder.toLE",
   "Eq",
   "ite",
   "Complex.abs_ofReal",
   "Semiring.toNonAssocSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "Eq.trans",
   "instHSub",
   "Complex.abs",
   "instHDiv",
   "zero_div",
   "Mathlib.Order.Basic._auxLemma.1",
   "DivisionSemiring.toGroupWithZero",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "instDecidableTrue",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Complex.im",
   "eq_true",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "Real.instAddGroupReal",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "Complex.instNegComplex",
   "Real",
   "zero_sub",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LinearOrderedField.toDiv",
   "True",
   "Abs.abs",
   "Real.instNegReal",
   "Real.instAddCommGroupReal",
   "AbsoluteValue.subadditiveHomClass",
   "Zero.toOfNat0",
   "zero_add",
   "Complex.instSemiringComplex",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Complex.ofReal'",
   "Real.arcsin",
   "Neg.toHasAbs",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "GroupWithZero.toMonoidWithZero",
   "ite_congr",
   "Complex.re",
   "Real.instZeroReal",
   "Real.instPreorderReal",
   "OrderedSemiring.toSemiring",
   "Complex",
   "Semifield.toDivisionSemiring",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.arg_ofReal_of_nonneg",
  "constType": "∀ {x : ℝ}, 0 ≤ x → Complex.arg ↑x = 0",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "False.rec",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Nat.instDvdNat",
   "Dvd.dvd",
   "decidable_of_iff'",
   "instDecidableAnd",
   "LE.le",
   "instLTNat",
   "And",
   "Nat.Prime",
   "instLENat",
   "instDecidableNot",
   "LT.lt",
   "Decidable",
   "Nat.decidable_dvd",
   "instOfNatNat",
   "Not",
   "Nat.prime_def_lt'",
   "Nat",
   "Nat.decLe",
   "Nat.decidableLoHi"],
  "name": "Nat.decidablePrime1",
  "constType": "(p : ℕ) → Decidable (Nat.Prime p)",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "StrictMonoOn.lt_iff_lt",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Set.univ",
   "StrictMono.strictMonoOn"],
  "name": "StrictMono.lt_iff_lt",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → ∀ {a b : α}, f a < f b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Set.addMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a : Set α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.zero_mul",
  "constType": "∀ (n : ℕ), 0 * n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["zsmulRec",
   "Zero",
   "Set.neg",
   "SMul",
   "Set.zero",
   "SMul.mk",
   "Set.add",
   "Set",
   "Add",
   "Int",
   "Neg"],
  "name": "Set.ZSMul",
  "constType":
  "{α : Type u_2} → [inst : Zero α] → [inst : Add α] → [inst : Neg α] → SMul ℤ (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CompleteLattice",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": ["Set", "HasSubset", "HasSubset.mk", "Set.instLESet", "LE.le"],
  "name": "Set.instHasSubsetSet",
  "constType": "{α : Type u_1} → HasSubset (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NatCast",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "NonAssocSemiring",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat"],
  "name": "NonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → NonAssocSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Rat.instPartialOrderRat",
   "inferInstance",
   "PartialOrder.toPreorder",
   "Rat",
   "Preorder"],
  "name": "Rat.instPreorderRat",
  "constType": "Preorder ℚ",
  "constCategory": "Definition"},
 {"references": ["Iff", "not_congr", "Not"],
  "name": "Iff.not",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasSubset",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Int.instSubInt",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.toIntCast",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Int.cast_add",
   "AddGroupWithOne.toAddGroup",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "AddMonoid.toAddSemigroup",
   "Int.cast_neg",
   "AddGroupWithOne",
   "Int.instNegInt",
   "Eq.trans",
   "instHSub",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "Int.instAddInt",
   "of_eq_true",
   "Int.cast",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Int"],
  "name": "Int.cast_sub",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m - n) = ↑m - ↑n",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Nontrivial"],
  "name": "DivisionRing.toNontrivial",
  "constType": "∀ {K : Type u} [self : DivisionRing K], Nontrivial K",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.val", "MeasurableSpace.comap", "MeasurableSpace", "Subtype"],
  "name": "Subtype.instMeasurableSpace",
  "constType":
  "{α : Type u_6} → {p : α → Prop} → [m : MeasurableSpace α] → MeasurableSpace (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Set.addMonoid.proof_1",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "HAdd.hAdd",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Set.addSemigroup",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b c : Set α), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "Monoid",
   "CommMonoid",
   "HMul.hMul",
   "Eq"],
  "name": "CommMonoid.mk",
  "constType":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "constCategory": "Other"},
 {"references": ["Quot", "Eq"],
  "name": "Quot.lift",
  "constType":
  "{α : Sort u} → {r : α → α → Prop} → {β : Sort v} → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → Quot r → β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Prod.snd",
   "Function.Bijective",
   "AddGroup",
   "Set.Elem",
   "Subtype.val",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "Prod",
   "Prod.fst",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.IsComplement",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Set G → Set G → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["One", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toOne",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "One.toOfNat1",
   "zero_lt_one",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "one_pos",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_right",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_9",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.le_total",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "MeasurableSpace.instLEMeasurableSpace",
   "Iff.intro",
   "Set.instHasSubsetSet",
   "Iff",
   "setOf",
   "MeasurableSpace.generateFrom_le",
   "Set",
   "MeasurableSet",
   "HasSubset.Subset",
   "MeasurableSpace.generateFrom",
   "LE.le",
   "MeasurableSpace",
   "MeasurableSpace.measurableSet_generateFrom",
   "Set.instMembershipSet"],
  "name": "MeasurableSpace.generateFrom_le_iff",
  "constType":
  "∀ {α : Type u_1} {s : Set (Set α)} (m : MeasurableSpace α),\n  MeasurableSpace.generateFrom s ≤ m ↔ s ⊆ {t | MeasurableSet t}",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "PartialOrder.toPreorder",
   "AbsoluteValue.add_le'",
   "Semiring",
   "ZeroHomClass",
   "AbsoluteValue",
   "Semiring.toMonoidWithZero",
   "SubadditiveHomClass.mk",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "AbsoluteValue.zeroHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "ZeroHomClass.toFunLike",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "SubadditiveHomClass",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.subadditiveHomClass",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Semiring R] → [inst_1 : OrderedSemiring S] → SubadditiveHomClass (AbsoluteValue R S) R S",
  "constCategory": "Definition"},
 {"references":
  ["Countable",
   "Function.Injective",
   "Exists.intro",
   "Nat",
   "Countable.mk",
   "Function.injective_id",
   "id"],
  "name": "instCountableNat",
  "constType": "Countable ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.mp", "Set.finite_coe_iff", "Set.Elem", "Set", "Finite", "Set.Finite"],
  "name": "Set.toFinite",
  "constType": "∀ {α : Type u} (s : Set α) [inst : Finite ↑s], Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Inf.inf",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubmonoid.mk",
   "And.intro",
   "And.casesOn",
   "AddSubmonoid.instInfAddSubmonoid",
   "AddSubsemigroup.carrier",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfAddSubgroup.match_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G) {x : G},\n  let src := H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid;\n  ∀\n    (motive :\n      x ∈ { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) }.toAddSubsemigroup.carrier →\n        Prop)\n    (x_1 :\n      x ∈ { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) }.toAddSubsemigroup.carrier),\n    (∀ (hx : x ∈ ↑H₁.toAddSubmonoid) (hx' : x ∈ ↑H₂.toAddSubmonoid),\n        motive (_ : x ∈ ↑H₁.toAddSubmonoid ∧ x ∈ ↑H₂.toAddSubmonoid)) →\n      motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "Exists",
   "instHasEquiv",
   "CauSeq.IsComplete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.IsComplete.isComplete",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.complete",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Or",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Classical.em",
   "Classical.propDecidable.match_1",
   "Nonempty"],
  "name": "Classical.propDecidable.proof_1",
  "constType": "∀ (a : Prop), Nonempty (Decidable a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "ZeroHomClass.mk",
   "ZeroHom.zeroHomClass.proof_1",
   "ZeroHom.toFun",
   "ZeroHomClass",
   "FunLike.mk",
   "ZeroHom",
   "ZeroHom.map_zero'"],
  "name": "ZeroHom.zeroHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHomClass (ZeroHom M N) M N",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "CompleteLattice.sSup_le",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_13",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)) (a : AddSubmonoid M), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Semifield.toCommSemiring",
   "Real",
   "Real.instLEReal",
   "Field.toSemifield",
   "Ring.toSemiring",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Norm.norm",
   "NormedAlgebra",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.mk",
  "constType":
  "{𝕜 : Type u_5} →\n  {𝕜' : Type u_6} →\n    [inst : NormedField 𝕜] →\n      [inst_1 : SeminormedRing 𝕜'] →\n        [toAlgebra : Algebra 𝕜 𝕜'] → (∀ (r : 𝕜) (x : 𝕜'), ‖r • x‖ ≤ ‖r‖ * ‖x‖) → NormedAlgebra 𝕜 𝕜'",
  "constCategory": "Other"},
 {"references": ["Prod.exists", "Exists", "Prod.mk", "propext", "Prod", "Eq"],
  "name": "Mathlib.Data.Prod.Basic._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) = ∃ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Lattice.toLinearOrder.proof_4",
   "Lattice.toLinearOrder.proof_2",
   "Min.mk",
   "Lattice.toLinearOrder.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "IsTotal",
   "LinearOrder.mk",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Lattice.toLinearOrder.proof_3",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder",
  "constType":
  "(α : Type u) →\n  [inst : Lattice α] →\n    [inst_1 : DecidableEq α] →\n      [inst_2 : DecidableRel fun x x_1 => x ≤ x_1] →\n        [inst_3 : DecidableRel fun x x_1 => x < x_1] → [inst : IsTotal α fun x x_1 => x ≤ x_1] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Nonempty.some",
  "constType": "{α : Sort u_2} → Nonempty α → α",
  "constCategory": "Definition"},
 {"references":
  ["IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Subgroup.instInfSetSubgroup",
   "IsGLB.of_image",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "SetLike.instPartialOrder",
   "isGLB_biInf",
   "SetLike.coe_subset_coe",
   "Subgroup",
   "Group",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Subgroup.instSetLikeSubgroup",
   "SetLike.coe"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (_s : Set (Subgroup G)), IsGLB _s (sInf _s)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.add_left_neg",
  "constType": "∀ {A : Type u} [self : AddGroup A] (a : A), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Multiset.map.proof_1",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.map",
   "Multiset.ofList"],
  "name": "Multiset.map",
  "constType":
  "{α : Type u_1} → {β : Type v} → (α → β) → Multiset α → Multiset β",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "le_max_left",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), a ≤ |a|",
  "constCategory": "Theorem"},
 {"references": ["Add", "MeasurableSpace"],
  "name": "MeasurableAdd",
  "constType":
  "(M : Type u_2) → [inst : MeasurableSpace M] → [inst : Add M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Invertible.invOf",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "mul_one",
   "One.toOfNat1",
   "invOf_eq_right_inv",
   "Monoid.toMulOneClass",
   "Invertible",
   "Eq"],
  "name": "invOf_one'",
  "constType": "∀ {α : Type u} [inst : Monoid α] {x : Invertible 1}, ⅟1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "Set.mem_image2_of_mem",
   "Set",
   "HSub.hSub",
   "Set.sub",
   "Sub",
   "Set.instMembershipSet"],
  "name": "Set.sub_mem_sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s t : Set α} {a b : α}, a ∈ s → b ∈ t → a - b ∈ s - t",
  "constCategory": "Theorem"},
 {"references": ["Bot.bot", "OrderBot.toBot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.bot_le",
  "constType":
  "∀ {α : Type u} [inst : LE α] [self : OrderBot α] (a : α), ⊥ ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.empty_subset",
   "Finset.instEmptyCollectionFinset",
   "Finset.mem_powerset",
   "EmptyCollection.emptyCollection",
   "Finset.powerset",
   "Finset",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Finset.instHasSubsetFinset",
   "Iff.mpr"],
  "name": "Finset.empty_mem_powerset",
  "constType": "∀ {α : Type u_1} (s : Finset α), ∅ ∈ Finset.powerset s",
  "constCategory": "Theorem"},
 {"references": ["cast", "HEq", "letFun", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam"],
  "name": "ZeroHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Zero M] → [inst : Zero N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["refPackage",
   "instHAdd",
   "refPackage.η",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instMulReal",
   "Eq.refl",
   "MeasureTheory.MeasureSpace.volume",
   "refPackage.X₀₁",
   "Eq",
   "MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "instHMul",
   "refPackage.X₀₂",
   "rdist",
   "MeasureTheory.MeasureSpace",
   "HMul.hMul",
   "tau",
   "AddCommGroup",
   "MeasurableSpace"],
  "name": "_private.PFR.EntropyPFR.0.tau._eq_1",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {G : Type uG} [inst_2 : AddCommGroup G] [inst_3 : MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω₁ : Type u_7}\n  {Ω₂ : Type u_8} [inst_4 : MeasurableSpace Ω₁] [inst_5 : MeasurableSpace Ω₂] (X₁ : Ω₁ → G) (X₂ : Ω₂ → G)\n  (μ₁ : MeasureTheory.Measure Ω₁) (μ₂ : MeasureTheory.Measure Ω₂),\n  τ[X₁ ; μ₁ # X₂ ; μ₂ | p] =\n    d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; MeasureTheory.volume # X₁ ; μ₁] +\n      p.η * d[p.X₀₂ ; MeasureTheory.volume # X₂ ; μ₂]",
  "constCategory": "Theorem"},
 {"references": ["MetricSpace", "NormedField"],
  "name": "NormedField.toMetricSpace",
  "constType": "{α : Type u_5} → [self : NormedField α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references": ["Inf", "SemilatticeInf"],
  "name": "SemilatticeInf.toInf",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → Inf α",
  "constCategory": "Definition"},
 {"references": ["Set.image2", "instHAdd", "HAdd.hAdd", "Set", "Add", "Add.mk"],
  "name": "Set.add",
  "constType": "{α : Type u_2} → [inst : Add α] → Add (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "Mathlib.Meta.NormNum.invertibleOfMul",
   "HMul.hMul",
   "instMulNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Mathlib.Meta.NormNum.invertibleOfMul'.proof_1",
   "Invertible",
   "Eq",
   "Semiring.toNatCast"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul'",
  "constType":
  "{α : Type u_1} → [inst : Semiring α] → {a k b : ℕ} → [inst_1 : Invertible ↑a] → a = k * b → Invertible ↑b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : SeminormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["LE", "OrderBot", "BoundedOrder"],
  "name": "BoundedOrder.toOrderBot",
  "constType":
  "{α : Type u} → [inst : LE α] → [self : BoundedOrder α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.add_left_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Monoid.toOne",
   "Mathlib.Algebra.GroupWithZero.NeZero._auxLemma.1",
   "MulZeroClass.mul_zero",
   "One.toOfNat1",
   "NeZero.one",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "False.elim",
   "GroupWithZero.toNontrivial",
   "MonoidWithZero.toMonoid",
   "Eq.mp",
   "GroupWithZero",
   "letFun",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "Eq.trans",
   "mul_inv_cancel",
   "congrFun",
   "Inv.inv",
   "GroupWithZero.toInv"],
  "name": "inv_ne_zero",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a⁻¹ ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonAssocRing",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.one_mul",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonAssocRing.toOne",
   "NonAssocRing.mul_one",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonAssocRing.natCast_succ",
   "SubNegMonoid.toAddMonoid",
   "NonAssocRing.toNatCast",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonAssocRing.natCast_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.toNonAssocSemiring",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing",
   "instHMul",
   "NormedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedRing.toRing",
   "Eq"],
  "name": "NormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toNormedRing : NormedRing α] → (∀ (x y : α), x * y = y * x) → NormedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "PosMulStrictMono",
   "Preorder",
   "Mul",
   "Subtype.mk",
   "Subtype",
   "CovariantClass.elim"],
  "name": "mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],\n  b < c → 0 < a → a * b < a * c",
  "constCategory": "Theorem"},
 {"references": ["Cardinal", "Cardinal.isEquivalent", "Quotient.mk'"],
  "name": "Cardinal.mk",
  "constType": "Type u → Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Set.addMonoid.proof_1",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "Eq.refl",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq",
   "Set.addSemigroup",
   "zsmulRec",
   "AddZeroClass.toZero",
   "SubtractionMonoid.toSubNegMonoid",
   "InvolutiveNeg.toNeg",
   "SubNegMonoid.toAddMonoid",
   "Nat",
   "Nat.succ",
   "Set.addZeroClass"],
  "name": "Set.subtractionMonoid.proof_8",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (n : ℕ) (a : Set α),\n  zsmulRec (Int.ofNat (Nat.succ n)) a = zsmulRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_two",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "sq",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["NoZeroDivisors",
   "IsDomain.toIsCancelMulZero",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelMulZero.toIsRightCancelMulZero",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "IsRightCancelMulZero.to_noZeroDivisors",
   "Ring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MonoidWithZero.toZero",
   "Ring.toSemiring",
   "Ring.toNonAssocRing"],
  "name": "IsDomain.to_noZeroDivisors",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] [inst_1 : IsDomain α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "Semiring.npow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_12",
  "constType": "∀ (n x : ℕ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "OrderedRing",
   "StrictOrderedCommRing.toOrderedCommRing",
   "OrderedCommRing.toOrderedRing"],
  "name": "Real.orderedRing",
  "constType": "OrderedRing ℝ",
  "constCategory": "Definition"},
 {"references": ["Preorder"],
  "name": "OrderHom",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : Preorder α] → [inst : Preorder β] → Type (max u_6 u_7)",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none", "String", "Lean.Syntax.atom", "Lean.Syntax"],
  "name": "Lean.mkAtom",
  "constType": "String → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.mul.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((x : ℕ) → motive x 0) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r", "Setoid", "Quotient", "Quot.inductionOn", "Quotient.mk"],
  "name": "Quotient.inductionOn",
  "constType":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s), (∀ (a : α), motive ⟦a⟧) → motive q",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "RatCast"],
  "name": "LinearOrderedField.toRatCast",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → RatCast α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Prod.snd",
   "HSub.hSub",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "MeasurableSub₂.mk",
  "constType":
  "∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : Sub G], (Measurable fun p => p.1 - p.2) → MeasurableSub₂ G",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "Semifield.toCommSemiring",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Inf.inf",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Preorder.le_trans",
   "Sup.mk",
   "implies_congr",
   "Preorder.toLE",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Inf.mk",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.16",
   "Preorder.toLT",
   "Rat.instNegRat",
   "CauSeq.le_inf",
   "Real.ind_mk",
   "Eq.symm",
   "SemilatticeSup.toPartialOrder",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Real.mk_le",
   "Preorder.le_refl",
   "Rat",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "CauSeq",
   "CauSeq.instInfCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.15",
   "Preorder.mk",
   "CauSeq.le_sup_left",
   "Eq.ndrec",
   "CauSeq.sup_le",
   "CauSeq.le_sup_right",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.mk_sup",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le",
   "congrFun"],
  "name": "Real.instDistribLatticeReal.proof_9",
  "constType": "∀ (a b c : ℝ), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "OfNat.ofNat", "Array.mkEmpty", "instOfNatNat", "Nat"],
  "name": "Array.empty",
  "constType": "{α : Type u} → Array α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Nonempty.intro",
   "Fintype",
   "Set.Elem",
   "Set.fintypeImage",
   "Classical.propDecidable",
   "Set",
   "Finite",
   "Eq.refl",
   "Set.image",
   "Finite.of_fintype",
   "Nonempty",
   "nonempty_fintype",
   "Eq",
   "Nonempty.casesOn"],
  "name": "Finite.Set.finite_image",
  "constType":
  "∀ {α : Type u} {β : Type v} (s : Set α) (f : α → β) [inst : Finite ↑s], Finite ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set.univ",
   "MeasureTheory.IsFiniteMeasure",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace"],
  "name": "MeasureTheory.IsFiniteMeasure.mk",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α},\n  ↑↑μ Set.univ < ⊤ → MeasureTheory.IsFiniteMeasure μ",
  "constCategory": "Other"},
 {"references":
  ["Subsemigroup.carrier",
   "SetLike",
   "MulOneClass.toMul",
   "SetLike.mk",
   "MulOneClass",
   "Submonoid.toSubsemigroup",
   "Submonoid",
   "Submonoid.instSetLikeSubmonoid.proof_1"],
  "name": "Submonoid.instSetLikeSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → SetLike (Submonoid M) M",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "One", "InvOneClass", "One.toOfNat1", "Inv", "Inv.inv", "Eq"],
  "name": "InvOneClass.mk",
  "constType":
  "{G : Type u_2} → [toOne : One G] → [toInv : Inv G] → 1⁻¹ = 1 → InvOneClass G",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "instHDiv",
   "MeasureTheory.Measure.map",
   "Prod.snd",
   "Real.natCast",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "ProbabilityTheory.entropy",
   "Prod.fst",
   "MeasureTheory.Measure.prod",
   "rfl",
   "AddGroup.toSubNegMonoid",
   "LinearOrderedField.toDiv",
   "Eq",
   "Prod.instMeasurableSpace",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "rdist",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Prod",
   "AddCommGroup.toAddGroup",
   "HDiv.hDiv",
   "Nat",
   "AddCommGroup",
   "instOfNat",
   "MeasurableSpace"],
  "name": "rdist_def",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {G : Type u_5} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  [hG : MeasurableSpace G] [inst : AddCommGroup G] (X : Ω → G) (Y : Ω' → G) (μ : MeasureTheory.Measure Ω)\n  (μ' : MeasureTheory.Measure Ω'),\n  d[X ; μ # Y ; μ'] =\n    H[fun x => x.1 - x.2 ;\n          MeasureTheory.Measure.prod (MeasureTheory.Measure.map X μ) (MeasureTheory.Measure.map Y μ')] -\n        H[X ; μ] / 2 -\n      H[Y ; μ'] / 2",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat", "Int.negOfNat", "Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.neg",
  "constType": "ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.mk",
   "CompleteLinearOrder.toCompleteLattice",
   "CompletelyDistribLattice",
   "CompleteLinearOrder",
   "CompleteLinearOrder.toCompletelyDistribLattice.proof_1"],
  "name": "CompleteLinearOrder.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [inst : CompleteLinearOrder α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "∀ {M : Type u_1} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Prod.snd",
   "Std.Logic._auxLemma.39",
   "Finset.instSProd",
   "Finset.instMembershipFinset",
   "Prod.fst",
   "True",
   "iff_self",
   "Eq",
   "Mathlib.Data.Finset.NAry._auxLemma.1",
   "And",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Function.uncurry",
   "Prod.mk",
   "Finset.image",
   "SProd.sprod",
   "Finset.image₂",
   "Finset",
   "congr",
   "Prod",
   "Mathlib.Data.Finset.Prod._auxLemma.1",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Mathlib.Data.Prod.Basic._auxLemma.2",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Finset.mem_image₂",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : α → β → γ} {s : Finset α} {t : Finset β}\n  {c : γ}, c ∈ Finset.image₂ f s t ↔ ∃ a b, a ∈ s ∧ b ∈ t ∧ f a b = c",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "Algebra.commutes'",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Algebra.id"],
  "name": "NormedAlgebra.id.proof_1",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (r x : 𝕜), Algebra.toRingHom r * x = x * Algebra.toRingHom r",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references": ["CanonicallyLinearOrderedSemifield", "Nontrivial"],
  "name": "CanonicallyLinearOrderedSemifield.toNontrivial",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyLinearOrderedSemifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Field.toInv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Field.mul_inv_cancel",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSet.compl_iff",
   "propext",
   "Set",
   "MeasurableSet",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "MeasurableSpace",
   "Eq"],
  "name": "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {s : Set α} {m : MeasurableSpace α}, MeasurableSet sᶜ = MeasurableSet s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.toOne",
   "zpowRec",
   "OfNat.ofNat",
   "Rat.commRing",
   "instOfNatInt",
   "Rat.instInvRat",
   "Rat",
   "CommRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.field.proof_2",
  "constType": "∀ (a : ℚ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "SubNegMonoid.toNeg",
   "Set",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "SetLike.instMembership",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "Eq.mpr",
   "AddGroup",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.comap",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "Set.preimage",
   "AddHomClass.toFunLike",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.add_mem'",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.neg_mem",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoidHom.map_neg",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "AddMonoidHom",
   "SetLike.coe"],
  "name": "AddSubgroup.comap.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup N) {a : G},\n  a ∈\n      {\n            toAddSubsemigroup :=\n              { carrier := ⇑f ⁻¹' ↑H,\n                add_mem' :=\n                  (_ :\n                    ∀ {a b : G},\n                      a ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                        b ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                          a + b ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier) },\n            zero_mem' :=\n              (_ : 0 ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier) }.toAddSubsemigroup.carrier →\n    f (-a) ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace"],
  "name": "MeasureTheory.MeasureSpace.volume",
  "constType":
  "{α : Type u_6} → [self : MeasureTheory.MeasureSpace α] → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.one_mul",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.mk",
   "NonUnitalSeminormedCommRing.mul_comm",
   "NonUnitalSeminormedRing.toNonUnitalRing"],
  "name": "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
  "constType":
  "{α : Type u_1} → [β : NonUnitalSeminormedCommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.le_trans",
   "Real.instSupReal",
   "Sup.mk",
   "Preorder.toLE",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.mpr",
   "Preorder.toLT",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Eq.symm",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Real.mk_le",
   "Preorder.le_refl",
   "Rat",
   "CauSeq",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Preorder.mk",
   "Eq.ndrec",
   "CauSeq.le_sup_right",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.mk_sup",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le"],
  "name": "Real.instDistribLatticeReal.proof_5",
  "constType": "∀ (a b : ℝ), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toOrderedRing.proof_1",
   "OrderedRing",
   "OrderedRing.mk",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.zero_le_one"],
  "name": "StrictOrderedRing.toOrderedRing",
  "constType": "{α : Type u} → [inst : StrictOrderedRing α] → OrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "CommMagma.toMul",
   "CommRing",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "mul_comm",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "id"],
  "name": "CancelDenoms.mul_subst",
  "constType":
  "∀ {α : Type u_1} [inst : CommRing α] {n1 n2 k e1 e2 t1 t2 : α},\n  n1 * e1 = t1 → n2 * e2 = t2 → n1 * n2 = k → k * (e1 * e2) = t1 * t2",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure.restrictₗ",
   "Set",
   "LinearMap.instFunLike",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "RingHom.id",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.restrict.proof_1",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.Measure.instModule",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "MeasurableSpace",
   "LinearMap",
   "Semiring.toModule"],
  "name": "MeasureTheory.Measure.restrict",
  "constType":
  "{α : Type u_2} → {_m0 : MeasurableSpace α} → MeasureTheory.Measure α → Set α → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instNNRealSemiring",
   "NNReal",
   "AddCommMonoidWithOne",
   "WithTop.addCommMonoidWithOne"],
  "name": "instENNRealAddCommMonoidWithOne",
  "constType": "AddCommMonoidWithOne ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "instHMul",
   "instSubNat",
   "Prod.mk",
   "Nat.sqrt",
   "Nat.decLt",
   "LT.lt",
   "HSub.hSub",
   "HMul.hMul",
   "Prod",
   "instMulNat",
   "Nat",
   "instLTNat",
   "ite"],
  "name": "Nat.unpair",
  "constType": "ℕ → ℕ × ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike",
   "Function.Injective",
   "Set",
   "SetLike.coe_injective'",
   "SetLike.coe",
   "Eq"],
  "name": "SetLike.coe_injective",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B], Function.Injective SetLike.coe",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Unit",
   "Unit.unit",
   "ProbabilityTheory.kernel.IndepFun",
   "MeasureTheory.Measure.dirac",
   "autoParam",
   "MeasurableSpace",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.514"],
  "name": "ProbabilityTheory.IndepFun",
  "constType":
  "{Ω : Type u_1} →\n  {β : Type u_6} →\n    {γ : Type u_7} →\n      [inst : MeasurableSpace Ω] →\n        [inst_1 : MeasurableSpace β] →\n          [inst_2 : MeasurableSpace γ] → (Ω → β) → (Ω → γ) → autoParam (MeasureTheory.Measure Ω) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "Exists",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Data.Real.ENNReal._auxLemma.18",
   "CanonicallyOrderedCommSemiring.toMul",
   "instENNRealAddCommMonoidWithOne",
   "CanLift.prf",
   "instNNRealSemiring",
   "Exists.casesOn",
   "CanonicallyOrderedCommSemiring.toOne",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "ENNReal.canLift",
   "Eq.mpr",
   "Mathlib.Data.Real.ENNReal._auxLemma.68",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.symm",
   "mul_inv_cancel",
   "Eq.trans",
   "NNReal",
   "Mathlib.Data.Real.ENNReal._auxLemma.27",
   "Nat.cast_one",
   "CanonicallyLinearOrderedSemifield.toInv",
   "id",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "DivisionSemiring.toGroupWithZero",
   "Top.top",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "ENNReal.instInvENNReal",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ENNReal.instCompleteLinearOrderENNReal",
   "instHMul",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "Eq.mp",
   "CompleteLattice.toTop",
   "HMul.hMul",
   "CanonicallyLinearOrderedSemifield.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Not",
   "instNNRealCanonicallyOrderedCommSemiring",
   "congrArg",
   "congrFun",
   "ENNReal.ofNNReal",
   "Inv.inv"],
  "name": "ENNReal.mul_inv_cancel",
  "constType": "∀ {a : ENNReal}, a ≠ 0 → a ≠ ⊤ → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "neg_neg",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "neg_sub",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), -(a - b) = b - a",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Finite.casesOn",
   "Finite.intro",
   "Finite",
   "Eq.refl",
   "Nat",
   "Equiv.trans",
   "Fin",
   "Equiv.symm",
   "Eq"],
  "name": "Finite.of_equiv",
  "constType":
  "∀ {β : Sort u_2} (α : Sort u_3) [h : Finite α], α ≃ β → Finite β",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Multiplicative",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective.countable",
   "Countable",
   "Subtype.val_injective",
   "Subtype.val",
   "Subtype"],
  "name": "Subtype.countable",
  "constType":
  "∀ {α : Sort u} [inst : Countable α] {p : α → Prop}, Countable { x // p x }",
  "constCategory": "Definition"},
 {"references": ["Monotone", "OrderHom", "OrderHom.toFun", "Preorder"],
  "name": "OrderHom.monotone'",
  "constType":
  "∀ {α : Type u_6} {β : Type u_7} [inst : Preorder α] [inst_1 : Preorder β] (self : α →o β), Monotone self.toFun",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b _c : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → _b ≤ _c ∧ ¬_c ≤ _b → Prop)\n  (x : _a ≤ _b ∧ ¬_b ≤ _a) (x_1 : _b ≤ _c ∧ ¬_c ≤ _b),\n  (∀ (hab : _a ≤ _b) (_hba : ¬_b ≤ _a) (hbc : _b ≤ _c) (hcb : ¬_c ≤ _b),\n      motive (_ : _a ≤ _b ∧ ¬_b ≤ _a) (_ : _b ≤ _c ∧ ¬_c ≤ _b)) →\n    motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.mul_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.casesOn",
   "instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "Eq.ndrec",
   "instOfNatInt",
   "Int.negSucc",
   "Eq.refl",
   "HMul.hMul",
   "Nat",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "Int.mul_zero",
  "constType": "∀ (a : ℤ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "OfNat.ofNat",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulZeroOneClass.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Zero.toOfNat0",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass.toMonoidWithZeroHomClass",
   "map_zero",
   "MonoidWithZeroHomClass.toZeroHomClass"],
  "name": "RingHom.map_zero",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nontrivial.mk",
   "Exists.intro",
   "instDecidableEqNat",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "Bool.true",
   "AddMonoid.toZero",
   "Eq.rec",
   "instOfNatNat",
   "Nontrivial",
   "Bool",
   "Nat",
   "Nat.cast_one"],
  "name": "instNontrivial",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst : CharZero α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLinearOrder.decidableLT",
   "ConditionallyCompleteLattice.le_csSup",
   "ConditionallyCompleteLattice.toLattice",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.proof_1",
   "CompleteLinearOrder",
   "CompleteLattice.toBot",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.proof_3",
   "ConditionallyCompleteLattice",
   "ConditionallyCompleteLattice.csSup_le",
   "CompleteLinearOrder.decidableEq",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.proof_4",
   "ConditionallyCompleteLattice.toInfSet",
   "ConditionallyCompleteLattice.mk",
   "ConditionallyCompleteLattice.le_csInf",
   "CompleteLinearOrder.decidableLE",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CompleteLinearOrder.le_total",
   "ConditionallyCompleteLattice.toSupSet",
   "CompleteLinearOrder.toCompleteLattice",
   "ConditionallyCompleteLattice.csInf_le",
   "ConditionallyCompleteLinearOrderBot",
   "ConditionallyCompleteLinearOrderBot.mk",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot.proof_2",
   "ConditionallyCompleteLinearOrder.mk"],
  "name": "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
  "constType":
  "{α : Type u_5} → [h : CompleteLinearOrder α] → ConditionallyCompleteLinearOrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "CommSemiring",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.instCommSemiringInt",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "OfNat.ofNat",
   "Subtype.val",
   "IsCauSeq",
   "One.toOfNat1",
   "Neg.neg",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "instHMul",
   "LinearOrderedField",
   "Ring.toNeg",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "CauSeq.instMulCauSeq",
   "CauSeq.instNegCauSeq.proof_1",
   "Neg",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Neg.mk",
   "CauSeq.ofEq"],
  "name": "CauSeq.instNegCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Neg (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "PartialOrder.toPreorder",
   "Set.mem_singleton",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "And.left",
   "Insert.insert",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "Set.instSingletonSet",
   "upperBounds",
   "lowerBounds",
   "Set.mem_insert_of_mem",
   "Singleton.singleton",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf.proof_5",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α], (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a b : α), sInf {a, b} ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instLENat",
   "GE.ge",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.AtLeastTwo.mk",
  "constType": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "NonUnitalSeminormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "NonUnitalSeminormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalSeminormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsScalarTower.right",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MulZeroClass.toSMulWithZero",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "Algebra.toSMul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "SMulZeroClass.toSMul"],
  "name": "ProbabilityTheory.measureEntropy.proof_1",
  "constType": "IsScalarTower ENNReal ENNReal ENNReal",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "Subtype.val",
   "Set",
   "HSub.hSub",
   "Sub",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Sub.mk",
   "Set.instMembershipSet",
   "AddSubgroup.sub.proof_1",
   "SubNegMonoid.toSub",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.sub",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Sub ↥H",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "Max"],
  "name": "LinearOrderedRing.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Max α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semifield.toCommSemiring",
   "Real",
   "DenselyNormedField.toNormedField",
   "NonUnitalRingHomClass.toMulHomClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "Eq.trans",
   "Real.denselyNormedField",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "Neg.neg",
   "RingHom.map_zero",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroOneClass.toZero",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.isROrC.proof_10",
  "constType": "(starRingEnd ℝ) 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "instHAdd",
   "HAdd.hAdd",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Add",
   "MeasurableAdd₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "MeasurableAdd₂.mk",
  "constType":
  "∀ {M : Type u_2} [inst : MeasurableSpace M] [inst_1 : Add M], (Measurable fun p => p.1 + p.2) → MeasurableAdd₂ M",
  "constCategory": "Other"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat.pow", "Nat", "NatPow.mk"],
  "name": "instNatPowNat",
  "constType": "NatPow ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "pos_iff_ne_zero",
   "Nat.canonicallyOrderedCommSemiring",
   "Nat.add_one_le_iff",
   "LE.le",
   "instLTNat",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instLENat",
   "Iff",
   "LT.lt",
   "Iff.trans",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.one_le_iff_ne_zero",
  "constType": "∀ {n : ℕ}, 1 ≤ n ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Multiplicative",
   "Multiplicative.toAdd",
   "Neg.neg",
   "Additive.ofMul",
   "FunLike.coe",
   "Inv",
   "Inv.mk",
   "Neg",
   "Equiv.instFunLikeEquiv",
   "Additive"],
  "name": "Multiplicative.inv",
  "constType": "{α : Type u} → [inst : Neg α] → Inv (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "sub_self",
   "DivisionRing.toRing",
   "AddGroup.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "AddGroupWithOne.toAddGroup",
   "True",
   "MulZeroClass.toMul",
   "mul_div_cancel",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "Field",
   "Ring.toSub",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Ne",
   "instHDiv",
   "False",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "HSub.hSub",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "congr",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "and_self",
   "congrFun"],
  "name": "Field.toEuclideanDomain.proof_4",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b ≠ 0 → a - a * b / b = 0 ∧ ¬b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "DivisionRing.toDivisionSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CauSeq.LimZero",
   "Semiring.toMonoidWithZero",
   "CauSeq.instZeroCauSeq",
   "Eq.refl",
   "dite",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "CauSeq.zero_limZero",
   "LinearOrderedField",
   "Eq.mpr",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.instInvCauchyToRing",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "DivisionRing",
   "congr_arg",
   "Classical.propDecidable",
   "dif_pos",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.Completion.instZeroCauchy",
   "DivisionSemiring.toSemiring",
   "CauSeq.inv",
   "Eq.ndrec",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "Not",
   "CauSeq.Completion.mk",
   "MonoidWithZero.toZero",
   "Inv.inv"],
  "name": "CauSeq.Completion.inv_zero",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], 0⁻¹ = 0",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mul_inv_rev",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Real.exp_lt_exp",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Eq.refl",
   "Real.exp",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.exp_log",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Real.instPreorderReal",
   "lt_trans",
   "Eq.symm",
   "id"],
  "name": "Real.log_lt_log",
  "constType": "∀ {x y : ℝ}, 0 < x → x < y → Real.log x < Real.log y",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Unit",
   "PUnit",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat.factorial.match_1",
   "Nat",
   "Nat.succ"],
  "name": "Nat.factorial",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoid.mul_comm",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "CommGroupWithZero.toDivisionCommMonoid.proof_1",
  "constType":
  "∀ {G₀ : Type u_1} [inst : CommGroupWithZero G₀] (a b : G₀), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "RightDistribClass.right_distrib",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "StrictOrderedCommSemiring"],
  "name": "StrictOrderedCommSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : StrictOrderedCommSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Monotone",
   "LinearOrder.toPartialOrder",
   "LT.lt.not_le",
   "Preorder",
   "lt_of_not_ge",
   "Preorder.toLE"],
  "name": "Monotone.reflect_lt",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a b : α}, f a < f b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["List.Perm.length_eq",
   "ZeroHom.mk",
   "Multiset.card.proof_2",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "List.length",
   "Quot.liftOn",
   "Multiset.card.proof_1",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card",
  "constType": "{α : Type u_1} → Multiset α →+ ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero_lt_of_ne_zero",
   "nonzero_of_invertible",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Semiring",
   "MulZeroOneClass.toZero",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "instLTNat",
   "Invertible",
   "Nat.cast_zero",
   "Semiring.toNatCast",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Eq.rec",
   "instOfNatNat",
   "Nontrivial",
   "Nat",
   "Eq.symm"],
  "name": "pos_of_invertible_cast",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] [inst_1 : Nontrivial α] (n : ℕ) [inst : Invertible ↑n], 0 < n",
  "constCategory": "Theorem"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.10",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "instOfNatInt",
   "Int.zero_ne_one",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Int"],
  "name": "Int.instNontrivialInt",
  "constType": "Nontrivial ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "dite",
   "Real.rpow_def_of_nonneg",
   "Preorder.toLE",
   "Real.instOneReal",
   "Eq",
   "ite",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "instHPow",
   "Real.instPowReal",
   "le_of_lt",
   "if_neg",
   "id",
   "HPow.hPow",
   "OrderedSemiring.zeroLEOneClass",
   "Real.exp_pos",
   "One.toOfNat1",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.6",
   "Real.orderedSemiring",
   "Real.exp",
   "LE.le",
   "Real.instZeroReal",
   "instHMul",
   "eq_true",
   "Real.log",
   "if_pos",
   "Eq.ndrec",
   "of_eq_true",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.7",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Not",
   "congrArg"],
  "name": "Real.rpow_nonneg_of_nonneg",
  "constType": "∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), 0 ≤ x ^ y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "MeasurableSet",
   "MeasurableSpace.mkOfClosure.proof_1",
   "MeasurableSpace.generateFrom",
   "MeasurableSpace.copy",
   "MeasurableSpace",
   "Set.instMembershipSet",
   "Eq"],
  "name": "MeasurableSpace.mkOfClosure",
  "constType":
  "{α : Type u_1} → (g : Set (Set α)) → {t | MeasurableSet t} = g → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references": ["Abs"],
  "name": "Abs.mk",
  "constType": "{α : Type u_1} → (α → α) → Abs α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid.mk",
   "AddSubmonoid.rec",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubmonoid.casesOn",
  "constType":
  "{M : Type u_4} →\n  [inst : AddZeroClass M] →\n    {motive : AddSubmonoid M → Sort u} →\n      (t : AddSubmonoid M) →\n        ((toAddSubsemigroup : AddSubsemigroup M) →\n            (zero_mem' : 0 ∈ toAddSubsemigroup.carrier) →\n              motive { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "LeftDistribClass",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "LeftDistribClass.mk",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R], (∀ (a b c : R), a * (b + c) = a * b + a * c) → LeftDistribClass R",
  "constCategory": "Other"},
 {"references":
  ["Subtype.property",
   "DecidablePred",
   "And",
   "Exists",
   "And.right",
   "Subtype.val",
   "LT.lt",
   "Nat.find",
   "Not",
   "Nat.findX",
   "Nat",
   "instLTNat"],
  "name": "Nat.find_min",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, m < Nat.find H → ¬p m",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "Nat.right_distrib",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "id",
   "Add.mk"],
  "name": "Nat.commSemiring.proof_1",
  "constType":
  "∀ (x x_1 : ℕ), (fun m n => m * n) (x + 1) x_1 = x_1 + (fun m n => m * n) x x_1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderIso",
   "RelIso.instRelHomClassRelIso",
   "RelIso.toEquiv",
   "RelIso",
   "LE",
   "FunLike.coe",
   "Equiv.apply_symm_apply",
   "LE.le",
   "OrderIso.symm",
   "RelHomClass.toFunLike",
   "Eq"],
  "name": "OrderIso.apply_symm_apply",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : LE α] [inst_1 : LE β] (e : α ≃o β) (x : β), e ((OrderIso.symm e) x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_2",
   "Mathlib.Order.OmegaCompletePartialOrder._auxLemma.14",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "RelHomClass.toFunLike",
   "OrderHom.mk",
   "Eq.mpr",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (s : α),\n  (∀ (i : ℕ), x i ≤ s) → (fun c => ⨆ i, c i) x ≤ s",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "Subsemigroup",
  "constType": "(M : Type u_4) → [inst : Mul M] → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Subtype.noConfusion",
   "Eq.refl",
   "Eq.casesOn",
   "Eq.symm",
   "Eq.propIntro",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "Subtype.mk.injEq",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (val : α) (property : p val) (val_1 : α) (property_1 : p val_1),\n  ({ val := val, property := property } = { val := val_1, property := property_1 }) = (val = val_1)",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt.match_1",
   "Ne",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "absurd",
   "lt_trichotomy",
   "GT.gt",
   "Eq"],
  "name": "lt_or_gt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≠ b → a < b ∨ a > b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "id"],
  "name": "neg_add_cancel_right",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + -b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Function.Injective",
   "Nat"],
  "name": "CharZero.mk",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R], Function.Injective Nat.cast → CharZero R",
  "constCategory": "Other"},
 {"references": [],
  "name": "OmegaCompletePartialOrder",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Set", "MeasurableSpace.MeasurableSet'", "MeasurableSpace"],
  "name": "MeasurableSet",
  "constType": "{α : Type u_1} → [inst : MeasurableSpace α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Finset.Nonempty",
   "MeasureTheory.MeasureSpace.mk",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "MeasureTheory.IsProbabilityMeasure",
   "Exists.casesOn",
   "MeasureTheory.MeasureSpace.volume",
   "MeasureTheory.Measure",
   "ProbabilityTheory.exists_isUniform",
   "MeasurableSingletonClass",
   "And",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "FiniteRange",
   "Finset.toSet",
   "MeasureTheory.MeasureSpace",
   "Finset",
   "Measurable",
   "And.intro",
   "And.casesOn",
   "MeasurableSpace",
   "ProbabilityTheory.IsUniform"],
  "name": "ProbabilityTheory.exists_isUniform_measureSpace",
  "constType":
  "∀ {S : Type u} [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] (H : Finset S),\n  Finset.Nonempty H →\n    ∃ Ω mΩ U,\n      MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n        Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ (∀ (ω : Ω), U ω ∈ H) ∧ FiniteRange U",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.symm",
  "constType": "∀ {a b : Prop}, a ∨ b → b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Complex.arg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "sub_self",
   "MulZeroOneClass.toMulOneClass",
   "Real.instSubReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "AbsoluteValue",
   "Real.instAddMonoidReal",
   "AddGroup.toSubtractionMonoid",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "Complex.abs",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.orderedSemiring",
   "Real.normedCommRing",
   "SubadditiveHomClass.toFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Real.instAddGroupReal",
   "congr",
   "Complex.log",
   "mul_one",
   "congrArg",
   "add_zero",
   "congrFun",
   "Real",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "AbsoluteValue.subadditiveHomClass",
   "Zero.toOfNat0",
   "Complex.instSemiringComplex",
   "MulZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHAdd",
   "HSub.hSub",
   "One.toOfNat1",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Complex.re",
   "Real.instZeroReal",
   "NormedCommRing.toSeminormedCommRing",
   "Real.log",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Complex",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "NegZeroClass.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.log_re",
  "constType": "∀ (x : ℂ), (Complex.log x).re = Real.log (Complex.abs x)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "Real.instSubReal",
   "Real",
   "ProbabilityTheory.entropy",
   "autoParam",
   "MeasureTheory.Measure.prod",
   "LinearOrderedField.toDiv",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "rdist",
   "AddCommGroup.toAddGroup",
   "HDiv.hDiv",
   "ProbabilityTheory.IdentDistrib.entropy_eq",
   "instOfNat",
   "Eq.trans",
   "eq_self",
   "_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.140",
   "instHSub",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "instHDiv",
   "Prod.snd",
   "HSub.hSub",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "AddGroup.toSubNegMonoid",
   "Prod.instMeasurableSpace",
   "of_eq_true",
   "rdist.proof_1",
   "congr",
   "Prod",
   "AddCommGroup",
   "congrArg",
   "MeasurableSpace",
   "congrFun"],
  "name": "ProbabilityTheory.IdentDistrib.rdist_eq",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {Ω'' : Type u_3} {Ω''' : Type u_4} {G : Type u_5} [mΩ : MeasurableSpace Ω]\n  {μ : MeasureTheory.Measure Ω} [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [mΩ'' : MeasurableSpace Ω'']\n  {μ'' : MeasureTheory.Measure Ω''} [mΩ''' : MeasurableSpace Ω'''] {μ''' : MeasureTheory.Measure Ω'''}\n  [hG : MeasurableSpace G] [inst : AddCommGroup G] {X : Ω → G} {Y : Ω' → G} {X' : Ω'' → G} {Y' : Ω''' → G},\n  ProbabilityTheory.IdentDistrib X X' →\n    ProbabilityTheory.IdentDistrib Y Y' → d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ''']",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "Measurable",
   "Add",
   "MeasurableSpace",
   "MeasurableAdd"],
  "name": "MeasurableAdd.measurable_add_const",
  "constType":
  "∀ {M : Type u_2} [inst : MeasurableSpace M] [inst_1 : Add M] [self : MeasurableAdd M] (c : M), Measurable fun x => x + c",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "LinearOrderedSemifield.toInv",
   "mul_lt_mul_left",
   "PartialOrder.toPreorder",
   "div_eq_mul_inv",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "Semifield.toCommGroupWithZero",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Preorder.toLT",
   "inv_lt_inv",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "of_eq_true",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "LT.lt",
   "congr",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "congrArg",
   "congrFun",
   "Inv.inv"],
  "name": "div_lt_div_left",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < a → 0 < b → 0 < c → (a / b < a / c ↔ c < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Semifield.toCommSemiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toInv",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.inv_zero",
  "constType": "∀ {α : Type u_4} [self : Semifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "And.left",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_left",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Classical.choose_spec",
   "Classical.choose",
   "Subtype.eq",
   "Subtype.val",
   "Set",
   "Set.InjOn",
   "Equiv.Set.imageOfInjOn.match_1",
   "And.left",
   "Eq",
   "Set.instMembershipSet",
   "Subtype.property",
   "And",
   "And.right",
   "Set.Elem",
   "Set.image",
   "Subtype.mk",
   "Set.mem_image_of_mem"],
  "name": "Equiv.Set.imageOfInjOn.proof_4",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α),\n  Set.InjOn f s →\n    ∀ (x : ↑s),\n      (fun p => { val := Classical.choose (_ : ↑p ∈ f '' s), property := (_ : Classical.choose (_ : ↑p ∈ f '' s) ∈ s) })\n          ((fun p => { val := f ↑p, property := (_ : f ↑p ∈ f '' s) }) x) =\n        x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "False",
   "GE.ge",
   "instLTNat",
   "LE.le",
   "GT.gt",
   "Eq",
   "Nat.le_total.match_1",
   "instLENat",
   "Eq.subst",
   "LT.lt",
   "letFun",
   "Nat.lt_trans",
   "Nat.lt_irrefl",
   "Not",
   "Nat.lt_or_ge",
   "Nat",
   "Nat.le_antisymm",
   "absurd"],
  "name": "Nat.not_le_of_gt",
  "constType": "∀ {n m : ℕ}, n > m → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image2", "Set.add", "instHAdd", "HAdd.hAdd", "Set", "Add", "rfl", "Eq"],
  "name": "Set.image2_add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α}, Set.image2 (fun x x_1 => x + x_1) s t = s + t",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Zero", "Mul"],
  "name": "NoZeroDivisors",
  "constType": "(M₀ : Type u_4) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references": ["Zero", "SMul", "SMulZeroClass"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_10} → {A : Type u_11} → [inst : Zero A] → [self : SMulZeroClass M A] → SMul M A",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "Subtype.val",
   "IsCauSeq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "GE.ge",
   "Semifield.toCommGroupWithZero",
   "Preorder.toLE",
   "Abs.abs",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "instLENat",
   "Preorder.toLT",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Lattice.toSemilatticeSup",
   "Nat",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "StrictOrderedRing.toPartialOrder",
   "instDistribLattice",
   "CauSeq",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LE.le",
   "GT.gt",
   "DistribLattice.toLattice",
   "And",
   "LinearOrderedField.toField",
   "Field.toDivisionRing"],
  "name": "CauSeq.Pos",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → CauSeq α abs → Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedCommRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommRing.toOrderedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedCommRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.mk_lt_aleph0_iff",
   "Cardinal.aleph0",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "Finite",
   "Cardinal",
   "Cardinal.partialOrder",
   "Cardinal.mk",
   "Eq"],
  "name": "Mathlib.SetTheory.Cardinal.Finite._auxLemma.6",
  "constType": "∀ {α : Type u}, (Cardinal.mk α < Cardinal.aleph0) = Finite α",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.aleph0",
   "PartialOrder.toPreorder",
   "Set.finite_coe_iff",
   "Set.Elem",
   "Preorder.toLT",
   "LT.lt",
   "Set",
   "Cardinal.lt_aleph0_iff_finite",
   "Finite",
   "Cardinal",
   "Iff.trans",
   "Cardinal.partialOrder",
   "Cardinal.mk",
   "Set.Finite",
   "Iff.mpr"],
  "name": "Set.Finite.lt_aleph0",
  "constType":
  "∀ {α : Type u} {S : Set α}, Set.Finite S → Cardinal.mk ↑S < Cardinal.aleph0",
  "constCategory": "Theorem"},
 {"references": ["Rat", "Int"],
  "name": "Rat.num",
  "constType": "ℚ → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatPow",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "AddMonoid.toZero",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Mathlib.Tactic.Ring.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.toFiniteSpanningSetsIn",
   "setOf",
   "instLENat",
   "MeasureTheory.Measure.FiniteSpanningSetsIn.set",
   "MeasureTheory.SigmaFinite",
   "Set",
   "Set.Accumulate",
   "MeasurableSet",
   "Nat",
   "MeasurableSpace"],
  "name": "MeasureTheory.spanningSets",
  "constType":
  "{α : Type u_1} →\n  {m0 : MeasurableSpace α} → (μ : MeasureTheory.Measure α) → [inst : MeasureTheory.SigmaFinite μ] → ℕ → Set α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "Iff", "And.intro", "And.left"],
  "name": "and_iff_left_of_imp",
  "constType": "∀ {a b : Prop}, (a → b) → (a ∧ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "_private.Mathlib.Data.Real.Basic.0.Real.one_def",
   "Rat",
   "Eq.refl",
   "One.toOfNat1",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instOneCauchy",
   "_private.Mathlib.Data.Real.Basic.0.Real.one",
   "Real.ofCauchy",
   "Abs.abs",
   "Real.instOneReal",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "letFun",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "id"],
  "name": "Real.cauchy_one",
  "constType": "1.cauchy = 1",
  "constCategory": "Theorem"},
 {"references": ["AddCommGroupWithOne", "IntCast"],
  "name": "AddCommGroupWithOne.toIntCast",
  "constType": "{R : Type u} → [self : AddCommGroupWithOne R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HMul.hMul",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.zero_mul",
  "constType":
  "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Lattice.toSemilatticeInf",
   "Set",
   "disjoint_iff",
   "Disjoint",
   "SemilatticeInf.toPartialOrder",
   "Set.instEmptyCollectionSet",
   "Inter.inter",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.instBooleanAlgebraSet",
   "Iff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.instInterSet"],
  "name": "Set.disjoint_iff_inter_eq_empty",
  "constType": "∀ {α : Type u} {s t : Set α}, Disjoint s t ↔ s ∩ t = ∅",
  "constCategory": "Theorem"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Set"],
  "name": "Set.Mem",
  "constType": "{α : Type u_1} → α → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{α : Type u_1} → [inst : Mul α] → [self : HasDistribNeg α] → InvolutiveNeg α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "NormedRing",
   "PseudoMetricSpace.toDist",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedRing.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NormedRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Lattice.toLinearOrder",
   "Preorder.toLT",
   "Real.lattice",
   "LT.lt",
   "Classical.propDecidable",
   "Real",
   "SemilatticeInf.toPartialOrder",
   "Real.instIsTotalRealLeInstLEReal",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Real.linearOrder",
  "constType": "LinearOrder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "DiscreteMeasurableSpace",
   "MeasurableSet",
   "DiscreteMeasurableSpace.forall_measurableSet",
   "MeasurableSpace"],
  "name": "measurableSet_discrete",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : DiscreteMeasurableSpace α] (s : Set α), MeasurableSet s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "mul_le_mul_of_nonneg_left",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Monotone",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPosMulMono",
   "OrderedSemiring.toPartialOrder"],
  "name": "monotone_mul_left_of_nonneg",
  "constType":
  "∀ {α : Type u} [inst : OrderedSemiring α] {a : α}, 0 ≤ a → Monotone fun x => a * x",
  "constCategory": "Theorem"},
 {"references":
  ["Real.linearOrder",
   "inferInstance",
   "instDecidableEq",
   "Real",
   "Decidable",
   "Eq"],
  "name": "Real.decidableEq",
  "constType": "(a b : ℝ) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references": ["Ne", "Preorder.toLT", "LT.lt", "ne_of_lt", "Preorder"],
  "name": "LT.lt.ne",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "PartialOrder.toPreorder",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "LE.le",
   "OrderedCommMonoid",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toCommMonoid : CommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b) → OrderedCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : ℕ) → Decidable (n = m)",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Iff.rfl",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Eq.refl",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "HImp.himp",
   "Eq.ndrec",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "propext",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quot"],
  "name": "Quotient",
  "constType": "{α : Sort u} → Setoid α → Sort u",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.Measure", "MeasurableSpace"],
  "name": "MeasureTheory.IsProbabilityMeasure",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references":
  ["add_left_cancel",
   "Function.Injective",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_right_injective",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G), Function.Injective fun x => a + x",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "CauSeq.Completion.instZeroCauchy",
   "Abs.abs",
   "Eq",
   "_private.Mathlib.Data.Real.Basic.0.Real.zero",
   "Rat.instSupRat",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "_private.Mathlib.Data.Real.Basic.0.Real.zero_def",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_zero",
  "constType": "{ cauchy := 0 } = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Or.imp_left",
   "Or",
   "Iff",
   "Or.inl",
   "Or.inr",
   "Function.comp",
   "Or.imp_right",
   "Or.rec"],
  "name": "or_assoc",
  "constType": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_9",
  "constType": "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.toFinset", "Set", "Finset", "Set.Finite.fintype", "Set.Finite"],
  "name": "Set.Finite.toFinset",
  "constType": "{α : Type u} → {s : Set α} → Set.Finite s → Finset α",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Commutative",
  "constType": "{α : Type u} → (α → α → α) → Prop",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelMonoid", "Nat"],
  "name": "AddRightCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Ne",
   "funext",
   "Finset.instEmptyCollectionFinset",
   "Finset.Nonempty",
   "EmptyCollection.emptyCollection",
   "Mathlib.Data.Finset.Basic._auxLemma.144",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "Mathlib.Data.Finset.Basic._auxLemma.145",
   "True",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Mathlib.Data.Finset.Basic._auxLemma.141",
   "DecidablePred",
   "Mathlib.Data.Finset.Basic._auxLemma.142",
   "And",
   "Mathlib.Data.Finset.Basic._auxLemma.143",
   "Iff",
   "of_eq_true",
   "Finset",
   "Finset.filter",
   "Not",
   "congrArg",
   "Eq.trans",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Finset.filter_nonempty_iff",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α},\n  Finset.Nonempty (Finset.filter p s) ↔ ∃ a ∈ s, p a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedRingReal",
   "Real",
   "Eq.le",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "abs_mul",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Lattice.toSemilatticeSup"],
  "name": "Real.normedCommRing.proof_1",
  "constType": "∀ (x y : ℝ), |x * y| ≤ |x| * |y|",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Set", "Set.instMembershipSet"],
  "name": "Set.Subset",
  "constType": "{α : Type u_1} → Set α → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Subtype.exists.match_2",
   "Exists.intro",
   "Subtype.exists.match_1",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) ↔ ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.inv_aux",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Subtype.val",
   "IsCauSeq",
   "CauSeq.LimZero",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.toInv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Not",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Subtype.mk",
   "Inv.inv"],
  "name": "CauSeq.inv",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : DivisionRing β] →\n        {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → (f : CauSeq β abv) → ¬CauSeq.LimZero f → CauSeq β abv",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_one",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "Group.toDivisionMonoid",
   "Std.Logic._auxLemma.4",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "One.nonempty",
   "Submonoid.instBotSubmonoid",
   "Set",
   "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.1",
   "implies_congr",
   "True",
   "SetLike.instMembership",
   "Eq",
   "Submonoid.toSubsemigroup",
   "forall_congr",
   "Subsemigroup.instSetLikeSubsemigroup",
   "Group",
   "InvOneClass.toInv",
   "Eq.trans",
   "Membership.mem",
   "Bot.bot",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass.toOne",
   "Subsemigroup",
   "Std.Logic._auxLemma.32",
   "One.toOfNat1",
   "Mathlib.GroupTheory.Subsemigroup.Basic._auxLemma.1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "InvOneClass.toOne",
   "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.8",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid",
   "Group.toDivInvMonoid",
   "Mathlib.Algebra.Group.Basic._auxLemma.15",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "Subgroup.instBotSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G], ∀ a ∈ ⊥.carrier, a⁻¹ ∈ ⊥.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_5",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (s : Set β) (a : β), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Invertible",
   "Preorder.toLE",
   "Iff.mpr",
   "Semiring.toNatCast",
   "Eq",
   "OrderedRing.toRing",
   "Decidable.decide",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.commute_cast",
   "Ring.toIntCast",
   "Bool.true",
   "Int.cast_mul",
   "Nat",
   "Eq.trans",
   "invOf_nonneg",
   "StrictOrderedRing.toPartialOrder",
   "Invertible.invOf",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "mul_le_mul_of_nonneg_left",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Eq.mp",
   "congr",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toMulPosMono",
   "congrArg",
   "OrderedSemiring.toPosMulMono",
   "Int",
   "Int.instLEInt",
   "congrFun",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Int.decLe",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddGroupWithOne.toIntCast",
   "of_decide_eq_true",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "StrictOrderedRing.toOrderedRing",
   "mul_mul_invOf_self_cancel'",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toNatCast",
   "LinearOrderedRing",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Eq.symm",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.cast_nonneg",
   "Ring.toSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "OrderedRing.toPartialOrder",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun",
   "HMul.hMul",
   "Int.cast_mono",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Bool",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Mathlib.Meta.NormNum.isRat_le_true.match_1"],
  "name": "Mathlib.Meta.NormNum.isRat_le_true",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] {a b : α} {na nb : ℤ} {da db : ℕ},\n  Mathlib.Meta.NormNum.IsRat a na da →\n    Mathlib.Meta.NormNum.IsRat b nb db → decide (Int.mul na (Int.ofNat db) ≤ Int.mul nb (Int.ofNat da)) = true → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Finset.partialOrder.proof_1",
   "HasSSubset.SSubset",
   "Finset.partialOrder.proof_3",
   "Finset",
   "Finset.partialOrder.proof_4",
   "HasSubset.Subset",
   "Finset.partialOrder.proof_2",
   "LT.mk",
   "Finset.instHasSSubsetFinset",
   "Finset.instHasSubsetFinset",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Finset.partialOrder",
  "constType": "{α : Type u_1} → PartialOrder (Finset α)",
  "constCategory": "Definition"},
 {"references": ["CommGroupWithZero", "Inv"],
  "name": "CommGroupWithZero.toInv",
  "constType": "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → Inv G₀",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_of_le_of_lt.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Trans.trans",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "inv_mul_cancel",
   "mul_assoc",
   "one_mul",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "GroupWithZero.toInv",
   "eq_self",
   "Ne",
   "False",
   "One.toOfNat1",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "eq_false",
   "of_eq_true",
   "GroupWithZero",
   "HMul.hMul",
   "instTransEq",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "Inv.inv",
   "congrFun"],
  "name": "inv_mul_cancel_left₀",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → ∀ (b : G₀), a⁻¹ * (a * b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Unit",
   "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {n : ℕ} {a a' : α}, Mathlib.Meta.NormNum.IsNat a n → ↑n = a' → a = a'",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Eq"],
  "name": "SemiconjBy",
  "constType": "{M : Type u_2} → [inst : Mul M] → M → M → M → Prop",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.mk",
  "constType": "{K : Type u} → (ℚ → K) → RatCast K",
  "constCategory": "Other"},
 {"references":
  ["not_le_of_gt",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "Preorder",
   "Preorder.toLE"],
  "name": "not_lt_of_ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn", "letFun", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references": ["Multiplicative", "rfl", "Eq"],
  "name": "Multiplicative.ofAdd.proof_1",
  "constType":
  "∀ {α : Type u_1} (x : α), (fun x => x) ((fun x => x) x) = (fun x => x) ((fun x => x) x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Set.Nonempty",
   "And.left",
   "instLTNat",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Eq",
   "mul_pos_iff",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Nat.cast",
   "Set.Elem",
   "or_false",
   "Set.Finite.image2",
   "Nat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
   "Eq.trans",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "Finite",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "Set.Nonempty.sub",
   "And",
   "instHMul",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "Set",
   "Real",
   "LT.lt.trans_le",
   "Semiring.toMonoidWithZero",
   "Ring.toNonAssocRing",
   "Set.toFinite",
   "True",
   "Zero.toOfNat0",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
   "Set.nonempty_coe_sort",
   "and_false",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Set.sub",
   "Mathlib.Init.Order.Defs._auxLemma.1",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "False",
   "Real.instLinearOrderedRingReal",
   "Real.instLTReal",
   "Real.nontrivial",
   "HSub.hSub",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Set.Finite",
   "Real.instZeroReal",
   "eq_false",
   "Set.finite_coe_iff",
   "Real.instPreorderReal",
   "letFun",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2"],
  "name": "PFR_conjecture_pos_aux",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ},\n  Set.Nonempty A → ↑(Nat.card ↑(A - A)) ≤ K * ↑(Nat.card ↑A) → 0 < ↑(Nat.card ↑A) ∧ 0 < ↑(Nat.card ↑(A - A)) ∧ 0 < K",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "Prod.snd",
   "instHAdd",
   "Subtype.val",
   "Set",
   "HAdd.hAdd",
   "AddSubgroup.isComplement_iff_existsUnique",
   "Prod.fst",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Set.instMembershipSet",
   "AddGroup",
   "Iff.mp",
   "Set.Elem",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.IsComplement",
   "Prod",
   "ExistsUnique"],
  "name": "AddSubgroup.IsComplement.existsUnique",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G}, AddSubgroup.IsComplement S T → ∀ (g : G), ∃! x, ↑x.1 + ↑x.2 = g",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Function.Injective.ne_iff",
   "Add",
   "add_left_injective"],
  "name": "add_ne_add_left",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G) {b c : G}, b + a ≠ c + a ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references":
  ["Filter.inter_sets",
   "Membership.mem",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter"],
  "name": "Filter.inter_mem",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → t ∈ f → s ∩ t ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "add_right_neg",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.LeftInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "OfNat.ofNat",
   "HEq",
   "MeasureTheory.Measure.map",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.map_apply",
   "BooleanAlgebra.toHasCompl",
   "True",
   "ProbabilityTheory.IsUniform.measure_preimage_compl",
   "iff_self",
   "Eq",
   "Set.ext",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasurableSingletonClass",
   "measurableSet_discrete",
   "Eq.mpr",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Iff",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.measure_eq_measure_of_null_diff",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Measurable",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Membership.mem",
   "Set.preimage",
   "eq_of_heq",
   "Set.instSDiffSet",
   "HasCompl.compl",
   "SDiff.sdiff",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.univ",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "And",
   "Countable",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "MeasureTheory.Measure.toOuterMeasure",
   "congr",
   "Not",
   "Eq.casesOn",
   "congrArg",
   "MeasureTheory.OuterMeasure",
   "Mathlib.Data.Set.Basic._auxLemma.87",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "Set.subset_univ"],
  "name": "ProbabilityTheory.IsUniform.full_measure",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Set S},\n  ProbabilityTheory.IsUniform H X → Measurable X → ↑↑(MeasureTheory.Measure.map X μ) H = ↑↑μ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Sub", "MeasurableSpace"],
  "name": "MeasurableSub₂",
  "constType":
  "(G : Type u_2) → [inst : MeasurableSpace G] → [inst : Sub G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Setoid",
   "AddMonoid.toOppositeAddAction",
   "AddGroup",
   "AddSubgroup.op",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddOpposite",
   "AddOpposite.addGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddAction.orbitRel",
   "AddGroup.toSubNegMonoid",
   "AddSubgroup.toAddGroup",
   "SetLike.instMembership",
   "Subtype",
   "AddSubgroup.instAddAction"],
  "name": "QuotientAddGroup.leftRel",
  "constType":
  "{α : Type u_1} → [inst : AddGroup α] → AddSubgroup α → Setoid α",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "max_le_iff",
   "LE.le",
   "Preorder.toLE",
   "Abs.abs",
   "DistribLattice.toLattice",
   "And",
   "Iff",
   "SemilatticeSup.toSup",
   "Lattice.toSemilatticeSup",
   "Neg"],
  "name": "abs_le'",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] {a b : α}, |a| ≤ b ↔ a ≤ b ∧ -a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat"],
  "name": "Nat.le.refl",
  "constType": "∀ {n : ℕ}, Nat.le n n",
  "constCategory": "Other"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "Multiset.attach",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.nodup_attach",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "Iff.mpr"],
  "name": "Finset.attach.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Finset α), Multiset.Nodup (Multiset.attach s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "Left.mul_nonneg",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul"],
  "name": "mul_nonneg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "SMul",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul"],
  "name": "Algebra.mk",
  "constType":
  "{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : Semiring A] →\n        [toSMul : SMul R A] →\n          (toRingHom : R →+* A) →\n            (∀ (r : R) (x : A), toRingHom r * x = x * toRingHom r) →\n              (∀ (r : R) (x : A), r • x = toRingHom r * x) → Algebra R A",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set",
   "Set.Iic",
   "Preorder",
   "LE.le",
   "Set.mem_Iic",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] {b x : α}, (x ∈ Set.Iic b) = (x ≤ b)",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MulOneClass.toOne", "MonoidHom", "OneHom"],
  "name": "MonoidHom.toOneHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → (M →* N) → OneHom M N",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Rat.instSemilatticeInfRat",
   "Rat",
   "SemilatticeInf.toPartialOrder",
   "PartialOrder"],
  "name": "Rat.instPartialOrderRat",
  "constType": "PartialOrder ℚ",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["HPow", "Nat", "Int.pow", "Int", "HPow.mk"],
  "name": "Int.instHPowIntNat",
  "constType": "HPow ℤ ℕ ℤ",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "instHasEquiv",
   "DivisionRing.toRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Or.resolve_right",
   "LT.mk",
   "Abs.abs",
   "Setoid.symm",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "Iff",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "CauSeq.not_limZero_of_pos",
   "Lattice.toSemilatticeSup",
   "CauSeq.lt_irrefl",
   "CauSeq.lt_trans",
   "instHSub",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "Or",
   "Or.inr",
   "CauSeq.instSubCauSeq",
   "instDistribLattice",
   "HSub.hSub",
   "CauSeq",
   "mt",
   "LE.le",
   "Iff.intro",
   "DistribLattice.toLattice",
   "CauSeq.equiv",
   "And",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.match_2",
   "Or.inl",
   "LinearOrderedField.toField",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LT.lt",
   "Not",
   "And.intro",
   "not_or_of_not",
   "HasEquiv.Equiv",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (x x_1 : CauSeq α abs), x < x_1 ↔ x ≤ x_1 ∧ ¬x_1 ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "MulOneClass",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "Additive.addZeroClass",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Additive"],
  "name": "Submonoid.toAddSubmonoid.proof_3",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : AddSubmonoid (Additive M)), 0 ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true",
   "instLENat",
   "Nat.succ_le_succ",
   "Nat",
   "Nat.succ",
   "LE.le",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Complex.Exponential._auxLemma.2",
  "constType": "∀ {n m : ℕ}, n ≤ m → (Nat.succ n ≤ Nat.succ m) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "Real.rpow_eq_zero",
   "instHPow",
   "propext",
   "Real.instPowReal",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.5",
  "constType": "∀ {x y : ℝ}, 0 ≤ x → y ≠ 0 → (x ^ y = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references": ["Real", "Dist"],
  "name": "Dist.mk",
  "constType": "{α : Type u_3} → (α → α → ℝ) → Dist α",
  "constCategory": "Other"},
 {"references": [],
  "name": "DivInvOneMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Countable",
   "Subtype.countable",
   "Set.Elem",
   "Set",
   "Set.instMembershipSet"],
  "name": "SetCoe.countable",
  "constType":
  "∀ {α : Type u_1} [inst : Countable α] (s : Set α), Countable ↑s",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "CauSeq.Completion.Cauchy.ring",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "CauSeq.Completion.instInvCauchyToRing",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_8",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℕ) (a : CauSeq.Completion.Cauchy abv),\n  zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "or_false.match_1",
  "constType":
  "∀ (p : Prop) (motive : p ∨ False → Prop) (x : p ∨ False), (∀ (h : p), motive (_ : p ∨ False)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Complex.ofReal'",
   "HPow.hPow",
   "Complex.instPowComplex",
   "instHPow",
   "Real",
   "Complex",
   "Complex.re"],
  "name": "Real.rpow",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Function.Injective",
   "Set",
   "Set.InjOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.injOn_of_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instSubReal",
   "Real.commRing",
   "MulZeroClass.mul_zero",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Complex.exp_add",
   "Eq",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "MulZeroClass.toZero",
   "sub_zero",
   "Complex.ofReal_add",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Complex.ofReal'",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "Complex.exp_ofReal_im",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.instAddComplex",
   "Real.exp",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.im",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Complex",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Real.exp_add",
  "constType": "∀ (x y : ℝ), Real.exp (x + y) = Real.exp x * Real.exp y",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Rat",
   "DivisionRing.toRatCast",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "RatCast",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Rat.cast",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.ofRat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instRatCastCauchyToRing",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : DivisionRing β] →\n        {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → RatCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AbsoluteValue.eq_zero",
   "AbsoluteValue.add_le",
   "PartialOrder.toPreorder",
   "Semiring",
   "AbsoluteValue",
   "AbsoluteValue.map_mul",
   "FunLike.coe",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "AbsoluteValue.nonneg",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "AbsoluteValue.subadditiveHomClass",
   "IsAbsoluteValue",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "IsAbsoluteValue.mk",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.isAbsoluteValue",
  "constType":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] (abv : AbsoluteValue R S),\n  IsAbsoluteValue ⇑abv",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Set.add",
   "instAddNat",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "nsmulRec",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Eq",
   "AddZeroClass.toZero",
   "Add.add",
   "instOfNatNat",
   "Nat",
   "Set.addZeroClass",
   "Add.mk"],
  "name": "Set.addMonoid.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoid α] (n : ℕ) (x : Set α), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references": ["False", "IsEmpty.mk", "IsEmpty", "id"],
  "name": "instIsEmptyFalse",
  "constType": "IsEmpty False",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
   "OfNat.ofNat",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "mul_le_mul",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
   "Semiring.toNatCast",
   "Real.instOneReal",
   "inferInstance",
   "Real.linearOrder",
   "Nat.ble",
   "IsROrC.charZero_isROrC",
   "Set.Elem",
   "PFR_conjecture_pos_aux'",
   "Real.instPowReal",
   "instTransLtToLTLeToLE",
   "LinearOrderedField.toLinearOrderedSemifield",
   "AddTorsor.nonempty",
   "le_of_lt",
   "addGroupIsAddTorsor",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "Subtype",
   "Nat.prime_two",
   "Nat.strictOrderedSemiring",
   "add_assoc",
   "div_lt_iff",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AddCommMagma.toAdd",
   "DivisionRing.toInv",
   "PartialOrder",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "propext",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "congr",
   "LinearOrder.toPartialOrder",
   "AddSubgroup.toAddCommGroup",
   "And.intro",
   "MonoidWithZero.toZero",
   "Real.rpow_one",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "DivisionRing.toDivisionSemiring",
   "sub_nonpos_of_le",
   "Set",
   "GE.ge",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Mathlib.Tactic.RPowRing.mul_pf_left",
   "Int.rawCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.sub_pf",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "div_lt_div_of_lt_left",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Nat.linearOrderedCommMonoidWithZero",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.mul_add",
   "instTransLeToLE",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "mul_le_mul_of_nonneg_right",
   "Monoid.toMulOneClass",
   "GroupWithZero.toMonoidWithZero",
   "LE.le",
   "GroupWithZero.toDiv",
   "Real.instDivisionRingReal",
   "NormedCommRing.toSeminormedCommRing",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "eq_div_iff",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "AddGroup.toSubtractionMonoid",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "Nat.cast_one",
   "Set.card_add_le",
   "neg_neg_of_pos",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HasSubset.Subset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddSubgroup.exists_left_transversal_of_le",
   "Real.orderedSemiring",
   "lt_of_not_ge",
   "MulZeroOneClass.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "True.intro",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "cast",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "mul_one",
   "mul_pos",
   "Mathlib.Tactic.Ring.mul_one",
   "instTransLeToLELtToLT",
   "Int.ofNat",
   "LinearOrderedSemifield.toSemifield",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "OmegaCompletePartialOrder.toPartialOrder",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.9",
   "Mathlib.Tactic.RPowRing.pow_congr",
   "ne_of_gt",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "le_or_lt",
   "Membership.mem",
   "eq_self",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Nat.cast_nonneg",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
   "PFR_conjecture_aux",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Bool",
   "instMulNat",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "LT.lt.ne'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.cast_pos",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.1",
   "mul_div_assoc'",
   "Set.Nonempty",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Nat.cast_zero",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isRat_add",
   "Mathlib.Meta.NormNum.isInt_add",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Real.strictOrderedSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HDiv.hDiv",
   "mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "Or",
   "Set.add",
   "Real.instRingReal",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.normedCommRing",
   "CommMagma.toMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Real.rpow_pos_of_pos",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "OrderedSemiring.toMulPosMono",
   "AddCommGroup",
   "OrderedSemiring.toPosMulMono",
   "Finite.of_fintype",
   "Int",
   "SetLike.coe",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
   "Mathlib.Tactic.Ring.sub_congr",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Real.rpow_le_rpow",
   "True",
   "Real.one_rpow",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Tactic.RPowRing.atom_pow_pf",
   "AddMonoid.toAddSemigroup",
   "one_pos",
   "div_div_eq_mul_div",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Mathlib.Meta.NormNum.isRat_mul",
   "Mathlib.Tactic.RPowRing.pow_pf",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Real.nontrivial",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Mathlib.Tactic.Ring.neg_add",
   "Countable",
   "Set.instHasSubsetSet",
   "Int.mul",
   "Real.instPreorderReal",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "zero_lt_two",
   "Real.instMulReal",
   "Real.instLEReal",
   "ElementaryAddCommGroup.exists_subgroup_subset_card_le",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Eq",
   "Nat.linearOrder",
   "Fintype",
   "Eq.mpr",
   "DivisionCommMonoid.toDivisionMonoid",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "DivisionSemiring.toGroupWithZero",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Finite",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instTransEq_1",
   "instHMul",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "mul_le_mul_of_nonneg_left",
   "div_pos",
   "Mathlib.Meta.NormNum.isInt_neg",
   "congrArg",
   "OrderedAddCommGroup.toAddCommGroup",
   "Zero",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "Mathlib.Tactic.RPowRing.pow_pos",
   "le_of_eq",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Nat.card_pos",
   "mul_comm",
   "Zero.toOfNat0",
   "instLENat",
   "one_mul",
   "Preorder.toLT",
   "instHPow",
   "AddSubgroup",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "LT.lt.le",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "lt_of_le_of_lt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Set.addSemigroup",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.RPowRing.mul_pf_right",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "PFR_conjecture",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ} [inst_2 : Countable G]\n  [inst_3 : ElementaryAddCommGroup G 2] [inst_4 : Fintype G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) →\n      ∃ H c, ↑(Nat.card ↑c) < 2 * K ^ 12 ∧ Nat.card ↥H ≤ Nat.card ↑A ∧ A ⊆ c + ↑H",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "IsAbsoluteValue",
  "constType":
  "{S : Type u_1} → [inst : OrderedSemiring S] → {R : Type u_2} → [inst : Semiring R] → (R → S) → Prop",
  "constCategory": "Other"},
 {"references": ["WithTop", "NNReal"],
  "name": "ENNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "max_eq_left",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "neg_nonpos"],
  "name": "abs_of_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ a → |a| = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "semiOutParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "SProd.sprod",
   "Set",
   "Eq.refl",
   "Prod",
   "Finite.of_fintype",
   "Set.toFinite",
   "Set.Finite",
   "Finite.Set.finite_prod",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.prod",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Set α} {t : Set β}, Set.Finite s → Set.Finite t → Set.Finite (s ×ˢ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instHAdd",
   "HAdd.hAdd",
   "PUnit",
   "Nat",
   "Add",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "nsmulRec",
  "constType": "{M : Type u} → [inst : Zero M] → [inst : Add M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.rec",
  "constType":
  "{α : Type u_1} →\n  [inst : Ring α] →\n    {a : α} →\n      {n : ℤ} →\n        {motive : Mathlib.Meta.NormNum.IsInt a n → Sort u} →\n          ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsInt a n)) →\n            (t : Mathlib.Meta.NormNum.IsInt a n) → motive t",
  "constCategory": "Other"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.succ_le_succ",
   "Nat.le_trans",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "LE.le"],
  "name": "Nat.lt_of_le_of_lt",
  "constType": "∀ {n m k : ℕ}, n ≤ m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "Prod",
   "Sup.sup",
   "Prod.fst",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "Lattice.toSemilatticeSup",
   "MeasurableSpace.comap",
   "MeasurableSpace"],
  "name": "MeasurableSpace.prod",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → MeasurableSpace α → MeasurableSpace β → MeasurableSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "one_le_two",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "instNatAtLeastTwo",
   "zero_lt_one",
   "instOfNatNat",
   "Nat",
   "instOfNat"],
  "name": "zero_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.preimage.proof_1",
   "Set.preimage",
   "Set",
   "Finset.toSet",
   "Finset",
   "Finset.preimage",
   "Set.Finite.coe_toFinset",
   "Set.InjOn",
   "Eq"],
  "name": "Finset.coe_preimage",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} (s : Finset β) (hf : Set.InjOn f (f ⁻¹' ↑s)),\n  ↑(Finset.preimage s f hf) = f ⁻¹' ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.4",
   "Ne",
   "OfNat.ofNat",
   "False",
   "Real",
   "Real.instLEReal",
   "and_true",
   "LE.le",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "eq_false",
   "eq_true",
   "Iff",
   "of_eq_true",
   "instHPow",
   "Real.instPowReal",
   "Not",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.rpow_eq_zero",
  "constType": "∀ {x y : ℝ}, 0 ≤ x → y ≠ 0 → (x ^ y = 0 ↔ x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Submonoid.mk",
   "Top",
   "MulOneClass.toMul",
   "MulOneClass",
   "Subsemigroup.mk",
   "Submonoid",
   "Submonoid.instTopSubmonoid.proof_1",
   "Set.univ",
   "Submonoid.instTopSubmonoid.proof_2",
   "Top.mk"],
  "name": "Submonoid.instTopSubmonoid",
  "constType": "{M : Type u_1} → [inst : MulOneClass M] → Top (Submonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "add_right_neg",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "add_assoc",
   "add_comm",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "NegZeroClass.toNeg",
   "neg_add_rev"],
  "name": "add_sub_add_left_eq_sub",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommGroup G] (a b c : G), c + a - (c + b) = a - b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "of_eq_true",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "congr",
   "AddCommSemigroup.toAddSemigroup",
   "congrArg",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "Eq.trans",
   "True",
   "Eq"],
  "name": "add_add_add_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Distrib.rightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "add_mul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b c₁ a₂ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "inferInstance",
   "Rat.instLatticeRat",
   "Rat",
   "Lattice.toSemilatticeSup"],
  "name": "Rat.instSemilatticeSupRat",
  "constType": "SemilatticeSup ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Exists",
   "Fintype",
   "Set.coe_toFinset",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Finset",
   "Eq.refl",
   "Exists.intro",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.exists_finset_coe",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Finite s → ∃ s', ↑s' = s",
  "constCategory": "Theorem"},
 {"references":
  ["RelIso.toEquiv",
   "RelEmbedding",
   "Equiv.toEmbedding",
   "RelIso.map_rel_iff'",
   "RelIso",
   "RelEmbedding.mk"],
  "name": "RelIso.toRelEmbedding",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → r ↪r s",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], α → b ↔ b",
  "constCategory": "Theorem"},
 {"references": ["Lean.SourceInfo"],
  "name": "Lean.SourceInfo.none",
  "constType": "Lean.SourceInfo",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "CompleteLattice.sSup_le",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_13",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (s : Set (Submonoid M)) (a : Submonoid M), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "ENNReal",
   "OfNat.ofNat",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "One.toOfNat1",
   "MeasureTheory.IsProbabilityMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "Set.univ",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.IsProbabilityMeasure.measure_univ",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [self : MeasureTheory.IsProbabilityMeasure μ],\n  ↑↑μ Set.univ = 1",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "npowRec.match_1",
  "constType":
  "{M : Type u_2} →\n  (motive : ℕ → M → Sort u_1) →\n    (x : ℕ) → (x_1 : M) → ((x : M) → motive 0 x) → ((n : ℕ) → (a : M) → motive (Nat.succ n) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Filter.map",
   "Set",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_map",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, t ∈ Filter.map m f ↔ m ⁻¹' t ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Ne",
   "OfNat.ofNat",
   "Or",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mt",
   "Iff.mpr",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "not_or",
   "instHMul",
   "And",
   "HMul.hMul",
   "Not",
   "And.intro",
   "Mul"],
  "name": "mul_ne_zero",
  "constType":
  "∀ {M₀ : Type u_2} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : NoZeroDivisors M₀] {a b : M₀}, a ≠ 0 → b ≠ 0 → a * b ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "Multiset.sum", "Finset", "Finset.val", "AddCommMonoid"],
  "name": "Finset.sum",
  "constType":
  "{β : Type u} → {α : Type v} → [inst : AddCommMonoid β] → Finset α → (α → β) → β",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "instHasEquiv",
   "Classical.choose",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.lim",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] →\n        {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → [inst_3 : CauSeq.IsComplete β abv] → CauSeq β abv → β",
  "constCategory": "Definition"},
 {"references":
  ["Function.swap",
   "AddCommSemigroup.toAddCommMagma",
   "Covariant",
   "covariant_flip_iff",
   "flip",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommSemigroup",
   "AddCommMagma.to_isCommutative",
   "isSymmOp_of_isCommutative",
   "CovariantClass.mk",
   "AddCommMagma.toAdd",
   "Iff.mpr",
   "CovariantClass.elim"],
  "name": "covariant_swap_add_of_covariant_add",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) [inst : AddCommSemigroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "OrderedAddCommGroup",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "AddCommGroup.toAddGroup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "OrderedAddCommGroup.toAddCommGroup",
   "neg_nonpos"],
  "name": "neg_nonpos_of_nonneg",
  "constType":
  "∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 ≤ a → -a ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "Iff", "And.symm.match_1", "And.intro"],
  "name": "and_imp",
  "constType": "∀ {a b c : Prop}, a ∧ b → c ↔ a → b → c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid.zsmul_succ'",
   "Complex.addCommGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddCommGroup.toAddGroup",
   "Complex",
   "Nat",
   "Nat.succ",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "Complex.Complex.addGroupWithOne.proof_5",
  "constType":
  "∀ (n : ℕ) (a : ℂ), SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Exists",
   "Filter.EventuallyEq",
   "Measurable",
   "_auto._@.Mathlib.MeasureTheory.Measure.MeasureSpaceDef._hyg.15593",
   "MeasureTheory.Measure.ae",
   "autoParam",
   "MeasurableSpace"],
  "name": "AEMeasurable",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : MeasurableSpace β] → {_m : MeasurableSpace α} → (α → β) → autoParam (MeasureTheory.Measure α) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "Nat.linearOrderedCommSemiring.proof_3",
  "constType": "∀ (a b : ℕ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.inf_compl_le_bot",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_7",
  "constType": "∀ {α : Type u_1} (x : Set α), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toDistribLattice",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Probability.Independence.Kernel._hyg.658",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.Embedding.mk",
   "Equiv.injective",
   "Function.Embedding",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.toEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → α ↪ β",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "MeasureTheory.Measure.map",
   "ProbabilityTheory.IdentDistrib.aemeasurable_snd",
   "ProbabilityTheory.IdentDistrib.aemeasurable_fst",
   "ProbabilityTheory.IdentDistrib",
   "Eq.trans",
   "MeasurableSpace",
   "ProbabilityTheory.IdentDistrib.mk"],
  "name": "ProbabilityTheory.IdentDistrib.trans",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] [inst_3 : MeasurableSpace δ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β}\n  {f : α → γ} {g : β → γ} {ρ : MeasureTheory.Measure δ} {h : δ → γ},\n  ProbabilityTheory.IdentDistrib f g → ProbabilityTheory.IdentDistrib g h → ProbabilityTheory.IdentDistrib f h",
  "constCategory": "Theorem"},
 {"references": ["Subtype.val", "Subtype"],
  "name": "Subtype.property",
  "constType": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self",
  "constCategory": "Definition"},
 {"references": ["outParam", "RelHomClass", "LE", "LE.le"],
  "name": "OrderHomClass",
  "constType":
  "Type u_6 →\n  (α : outParam (Type u_7)) → (β : outParam (Type u_8)) → [inst : LE α] → [inst : LE β] → Type (max (max u_6 u_7) u_8)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Field",
   "Field.toInv",
   "Field.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "Field.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "NonAssocSemiring",
   "Eq",
   "Nat.cast_mul"],
  "name": "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑m * ↑n = ↑(m * n)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_eq_of_add",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), a + b = 0 → -a = b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Top.top",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "Top",
   "CompleteLattice",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.mk",
  "constType":
  "{α : Type u_9} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, a ≤ sSup s) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a) →\n          [toInfSet : InfSet α] →\n            (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) →\n                [toTop : Top α] → [toBot : Bot α] → (∀ (x : α), x ≤ ⊤) → (∀ (x : α), ⊥ ≤ x) → CompleteLattice α",
  "constCategory": "Other"},
 {"references": [],
  "name": "LinearOrderedCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "HSub.hSub",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GT.gt",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "LT.lt",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat"],
  "name": "IsCauSeq",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → {β : Type u_2} → [inst : Ring β] → (β → α) → (ℕ → β) → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "nsmulRec",
   "Eq",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "congr",
   "CauSeq.Completion.Cauchy",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Real.cauchy"],
  "name": "Real.commRing.proof_8",
  "constType": "∀ (a b c : ℝ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "Preorder"],
  "name": "lt_irrefl.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x : α) → x < x → Prop) (x : α) (x_1 : x < x),\n  (∀ (_a : α) (haa : _a < _a), motive _a haa) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "NormedField",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "SeminormedAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Module",
   "NormedSpace"],
  "name": "NormedSpace.toModule",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} → [inst : NormedField α] → [inst_1 : SeminormedAddCommGroup β] → [self : NormedSpace α β] → Module α β",
  "constCategory": "Definition"},
 {"references": ["Quot.ind", "Quot", "Quot.mk"],
  "name": "Quot.induction_on",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r), (∀ (a : α), β (Quot.mk r a)) → β q",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.below",
   "Nat.brecOn",
   "Nat.zero",
   "Bool.false",
   "Bool.true",
   "Unit",
   "PUnit",
   "Nat.beq.match_1",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.beq",
  "constType": "ℕ → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CanonicallyOrderedCommSemiring.toMul",
   "instHSMul",
   "MeasureTheory.Measure.map",
   "measurable_fst",
   "Set",
   "NonUnitalCommSemiring.toCommSemigroup",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.Measure.map_apply",
   "CommSemiring.toNonUnitalCommSemiring",
   "MeasureTheory.Measure.prod",
   "True",
   "Eq",
   "mul_comm",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "SProd.sprod",
   "HSMul.hSMul",
   "MeasurableSet",
   "Algebra.toSMul",
   "Eq.trans",
   "eq_self",
   "Set.instSProd",
   "IsScalarTower.right",
   "Set.preimage",
   "Prod.fst",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.SFinite",
   "Set.univ",
   "CommMagma.toMul",
   "Prod.instMeasurableSpace",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "Mathlib.MeasureTheory.Constructions.Prod.Basic._auxLemma.5",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "congr",
   "HMul.hMul",
   "Prod",
   "Algebra.id",
   "MeasureTheory.Measure.prod_prod",
   "congrArg",
   "MeasurableSpace",
   "MeasureTheory.Measure.ext"],
  "name": "MeasureTheory.Measure.map_fst_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν],\n  MeasureTheory.Measure.map Prod.fst (MeasureTheory.Measure.prod μ ν) = ↑↑ν Set.univ • μ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.mk", "Monotone", "OrderHom", "Preorder", "OrderHom.rec"],
  "name": "OrderHom.casesOn",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] →\n        {motive : (α →o β) → Sort u} →\n          (t : α →o β) →\n            ((toFun : α → β) → (monotone' : Monotone toFun) → motive { toFun := toFun, monotone' := monotone' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Field",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toInv",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "Field.inv_zero",
  "constType": "∀ {K : Type u} [self : Field K], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "MonoidWithZero.toMonoid",
   "instOfNatInt",
   "GroupWithZero",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "Int",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_zero'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), GroupWithZero.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Neg.toHasAbs",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "LinearOrderedRing.toLinearOrder",
   "SemilatticeSup.toSup",
   "Iff",
   "LinearOrderedRing",
   "abs_eq_zero",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AbsoluteValue.abs.proof_2",
  "constType":
  "∀ {S : Type u_1} [inst : LinearOrderedRing S] (x : S), |x| = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Subgroup.toGroup.proof_5",
   "Membership.mem",
   "Subgroup.div",
   "Subtype.val",
   "Subgroup.one",
   "Subgroup.toGroup.proof_4",
   "Function.Injective.group",
   "Subgroup.npow",
   "SetLike.instMembership",
   "Subgroup.toGroup.proof_7",
   "Subgroup.toGroup.proof_3",
   "Subgroup.toGroup.proof_1",
   "Subgroup",
   "Subgroup.toGroup.proof_2",
   "Group",
   "Subgroup.inv",
   "Subgroup.mul",
   "Subgroup.zpow",
   "Subtype",
   "Subgroup.toGroup.proof_6",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.toGroup",
  "constType":
  "{G : Type u_5} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
  "constCategory": "Definition"},
 {"references":
  ["AddOpposite.addMonoid.proof_5",
   "instHSMul",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "AddOpposite.addMonoid.proof_4",
   "AddMonoid.toAddZeroClass",
   "AddSemigroup",
   "AddMonoid",
   "AddMonoid.mk",
   "AddMonoid.toNatSMul",
   "AddOpposite.addSemigroup",
   "AddZeroClass.toZero",
   "AddOpposite.unop",
   "AddOpposite.addMonoid.proof_3",
   "AddMonoid.toAddSemigroup",
   "AddOpposite.op",
   "AddOpposite.addMonoid.proof_1",
   "HSMul.hSMul",
   "AddOpposite",
   "AddOpposite.addZeroClass",
   "AddOpposite.addMonoid.proof_2",
   "Nat",
   "AddZeroClass"],
  "name": "AddOpposite.addMonoid",
  "constType": "(α : Type u) → [inst : AddMonoid α] → AddMonoid αᵃᵒᵖ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references": ["MetricSpace", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toMetricSpace",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → MetricSpace E",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.38",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["RelEmbedding.instRelHomClassRelEmbedding.proof_2",
   "Function.Embedding.toFun",
   "RelEmbedding",
   "RelEmbedding.instRelHomClassRelEmbedding.proof_1",
   "RelHomClass",
   "FunLike.mk",
   "RelEmbedding.toEmbedding",
   "RelHomClass.mk"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → RelHomClass (r ↪r s) r s",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mul_pos",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Rat.instLERat",
   "Max.mk",
   "Iff.rfl",
   "Rat.not_le",
   "Eq.refl",
   "Preorder.toLE",
   "ite",
   "Eq",
   "Rat.le_antisymm",
   "inferInstance",
   "Eq.mpr",
   "Rat.le_refl",
   "Iff",
   "Decidable",
   "Eq.symm",
   "Rat.le_trans",
   "id",
   "Rat",
   "and_iff_right_of_imp",
   "LE.le",
   "Preorder.mk",
   "Rat.instLTRat",
   "Or.resolve_left",
   "And",
   "Eq.ndrec",
   "Rat.instDecidableLeRatInstLERat",
   "propext",
   "LT.lt",
   "Max.max",
   "Not",
   "Rat.le_total"],
  "name": "Rat.linearOrder.proof_3",
  "constType": "∀ (a b : ℚ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Prod.mk",
   "Eq.refl",
   "Prod",
   "Eq.casesOn",
   "And.intro",
   "Eq.symm",
   "And.casesOn",
   "Eq.propIntro",
   "Prod.noConfusion",
   "Eq"],
  "name": "Prod.mk.injEq",
  "constType":
  "∀ {α : Type u} {β : Type v} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),\n  ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real.instAddReal",
   "Real.instAddMonoidReal",
   "AddGroup.toSubtractionMonoid",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "Real.instOneReal",
   "Eq",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Real.linearOrder",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "Mathlib.Tactic.Ring.neg_congr",
   "MonoidWithZero.toMonoid",
   "le_of_not_gt",
   "Real.instCommSemiringReal",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Nat.cast_one",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Real.partialOrder",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.instRingReal",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Eq.mp",
   "Real.instAddGroupReal",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "LinearOrder.toPartialOrder",
   "Int",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "sub_nonpos_of_le",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Linarith.lt_irrefl",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Mathlib.Tactic.Ring.sub_congr",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Ring.toNonAssocRing",
   "Mathlib.Tactic.Ring.sub_pf",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "instHPow",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "neg_nonpos_of_nonneg",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "_private.Mathlib.Data.Complex.Exponential.0.Real.add_one_le_exp_of_nonneg",
   "Mathlib.Tactic.Ring.cast_pos",
   "HSub.hSub",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "One.toOfNat1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Real.exp",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "sub_neg_of_lt",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.one_le_exp",
  "constType": "∀ {x : ℝ}, 0 ≤ x → 1 ≤ Real.exp x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "AddSubgroup.add",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x + x_1) = ↑(x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.decidableMem",
   "DecidableEq",
   "Decidable",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset"],
  "name": "Finset.decidableMem",
  "constType":
  "{α : Type u_1} → [_h : DecidableEq α] → (a : α) → (s : Finset α) → Decidable (a ∈ s)",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Finset.card",
   "Prod.snd",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Prod.fst",
   "Set.InjOn",
   "Eq",
   "Finset.card_image₂_iff",
   "instHMul",
   "Iff",
   "DecidableEq",
   "Finset.toSet",
   "SProd.sprod",
   "Finset",
   "HMul.hMul",
   "Prod",
   "Add",
   "Nat",
   "instMulNat",
   "Finset.add"],
  "name": "Finset.card_add_iff",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] {s t : Finset α},\n  Finset.card (s + t) = Finset.card s * Finset.card t ↔ Set.InjOn (fun p => p.1 + p.2) (↑s ×ˢ ↑t)",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "SMul", "SMul.mk", "HMul.hMul", "Mul"],
  "name": "Mul.toSMul",
  "constType": "(α : Type u_10) → [inst : Mul α] → SMul α α",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "autoParam",
   "AddMonoid",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "AddMonoidWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toNatCast : NatCast R] →\n    [toAddMonoid : AddMonoid R] →\n      [toOne : One R] →\n        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ → AddMonoidWithOne R",
  "constCategory": "Other"},
 {"references": ["Monoid"],
  "name": "MulAction",
  "constType":
  "(α : Type u_10) → Type u_11 → [inst : Monoid α] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_1} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_irrefl.match_1",
   "False",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "lt_irrefl.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "VSub"],
  "name": "VSub.mk",
  "constType":
  "{G : outParam (Type u_1)} → {P : Type u_2} → (P → P → G) → VSub G P",
  "constCategory": "Other"},
 {"references":
  ["IntCast.mk", "Int.negSucc", "Nat", "Int", "rfl", "IntCast.intCast", "Eq"],
  "name": "Int.instCommRingInt.proof_9",
  "constType":
  "∀ (x : ℕ), IntCast.intCast (Int.negSucc x) = IntCast.intCast (Int.negSucc x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "ENNReal",
   "OfNat.ofNat",
   "WithTop.untop'",
   "instNNRealZero",
   "NNReal"],
  "name": "ENNReal.toNNReal",
  "constType": "ENNReal → NNReal",
  "constCategory": "Definition"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "InvOneClass.toOne",
   "OfNat.ofNat",
   "Bot.bot",
   "Iff",
   "DivInvOneMonoid.toInvOneClass",
   "Iff.rfl",
   "Subgroup.instBotSubgroup",
   "Subgroup",
   "One.toOfNat1",
   "Group",
   "DivisionMonoid.toDivInvOneMonoid",
   "SetLike.instMembership",
   "Eq",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.mem_bot",
  "constType": "∀ {G : Type u_1} [inst : Group G] {x : G}, x ∈ ⊥ ↔ x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toField",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "Semifield.toCommSemiring",
   "NormedField",
   "Algebra",
   "Field.toSemifield",
   "NormedAlgebra",
   "Ring.toSemiring"],
  "name": "NormedAlgebra.toAlgebra",
  "constType":
  "{𝕜 : Type u_5} →\n  {𝕜' : Type u_6} → [inst : NormedField 𝕜] → [inst_1 : SeminormedRing 𝕜'] → [self : NormedAlgebra 𝕜 𝕜'] → Algebra 𝕜 𝕜'",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.natAbs",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "SubNegMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "Nat.cast_nonneg",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "eq_true",
   "Nat.cast",
   "OrderedSemiring.toSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.2",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), (0 ≤ ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "StrictOrderedCommSemiring.mk",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrder.max_def",
   "Nat.linearOrderedCommSemiring.proof_6",
   "LT.mk",
   "Preorder.toLE",
   "Nat.add_le_add_left",
   "Nat.linearOrder",
   "Nat.linearOrderedCommSemiring.proof_5",
   "StrictOrderedSemiring.mk",
   "Nat.le_of_add_le_add_left",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "CommSemiring",
   "Nat.mul_lt_mul_of_pos_right",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Nat",
   "Nat.linearOrderedCommSemiring.proof_3",
   "LinearOrder",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Nat.lt",
   "LinearOrderedCommSemiring",
   "Nat.linearOrderedCommSemiring.proof_1",
   "Preorder.mk",
   "LinearOrder.toOrd",
   "Nat.commSemiring",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "LinearOrder.toPartialOrder",
   "Nat.linearOrderedCommSemiring.proof_2",
   "Nat.linearOrderedCommSemiring.proof_4",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.linearOrderedCommSemiring",
  "constType": "LinearOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom.toFun", "ZeroHom", "Eq"],
  "name": "ZeroHom.map_zero'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ZeroHom.toFun self 0 = 0",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasureTheory.OuterMeasure",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Max"],
  "name": "LinearOrderedAddCommGroup.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Top.top",
   "Subgroup.instTopSubgroup",
   "Subgroup",
   "Group",
   "Set.mem_univ",
   "SetLike.instMembership",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.mem_top",
  "constType": "∀ {G : Type u_1} [inst : Group G] (x : G), x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "dite",
   "add_tsub_cancel_of_le",
   "instLTNat",
   "Iff.mpr",
   "Preorder.toLE",
   "ite",
   "Eq",
   "Nat.linearOrder",
   "Eq.mpr",
   "le_of_not_gt",
   "Nat",
   "Eq.trans",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "add_assoc",
   "Prod.snd",
   "Nat.sqrt_le_add",
   "Nat.canonicallyOrderedCommSemiring",
   "Prod.fst",
   "AddCommMagma.toAdd",
   "instDecidableTrue",
   "instDecidableFalse",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "Nat.sqrt",
   "Nat.orderedSemiring",
   "LT.lt",
   "congr",
   "LinearOrder.toPartialOrder",
   "Not",
   "congrArg",
   "congrFun",
   "Nat.unpair",
   "instSubNat",
   "Nat.decLt",
   "Nat.addSemigroup",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "tsub_le_iff_left",
   "Nat.sqrt_le",
   "True",
   "instLENat",
   "Preorder.toLT",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Eq.symm",
   "if_neg",
   "id",
   "Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat",
   "eq_self",
   "False",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "Nat.pair",
   "HSub.hSub",
   "Nat.addCommSemigroup",
   "LE.le",
   "ite_congr",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "eq_false",
   "if_pos",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "LE.le.not_lt",
   "Prod.mk",
   "letFun",
   "HMul.hMul",
   "Prod",
   "instMulNat"],
  "name": "Nat.pair_unpair",
  "constType": "∀ (n : ℕ), Nat.pair (Nat.unpair n).1 (Nat.unpair n).2 = n",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "Set.iUnion",
   "iSup_const",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Nonempty",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "Set.iUnion_const",
  "constType":
  "∀ {β : Type u_2} {ι : Sort u_4} [inst : Nonempty ι] (s : Set β), ⋃ x, s = s",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MeasureTheory.MeasureSpace.mk",
   "AddCommGroup.toAddCommMonoid",
   "MeasureTheory.IsProbabilityMeasure",
   "Real.instOneReal",
   "Eq",
   "DiscreteMeasurableSpace.toMeasurableAdd₂",
   "MeasurableSingletonClass",
   "Fintype",
   "Eq.mpr",
   "rdist",
   "HDiv.hDiv",
   "Nat",
   "instOfNat",
   "Finite.to_countable",
   "instHDiv",
   "ProbabilityTheory.IdentDistrib",
   "AddCommMagma.toAdd",
   "Prod.instMeasurableSpace",
   "And",
   "propext",
   "Eq.mp",
   "instNatAtLeastTwo",
   "Matrix.vecCons",
   "AddCommGroup",
   "Prod.instMeasurableSingletonClass",
   "MeasurableSpace",
   "Finite.of_fintype",
   "Fin",
   "Exists",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "refPackage.η",
   "Real",
   "Eq.refl",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "MeasureTheory.MeasureSpace.volume",
   "tau_minimizes",
   "LinearOrderedField.toDiv",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ProbabilityTheory.IdentDistrib.trans",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "tau_strictly_decreases_aux",
   "instOfNatNat",
   "Measurable",
   "Eq.symm",
   "Nat.succ",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "refPackage",
   "ProbabilityTheory.IdentDistrib.symm",
   "One.toOfNat1",
   "instCountableProd",
   "Matrix.vecEmpty",
   "ProbabilityTheory.independent_copies4_nondep",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Eq.ndrec",
   "MeasureTheory.MeasureSpace",
   "tau_strictly_decreases.match_1",
   "letFun",
   "ProbabilityTheory.iIndepFun",
   "Prod",
   "ElementaryAddCommGroup",
   "ProbabilityTheory.IdentDistrib.tau_minimizes"],
  "name": "tau_strictly_decreases",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {Ω : Type u_3} [mΩ : MeasureTheory.MeasureSpace Ω] [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_4 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [inst_5 : AddCommGroup G]\n  [inst_6 : ElementaryAddCommGroup G 2] [inst_7 : Fintype G] [inst_8 : MeasurableSpace G]\n  [inst_9 : MeasurableSingletonClass G] (p : refPackage Ω₀₁ Ω₀₂ G) {X₁ X₂ : Ω → G},\n  Measurable X₁ → Measurable X₂ → tau_minimizes p X₁ X₂ → p.η = 1 / 9 → d[X₁ # X₂] = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.natAbs_mul_self.match_1",
   "Or",
   "Or.inl",
   "Nat.cast",
   "Or.inr",
   "instNatCastInt",
   "Int.negSucc",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "rfl",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.natAbs_eq",
  "constType": "∀ (a : ℤ), a = ↑(Int.natAbs a) ∨ a = -↑(Int.natAbs a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.toZero",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "CommMonoidWithZero.toCommMonoid",
   "CommGroupWithZero.inv_zero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toNontrivial",
   "CommGroupWithZero.zpow_succ'",
   "CommGroupWithZero.div_eq_mul_inv",
   "CommMonoidWithZero.zero_mul",
   "MonoidWithZero.mk",
   "CommGroupWithZero.toDiv",
   "GroupWithZero",
   "GroupWithZero.mk",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toGroupWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → GroupWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α] (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_6",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Distrib",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.ext_cauchy",
   "AddMonoid.toAddZeroClass",
   "True",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Real.cauchy_zero",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "Rat.instNegRat",
   "Eq.trans",
   "Add.mk",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "add_assoc",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "CauSeq.Completion.Cauchy.ring",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "congr",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "congrFun"],
  "name": "Real.commRing.proof_2",
  "constType": "∀ (a : ℝ), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Acc"],
  "name": "Acc.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop} (x : α), (∀ (y : α), r y x → Acc r y) → Acc r x",
  "constCategory": "Other"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instAddNat",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "Eq",
   "AddGroupWithOne.intCast_negSucc",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Int.cast",
   "Int.negSucc",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat"],
  "name": "Int.cast_negSucc",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑(Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Eq"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
  "constType":
  "∀ {α : Type u_1} (a b : MeasurableSpace α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "of_eq_true",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommGroup",
   "congrArg",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "True",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun",
   "Eq"],
  "name": "Mathlib.Tactic.Abel.subst_into_negg",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (a ta t : α), a = ta → -ta = t → -a = t",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "Multiplicative",
   "AddGroup",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq",
   "Multiplicative.divInvMonoid"],
  "name": "Multiplicative.group.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] (a b : Multiplicative α), a / b = a * b⁻¹",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Nontrivial"],
  "name": "GroupWithZero.toNontrivial",
  "constType": "∀ {G₀ : Type u} [self : GroupWithZero G₀], Nontrivial G₀",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Real.exp_log_eq_abs",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Eq",
   "Real.instNegReal",
   "Real.exp_injective",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "Lattice.toSemilatticeSup",
   "LinearOrderedRing.noZeroDivisors",
   "Real.exp_add",
   "id",
   "Neg.toHasAbs",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "instHAdd",
   "instDistribLattice",
   "mul_ne_zero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.exp",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "instHMul",
   "Real.log",
   "Eq.ndrec",
   "abs_mul",
   "HMul.hMul"],
  "name": "Real.log_mul",
  "constType":
  "∀ {x y : ℝ}, x ≠ 0 → y ≠ 0 → Real.log (x * y) = Real.log x + Real.log y",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Rat",
   "_auto._@.Std.Data.Rat.Basic._hyg.27",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "Int",
   "_auto._@.Std.Data.Rat.Basic._hyg.4",
   "Int.natAbs"],
  "name": "Rat.mk'",
  "constType":
  "(num : ℤ) → (den : ℕ) → autoParam (den ≠ 0) _auto✝ → autoParam (Nat.Coprime (Int.natAbs num) den) _auto✝¹ → ℚ",
  "constCategory": "Other"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "Min.mk",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "inf_eq_minDefault",
   "Lattice.toInf",
   "IsTotal",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Theorem"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "IntCast"],
  "name": "AddGroupWithOne.toIntCast",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → IntCast R",
  "constCategory": "Definition"},
 {"references": ["SMul", "instHSMul", "HSMul.hSMul", "IsScalarTower", "Eq"],
  "name": "IsScalarTower.mk",
  "constType":
  "∀ {M : Type u_10} {N : Type u_11} {α : Type u_12} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α],\n  (∀ (x : M) (y : N) (z : α), (x • y) • z = x • y • z) → IsScalarTower M N α",
  "constCategory": "Other"},
 {"references": ["instHSub", "HSub.hSub", "Sub", "Sub.mk"],
  "name": "Pi.instSub",
  "constType":
  "{I : Type u} → {f : I → Type v₁} → [inst : (i : I) → Sub (f i)] → Sub ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["Trans",
   "lt_of_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLeToLELtToLT",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LT.lt LT.lt",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "Preorder.lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "True",
   "max_def",
   "Eq",
   "ite",
   "le_of_not_le",
   "Eq.mpr",
   "if_pos",
   "of_eq_true",
   "Max.max",
   "LinearOrder.toMax",
   "Decidable",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_max_right",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), b ≤ max a b",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "div_eq_mul_inv",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Eq",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Rat.rawCast",
   "HDiv.hDiv",
   "Nat",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "Invertible.invOf",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.to_raw_eq.match_1",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "Int.cast",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {n : ℤ} {d : ℕ} [inst : DivisionRing α] {a : α}, Mathlib.Meta.NormNum.IsRat a n d → a = Rat.rawCast n d",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real",
   "Set",
   "MeasureTheory.Measure.real",
   "ENNReal.toReal",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.measureReal_def",
  "constType":
  "∀ {α : Type u_1} {x : MeasurableSpace α} (μ : MeasureTheory.Measure α) (s : Set α), μ.real s = (↑↑μ s).toReal",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg.toNeg",
   "Set",
   "InvolutiveNeg.neg_neg",
   "Neg.neg",
   "SubtractionMonoid",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_10",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (x : Set α), - -x = x",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Neg.toHasAbs",
   "LT.lt.ne'",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Real.exp_log_eq_abs",
   "Real.exp",
   "Abs.abs",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.linearOrder",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "abs_of_pos",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "id"],
  "name": "Real.exp_log",
  "constType": "∀ {x : ℝ}, 0 < x → Real.exp (Real.log x) = x",
  "constCategory": "Theorem"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.iUnion",
   "propext",
   "Set",
   "Set.mem_iUnion",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Lattice._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Real.instLTReal",
   "Iff.rfl",
   "Real.exp_le_exp",
   "Real",
   "Real.instLEReal",
   "Eq.refl",
   "LE.le",
   "Real.exp",
   "Eq",
   "Real.exp_log",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Eq.mpr",
   "Real.log",
   "Iff",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Eq.symm",
   "id"],
  "name": "Real.log_le_log_iff",
  "constType": "∀ {x y : ℝ}, 0 < x → 0 < y → (Real.log x ≤ Real.log y ↔ x ≤ y)",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "MeasurableSpace.instLEMeasurableSpace",
   "MeasurableSpace.map",
   "Measurable",
   "MeasurableSpace.comap",
   "LE.le",
   "MeasurableSpace",
   "MeasurableSpace.comap_le_iff_le_map",
   "Iff.mpr"],
  "name": "Measurable.of_comap_le",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m₁ : MeasurableSpace α} {m₂ : MeasurableSpace β} {f : α → β},\n  MeasurableSpace.comap f m₂ ≤ m₁ → Measurable f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Function.minimalPeriod",
   "dif_pos",
   "Nat.decLt",
   "Set",
   "Classical.propDecidable",
   "dite",
   "instDecidableAnd",
   "Function.isPeriodicPt_zero",
   "instLTNat",
   "Eq",
   "Set.instMembershipSet",
   "GT.gt",
   "And",
   "Nat.find_spec",
   "And.right",
   "Eq.mpr",
   "Function.IsPeriodicPt.instDecidableIsPeriodicPt",
   "dif_neg",
   "Function.IsPeriodicPt",
   "Nat.find",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Function.periodicPts",
   "congrFun",
   "id"],
  "name": "Function.isPeriodicPt_minimalPeriod",
  "constType":
  "∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f (Function.minimalPeriod f x) x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_7",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.MeasurableSet'",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "MeasurableSpace"],
  "name": "MeasurableSpace.measurableSet_compl",
  "constType":
  "∀ {α : Type u_7} (self : MeasurableSpace α) (s : Set α),\n  MeasurableSpace.MeasurableSet' self s → MeasurableSpace.MeasurableSet' self sᶜ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Ne",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid.toOne",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Inv.inv"],
  "name": "CommGroupWithZero.mul_inv_cancel",
  "constType":
  "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀] (a : G₀), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Filter.mem_of_superset",
   "Filter",
   "Set.univ",
   "Filter.univ_mem",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.univ_mem'",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s : Set α}, (∀ (a : α), a ∈ s) → s ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Div",
   "HDiv.hDiv",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoidWithZero",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "Nontrivial",
   "Int",
   "Inv.inv"],
  "name": "CommGroupWithZero.mk",
  "constType":
  "{G₀ : Type u_4} →\n  [toCommMonoidWithZero : CommMonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → CommGroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "AddMonoidHomClass.toZeroHomClass",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "Nat.cast_zero",
   "Eq",
   "eq_natCast'.match_1",
   "Zero.toOfNat0",
   "PProd",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "PUnit",
   "map_zero",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "Nat.cast_one",
   "id",
   "eq_self",
   "Nat.below",
   "Nat.brecOn",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Unit",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "map_add",
   "FunLike.coe",
   "AddMonoidHomClass",
   "Nat.cast_add",
   "AddMonoidWithOne",
   "Nat.rec",
   "PProd.fst",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "congr",
   "AddMonoidHomClass.toAddHomClass",
   "congrArg"],
  "name": "map_natCast'",
  "constType":
  "∀ {B : Type u_4} {F : Type u_5} [inst : AddMonoidWithOne B] {A : Type u_6} [inst_1 : AddMonoidWithOne A]\n  [inst_2 : AddMonoidHomClass F A B] (f : F), f 1 = 1 → ∀ (n : ℕ), f ↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "zero_add",
   "instHMul",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Multiplicative",
   "MulOneClass",
   "Multiplicative.mul",
   "One.mk",
   "HMul.hMul",
   "One.toOfNat1",
   "add_zero",
   "MulOneClass.mk",
   "AddZeroClass",
   "instOneMultiplicative",
   "Mul.mk"],
  "name": "Multiplicative.mulOneClass",
  "constType":
  "{α : Type u} → [inst : AddZeroClass α] → MulOneClass (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_7",
  "constType": "∀ (a : ℕ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing",
   "Monoid.mk",
   "DivisionRing.div_eq_mul_inv",
   "NonUnitalSemiring.mul_assoc",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.zpow_zero'",
   "DivInvMonoid",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "DivInvMonoid.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toInv",
   "Semiring.toOne",
   "Semiring.npow",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toDiv",
   "Semigroup.mk"],
  "name": "DivisionRing.toDivInvMonoid",
  "constType": "{K : Type u} → [self : DivisionRing K] → DivInvMonoid K",
  "constCategory": "Definition"},
 {"references":
  ["CoheytingAlgebra",
   "BiheytingAlgebra.sdiff_le_iff",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "GeneralizedCoheytingAlgebra.mk",
   "BiheytingAlgebra.top_sdiff",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "CoheytingAlgebra.mk",
   "BiheytingAlgebra.toSDiff",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra"],
  "name": "BiheytingAlgebra.toCoheytingAlgebra",
  "constType":
  "{α : Type u_2} → [inst : BiheytingAlgebra α] → CoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instDecidableEq",
   "SubNegMonoid.toNeg",
   "AddCommGroup.toAddCommMonoid",
   "MeasureTheory.IsProbabilityMeasure",
   "measurableSet_discrete",
   "SubNegMonoid.toSub",
   "Pi.instAdd",
   "MeasureTheory.OuterMeasure.measureOf",
   "Measurable.aemeasurable",
   "HSMul.hSMul",
   "MulActionWithZero.toMulAction",
   "instHSub",
   "IsScalarTower.right",
   "eq_of_heq",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "Module.toMulActionWithZero",
   "instENNRealZero",
   "AddCommMagma.toAdd",
   "And",
   "MeasureTheory.Measure.toOuterMeasure",
   "And.intro",
   "AddCommGroup",
   "Finite.of_fintype",
   "MeasurableSpace",
   "SetLike.coe",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "HEq",
   "Real",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "DiscreteMeasurableSpace.toMeasurableSub",
   "MeasureTheory.Measure.instModule",
   "Measurable",
   "Measurable.sub_const",
   "Decidable.byContradiction",
   "MeasureTheory.IsProbabilityMeasure.ne_zero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Semiring.toModule",
   "Finset.sum",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "MeasureTheory.Measure.dirac",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Eq.ndrec",
   "MeasureTheory.Measure.instZero",
   "letFun",
   "NegZeroClass.toNeg",
   "MeasureTheory.Measure.sum",
   "instHSMul",
   "HAdd.hAdd",
   "MeasureTheory.Measure.map_apply",
   "sub_eq_add_neg",
   "rdist_add_const",
   "Finset.sum_const_zero",
   "Exists.casesOn",
   "autoParam",
   "Eq",
   "symmGroup",
   "MeasurableSingletonClass",
   "ENNReal",
   "Eq.mpr",
   "Fintype",
   "rdist",
   "MonoidWithZero.toMonoid",
   "instLinearOrder",
   "MonoidWithZero.toMulActionWithZero",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Algebra.toSMul",
   "Eq.trans",
   "Mathlib.Tactic.PushNeg.not_exists_eq",
   "Finite.to_countable",
   "Ne",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.407",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "MeasureTheory.Measure.sum_smul_dirac",
   "Finset.univ",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulActionWithZero.toSMulWithZero",
   "HEq.refl",
   "of_eq_true",
   "Fintype.decidableExistsFintype",
   "Eq.mp",
   "Not",
   "Singleton.singleton",
   "Algebra.id",
   "congrArg",
   "zero_smul",
   "Mathlib.Tactic.PushNeg.not_ne_eq",
   "MeasureTheory.isProbabilityMeasure_map",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasurableSub₂",
   "MeasureTheory.MeasureSpace.volume",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Set.instSingletonSet",
   "instFiniteRange",
   "forall_congr",
   "instDecidableNot",
   "IsScalarTower.left",
   "AddMonoid.toZero",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "eq_self",
   "funext",
   "False",
   "Set.preimage",
   "instHAdd",
   "MeasureTheory.Measure.sum_fintype",
   "HSub.hSub",
   "isUniform_sub_const_of_rdist_eq_zero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddGroup.toSubNegMonoid",
   "MeasurableAdd₂",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "SubNegMonoid.toAddMonoid",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Eq.casesOn",
   "ProbabilityTheory.IsUniform",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.380"],
  "name": "exists_isUniform_of_rdist_self_eq_zero",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} [inst : MeasureTheory.MeasureSpace Ω]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [inst_2 : AddCommGroup G] [inst_3 : Fintype G]\n  [inst_4 : MeasurableSpace G] [inst_5 : MeasurableAdd₂ G] [inst_6 : MeasurableSub₂ G] {X : Ω → G}\n  [inst_7 : MeasurableSingletonClass G],\n  Measurable X → d[X # X] = 0 → ∃ H U, Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ d[X # U] = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "mul_lt_mul_of_pos_left",
   "congrArg",
   "MulZeroClass.toMul"],
  "name": "mul_neg_of_pos_of_neg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → b < 0 → a * b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.partialOrder.proof_2",
   "Pi.partialOrder.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Pi.partialOrder.proof_3",
   "Preorder.toLT",
   "Pi.preorder",
   "Pi.partialOrder.proof_1",
   "Preorder",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "Pi.partialOrder",
  "constType":
  "{ι : Type u_1} → {π : ι → Type u_2} → [inst : (i : ι) → PartialOrder (π i)] → PartialOrder ((i : ι) → π i)",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_refl",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
  "constType": "∀ {α : Type u_1} (a : MeasurableSpace α), a ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "FiniteRange",
  "constType": "{Ω : Type u_1} → {G : Type u_2} → (Ω → G) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Filter",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "UniformSpace.ofDist",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "uniformity",
   "of_eq_true",
   "Real.instAddGroupReal",
   "Prod",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_4",
  "constType": "uniformity ℝ = uniformity ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.ble",
   "False",
   "instLENat",
   "Bool.true",
   "Not",
   "Bool",
   "Nat",
   "Nat.ble_eq_true_of_le",
   "absurd",
   "LE.le",
   "Eq"],
  "name": "Nat.not_le_of_not_ble_eq_true",
  "constType": "∀ {n m : ℕ}, ¬Nat.ble n m = true → ¬n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Classical.choose_spec",
   "Ne",
   "funext",
   "Or",
   "False",
   "Classical.choose",
   "Or.inr",
   "Eq.refl",
   "Exists.intro",
   "Init.Classical._auxLemma.1",
   "mt",
   "rfl",
   "True",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Or.inl",
   "of_eq_true",
   "propext",
   "Classical.em.match_2",
   "letFun",
   "congr",
   "Not",
   "Classical.em.match_1",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "Classical.em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.Measure.map",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.preimage",
   "MeasureTheory.Measure.toOuterMeasure",
   "Measurable.aemeasurable",
   "Set",
   "MeasurableSet",
   "Measurable",
   "MeasureTheory.Measure.map_apply_of_aemeasurable",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.Measure.map_apply",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {f : α → β}, Measurable f → ∀ {s : Set β}, MeasurableSet s → ↑↑(MeasureTheory.Measure.map f μ) s = ↑↑μ (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Set",
   "And.left",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_9",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (x x_1 : AddSubmonoid M) (x_2 : M), x_2 ∈ ↑x ∧ x_2 ∈ ↑x_1 → x_2 ∈ ↑x",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "AbsoluteValue",
  "constType":
  "(R : Type u_1) → (S : Type u_2) → [inst : Semiring R] → [inst : OrderedSemiring S] → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "StrictMonoOn",
   "Set",
   "StrictMono",
   "Preorder",
   "StrictMono.imp",
   "Set.instMembershipSet"],
  "name": "StrictMono.strictMonoOn",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → ∀ (s : Set α), StrictMonoOn f s",
  "constCategory": "Theorem"},
 {"references": ["LE", "le_of_le_of_eq", "LE.le", "Eq"],
  "name": "LE.le.trans_eq",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.mp",
   "Iff",
   "Preorder.toLT",
   "lt_iff_lt_of_le_iff_le'",
   "LT.lt",
   "StrictMono",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "strictMono_of_le_iff_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  (∀ (x y : α), x ≤ y ↔ f x ≤ f y) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "Monoid.mk",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Semiring.npow_succ",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "HDiv.hDiv",
   "Real.strictOrderedRing",
   "Semigroup.mk",
   "StrictOrderedRing.toPartialOrder",
   "instHDiv",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "DivInvMonoid.div'",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_6",
  "constType": "∀ (a b : ℝ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CanonicallyOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "instTransLeToLE",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "add_le_add_left",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "instTransEq_1",
   "CovariantClass",
   "add_zero",
   "AddZeroClass"],
  "name": "add_le_of_le_of_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, b ≤ c → a ≤ 0 → b + a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "div_eq_mul_inv",
   "Semiring.toMonoidWithZero",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "invertibleOfNonzero",
   "Semiring.toNatCast",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Rat.rawCast",
   "HDiv.hDiv",
   "Nat",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "Ne",
   "Invertible.invOf",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "DivInvMonoid.toInv",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "of_eq_true",
   "Int.cast",
   "letFun",
   "congr",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : DivisionRing α] (n : ℤ) (d : ℕ), ↑d ≠ 0 → Mathlib.Meta.NormNum.IsRat (Rat.rawCast n d) n d",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.zero_le_one",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Int.casesOn",
   "Int.ofNat",
   "Int.negSucc",
   "Unit",
   "Unit.unit",
   "Nat",
   "Nat.succ",
   "Int",
   "Nat.casesOn"],
  "name": "Int.cast_neg.match_1",
  "constType":
  "∀ (motive : ℤ → Prop) (x : ℤ),\n  (Unit → motive (Int.ofNat 0)) →\n    (∀ (n : ℕ), motive (Int.ofNat (Nat.succ n))) → (∀ (n : ℕ), motive (Int.negSucc n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.commRing",
   "Eq",
   "Real.instOneReal",
   "Eq.mpr",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "Eq.trans",
   "Ne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.ofCauchy.injEq",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "CommMagma.toMul",
   "CauSeq.Completion.inv_mul_cancel",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Mathlib.Data.Real.Basic._auxLemma.18",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Not",
   "LinearOrderedCommRing.mul_comm",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "Abs.abs",
   "Inv.mk",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "mul_comm",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "CauSeq.Completion.instMulCauchy",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "Real.instZeroReal",
   "Eq.ndrec",
   "Mathlib.Data.Real.Basic._auxLemma.3",
   "Rat.divisionRing",
   "LinearOrderedCommRing.mk",
   "Real.linearOrderedCommRing",
   "Real.casesOn",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Real.instLinearOrderedFieldReal.proof_10",
  "constType": "∀ (a : ℝ), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toNatCast",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "LinearOrderedField.toRatCast",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Int.natAbs"],
  "name": "LinearOrderedField.ratCast_mk",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Or",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Order.Basic._auxLemma.1",
   "Or.casesOn",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "instHMul",
   "Decidable.eq_or_lt_of_le",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "le_refl",
   "mul_lt_mul_of_pos_right",
   "congr",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] (a b c : α),\n  a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.succ_le_succ.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (x : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m x",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal.toRealHom",
   "CanonicallyOrderedCommSemiring.toMul",
   "MulZeroOneClass.toMulOneClass",
   "Real.instMulReal",
   "Real",
   "NonAssocSemiring.toMulZeroOneClass",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "ENNReal.toReal",
   "MonoidHom.map_mul"],
  "name": "ENNReal.toReal_mul",
  "constType": "∀ {a b : ENNReal}, (a * b).toReal = a.toReal * b.toReal",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "Fin.elim0'", "instOfNatNat", "Nat", "Fin"],
  "name": "Matrix.vecEmpty",
  "constType": "{α : Type u} → Fin 0 → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "SemiconjBy",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "SemiconjBy.one_right",
   "Eq.symm"],
  "name": "SemiconjBy.one_left",
  "constType":
  "∀ {M : Type u_2} [inst : MulOneClass M] (x : M), SemiconjBy 1 x x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "NormedRing.toNorm",
   "PseudoMetricSpace.toDist",
   "NormedRing.dist_eq",
   "NormedCommRing",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NormedRing.toMetricSpace",
   "NormedRing.toRing",
   "Dist.dist",
   "Eq"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_2",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), 0 + a = a",
  "constCategory": "Theorem"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "add_sub_cancel'",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "Eq.symm",
   "add_sub_assoc",
   "id"],
  "name": "add_sub_cancel'_right",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a + (b - a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_9",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "And.right", "Iff", "And.intro"],
  "name": "and_iff_right_of_imp",
  "constType": "∀ {b a : Prop}, (b → a) → (a ∧ b ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_13",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_8",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_9",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_7",
   "Lattice.mk",
   "LT.mk",
   "SetLike.instMembership",
   "Preorder.toLE",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_5",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_14",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_10",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_6",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_3",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_12",
   "AddSubmonoid.mem_top",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_4",
   "Top.top",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_11",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_2",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_16",
   "SemilatticeSup.mk",
   "completeLatticeOfInf",
   "AddSubmonoid",
   "LE.le",
   "Preorder.mk",
   "InfSet.mk",
   "SetLike.instPartialOrder",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "CompleteLattice",
   "LT.lt",
   "Bot.mk",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_15",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Top.mk",
   "AddSubmonoid.instInfAddSubmonoid"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → CompleteLattice (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": ["Set.preimage", "Set", "Neg.neg", "Neg.mk", "Neg"],
  "name": "Set.neg",
  "constType": "{α : Type u_2} → [inst : Neg α] → Neg (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "instHDiv",
   "LinearOrderedSemifield",
   "PartialOrder.toPreorder",
   "div_lt_div_left",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Iff.mpr",
   "LT.lt.trans",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring"],
  "name": "div_lt_div_of_lt_left",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → 0 < b → b < a → c / a < c / b",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsRat.casesOn",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "HEq",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Eq.casesOn",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.to_isInt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℤ) → Mathlib.Meta.NormNum.IsRat x x_1 1 → Prop) (x : α)\n  (x_1 : ℤ) (x_2 : Mathlib.Meta.NormNum.IsRat x x_1 1),\n  (∀ (num : ℤ) (inv : Invertible ↑1), motive (↑num * ⅟↑1) num (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑1) num 1)) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "MeasureTheory.Measure.measure_univ_ne_zero",
   "pos_iff_ne_zero",
   "AddCommMonoid.toAddMonoid",
   "instENNRealZero",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Iff",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "MeasureTheory.Measure.instZero",
   "LT.lt",
   "AddMonoid.toZero",
   "Iff.trans",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "MeasurableSpace",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "MeasureTheory.Measure.measure_univ_pos",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α}, 0 < ↑↑μ Set.univ ↔ μ ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "MeasureTheory.Measure.map",
   "Set.preimage",
   "Function.comp",
   "Set",
   "MeasureTheory.Measure.map_apply",
   "Measurable.comp",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "eq_true",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasurableSet",
   "congr",
   "Measurable",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "MeasureTheory.Measure.ext"],
  "name": "MeasureTheory.Measure.map_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {m0 : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {g : β → γ} {f : α → β},\n  Measurable g →\n    Measurable f → MeasureTheory.Measure.map g (MeasureTheory.Measure.map f μ) = MeasureTheory.Measure.map (g ∘ f) μ",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references": [],
  "name": "StrictOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "OrderedRing.toPartialOrder",
   "Zero.toOfNat0",
   "OrderedRing.toRing",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedRing.mul_nonneg",
  "constType":
  "∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "add_right_neg",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "add_neg_self",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0",
  "constCategory": "Theorem"},
 {"references": ["And", "and_iff_left_of_imp", "Iff"],
  "name": "and_iff_left",
  "constType": "∀ {b a : Prop}, b → (a ∧ b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.pairwiseDisjoint_insert",
   "Membership.mem",
   "And",
   "Ne",
   "Set.PairwiseDisjoint",
   "PartialOrder.toPreorder",
   "Set",
   "Disjoint",
   "And.intro",
   "OrderBot",
   "Insert.insert",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.instInsertSet",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "Set.PairwiseDisjoint.insert",
  "constType":
  "∀ {α : Type u_1} {ι : Type u_4} [inst : PartialOrder α] [inst_1 : OrderBot α] {s : Set ι} {f : ι → α},\n  Set.PairwiseDisjoint s f → ∀ {i : ι}, (∀ j ∈ s, i ≠ j → Disjoint (f i) (f j)) → Set.PairwiseDisjoint (insert i s) f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "SetLike.instMembership",
   "AddMemClass"],
  "name": "AddMemClass.mk",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : Add M] [inst_1 : SetLike S M],\n  (∀ {s : S} {a b : M}, a ∈ s → b ∈ s → a + b ∈ s) → AddMemClass S M",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_left_cancel",
   "Exists",
   "Nat.le_of_add_le_add_left.match_1",
   "Eq.ndrec",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.mp",
   "Eq.refl",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left",
  "constType": "∀ {a b c : ℕ}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "add_right_neg",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "id"],
  "name": "add_neg_cancel_right",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + b + -b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CauchySeq",
   "Exists",
   "PseudoEMetricSpace.toUniformSpace",
   "CompleteSpace",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "EMetric.instIsCountablyGeneratedUniformity",
   "PseudoEMetricSpace",
   "Filter.Tendsto",
   "UniformSpace.toTopologicalSpace",
   "Nat",
   "Filter.atTop",
   "UniformSpace.complete_of_cauchySeq_tendsto",
   "Nat.strictOrderedSemiring"],
  "name": "EMetric.complete_of_cauchySeq_tendsto",
  "constType":
  "∀ {α : Type u} [inst : PseudoEMetricSpace α],\n  (∀ (u : ℕ → α), CauchySeq u → ∃ a, Filter.Tendsto u Filter.atTop (nhds a)) → CompleteSpace α",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Int"],
  "name": "DivisionRing.zpow",
  "constType": "{K : Type u} → [self : DivisionRing K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references": ["Rat", "Add", "Rat.add", "Add.mk"],
  "name": "Rat.instAddRat",
  "constType": "Add ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT", "LT.lt", "lt_trans", "IsTrans", "IsTrans.mk", "Preorder"],
  "name": "instIsTransLtToLT",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsTrans α fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["CanonicallyOrderedCommSemiring", "Nat"],
  "name": "CanonicallyOrderedCommSemiring.npow",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNatInt",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
   "AddCommMonoid.mk",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalCommSemiring.mk",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [s : NonUnitalCommRing α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.zero_mem",
   "Set.mem_biInter",
   "Set",
   "Set.iInter",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet",
   "SetLike.coe"],
  "name": "AddSubmonoid.instInfSetAddSubmonoid.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)), 0 ∈ ⋂ x ∈ s, ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["DivInvOneMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.mk",
  "constType":
  "{G : Type u_2} → [toDivInvMonoid : DivInvMonoid G] → 1⁻¹ = 1 → DivInvOneMonoid G",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddZeroClass.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.6",
   "neg_pos_of_neg",
   "PartialOrder.toPreorder",
   "mul_neg",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "AddGroupWithOne.toAddGroup",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Preorder.toLT",
   "InvolutiveNeg.toNeg",
   "StrictOrderedRing",
   "AddGroup.toAddCancelMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "StrictOrderedRing.toPartialOrder",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "StrictOrderedSemiring.toSemiring",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "mul_lt_mul_of_pos_right",
   "HMul.hMul",
   "congr",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrArg"],
  "name": "mul_lt_mul_of_neg_right",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedRing α] {a b c : α}, b < a → c < 0 → a * c < b * c",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "GeneralizedBooleanAlgebra.toSDiff",
   "OrderHom",
   "SDiff.sdiff",
   "FunLike.coe",
   "disjointed.match_1",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "partialSups",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "StrictOrderedSemiring.toPartialOrder",
   "GeneralizedBooleanAlgebra",
   "GeneralizedCoheytingAlgebra.toLattice",
   "instOfNatNat",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Lattice.toSemilatticeSup",
   "Nat",
   "SemilatticeSup.toPartialOrder",
   "Nat.strictOrderedSemiring"],
  "name": "disjointed",
  "constType":
  "{α : Type u_1} → [inst : GeneralizedBooleanAlgebra α] → (ℕ → α) → ℕ → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "IntCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["StrictMono.compares",
   "Iff.mp",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Function.Injective",
   "Ordering.Compares",
   "Preorder.toLT",
   "Ordering.eq",
   "letFun",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Eq"],
  "name": "StrictMono.injective",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → Function.Injective f",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "instHAdd",
   "HAdd.hAdd",
   "Function.Injective.addMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddCommSemigroup.add_comm",
   "AddMonoid.mk",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq",
   "Zero.toOfNat0",
   "Function.Injective.addCommSemigroup",
   "AddMonoid.nsmul_zero",
   "AddCommMonoid.mk",
   "Function.Injective",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "AddCommSemigroup",
   "HSMul.hSMul",
   "AddMonoid.zero_add",
   "AddCommSemigroup.toAddSemigroup",
   "Add",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "Function.Injective.addCommMonoid",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddCommMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddCommMonoid M₁",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.measurableSet_compl",
   "Set",
   "MeasurableSet",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "MeasurableSpace"],
  "name": "MeasurableSet.compl",
  "constType":
  "∀ {α : Type u_1} {s : Set α} {m : MeasurableSpace α}, MeasurableSet s → MeasurableSet sᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "zero_add",
   "eq_true",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder",
   "congrFun"],
  "name": "Linarith.le_of_eq_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a = 0 → b ≤ 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.Finite.fintype",
   "Set.Finite.toFinset",
   "Set.mem_toFinset",
   "Set.Finite",
   "Set.instMembershipSet"],
  "name": "Set.Finite.mem_toFinset",
  "constType":
  "∀ {α : Type u} {s : Set α} {a : α} (hs : Set.Finite s), a ∈ Set.Finite.toFinset hs ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["MeasureTheory.Measure", "Set", "MeasurableSpace"],
  "name": "MeasureTheory.Measure.FiniteSpanningSetsIn",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Set (Set α) → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSet.univ",
   "eq_true",
   "MeasurableSet",
   "Set.univ",
   "MeasurableSpace",
   "True",
   "Eq"],
  "name": "PFR.ForMathlib.Uniform._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α}, MeasurableSet Set.univ = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references": ["One", "OneHom"],
  "name": "OneHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : One M] → [inst_1 : One N] → OneHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Set",
   "Set.Nonempty",
   "HSub.hSub",
   "Set.Nonempty.image2",
   "Set.sub",
   "Sub"],
  "name": "Set.Nonempty.sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s t : Set α}, Set.Nonempty s → Set.Nonempty t → Set.Nonempty (s - t)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableEq",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toMul",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "Inter.inter",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasurableSet",
   "Measurable",
   "Eq.symm",
   "And.casesOn",
   "MeasureTheory.Measure.ae",
   "Pi.addZeroClass",
   "Subtype",
   "Membership.mem",
   "setOf",
   "Set.preimage",
   "Function.comp",
   "ProbabilityTheory.kernel.IndepFun",
   "Filter.Eventually",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasurableSpace.comap",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "instHMul",
   "And",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set.preimage_comp",
   "ProbabilityTheory.kernel",
   "ProbabilityTheory.instFunLikeSubtypeForAllMeasureMemAddSubmonoidAddZeroClassToAddZeroClassToAddMonoidInstAddCommMonoidInstMembershipInstSetLikeAddSubmonoidKernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "HMul.hMul",
   "And.intro",
   "MeasurableSpace",
   "Set.instInterSet"],
  "name": "ProbabilityTheory.kernel.IndepFun.comp",
  "constType":
  "∀ {α : Type u_1} {Ω : Type u_2} {β : Type u_4} {β' : Type u_5} {γ : Type u_6} {γ' : Type u_7} {_mα : MeasurableSpace α}\n  {_mΩ : MeasurableSpace Ω} {κ : ↥(ProbabilityTheory.kernel α Ω)} {μ : MeasureTheory.Measure α} {f : Ω → β} {g : Ω → β'}\n  {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {mγ : MeasurableSpace γ} {mγ' : MeasurableSpace γ'} {φ : β → γ}\n  {ψ : β' → γ'},\n  ProbabilityTheory.kernel.IndepFun f g κ →\n    Measurable φ → Measurable ψ → ProbabilityTheory.kernel.IndepFun (φ ∘ f) (ψ ∘ g) κ",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.invertibleOfMul.match_1",
   "Semiring",
   "Mathlib.Meta.NormNum.invertibleOfMul.proof_1",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Invertible",
   "Eq",
   "Semiring.toNatCast",
   "SemigroupWithZero.toSemigroup",
   "Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Invertible.mk",
   "Nat",
   "Mathlib.Meta.NormNum.invertibleOfMul.proof_2"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul",
  "constType":
  "{α : Type u_1} → [inst : Semiring α] → (k : ℕ) → (b a : α) → [inst_1 : Invertible a] → a = ↑k * b → Invertible b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedCommRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedCommRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "HMul.hMul",
   "Complex.log",
   "One.toOfNat1",
   "Complex",
   "Complex.instMulComplex",
   "Complex.exp",
   "Complex.instOneComplex",
   "Eq",
   "ite"],
  "name": "Complex.cpow",
  "constType": "ℂ → ℂ → ℂ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd", "AddSubmonoid", "AddZeroClass", "AddSubsemigroup"],
  "name": "AddSubmonoid.toAddSubsemigroup",
  "constType":
  "{M : Type u_4} → [inst : AddZeroClass M] → AddSubmonoid M → AddSubsemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "Set.mem_iInter₂",
   "Iff.mp",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "instHAdd",
   "Set.mem_biInter",
   "HAdd.hAdd",
   "Set",
   "Set.iInter",
   "AddSubmonoid.add_mem",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instInfSetAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)) {a b : M},\n  a ∈ ⋂ t ∈ s, ↑t → b ∈ ⋂ t ∈ s, ↑t → a + b ∈ ⋂ x ∈ s, ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSMul",
   "instHAdd",
   "Nat.iterate",
   "HAdd.hAdd",
   "HSMul.hSMul",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.toAddAction",
   "Nat",
   "vadd_iterate",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq"],
  "name": "add_left_iterate",
  "constType":
  "∀ {G : Type u_3} [inst : AddMonoid G] (a : G) (n : ℕ), (fun x => a + x)^[n] = fun x => n • a + x",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "False", "Or.inr", "false_or.match_1", "propext", "Eq"],
  "name": "false_or",
  "constType": "∀ (p : Prop), (False ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_3",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "One.toOfNat1",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Int",
   "Eq"],
  "name": "CommGroupWithZero.zpow_zero'",
  "constType":
  "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀] (a : G₀), CommGroupWithZero.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "instAddNat",
   "Int.negSucc",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.subNatNat",
   "Int.add.match_1"],
  "name": "Int.add",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Real.cos",
   "Complex.ofReal'",
   "Complex.ofReal_cos_ofReal_re",
   "Real",
   "Complex",
   "Complex.cos",
   "Eq"],
  "name": "Complex.ofReal_cos",
  "constType": "∀ (x : ℝ), ↑(Real.cos x) = Complex.cos ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Equiv",
   "AddZeroClass.toAdd",
   "Multiset.card",
   "List.instMembershipList",
   "Finset.mem_univ_val",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Multiset.instMembershipMultiset",
   "Quot.recOnSubsingleton'",
   "Fintype",
   "Nat.addMonoid",
   "Trunc.mk",
   "Fintype.truncEquivFin.proof_2",
   "Multiset",
   "Finset.val",
   "Trunc",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Equiv.symm",
   "id",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "Multiset.Nodup",
   "Fintype.card",
   "FunLike.coe",
   "List.length",
   "Setoid.r",
   "Finset.univ",
   "List.Nodup",
   "DecidableEq",
   "List",
   "Fintype.truncEquivFin.proof_1",
   "AddMonoidHomClass.toAddHomClass",
   "List.Nodup.getEquivOfForallMemList",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "Fin",
   "AddMonoidHom",
   "Quot.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Fintype.truncEquivFin",
  "constType":
  "(α : Type u_4) → [inst : DecidableEq α] → [inst : Fintype α] → Trunc (α ≃ Fin (Fintype.card α))",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Eq.mpr",
   "Eq.ndrec",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Eq"],
  "name": "Mathlib.Tactic.Abel.subst_into_addg",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (l r tl tr t : α), l = tl → r = tr → tl + tr = t → l + r = t",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "Set.preimage",
   "AddHomClass.toFunLike",
   "AddSubgroup.comap.proof_2",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.comap.proof_3",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubgroup.mk",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.comap",
   "AddMonoidHom",
   "AddSubgroup.comap.proof_1",
   "SetLike.coe"],
  "name": "AddSubgroup.comap",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → {N : Type u_7} → [inst_1 : AddGroup N] → (G →+ N) → AddSubgroup N → AddSubgroup G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "LE.le.trans",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "mul_le_mul_of_nonneg_right",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "MulPosMono",
   "MulZeroClass.toMul"],
  "name": "mul_le_mul",
  "constType":
  "∀ {α : Type u_1} {a b c d : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α]\n  [inst_3 : MulPosMono α], a ≤ b → c ≤ d → 0 ≤ c → 0 ≤ b → a * c ≤ b * d",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Complex.instOneComplex",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "eq_self",
   "Complex.instZeroComplex",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.exp_zero",
   "NormedField.toNormedCommRing",
   "instDecidableTrue",
   "ite_self",
   "ite_congr",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "HMul.hMul",
   "Complex.log",
   "Complex",
   "Not",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.cpow_zero",
  "constType": "∀ (x : ℂ), x ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.image2",
   "funext",
   "Mathlib.Logic.Basic._auxLemma.32",
   "Std.Logic._auxLemma.39",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "And",
   "Iff",
   "of_eq_true",
   "congr",
   "Set.image",
   "congrArg",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image2_image_left",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : Set α} {t : Set β} (f : γ → β → δ) (g : α → γ),\n  Set.image2 f (g '' s) t = Set.image2 (fun a b => f (g a) b) s t",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.mul_one",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Or.symm",
   "LE.le.lt_or_eq",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "eq_or_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "Subgroup.instInfSetSubgroup.proof_1",
   "Membership.mem",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Submonoid.one_mem'",
   "Submonoid.instInfSetSubmonoid",
   "MulOneClass.toOne",
   "Set",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.copy",
   "iInf",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Submonoid",
   "Set.iInter",
   "Group",
   "Group.toDivInvMonoid",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instInfSetSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)),\n  1 ∈\n    (Submonoid.copy (⨅ S ∈ s, S.toSubmonoid) (⋂ S ∈ s, ↑S)\n          (_ : ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toSubmonoid))).toSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsRat.casesOn",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "NonUnitalNonAssocRing.toMul",
   "HEq",
   "DivisionRing.toRing",
   "Int.negOfNat",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.IsRat.neg_to_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ}\n  (motive : (x x_1 x_2 : α) → Mathlib.Meta.NormNum.IsRat x (Int.negOfNat n) d → ↑n = x_1 → ↑d = x_2 → Prop)\n  (x x_1 x_2 : α) (x_3 : Mathlib.Meta.NormNum.IsRat x (Int.negOfNat n) d) (x_4 : ↑n = x_1) (x_5 : ↑d = x_2),\n  (∀ (inv : Invertible ↑d),\n      motive (↑(Int.negOfNat n) * ⅟↑d) ↑n ↑d\n        (_ : Mathlib.Meta.NormNum.IsRat (↑(Int.negOfNat n) * ⅟↑d) (Int.negOfNat n) d) (_ : ↑n = ↑n) (_ : ↑d = ↑d)) →\n    motive x x_1 x_2 x_3 x_4 x_5",
  "constCategory": "Definition"},
 {"references": ["Prod.snd", "Prod.mk", "Prod", "Prod.fst"],
  "name": "Prod.swap",
  "constType": "{α : Type u_1} → {β : Type u_2} → α × β → β × α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Int.instCommSemiringInt",
   "Int"],
  "name": "Int.instSemiringInt",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "rfl",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "Eq",
   "neg_mul_neg",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "SemilatticeSup.toSup",
   "abs_by_cases",
   "Ring.toNeg",
   "LinearOrderedRing",
   "HMul.hMul",
   "Lattice.toSemilatticeSup"],
  "name": "abs_mul_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a| * |a| = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "AddSubmonoid.instSetLikeAddSubmonoid.proof_1",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "AddZeroClass"],
  "name": "AddSubmonoid.instSetLikeAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → SetLike (AddSubmonoid M) M",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "div_eq_inv_mul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedSemifield.toInv",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "Iff.rfl",
   "one_div",
   "Eq.refl",
   "Semifield.toCommGroupWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "one_mul",
   "Iff",
   "DivisionCommMonoid.toDivisionMonoid",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "InvOneClass.toInv",
   "Eq.symm",
   "le_div_iff",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "id",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GroupWithZero.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "DivInvMonoid.toInv",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "DivInvOneMonoid.toInvOneClass",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "div_le_iff",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "inv_le_inv",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ ≤ b⁻¹ ↔ b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Set.image_preimage_eq_inter_range",
   "congr_arg",
   "Set.preimage",
   "Subtype.val",
   "Subtype.range_coe",
   "Set",
   "Inter.inter",
   "Set.image",
   "Eq.trans",
   "Subtype",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Subtype.image_preimage_coe",
  "constType":
  "∀ {α : Type u_1} (s t : Set α), Subtype.val '' (Subtype.val ⁻¹' t) = t ∩ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Zero.toOfNat0",
   "AddGroup",
   "Iff",
   "Left.nonneg_neg_iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_nonneg",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "FunLike",
   "AddHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Add M] →\n        [inst_1 : Add N] →\n          [toFunLike : FunLike F M fun x => N] → (∀ (f : F) (x y : M), f (x + y) = f x + f y) → AddHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["Add.add",
   "Set.add",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "Set.addSemigroup.proof_1",
   "Add",
   "AddSemigroup",
   "Add.mk"],
  "name": "Set.addSemigroup",
  "constType":
  "{α : Type u_2} → [inst : AddSemigroup α] → AddSemigroup (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Complex.arg",
   "Complex.ofReal'",
   "Distrib.toAdd",
   "Complex.abs",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AbsoluteValue",
   "Real",
   "Eq.refl",
   "Complex.instAddComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "instHMul",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "Real.log",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Complex",
   "Complex.log",
   "Complex.instMulComplex",
   "OrderedSemiring.toPartialOrder",
   "Complex.I"],
  "name":
  "_private.Mathlib.Analysis.SpecialFunctions.Complex.Log.0.Complex.log._eq_1",
  "constType":
  "∀ (x : ℂ), Complex.log x = ↑(Real.log (Complex.abs x)) + ↑(Complex.arg x) * Complex.I",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "eq_true",
   "One",
   "zero_le_one",
   "LE",
   "One.toOfNat1",
   "LE.le",
   "True",
   "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], (0 ≤ 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Set",
   "Set.iInter",
   "Set.instInfSetSet",
   "Iff.mpr",
   "iInf_congr_Prop",
   "Eq"],
  "name": "Set.iInter_congr_Prop",
  "constType":
  "∀ {α : Type u_1} {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q),\n  (∀ (x : q), f₁ (_ : p) = f₂ x) → Set.iInter f₁ = Set.iInter f₂",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Decidable", "Not", "dite"],
  "name": "Decidable.not_or_of_imp",
  "constType": "∀ {a b : Prop} [inst : Decidable a], (a → b) → ¬a ∨ b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Div"],
  "name": "DivisionRing.toDiv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Div K",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "ProbabilityTheory.IdentDistrib.map_eq",
   "MeasureTheory.Measure.map",
   "Real",
   "ProbabilityTheory.entropy",
   "ProbabilityTheory.IdentDistrib",
   "autoParam",
   "ProbabilityTheory.measureEntropy",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "of_eq_true",
   "_auto._@.PFR.ForMathlib.Entropy.Measure._hyg.98",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "congrFun"],
  "name": "ProbabilityTheory.IdentDistrib.entropy_eq",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] {X : Ω → S}\n  {μ : MeasureTheory.Measure Ω} {Ω' : Type u_1} [inst_1 : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'}\n  {X' : Ω' → S}, ProbabilityTheory.IdentDistrib X X' → H[X ; μ] = H[X' ; μ']",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "CommMonoid"],
  "name": "CommMonoid.toMonoid",
  "constType": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "CanonicallyOrderedCommSemiring.toMul",
   "PartialOrder.toPreorder",
   "Top.top",
   "Eq.refl",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "implies_congr",
   "Preorder.toLE",
   "ENNReal.mul_lt_top",
   "OrderTop.toTop",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "instHMul",
   "ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "Mathlib.Data.Real.ENNReal._auxLemma.37",
   "Eq.mp",
   "CompleteLattice.toTop",
   "HMul.hMul",
   "LinearOrderedAddCommMonoidWithTop.toOrderTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "OrderedSemiring.toPartialOrder"],
  "name": "ENNReal.mul_ne_top",
  "constType": "∀ {a b : ENNReal}, a ≠ ⊤ → b ≠ ⊤ → a * b ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Min"],
  "name": "LinearOrder.toMin",
  "constType": "{α : Type u} → [self : LinearOrder α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "SemilatticeSup.le_sup_right",
   "Submonoid",
   "Sup.sup",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_7",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b : Submonoid M), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring"],
  "name": "StarRing",
  "constType": "(R : Type u) → [inst : NonUnitalNonAssocSemiring R] → Type u",
  "constCategory": "Other"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} → [self : Ring R] → Sub R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "Group",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "Group.mk",
  "constType":
  "{G : Type u} → [toDivInvMonoid : DivInvMonoid G] → (∀ (a : G), a⁻¹ * a = 1) → Group G",
  "constCategory": "Other"},
 {"references": ["Equiv", "Additive.ofMul", "Additive", "Equiv.symm"],
  "name": "Additive.toMul",
  "constType": "{α : Type u} → Additive α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "implies_true",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "DecidablePred",
   "Finset.univ",
   "And",
   "Fintype",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "Finset.filter",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "congrFun"],
  "name": "Subtype.fintype.proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] [inst_1 : Fintype α] (a : α),\n  a ∈ Finset.filter p Finset.univ ↔ p a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddHomClass.toFunLike",
   "instHAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Real.normedCommRing",
   "Ring.toSemiring",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "CommRing.toRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_7",
  "constType":
  "∀ (z w : ℝ), 0 = (AddMonoidHom.id ℝ) z * 0 + 0 * (AddMonoidHom.id ℝ) w",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddRightCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = c + b → a = c) → AddRightCancelSemigroup G",
  "constCategory": "Other"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "funext",
   "AddSubmonoid.coe_iInf",
   "Set.iInter_congr_Prop",
   "Set",
   "Eq.refl",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "of_eq_true",
   "iInf",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "Set.iInter",
   "congrArg",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "Eq.trans",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfSetAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)), ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toAddSubmonoid)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step", "Nat.le", "Nat.le.refl", "Nat", "Nat.succ", "Nat.le.rec"],
  "name": "Nat.le.casesOn",
  "constType":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {a : ℕ} (t : Nat.le n a),\n  motive n (_ : Nat.le n n) → (∀ {m : ℕ} (a : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive a t",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "instHMul",
   "RingHom",
   "MulOneClass.toMul",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "MonoidHom.map_mul'",
   "HMul.hMul",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (x_2 y : α),\n  OneHom.toFun (↑↑f) (x_2 * y) = OneHom.toFun (↑↑f) x_2 * OneHom.toFun (↑↑f) y",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusionType",
  "constType": "Sort u → ℕ → ℕ → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ_add.match_1",
   "Eq",
   "PProd",
   "Nat.zero_add",
   "Eq.mpr",
   "PProd.fst",
   "Nat.rec",
   "Eq.ndrec",
   "PUnit",
   "letFun",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Nat.succ",
   "id"],
  "name": "Nat.add_comm",
  "constType": "∀ (n m : ℕ), n + m = m + n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "AddHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Nat.addMonoid",
   "Finset",
   "Multiset",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["exists_prop_congr", "Exists", "Iff", "propext", "Iff.mpr", "Eq"],
  "name": "exists_prop_congr'",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Finset.instOrderBotFinsetToLEToPreorderPartialOrder",
   "propext",
   "Disjoint",
   "Finset",
   "Finset.not_disjoint_iff",
   "Finset.instMembershipFinset",
   "Finset.partialOrder",
   "Not",
   "Eq"],
  "name": "Mathlib.Combinatorics.Additive.RuzsaCovering._auxAddLemma.1",
  "constType":
  "∀ {α : Type u_1} {s t : Finset α}, (¬Disjoint s t) = ∃ a ∈ s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype.subtype.proof_1",
   "Membership.mem",
   "Fintype",
   "Fintype.subtype.proof_3",
   "Fintype.mk",
   "Iff",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Fintype.subtype.proof_2",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype",
  "constType":
  "{α : Type u_1} → {p : α → Prop} → (s : Finset α) → (∀ (x : α), x ∈ s ↔ p x) → Fintype { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "NonUnitalSemiring.mul_assoc",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "StrictOrderedRing.toNontrivial",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "HMul.hMul",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_1",
  "constType": "∀ (a b c : ℝ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Set.addMonoid.proof_1",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "SubNegMonoid.toNeg",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "AddMonoid.add_zero",
   "Set.addMonoid",
   "Eq",
   "Sub.mk",
   "zsmulRec",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Set.image_image2_distrib_right",
   "Set.image_id",
   "AddMonoid.toAddSemigroup",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "Set.sub",
   "Sub.sub",
   "Nat",
   "Set.image",
   "Eq.symm",
   "Nat.succ",
   "id",
   "instHSub",
   "Set.neg",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Neg.neg",
   "Set.image_neg",
   "Set.involutiveNeg",
   "SubNegMonoid.mk",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddMonoid.mk",
   "Set.addSemigroup",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "Int.negSucc",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "congr",
   "AddMonoid.zero_add",
   "Mathlib.Data.Set.Pointwise.Basic._auxAddLemma.12",
   "congrArg",
   "Set.image_image2_antidistrib",
   "Int",
   "neg_add_rev",
   "Set.addZeroClass"],
  "name": "Set.subtractionMonoid.proof_11",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (s t : Set α), -(s + t) = -t + -s",
  "constCategory": "Theorem"},
 {"references":
  ["ProbabilityTheory.IdentDistrib.map_eq",
   "MeasureTheory.Measure.map",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.IdentDistrib.aemeasurable_snd",
   "ProbabilityTheory.IdentDistrib",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasurableSet",
   "ProbabilityTheory.IdentDistrib.aemeasurable_fst",
   "MeasureTheory.Measure.map_apply_of_aemeasurable",
   "Eq.symm",
   "MeasurableSpace",
   "id"],
  "name": "ProbabilityTheory.IdentDistrib.measure_mem_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ},\n  ProbabilityTheory.IdentDistrib f g → ∀ {s : Set γ}, MeasurableSet s → ↑↑μ (f ⁻¹' s) = ↑↑ν (g ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "MulZeroClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "constCategory": "Other"},
 {"references":
  ["TopologicalSpace",
   "definition._@.Mathlib.Topology.Basic._hyg.10680",
   "Filter",
   "Subtype",
   "Eq"],
  "name": "wrapped._@.Mathlib.Topology.Basic._hyg.10680",
  "constType": "Subtype (Eq @definition✝)",
  "constCategory": "Other"},
 {"references": ["AddZeroClass"],
  "name": "AddSubmonoid",
  "constType": "(M : Type u_4) → [inst : AddZeroClass M] → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.mul_comm",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_8",
   "OrderBot",
   "Nat.canonicallyOrderedCommSemiring.proof_12",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.nontrivial",
   "OrderedAddCommMonoid",
   "Nat.eq_zero_of_mul_eq_zero",
   "inferInstance",
   "instLENat",
   "Semiring.npow",
   "Nat.canonicallyOrderedCommSemiring.proof_10",
   "Nat.canonicallyOrderedCommSemiring.proof_3",
   "CommSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Nat",
   "Nat.canonicallyOrderedCommSemiring.proof_7",
   "Nat.linearOrderedSemiring",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.add_le_add_left",
   "Nat.canonicallyOrderedCommSemiring.proof_5",
   "CanonicallyOrderedCommSemiring.mk",
   "Nat.le_add_right",
   "OrderedAddCommMonoid.mk",
   "OrderBot.bot_le",
   "Nat.canonicallyOrderedCommSemiring.proof_11",
   "Nat.canonicallyOrderedCommSemiring.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.canonicallyOrderedCommSemiring.proof_6",
   "StrictOrderedSemiring.toSemiring",
   "Semiring.toOne",
   "Nat.commSemiring",
   "Nat.canonicallyOrderedCommSemiring.proof_9",
   "Nat.canonicallyOrderedCommSemiring.proof_1",
   "Nat.orderedSemiring",
   "OrderBot.toBot",
   "Nat.canonicallyOrderedCommSemiring.proof_4",
   "LinearOrderedSemiring",
   "Nontrivial",
   "OrderBot.mk",
   "Nat.orderBot",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Finite",
  "constType": "Sort u_1 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Int.add_zero",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.rec",
   "Int.add_comm",
   "Int",
   "Eq",
   "Int.instAddInt"],
  "name": "Int.zero_add",
  "constType": "∀ (a : ℤ), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instHSMul",
   "MeasureTheory.Measure.instSFiniteMap",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.Measure.prod",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "MeasureTheory.Measure.prod.instIsProbabilityMeasure",
   "ENNReal",
   "inferInstance",
   "MeasureTheory.OuterMeasure.measureOf",
   "one_smul",
   "Measurable.aemeasurable",
   "MonoidWithZero.toMonoid",
   "MeasureTheory.Measure.map_snd_prod",
   "HSMul.hSMul",
   "MonoidWithZero.toMulActionWithZero",
   "MeasureTheory.Measure.instMulAction",
   "Algebra.toSMul",
   "Eq.trans",
   "measurable_snd",
   "MulActionWithZero.toMulAction",
   "Prod.snd",
   "IsScalarTower.right",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "instENNRealZero",
   "ProbabilityTheory.IdentDistrib.mk",
   "Prod.instMeasurableSpace",
   "And",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.map_fst_prod",
   "And.intro",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "ProbabilityTheory.IndepFun",
   "Exists",
   "MeasureTheory.isProbabilityMeasure_map",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "measurable_fst",
   "MeasureTheory.instSFinite",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.Measure.instSMul",
   "ProbabilityTheory.indepFun_fst_snd",
   "Exists.intro",
   "True",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "IsScalarTower.left",
   "Measurable",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "eq_self",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Set.univ",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Prod"],
  "name": "ProbabilityTheory.independent_copies",
  "constType":
  "∀ {Ω : Type u_5} {Ω' : Type u_6} {α : Type u_7} {β : Type u_9} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {X : Ω → α} {Y : Ω' → β},\n  Measurable X →\n    Measurable Y →\n      ∀ (μ : MeasureTheory.Measure Ω) (μ' : MeasureTheory.Measure Ω') [inst_2 : MeasureTheory.IsProbabilityMeasure μ]\n        [inst_3 : MeasureTheory.IsProbabilityMeasure μ'],\n        ∃ ν X' Y',\n          MeasureTheory.IsProbabilityMeasure ν ∧\n            Measurable X' ∧\n              Measurable Y' ∧\n                ProbabilityTheory.IndepFun X' Y' ∧\n                  ProbabilityTheory.IdentDistrib X' X ∧ ProbabilityTheory.IdentDistrib Y' Y",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "Finset.sum",
   "Finset",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidHom.mulRight",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "map_sum",
   "AddMonoidHom",
   "Eq"],
  "name": "Finset.sum_mul",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Finset α} {b : β} {f : α → β} [inst : NonUnitalNonAssocSemiring β],\n  (Finset.sum s fun x => f x) * b = Finset.sum s fun x => f x * b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "propext", "or_self.match_1", "Eq"],
  "name": "or_self",
  "constType": "∀ (p : Prop), (p ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instAddCommGroupReal",
   "NormedAddCommGroup",
   "NormedAddCommGroup.mk",
   "Real.metricSpace",
   "Real",
   "Real.normedAddCommGroup.proof_1",
   "Real.norm"],
  "name": "Real.normedAddCommGroup",
  "constType": "NormedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["And", "And.right", "False", "Not"],
  "name": "instDecidableAnd.proof_1",
  "constType": "∀ {p q : Prop}, ¬q → p ∧ q → False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["DivisionSemiring", "Nontrivial"],
  "name": "DivisionSemiring.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : DivisionSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_refl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_1",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Or",
   "Nat.cast",
   "Int.natAbs_eq",
   "instNatCastInt",
   "Int.instNegInt",
   "Neg.neg",
   "Exists.intro",
   "Nat",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.eq_nat_or_neg",
  "constType": "∀ (a : ℤ), ∃ n, a = ↑n ∨ a = -↑n",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NormedCommRing.toSeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "IsROrC.toDenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NormedField.toNormedCommRing",
   "NormedAlgebra",
   "semiOutParam"],
  "name": "IsROrC.toNormedAlgebra",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → NormedAlgebra ℝ K",
  "constCategory": "Definition"},
 {"references": ["And", "False", "Not", "And.left"],
  "name": "instDecidableAnd.proof_2",
  "constType": "∀ {p q : Prop}, ¬p → p ∧ q → False",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "instHAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "HAdd.hAdd",
   "AddSubsemigroup.add_mem'",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubmonoid.comap",
   "AddSubsemigroup.carrier",
   "AddMonoidHom"],
  "name": "AddSubgroup.comap.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup N) {a b : G},\n  a ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n    b ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n      a + b ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "OrderedCommMonoid.toCovariantClassLeft",
   "Zero.toOfNat0",
   "mul_le_mul_left'",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "LeftDistribClass.left_distrib",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq"],
  "name": "left_distrib",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.decLe",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "LinearOrderedRing.toStrictOrderedRing",
   "HEq",
   "Eq.refl",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Decidable.decide",
   "Nat.cast",
   "LinearOrderedRing",
   "Bool.true",
   "Ring.toIntCast",
   "Nat",
   "Eq.symm",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "LE.le",
   "Semiring.toOne",
   "instHMul",
   "Int.mul",
   "Eq.ndrec",
   "HEq.refl",
   "Int.cast",
   "HMul.hMul",
   "Bool",
   "Eq.casesOn",
   "Int",
   "Int.instLEInt"],
  "name": "Mathlib.Meta.NormNum.isRat_le_true.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α]\n  (motive :\n    (x x_1 : α) →\n      (x_2 x_3 : ℤ) →\n        (x_4 x_5 : ℕ) →\n          Mathlib.Meta.NormNum.IsRat x x_2 x_4 →\n            Mathlib.Meta.NormNum.IsRat x_1 x_3 x_5 →\n              decide (Int.mul x_2 (Int.ofNat x_5) ≤ Int.mul x_3 (Int.ofNat x_4)) = true → Prop)\n  (x x_1 : α) (x_2 x_3 : ℤ) (x_4 x_5 : ℕ) (x_6 : Mathlib.Meta.NormNum.IsRat x x_2 x_4)\n  (x_7 : Mathlib.Meta.NormNum.IsRat x_1 x_3 x_5)\n  (x_8 : decide (Int.mul x_2 (Int.ofNat x_5) ≤ Int.mul x_3 (Int.ofNat x_4)) = true),\n  (∀ (num num_1 : ℤ) (da db : ℕ) (inv : Invertible ↑da) (inv_1 : Invertible ↑db)\n      (h : decide (Int.mul num (Int.ofNat db) ≤ Int.mul num_1 (Int.ofNat da)) = true),\n      motive (↑num * ⅟↑da) (↑num_1 * ⅟↑db) num num_1 da db (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑da) num da)\n        (_ : Mathlib.Meta.NormNum.IsRat (↑num_1 * ⅟↑db) num_1 db) h) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "outParam",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → AddHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder"],
  "name": "Real.instPreorderReal",
  "constType": "Preorder ℝ",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.le_top",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_14",
  "constType": "∀ {α : Type u_1} (a : α → Prop), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.instAddInt"],
  "name": "Int.lt",
  "constType": "ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "Rat.instLERat",
   "Iff.rfl",
   "instHAdd",
   "HAdd.hAdd",
   "Rat",
   "HSub.hSub",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Rat.instAddRat",
   "Eq",
   "Rat.instSubRat",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Rat.addCommGroup",
   "Rat.le_iff_Nonneg",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "Rat.Nonneg",
   "add_sub_add_left_eq_sub",
   "id"],
  "name": "Rat.add_le_add_left",
  "constType": "∀ {a b c : ℚ}, c + a ≤ c + b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance", "DecidableEq", "Classical.propDecidable", "Eq"],
  "name": "Classical.decEq",
  "constType": "(α : Sort u) → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Rat.instLERat",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Iff.rfl",
   "Rat.not_le",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Rat.le_antisymm",
   "inferInstance",
   "Eq.mpr",
   "Iff",
   "Rat.le_refl",
   "Decidable",
   "compareOfLessAndEq",
   "Eq.symm",
   "Rat.le_trans",
   "id",
   "Ordering",
   "Rat",
   "and_iff_right_of_imp",
   "decidableEqOfDecidableLE",
   "LE.le",
   "Preorder.mk",
   "Rat.instLTRat",
   "Or.resolve_left",
   "And",
   "Ord.compare",
   "Rat.instDecidableLeRatInstLERat",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "decidableLTOfDecidableLE",
   "Not",
   "Rat.le_total"],
  "name": "Rat.linearOrder.proof_4",
  "constType": "∀ (a b : ℚ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite.rec",
   "Set.Finite"],
  "name": "Set.Finite.casesOn",
  "constType":
  "∀ {α : Type u} {s : Set α} {motive : Set.Finite s → Prop} (t : Set.Finite s),\n  (∀ (a : Fintype ↑s), motive (_ : Set.Finite s)) → motive t",
  "constCategory": "Definition"},
 {"references": ["Div.mk", "Rat.div", "Rat", "Div"],
  "name": "Rat.instDivRat",
  "constType": "Div ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrderedAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrderedAddCommMonoid.toMin",
   "LE.le",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommMonoid.min_def",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedAddCommMonoid α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "AbsoluteValue",
   "Semiring.toMonoidWithZero",
   "AbsoluteValue.nonneg'",
   "FunLike.coe",
   "LE.le",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.nonneg",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) (x : R),\n  0 ≤ abv x",
  "constCategory": "Theorem"},
 {"references":
  ["Submonoid.mk",
   "Subgroup.mk",
   "Subgroup.instInfSetSubgroup.proof_1",
   "Membership.mem",
   "Subgroup.instInfSetSubgroup.proof_3",
   "Submonoid.instInfSetSubmonoid",
   "Set",
   "InfSet",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "InfSet.mk",
   "Submonoid.copy",
   "iInf",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Submonoid",
   "Set.iInter",
   "Group",
   "Group.toDivInvMonoid",
   "Subgroup.instInfSetSubgroup.proof_2",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instInfSetSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → InfSet (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Exists",
   "OfNat.ofNat",
   "AddSubmonoid.zero_mem",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toZeroHomClass",
   "Set",
   "AddMonoidHomClass",
   "Exists.intro",
   "FunLike.coe",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "map_zero",
   "And.intro",
   "AddMonoidHomClass.toAddHomClass",
   "AddZeroClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.map.proof_2",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (S : AddSubmonoid M), ∃ a ∈ ↑S, f a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Distrib.toAdd",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "AbsoluteValue",
   "Complex.sin",
   "Eq.refl",
   "Complex.cos",
   "Real.pi",
   "Complex.exp_eq_exp_re_mul_sin_add_cos",
   "Preorder.toLE",
   "Complex.abs_exp",
   "Eq",
   "Real.instNegReal",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Complex.arg_mul_cos_add_sin_mul_I",
   "Preorder.toLT",
   "Complex.re_add_im",
   "Eq.symm",
   "id",
   "Complex.I",
   "Complex.ofReal'",
   "Complex.abs",
   "Complex.ofReal_exp",
   "Real.instLTReal",
   "instHAdd",
   "Real.exp_pos",
   "Neg.neg",
   "Complex.instAddComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "Real.exp",
   "LE.le",
   "SubadditiveHomClass.toFunLike",
   "Complex.re",
   "_private.Mathlib.Analysis.SpecialFunctions.Complex.Log.0.Complex.log._eq_1",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Complex.im",
   "instHMul",
   "Real.log",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Real.instPreorderReal",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Complex.log",
   "Complex",
   "And.intro",
   "Complex.instMulComplex",
   "Real.log_exp",
   "Complex.exp",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.log_exp",
  "constType":
  "∀ {x : ℂ}, -Real.pi < x.im → x.im ≤ Real.pi → Complex.log (Complex.exp x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.mk",
  "constType":
  "{M : Type u} → [toZero : Zero M] → [toAdd : Add M] → (∀ (a : M), 0 + a = a) → (∀ (a : M), a + 0 = a) → AddZeroClass M",
  "constCategory": "Other"},
 {"references":
  ["Set",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "implies_congr",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "forall_congr",
   "Finset.toSet",
   "Finset",
   "MeasurableSet",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "Set.preimage",
   "Finset.sum",
   "implies_true",
   "Finset.instMembershipFinset",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "MeasureTheory.sum_measure_preimage_singleton",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.14",
   "Singleton.singleton",
   "MeasurableSpace",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.sum_measure_singleton",
  "constType":
  "∀ {S : Type u_1} {s : Finset S} {x : MeasurableSpace S} [inst : MeasurableSingletonClass S]\n  (μ : MeasureTheory.Measure S), (Finset.sum s fun x_1 => ↑↑μ {x_1}) = ↑↑μ ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["inf_le_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_trans",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_of_left_le",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ c → a ⊓ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "PartialOrder.toPreorder",
   "MulHom.map_mul'",
   "Semiring",
   "AbsoluteValue",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "AbsoluteValue.toMulHom",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "OrderedSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.map_mul",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) (x y : R),\n  abv (x * y) = abv x * abv y",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike.mem_coe",
   "SetLike",
   "propext",
   "Set",
   "SetLike.instMembership",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.SetLike.Basic._auxLemma.3",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.decLt",
   "LT.lt",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "instLTNat",
   "ite"],
  "name": "Nat.pair",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "AddHomClass", "Add"],
  "name": "AddHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Add M] → [inst_1 : Add N] → [self : AddHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommGroupWithOne.toAddCommGroup",
   "AddCommGroupWithOne",
   "One.toOfNat1",
   "AddCommGroupWithOne.toNatCast",
   "AddCommGroupWithOne.toOne",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat"],
  "name": "AddCommGroupWithOne.natCast_succ",
  "constType":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Int.instMulInt",
   "instOfNatInt",
   "Eq.refl",
   "Int.instLTInt",
   "Eq",
   "Int.eq_succ_of_zero_lt",
   "instHMul",
   "Nat.add",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "instNatCastInt",
   "Int.ofNat_succ_pos",
   "LT.lt",
   "Int.mul_pos.match_1",
   "HMul.hMul",
   "Int.ofNat_mul",
   "instMulNat",
   "Nat",
   "Nat.mul",
   "Eq.symm",
   "Int",
   "Nat.succ",
   "id"],
  "name": "Int.mul_pos",
  "constType": "∀ {a b : ℤ}, 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["DenselyNormedField", "IsROrC", "semiOutParam"],
  "name": "IsROrC.toDenselyNormedField",
  "constType":
  "{K : semiOutParam (Type u_1)} → [self : IsROrC K] → DenselyNormedField K",
  "constCategory": "Definition"},
 {"references":
  ["False",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "Preorder",
   "lt_self_iff_false",
   "Eq"],
  "name": "PFR.Main._auxLemma.7",
  "constType": "∀ {α : Type u} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["Abs", "Abs.mk", "Sup", "Neg.neg", "Sup.sup", "Neg"],
  "name": "Neg.toHasAbs",
  "constType": "{α : Type u_1} → [inst : Neg α] → [inst : Sup α] → Abs α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Function.comp",
   "Equiv.mk",
   "Equiv.trans.proof_2",
   "FunLike.coe",
   "Equiv.trans.proof_1",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.trans",
  "constType":
  "{α : Sort u} → {β : Sort v} → {γ : Sort w} → α ≃ β → β ≃ γ → α ≃ γ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "rfl",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHom.id.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddZeroClass M] (x x_1 : M),\n  ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1) =\n    ZeroHom.toFun { toFun := fun x => x, map_zero' := (_ : (fun x => x) 0 = (fun x => x) 0) } (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "mul_le_mul_of_nonneg_left",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toPosMulMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x_2 * x ≤ x_2 * x_1",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : SProd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "add_eq_zero_iff_eq_neg",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "Iff",
   "InvolutiveNeg.toNeg",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_neg_eq_zero",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a + -b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "nsmulRec",
   "Eq",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "Real.cauchy_add",
   "AddSemigroup.toAdd",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Real.cauchy"],
  "name": "Real.commRing.proof_9",
  "constType": "∀ (a : ℝ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Nat",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Nat.succ",
   "Eq"],
  "name": "CommGroupWithZero.zpow_succ'",
  "constType":
  "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀] (n : ℕ) (a : G₀),\n  CommGroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * CommGroupWithZero.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Real.rpow_zero",
   "OfNat.ofNat",
   "Or",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "Real.partialOrder",
   "Real",
   "Real.instLEReal",
   "One.toOfNat1",
   "Or.casesOn",
   "LE.le",
   "True",
   "Real.instOneReal",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.rpow_lt_rpow",
   "Eq.ndrec",
   "of_eq_true",
   "Preorder.toLT",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "le_refl",
   "congr",
   "le_of_lt",
   "congrArg",
   "Eq.trans",
   "eq_or_lt_of_le"],
  "name": "Real.rpow_le_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → x ≤ y → 0 ≤ z → x ^ z ≤ y ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Semigroup.toMul",
   "MulZeroClass.mk",
   "MulZeroClass",
   "SemigroupWithZero.mul_zero",
   "SemigroupWithZero.zero_mul",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero"],
  "name": "SemigroupWithZero.toMulZeroClass",
  "constType":
  "{S₀ : Type u} → [self : SemigroupWithZero S₀] → MulZeroClass S₀",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "InvolutiveNeg.neg_neg",
   "Neg.neg",
   "Eq"],
  "name": "neg_neg",
  "constType": "∀ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references": ["Array", "List.concat", "Array.mk", "Array.data"],
  "name": "Array.push",
  "constType": "{α : Type u} → Array α → α → Array α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "add_nonpos",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "Real.linearOrder",
   "measurableSet_discrete",
   "IsROrC.charZero_isROrC",
   "Iff",
   "Set.Elem",
   "ProbabilityTheory.IsUniform.entropy_eq'",
   "instOfNat",
   "Subtype",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "DivisionRing.toInv",
   "Prod.instMeasurableSpace",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "AddZeroClass.toAdd",
   "NatCast",
   "CommMonoidWithZero.toZero",
   "HEq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Real.instLTReal",
   "LE.le.trans",
   "Mathlib.Tactic.Ring.mul_add",
   "add_lt_of_le_of_neg",
   "Field.toSemifield",
   "LE.le",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "Mathlib.Tactic.Ring.mul_congr",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.isROrC",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "And.casesOn",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Filter.univ_mem'",
   "Real.field",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "Set.instMembershipSet",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "HEq.refl",
   "Eq.mp",
   "Real.instAddGroupReal",
   "ProbabilityTheory.IsUniform.ae_mem",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.IndepFun",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "Pi.instSub",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Linarith.mul_nonpos",
   "Real.log_mul",
   "Set.sub",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "MeasureTheory.MeasureSpace",
   "Real.log_le_log",
   "Eq.casesOn",
   "Bool",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "LT.lt.ne'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "Set.Nonempty",
   "Finite.Set.finite_image2",
   "Real.orderedRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Mathlib.Data.Set.Finite._auxLemma.3",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "le_of_not_gt",
   "HDiv.hDiv",
   "instHSub",
   "HPow.hPow",
   "eq_of_heq",
   "Set.sub_mem_sub",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.isRat_div",
   "Field.toDiv",
   "AddCommGroup",
   "Int",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "Set.toFinite",
   "Filter.mp_mem",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Finset",
   "ProbabilityTheory.IsUniform.of_identDistrib",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Countable",
   "Int.mul",
   "sub_neg_of_lt",
   "Bool.false",
   "Real.instPreorderReal",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instLEReal",
   "Exists.casesOn",
   "Eq",
   "OrderedRing.toRing",
   "ProbabilityTheory.entropy_le_log_card_of_mem",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "rdist",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "setOf",
   "Real.partialOrder",
   "Nat.rawCast",
   "Finite",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "congrArg",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "Iff.rfl",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "le_of_eq",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Preorder.toLT",
   "instHPow",
   "Ring.toSub",
   "LE",
   "Linarith.mul_neg",
   "PFR_conjecture_pos_aux",
   "Real.strictOrderedRing",
   "MeasureTheory.Measure.ae",
   "Eq.symm",
   "Measurable.sub'",
   "funext",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "ProbabilityTheory.IdentDistrib.symm",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Semiring.toOne",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "ProbabilityTheory.independent_copies_two",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "DivisionSemiring.toSemiring",
   "Real.log",
   "Real.semiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Set.Finite.toFinset"],
  "name": "rdist_le_of_isUniform_of_card_add_le",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : MeasurableSpace G] [inst_2 : MeasurableSingletonClass G] {A : Set G}\n  [inst_3 : Finite ↑A] {K : ℝ} [inst_4 : Countable G],\n  Set.Nonempty A →\n    ↑(Nat.card ↑(A - A)) ≤ K * ↑(Nat.card ↑A) →\n      ∀ {Ω : Type u_2} [inst_5 : MeasureTheory.MeasureSpace Ω]\n        [inst_6 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {U₀ : Ω → G},\n        ProbabilityTheory.IsUniform A U₀ → Measurable U₀ → d[U₀ # U₀] ≤ Real.log K",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.mem_iInter₂_of_mem",
   "Set",
   "Set.iInter",
   "Set.instMembershipSet"],
  "name": "Set.mem_biInter",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : α → Set β} {y : β}, (∀ x ∈ s, y ∈ t x) → y ∈ ⋂ x ∈ s, t x",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LE.le.not_lt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "lt_of_not_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_imp_lt_of_le_imp_le",
  "constType":
  "∀ {α : Type u} {β : Type u_3} [inst : LinearOrder α] [inst_1 : Preorder β] {a b : α} {c d : β},\n  (a ≤ b → c ≤ d) → d < c → b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "AbsoluteValue",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "Real.arcsin_zero",
   "Real.instAddMonoidReal",
   "div_zero",
   "Real.decidableLE",
   "Real.pi",
   "Preorder.toLE",
   "Eq",
   "ite",
   "Semiring.toNonAssocSemiring",
   "AbsoluteValue.zeroHomClass",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "Eq.trans",
   "instHSub",
   "Complex.abs",
   "Complex.instZeroComplex",
   "instHDiv",
   "Mathlib.Order.Basic._auxLemma.1",
   "DivisionSemiring.toGroupWithZero",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "instDecidableTrue",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Complex.im",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "Real.instAddGroupReal",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "Complex.instNegComplex",
   "Real",
   "Semiring.toMonoidWithZero",
   "zero_sub",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LinearOrderedField.toDiv",
   "True",
   "AbsoluteValue.subadditiveHomClass",
   "Zero.toOfNat0",
   "zero_add",
   "Complex.instSemiringComplex",
   "ZeroHomClass.toFunLike",
   "map_zero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Real.arcsin",
   "Complex.addCommGroup",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "GroupWithZero.toMonoidWithZero",
   "ite_congr",
   "Complex.re",
   "Real.instZeroReal",
   "OrderedSemiring.toSemiring",
   "Real.instPreorderReal",
   "Complex",
   "Semifield.toDivisionSemiring",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.arg_zero",
  "constType": "Complex.arg 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["OrderIso", "RelIso.symm", "LE", "LE.le"],
  "name": "OrderIso.symm",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : LE α] → [inst_1 : LE β] → α ≃o β → β ≃o α",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset.image₂",
   "Finset",
   "Add",
   "Add.mk"],
  "name": "Finset.add",
  "constType":
  "{α : Type u_2} → [inst : DecidableEq α] → [inst : Add α] → Add (Finset α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "Nat",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec",
   "Exists",
   "Cardinal.toNat_apply_of_lt_aleph0",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero",
   "Classical.choose",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "Cardinal.nat_lt_aleph0",
   "Cardinal.partialOrder",
   "ZeroHom",
   "FunLike.coe",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Eq.mpr",
   "Eq.ndrec",
   "Cardinal.aleph0",
   "Nat.cast",
   "Cardinal.instNatCastCardinal",
   "Iff.mp",
   "Cardinal.natCast_inj",
   "propext",
   "Preorder.toLT",
   "ZeroHomClass.toFunLike",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Cardinal.lt_aleph0",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Cardinal.toNat_cast",
  "constType": "∀ (n : ℕ), Cardinal.toNat ↑n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "One.toOfNat1",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instOneCauchy",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Real.instOneReal",
   "Rat.instSupRat",
   "Real.ofCauchy_one",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.18",
  "constType": "1 = { cauchy := 1 }",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Not",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
  "constType":
  "∀ {α : Type u_1} (a b : MeasurableSpace α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton_iff",
  "constType": "∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NoZeroDivisors",
   "CommMonoidWithZero.toZero",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.eq_zero_or_eq_zero_of_mul_eq_zero",
   "NoZeroDivisors.mk",
   "CanonicallyOrderedCommSemiring",
   "CommSemiring.toCommMonoidWithZero"],
  "name": "CanonicallyOrderedCommSemiring.toNoZeroDivisors",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedCommSemiring α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references":
  ["Iff", "Function.Injective", "Eq.rec", "Function.Injective.eq_iff", "Eq"],
  "name": "Function.Injective.eq_iff'",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α} {c : β}, f b = c → (f a = c ↔ a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["funext",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "inf_of_le_right",
   "Inf.inf",
   "inf_of_le_left",
   "SemilatticeInf.toPartialOrder",
   "dite",
   "minDefault",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "Or.resolve_left",
   "if_pos",
   "Eq.mpr",
   "IsTotal",
   "Not",
   "total_of",
   "congrArg",
   "if_neg",
   "SemilatticeInf",
   "DecidableRel",
   "id"],
  "name": "inf_eq_minDefault",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1], (fun x x_1 => x ⊓ x_1) = minDefault",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "AddCommGroupWithOne"],
  "name": "AddCommGroupWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddCommGroupWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddSubgroup.casesOn",
   "AddGroup",
   "Eq.rec",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddSubsemigroup.casesOn",
   "AddZeroClass",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "instHAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubsemigroup",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Add",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instSetLikeAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (p q : AddSubgroup G), (fun s => s.carrier) p = (fun s => s.carrier) q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "SMulWithZero",
  "constType":
  "(R : Type u_1) → (M : Type u_3) → [inst : Zero R] → [inst : Zero M] → Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Membership.mem",
   "Classical.choose",
   "Equiv.Set.imageOfInjOn.proof_3",
   "Subtype.val",
   "Set",
   "Equiv.Set.imageOfInjOn.proof_1",
   "Equiv.Set.imageOfInjOn.proof_2",
   "Set.InjOn",
   "Set.instMembershipSet",
   "Eq",
   "Equiv.Set.imageOfInjOn.proof_5",
   "And",
   "Set.Elem",
   "Equiv.mk",
   "Equiv.Set.imageOfInjOn.proof_4",
   "Set.image",
   "Subtype.mk"],
  "name": "Equiv.Set.imageOfInjOn",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Set.InjOn f s → ↑s ≃ ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Semiring.toNatCast",
   "Real.linearOrder",
   "SubNegMonoid.toSub",
   "IsROrC.charZero_isROrC",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.neg_congr",
   "instOfNat",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Real.instRingReal",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "AddCommGroup",
   "MeasurableSpace",
   "Int",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Abs.abs",
   "MeasureTheory.Measure",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "neg_nonpos_of_nonneg",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Countable",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "Bool.false",
   "Real.instPreorderReal",
   "Mathlib.Tactic.Ring.add_mul",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Tactic.Ring.mul_congr",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.isROrC",
   "AddGroup.toSubtractionMonoid",
   "diff_ent_le_rdist",
   "Real.instSupReal",
   "Eq",
   "MeasurableSingletonClass",
   "Semiring.toNonAssocSemiring",
   "FiniteRange",
   "rdist",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Real.partialOrder",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "Eq.mp",
   "Real.instAddGroupReal",
   "Mathlib.Tactic.Ring.mul_one",
   "OrderedAddCommGroup.toAddCommGroup",
   "abs_nonneg",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Real.natCast",
   "lt_zero_of_zero_gt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasurableSub₂",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "instHPow",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Linarith.mul_neg",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "ge_trans",
   "Real.strictOrderedRing",
   "CommSemiring.toCommMonoidWithZero",
   "add_lt_of_neg_of_le",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Bool",
   "NegZeroClass.toZero"],
  "name": "rdist_nonneg",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [hG : MeasurableSpace G]\n  [inst : MeasurableSingletonClass G] [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G]\n  {X : Ω → G} {Y : Ω' → G} [inst_3 : FiniteRange X] [inst_4 : FiniteRange Y]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure μ] [inst_6 : MeasureTheory.IsProbabilityMeasure μ'],\n  Measurable X → Measurable Y → 0 ≤ d[X ; μ # Y ; μ']",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "PseudoMetricSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["InvOneClass", "Inv"],
  "name": "InvOneClass.toInv",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → Inv G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references":
  ["SupSet",
   "Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "SupSet.mk",
   "Set.instMembershipSet"],
  "name": "Set.instSupSetSet",
  "constType": "{α : Type u_1} → SupSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.toSubmonoid",
  "constType": "{G : Type u_5} → [inst : Group G] → Subgroup G → Submonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Int.natAbs_mul_self.match_1",
   "OfNat.ofNat",
   "instOfNatInt",
   "Int.negSucc",
   "instHAdd",
   "HAdd.hAdd",
   "Nat",
   "rfl",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "Int.add_zero",
  "constType": "∀ (a : ℤ), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "pos_and_pos_or_neg_and_neg_of_mul_pos",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing",
   "Iff.mpr",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "Iff",
   "mul_pos_of_neg_of_neg",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Or.elim",
   "StrictOrderedRing.toPartialOrder",
   "and_imp",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "StrictOrderedSemiring.toSemiring",
   "Iff.intro",
   "instHMul",
   "And",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "HMul.hMul",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "mul_pos",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toMulPosMono",
   "OrderedSemiring.toPosMulMono"],
  "name": "mul_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α}, 0 < a * b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "invertibleOne.proof_2",
   "One.toOfNat1",
   "Invertible.mk",
   "invertibleOne.proof_1",
   "Invertible",
   "Monoid.toMulOneClass"],
  "name": "invertibleOne",
  "constType": "{α : Type u} → [inst : Monoid α] → Invertible 1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "And.left",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), l (sSup (u '' s)) ∈ upperBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "zpowRec",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "instOfNatInt",
   "DivisionRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.instInvCauchyToRing",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_7",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : CauSeq.Completion.Cauchy abv), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "instNatPowNat",
   "instOfNatNat",
   "Nat",
   "instPowNat",
   "rfl",
   "Eq"],
  "name": "Nat.pow_zero",
  "constType": "∀ (n : ℕ), n ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "And.left",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b : AddSubgroup G) (_x : G),\n  _x ∈ ↑_a.toAddSubmonoid ∧ _x ∈ ↑_b.toAddSubmonoid → _x ∈ ↑_a.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Decidable", "LinearOrder.decidableEq", "Eq"],
  "name": "instDecidableEq",
  "constType":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Set",
   "HasCompl.compl",
   "HasSubset.Subset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set.compl_subset_compl",
   "MeasurableSpace",
   "MeasureTheory.measure_mono_null"],
  "name": "MeasureTheory.Measure.ae.proof_2",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) {x y : Set α},\n  x ∈ {s | ↑↑μ sᶜ = 0} → x ⊆ y → ↑↑μ yᶜ = 0",
  "constCategory": "Theorem"},
 {"references": ["UniformSpace"],
  "name": "CompleteSpace",
  "constType": "(α : Type u) → [inst : UniformSpace α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.map₂.proof_1",
   "instHasEquiv",
   "Setoid",
   "Quotient.lift₂",
   "Quotient",
   "HasEquiv.Equiv",
   "Relator.LiftFun",
   "Quotient.mk"],
  "name": "Quotient.map₂",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    [sa : Setoid α] →\n      [sb : Setoid β] →\n        {γ : Sort u_4} →\n          [sc : Setoid γ] →\n            (f : α → β → γ) →\n              ((fun x x_1 => x ≈ x_1) ⇒ (fun x x_1 => x ≈ x_1) ⇒ fun x x_1 => x ≈ x_1) f f →\n                Quotient sa → Quotient sb → Quotient sc",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "MulPosStrictMono",
   "Subtype.mk",
   "Subtype",
   "CovariantClass.elim"],
  "name": "mul_lt_mul_of_pos_right",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],\n  b < c → 0 < a → b * a < c * a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.OuterMeasure.addCommMonoid",
   "MeasureTheory.Measure.zero_toOuterMeasure",
   "MeasureTheory.Measure.add_toOuterMeasure",
   "AddMonoidWithOne.toAddMonoid",
   "instENNRealAddCommMonoidWithOne",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.instSMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MeasureTheory.Measure.instAddCommMonoid.proof_2",
   "AddMonoid.toNatSMul",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "MeasureTheory.Measure.instAdd",
   "MeasureTheory.Measure.instAddCommMonoid.proof_1",
   "Function.Injective.addCommMonoid",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "AddCommMonoid"],
  "name": "MeasureTheory.Measure.instAddCommMonoid",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → AddCommMonoid (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "DecidableEq",
   "dif_pos",
   "Function.update",
   "Not",
   "Eq.symm",
   "rfl",
   "Eq"],
  "name": "Function.update_same",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (a : α) (v : β a) (f : (a : α) → β a),\n  Function.update f a v a = v",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.sSup_le",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)) (a : AddSubgroup G), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "instHMul",
   "MulOneClass.toMul",
   "Iff",
   "DivInvOneMonoid.toInvOneClass",
   "IsUnit.unit'",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "Units.eq_mul_inv_iff_mul_eq",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Inv.inv",
   "Eq"],
  "name": "IsUnit.eq_mul_inv_iff_mul_eq",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit c → (a = b * c⁻¹ ↔ a * c = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "DecidablePred",
   "And",
   "Exists",
   "Subtype.val",
   "LT.lt",
   "Nat.find",
   "Not",
   "Nat.findX",
   "Nat",
   "And.left",
   "instLTNat"],
  "name": "Nat.find_spec",
  "constType":
  "∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find H)",
  "constCategory": "Theorem"},
 {"references": ["Real", "Complex"],
  "name": "Complex.re",
  "constType": "ℂ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "Set.Elem", "Subtype.val", "Set", "Set.instMembershipSet"],
  "name": "Set.restrict",
  "constType":
  "{α : Type u_1} → {π : α → Type u_5} → (s : Set α) → ((a : α) → π a) → (a : ↑s) → π ↑a",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "ProbabilityTheory.IdentDistrib",
   "autoParam",
   "MeasurableSpace",
   "AEMeasurable"],
  "name": "ProbabilityTheory.IdentDistrib.aemeasurable_snd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {f : α → γ} {g : β → γ} {μ : autoParam (MeasureTheory.Measure α) _auto✝}\n  {ν : autoParam (MeasureTheory.Measure β) _auto✝¹}, ProbabilityTheory.IdentDistrib f g → AEMeasurable g",
  "constCategory": "Definition"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Definition"},
 {"references": ["Norm", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Complex.instZeroComplex",
   "Complex.cpow_zero",
   "Real",
   "One.toOfNat1",
   "True",
   "Eq",
   "Complex.re",
   "Real.instOneReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.rpow_zero",
  "constType": "∀ (x : ℝ), x ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Classical.decRel",
   "Ordering",
   "PartialOrder.mk",
   "Ord.mk",
   "Quotient.liftOn₂",
   "Eq.refl",
   "decidableEqOfDecidableLE",
   "Cardinal.partialOrder.proof_2",
   "Cardinal.instLECardinal.proof_1",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "Ord.compare",
   "And",
   "Cardinal.partialOrder.proof_1",
   "Preorder.toLT",
   "Cardinal.partialOrder.proof_3",
   "decidableLTOfDecidableLE",
   "Cardinal",
   "Cardinal.partialOrder.proof_4",
   "Not",
   "Function.Embedding",
   "compareOfLessAndEq",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.linearOrder.proof_4",
  "constType": "∀ (a b : Cardinal.{u_1}), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommMonoid.toAddMonoid",
   "CommMonoid.mul_comm",
   "CommMonoidWithZero",
   "CommSemiring.toCommMonoidWithZero.proof_1",
   "CommSemiring.toCommMonoidWithZero.proof_2",
   "CommMonoid",
   "CommSemiring",
   "AddMonoid.toZero",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "CommMonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map", "DecidableEq", "Finset", "Finset.val", "Multiset.toFinset"],
  "name": "Finset.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq β] → (α → β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulPosStrictMono",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toMulPosStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], MulPosStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "AddCommMonoid.toAddMonoid",
   "Pi.addCommMonoid.proof_3",
   "Pi.addCommMonoid.proof_1",
   "Pi.addCommMonoid.proof_2",
   "AddMonoid",
   "AddMonoid.mk",
   "Pi.addMonoid",
   "AddCommMonoid.mk",
   "AddMonoid.toAddSemigroup",
   "Pi.addCommMonoid.proof_5",
   "AddMonoid.toZero",
   "AddCommSemigroup",
   "Pi.addCommSemigroup",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid",
   "Pi.addCommMonoid.proof_4"],
  "name": "Pi.addCommMonoid",
  "constType":
  "{I : Type u} → {f : I → Type v} → [inst : (i : I) → AddCommMonoid (f i)] → AddCommMonoid ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "HasCompl",
   "Inf.inf",
   "Set",
   "InfSet.sInf",
   "CompletelyDistribLattice",
   "CompleteLattice.toBot",
   "iSup",
   "autoParam",
   "Preorder.toLE",
   "Eq",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "CompleteAtomicBooleanAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "SDiff",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8764",
   "SemilatticeSup.toPartialOrder",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "HasCompl.compl",
   "SDiff.sdiff",
   "SupSet.sSup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8792",
   "LE.le",
   "Set.instMembershipSet",
   "iInf",
   "CompleteLattice.toInfSet",
   "CompleteLattice.toTop",
   "Sup.sup"],
  "name": "CompleteAtomicBooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toCompletelyDistribLattice : CompletelyDistribLattice α] →\n    (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) →\n      [toHasCompl : HasCompl α] →\n        [toSDiff : SDiff α] →\n          [toHImp : HImp α] →\n            (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n              (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                  autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ →\n                    (∀ (a : α) (s : Set α), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b) →\n                      (∀ (a : α) (s : Set α), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s) → CompleteAtomicBooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "neg_zero",
   "Real",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Eq.refl",
   "Real.instSupReal",
   "dite",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Real.exp_log_eq_abs",
   "Abs.abs",
   "True",
   "Real.instNegReal",
   "Eq",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "Real.log_zero",
   "LinearOrderedRing.toLinearOrder",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "abs_inv",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Real.exp_neg",
   "Real.instInvReal",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "inv_ne_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "GroupWithZero.toInv",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "eq_self",
   "DivisionSemiring.toGroupWithZero",
   "instDistribLattice",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.exp",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.inv_zero",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "Real.log",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "Real.exp_eq_exp",
   "congr",
   "Not",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "congrArg",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "Real.log_inv",
  "constType": "∀ (x : ℝ), Real.log x⁻¹ = -Real.log x",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "AddSubgroup",
   "HasQuotient",
   "Quotient",
   "QuotientAddGroup.leftRel",
   "HasQuotient.mk"],
  "name": "QuotientAddGroup.instHasQuotientAddSubgroup",
  "constType":
  "{α : Type u_1} → [inst : AddGroup α] → HasQuotient α (AddSubgroup α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.succ_add.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (x : ℕ), motive x 0) → (∀ (n m : ℕ), motive n (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHPow",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "Real.exp_add",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "HPow.hPow",
   "mul_add",
   "Real.instLTReal",
   "instHAdd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.normedCommRing",
   "Real.exp",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.instZeroReal",
   "Distrib.leftDistribClass",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "Real.log",
   "of_eq_true",
   "LT.lt",
   "HMul.hMul",
   "congr",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg"],
  "name": "Real.rpow_add",
  "constType": "∀ {x : ℝ}, 0 < x → ∀ (y z : ℝ), x ^ (y + z) = x ^ y * x ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Real.negMulLog",
   "OfNat.ofNat",
   "HEq",
   "MeasureTheory.Measure.map",
   "Set",
   "Real",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "ENNReal.zero_toReal",
   "ENNReal",
   "Eq.mpr",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "tsum_eq_sum",
   "AddMonoid.toZero",
   "Finset.toSet",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "Finset",
   "Measurable",
   "UniformSpace.toTopologicalSpace",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Membership.mem",
   "False",
   "Mathlib.Data.Set.Basic._auxLemma.49",
   "eq_of_heq",
   "Finset.sum",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "HasCompl.compl",
   "Real.pseudoMetricSpace",
   "Finset.instMembershipFinset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "tsum",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Real.negMulLog_zero",
   "Set.instMembershipSet",
   "Real.instZeroReal",
   "eq_false",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "MeasureTheory.Measure.toOuterMeasure",
   "ProbabilityTheory.entropy_eq_sum",
   "Not",
   "Singleton.singleton",
   "Eq.casesOn",
   "congrArg",
   "Real.instAddCommMonoidReal",
   "ENNReal.toReal",
   "MeasurableSpace",
   "MeasureTheory.measure_mono_null"],
  "name": "ProbabilityTheory.entropy_eq_sum_finset",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] {X : Ω → S},\n  Measurable X →\n    ∀ {μ : MeasureTheory.Measure Ω} [inst_1 : MeasureTheory.IsProbabilityMeasure μ] {A : Finset S},\n      ↑↑(MeasureTheory.Measure.map X μ) (↑A)ᶜ = 0 →\n        H[X ; μ] = Finset.sum A fun x => Real.negMulLog (↑↑(MeasureTheory.Measure.map X μ) {x}).toReal",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "Zero",
   "OfNat.ofNat",
   "Semiring.toMonoidWithZero",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "Zero.mk",
   "LinearOrderedField.toLinearOrderedSemifield",
   "MonoidWithZero.toZero",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.instZeroCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Zero (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "AddSubgroup.instTopAddSubgroup",
   "Top.top",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Set.mem_univ",
   "SetLike.instMembership"],
  "name": "AddSubgroup.mem_top",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (x : G), x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Mathlib.Algebra.Invertible.Defs._auxLemma.2",
   "mul_mul_invOf_self_cancel'",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "invertibleMul.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a * b * (⅟b * ⅟a) = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mk'",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.169",
   "autoParam",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "Ring",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "DivisionRing",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.128",
   "Int.natAbs",
   "Inv.inv"],
  "name": "DivisionRing.mk",
  "constType":
  "{K : Type u} →\n  [toRing : Ring K] →\n    [toInv : Inv K] →\n      [toDiv : Div K] →\n        autoParam (∀ (a b : K), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → K → K) →\n            autoParam (∀ (a : K), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : K), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial K] →\n                    [toRatCast : RatCast K] →\n                      (∀ (a : K), a ≠ 0 → a * a⁻¹ = 1) →\n                        0⁻¹ = 0 →\n                          autoParam\n                              (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                              _auto✝⁴ →\n                            (qsmul : ℚ → K → K) →\n                              autoParam (∀ (a : ℚ) (x : K), qsmul a x = ↑a * x) _auto✝⁵ → DivisionRing K",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoid.zero_add",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a : α), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Exists",
   "Classical.choose",
   "Classical.indefiniteDescription"],
  "name": "Classical.choose_spec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "Set",
   "Filter.Eventually",
   "MeasureTheory.Measure.ae",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "Set.instMembershipSet",
   "ProbabilityTheory.IsUniform.measure_preimage_compl"],
  "name": "ProbabilityTheory.IsUniform.ae_mem",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Set S},\n  ProbabilityTheory.IsUniform H X → ∀ᵐ (ω : Ω) ∂μ, X ω ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Set.Nonempty",
   "Set.not_nonempty_iff_eq_empty",
   "Set.instEmptyCollectionSet",
   "Not",
   "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.36",
  "constType": "∀ {α : Type u} {s : Set α}, (¬Set.Nonempty s) = (s = ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "Function.Injective",
   "Function.Bijective.injective",
   "SubNegMonoid.toAddMonoid",
   "AddAction.toVAdd",
   "HVAdd.hVAdd",
   "instHVAdd",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "AddAction.bijective"],
  "name": "AddAction.injective",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddAction α β] (g : α), Function.Injective fun x => g +ᵥ x",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "Real",
   "Real.instRingReal",
   "AddGroupWithOne.toAddGroup"],
  "name": "Real.instAddGroupReal",
  "constType": "AddGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instSubsingletonPUnit",
   "Filter.EventuallyEq",
   "PFR.Mathlib.Probability.Independence.Basic._auxLemma.16",
   "AddCommMonoid.toAddMonoid",
   "Subsingleton.measurableSingletonClass",
   "AddMonoid.toAddZeroClass",
   "Pure.pure",
   "SetLike.instMembership",
   "Eq",
   "MeasureTheory.Measure",
   "ProbabilityTheory.kernel.IndepFun.ae_eq'",
   "Eq.mpr",
   "Filter.instPureFilter",
   "Unit.unit",
   "Filter",
   "MeasureTheory.Measure.ae",
   "Pi.addZeroClass",
   "Eq.trans",
   "MeasureTheory.ae_dirac_eq",
   "Subtype",
   "id",
   "Membership.mem",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Unit",
   "FunLike.coe",
   "Filter.Eventually",
   "MeasureTheory.Measure.dirac",
   "AddSubmonoid",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "ProbabilityTheory.kernel",
   "ProbabilityTheory.instFunLikeSubtypeForAllMeasureMemAddSubmonoidAddZeroClassToAddZeroClassToAddMonoidInstAddCommMonoidInstMembershipInstSetLikeAddSubmonoidKernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "congrArg",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.IndepFun.ae_eq'",
  "constType":
  "∀ {β : Type u_11} {β' : Type u_12} {Ω : Type u_13} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω}\n  {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β} {g g' : Ω → β'},\n  ProbabilityTheory.IndepFun f g →\n    f =ᶠ[MeasureTheory.Measure.ae μ] f' → g =ᶠ[MeasureTheory.Measure.ae μ] g' → ProbabilityTheory.IndepFun f' g'",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references":
  ["Set.add",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddHomClass",
   "HAdd.hAdd",
   "Set.image_image2_distrib",
   "Set",
   "map_add",
   "FunLike.coe",
   "Set.image",
   "Add",
   "Eq"],
  "name": "Set.image_add",
  "constType":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Add α] [inst_1 : Add β] [inst_2 : AddHomClass F α β] (m : F)\n  {s t : Set α}, ⇑m '' (s + t) = ⇑m '' s + ⇑m '' t",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "Eq.mpr",
   "Eq.ndrec",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.max_def",
   "LinearOrder.toMax",
   "Max.max",
   "Eq.refl",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "id",
   "ite",
   "Eq"],
  "name": "max_def",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references": ["Inhabited"],
  "name": "Inhabited.default",
  "constType": "{α : Sort u} → [self : Inhabited α] → α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace.mk",
   "MeasureTheory.MeasureSpace",
   "Prod",
   "MeasureTheory.Measure.prod",
   "MeasureTheory.MeasureSpace.volume",
   "Prod.instMeasurableSpace"],
  "name": "MeasureTheory.Measure.prod.measureSpace",
  "constType":
  "{α : Type u_7} →\n  {β : Type u_8} →\n    [inst : MeasureTheory.MeasureSpace α] → [inst : MeasureTheory.MeasureSpace β] → MeasureTheory.MeasureSpace (α × β)",
  "constCategory": "Definition"},
 {"references": ["Zero", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "UniformSpace",
   "UniformSpace.ofDist.proof_1",
   "Real.orderedAddCommMonoid",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "UniformSpace.ofFun",
   "LE.le",
   "Eq"],
  "name": "UniformSpace.ofDist",
  "constType":
  "{α : Type u} →\n  (dist : α → α → ℝ) →\n    (∀ (x : α), dist x x = 0) →\n      (∀ (x y : α), dist x y = dist y x) → (∀ (x y z : α), dist x z ≤ dist x y + dist y z) → UniformSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_eq_of_mul",
  "constType":
  "∀ {G : Type u} [self : DivisionMonoid G] (a b : G), a * b = 1 → a⁻¹ = b",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Distrib",
   "Eq"],
  "name": "Distrib.mk",
  "constType":
  "{R : Type u_1} →\n  [toMul : Mul R] →\n    [toAdd : Add R] →\n      (∀ (a b c : R), a * (b + c) = a * b + a * c) → (∀ (a b c : R), (a + b) * c = a * c + b * c) → Distrib R",
  "constCategory": "Other"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "exists_and_left.match_1",
   "Exists.intro",
   "And.intro",
   "exists_and_left.match_2"],
  "name": "exists_and_left",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) ↔ b ∧ ∃ x, p x",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Dvd.elim",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "SemigroupWithZero.toZero",
   "SemigroupWithZero.toMulZeroClass",
   "Eq.trans",
   "Eq",
   "SemigroupWithZero"],
  "name": "eq_zero_of_zero_dvd",
  "constType":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a → a = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inhabited",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["RingEquiv", "Add", "Mul"],
  "name": "RingAut",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Type u_1",
  "constCategory": "Definition"},
 {"references": ["One", "Mul", "Invertible"],
  "name": "Invertible.invOf",
  "constType":
  "{α : Type u} → [inst : Mul α] → [inst_1 : One α] → (a : α) → [self : Invertible a] → α",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "Int.negSucc", "Nat", "Int.rec", "Int"],
  "name": "Int.casesOn",
  "constType":
  "{motive : ℤ → Sort u} → (t : ℤ) → ((a : ℕ) → motive (Int.ofNat a)) → ((a : ℕ) → motive (Int.negSucc a)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff.rfl",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Nat.cast_eq_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n = 0 ↔ n = 0",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.mk",
  "constType": "{α : Type u} → (α → α → α) → Add α",
  "constCategory": "Other"},
 {"references":
  ["DivisionMonoid",
   "instHMul",
   "MulOneClass.toMul",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "mul_inv_rev",
  "constType":
  "∀ {G : Type u_1} [inst : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "DivInvMonoid",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "mul_div_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * b / c = a * (b / c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Or", "Or.inl", "False", "propext", "or_false.match_1", "Eq"],
  "name": "or_false",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references": ["AddCommSemigroup", "AddSemigroup"],
  "name": "AddCommSemigroup.toAddSemigroup",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "IsUnit.div_eq_iff",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Iff",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "div_eq_iff",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c ↔ a = c * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real",
   "Real.commRing",
   "Real.zero_lt_one",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "AddMonoid.toZero",
   "Real.instPreorderReal",
   "CommRing.toRing",
   "le_of_lt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instStrictOrderedCommRingReal.proof_3",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Real",
   "CommSemiring",
   "Real.commRing"],
  "name": "Real.instCommSemiringReal",
  "constType": "CommSemiring ℝ",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "CauSeq.Completion.instZeroCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "_private.Mathlib.Data.Real.Basic.0.Real.zero",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Eq.ndrec",
   "_private.Mathlib.Data.Real.Basic.0.Real.zero_def",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "letFun",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "id"],
  "name": "Real.cauchy_zero",
  "constType": "0.cauchy = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Nat.zero_ne_one",
   "instOfNatNat",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "Nat"],
  "name": "Nat.nontrivial",
  "constType": "Nontrivial ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.IsComplete",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    (β : Type u_2) → [inst_1 : Ring β] → (abv : β → α) → [inst : IsAbsoluteValue abv] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "LinearOrderedSemifield.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "Semiring",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalSemiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4056",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "autoParam",
   "Eq",
   "NatCast.natCast",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4095",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                (npow : ℕ → α → α) →\n                  autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                    autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ → Semiring α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_zero",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["One",
   "zpowRec.match_1",
   "npowRec",
   "Nat",
   "Mul",
   "Nat.succ",
   "Int",
   "Inv",
   "Inv.inv"],
  "name": "zpowRec",
  "constType":
  "{M : Type u_2} → [inst : One M] → [inst : Mul M] → [inst : Inv M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "Eq"],
  "name": "neg_eq_of_add_eq_zero_right",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] {a b : G}, a + b = 0 → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real",
   "AbsoluteValue",
   "HAdd.hAdd",
   "MulZeroClass.zero_mul",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Real.orderedRing",
   "Eq",
   "Complex.Complex.addGroupWithOne",
   "Zero.toOfNat0",
   "OneHomClass.toFunLike",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "MonoidHomClass.toOneHomClass",
   "MulZeroClass.toZero",
   "OrderedRing.toOrderedSemiring",
   "Eq.trans",
   "Complex.arg_one",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Complex.instOneComplex",
   "Complex.I",
   "eq_self",
   "Complex.ofReal'",
   "Complex.abs",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Complex.instZeroComplex",
   "Complex.instNontrivialComplex",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "instHAdd",
   "map_one",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "FunLike.coe",
   "Complex.instAddComplex",
   "Real.log_one",
   "NormedField.toNormedCommRing",
   "Real.orderedSemiring",
   "Real.instZeroReal",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "Real.log",
   "of_eq_true",
   "Real.instIsDomainRealSemiring",
   "OrderedSemiring.toSemiring",
   "congr",
   "HMul.hMul",
   "Complex.log",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Complex",
   "add_zero",
   "congrArg",
   "AbsoluteValue.monoidWithZeroHomClass",
   "Complex.instMulComplex",
   "congrFun"],
  "name": "Complex.log_one",
  "constType": "Complex.log 1 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real",
   "Real.definition._@.Mathlib.Data.Real.Basic._hyg.827",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.827",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddCommMonoidWithOne",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["Trans", "outParam"],
  "name": "Trans.mk",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Sort u} →\n        {s : β → γ → Sort v} →\n          {t : outParam (α → γ → Sort w)} → ({a : α} → {b : β} → {c : γ} → r a b → s b c → t a c) → Trans r s t",
  "constCategory": "Other"},
 {"references":
  ["instDecidableFalse",
   "False",
   "instDecidableNot",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "instDecidableIff",
   "instDecidableTrue",
   "instDecidableEqProp",
   "True",
   "Eq"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.casesOn"],
  "name": "Or.elim.match_1",
  "constType":
  "∀ {a b : Prop} (motive : a ∨ b → Prop) (h : a ∨ b),\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → motive h",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "OfNat.ofNat",
   "One.toOfNat1",
   "Semiring.npow_zero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "Semiring.npow",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "instOfNatNat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_4",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (x : CauSeq.Completion.Cauchy abv), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set.mem_setOf",
   "Set.preimage",
   "Set",
   "Eq.refl",
   "Inter.inter",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Set.range",
   "Iff.intro",
   "Set.image_preimage_eq_inter_range.match_1",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "Eq.rec",
   "letFun",
   "And.intro",
   "_private.Mathlib.Data.Set.Image.0.Set.preimage._eq_1",
   "Set.image",
   "Set.mem_range_self",
   "Set.image_preimage_eq_inter_range.match_2",
   "id",
   "Set.instInterSet",
   "Set.mem_image_of_mem"],
  "name": "Set.image_preimage_eq_inter_range",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {t : Set β}, f '' (f ⁻¹' t) = t ∩ Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubgroup.map.proof_1",
   "AddSubsemigroup.mk",
   "AddHomClass.toFunLike",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "AddSubmonoid.map",
   "AddSubgroup.map.proof_3",
   "AddGroup",
   "AddSubgroup.map.proof_2",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubgroup.mk",
   "Set.image",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddMonoidHom",
   "SetLike.coe"],
  "name": "AddSubgroup.map",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → {N : Type u_5} → [inst_1 : AddGroup N] → (G →+ N) → AddSubgroup G → AddSubgroup N",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Finset.vaddFinset",
   "CompleteSemilatticeInf.toPartialOrder",
   "HAdd.hAdd",
   "Set",
   "Set.InjOn",
   "True",
   "iff_self",
   "Eq",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Eq.mpr",
   "Iff",
   "SProd.sprod",
   "Finset.toSet",
   "Finset",
   "HVAdd.hVAdd",
   "Eq.trans",
   "Add.toVAdd",
   "id",
   "Set.instSProd",
   "funext",
   "CompletelyDistribLattice.toCompleteLattice",
   "Set.PairwiseDisjoint",
   "Prod.snd",
   "Set.vaddSet",
   "instHAdd",
   "Mathlib.Data.Finset.Pointwise._auxAddLemma.66",
   "Finset.partialOrder",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Prod.fst",
   "instHVAdd",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Finset.instOrderBotFinsetToLEToPreorderPartialOrder",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "DecidableEq",
   "Finset.coe_vadd_finset",
   "Prod",
   "Mathlib.Data.Finset.Pointwise._auxAddLemma.67",
   "Add",
   "CompleteLattice.toCompleteSemilatticeInf",
   "congrArg",
   "IsLeftCancelAdd",
   "congrFun"],
  "name": "Finset.pairwiseDisjoint_vadd_iff",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsLeftCancelAdd α] [inst_2 : DecidableEq α] {s : Set α} {t : Finset α},\n  (Set.PairwiseDisjoint s fun x => x +ᵥ t) ↔ Set.InjOn (fun p => p.1 + p.2) (s ×ˢ ↑t)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "add_lt_add_left",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "instTransEq_1",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "instTransLtToLTLeToLE",
   "add_zero",
   "AddZeroClass"],
  "name": "add_lt_of_le_of_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α}, b ≤ c → a < 0 → b + a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.instEmptyCollectionFinset",
   "Fintype.mk",
   "Fintype",
   "EmptyCollection.emptyCollection",
   "Fintype.ofSurjective",
   "Function.Injective",
   "Finset",
   "Function.invFun_surjective",
   "Fintype.ofInjective.proof_1",
   "Not",
   "dite",
   "Classical.dec",
   "Function.invFun",
   "Nonempty",
   "Eq"],
  "name": "Fintype.ofInjective",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Fintype β] → (f : α → β) → Function.Injective f → Fintype α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.Nonempty",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.image2.match_1",
  "constType":
  "∀ {β : Type u_1} {t : Set β} (motive : Set.Nonempty t → Prop) (x : Set.Nonempty t),\n  (∀ (w : β) (hb : w ∈ t), motive (_ : ∃ x, x ∈ t)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Set",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "Preorder.le_trans",
   "LT.mk",
   "Preorder.toLE",
   "SetLike.instMembership",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "completeLatticeOfInf",
   "LE.le",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Preorder.mk",
   "SetLike.instPartialOrder",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "LT.lt",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "PartialOrder.le_antisymm",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.lt_iff_le_not_le",
   "SetLike.coe"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_11",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (x x_1 x_2 : AddSubmonoid M),\n  x ≤ x_1 → x ≤ x_2 → ∀ x_3 ∈ x, x_3 ∈ ↑x_1 ∧ x_3 ∈ ↑x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "instHasEquiv",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.equiv",
   "Real.mk_eq",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "propext",
   "Real.mk",
   "Rat.instNegRat",
   "HasEquiv.Equiv",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.7",
  "constType": "∀ {f g : CauSeq ℚ abs}, (Real.mk f = Real.mk g) = (f ≈ g)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.zsmul (Int.ofNat (Nat.succ n)) a = a + AddGroupWithOne.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Monoid.toNatPow",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₃ b c : R} (a₁ : R) (a₂ : ℕ), a₃ * b = c → a₁ ^ a₂ * a₃ * b = a₁ ^ a₂ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Set.instHasSubsetSet",
   "Set.Elem",
   "Set",
   "Cardinal",
   "HasSubset.Subset",
   "Function.Embedding",
   "Cardinal.mk",
   "LE.le",
   "Set.embeddingOfSubset",
   "Cardinal.instLECardinal"],
  "name": "Cardinal.mk_le_mk_of_subset",
  "constType":
  "∀ {α : Type u_1} {s t : Set α}, s ⊆ t → Cardinal.mk ↑s ≤ Cardinal.mk ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Units",
   "inv_mul_cancel",
   "Ne",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "MonoidWithZero.toZero",
   "mul_inv_cancel",
   "Units.mk",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toInv",
   "Inv.inv"],
  "name": "Units.mk0",
  "constType":
  "{G₀ : Type u_3} → [inst : GroupWithZero G₀] → (a : G₀) → a ≠ 0 → G₀ˣ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedAddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "HVAdd"],
  "name": "HVAdd.hVAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HVAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "OrderedRing.toPartialOrder",
   "OrderedRing.toRing",
   "OrderedRing.toOrderedSemiring.proof_1",
   "Semiring",
   "OrderedRing",
   "OrderedRing.add_le_add_left",
   "OrderedSemiring.mk",
   "OrderedRing.toOrderedSemiring.proof_2",
   "Ring.toSemiring",
   "OrderedRing.zero_le_one"],
  "name": "OrderedRing.toOrderedSemiring",
  "constType": "{α : Type u} → [inst : OrderedRing α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [inst : Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references": ["Rat.inv", "Rat", "Inv", "Inv.mk"],
  "name": "Rat.instInvRat",
  "constType": "Inv ℚ",
  "constCategory": "Definition"},
 {"references": ["Cardinal", "Nat", "Cardinal.mk", "Cardinal.lift"],
  "name": "Cardinal.aleph0",
  "constType": "Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Complex.instCommSemiringComplex",
   "Semiring",
   "Complex"],
  "name": "Complex.instSemiringComplex",
  "constType": "Semiring ℂ",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsLeftCancelAdd.add_left_cancel",
   "Add",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_left_cancel",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.toDiv",
   "CommGroupWithZero",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Inv.inv",
   "Eq"],
  "name": "CommGroupWithZero.div_eq_mul_inv",
  "constType":
  "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀] (a b : G₀), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedCommSemiring",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Subsemigroup.carrier",
   "Group.toDivisionMonoid",
   "MulOneClass.toMul",
   "Set",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "DivInvOneMonoid.toInvOneClass",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "Subgroup.inv_mem'",
  "constType":
  "∀ {G : Type u_5} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "List.Perm.length_eq",
   "OfNat.ofNat",
   "Quotient.inductionOn₂",
   "List.length_append",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "HAdd.hAdd",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Eq",
   "Zero.toOfNat0",
   "Quot.liftOn",
   "AddZeroClass.toZero",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card.proof_2",
  "constType":
  "∀ {α : Type u_1} (s t : Multiset α),\n  ZeroHom.toFun\n      {\n        toFun := fun s =>\n          Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n        map_zero' :=\n          (_ :\n            (fun s =>\n                  Quot.liftOn s List.length\n                    (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                0 =\n              (fun s =>\n                  Quot.liftOn s List.length\n                    (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                0) }\n      (s + t) =\n    ZeroHom.toFun\n        {\n          toFun := fun s =>\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        s +\n      ZeroHom.toFun\n        {\n          toFun := fun s =>\n            Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂),\n          map_zero' :=\n            (_ :\n              (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0 =\n                (fun s =>\n                    Quot.liftOn s List.length\n                      (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n                  0) }\n        t",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_1",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3954",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Equiv", "MulEquiv", "Mul"],
  "name": "MulEquiv.toEquiv",
  "constType":
  "{M : Type u_12} → {N : Type u_13} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → M ≃ N",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "And.intro",
   "Exists.intro",
   "ExistsUnique",
   "And.casesOn",
   "Exists.casesOn",
   "Eq"],
  "name": "ExistsUnique.exists.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃! x, p x) → Prop) (x : ∃! x, p x),\n  (∀ (x : α) (h : p x) (right : ∀ (y : α), (fun x => p x) y → y = x),\n      motive (_ : ∃ x, (fun x => p x) x ∧ ∀ (y : α), p y → y = x)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["Finset.coe_inj",
   "Iff.mp",
   "Function.Injective",
   "Finset.toSet",
   "Set",
   "Finset",
   "Eq"],
  "name": "Finset.coe_injective",
  "constType": "∀ {α : Type u_4}, Function.Injective Finset.toSet",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.sub_eq_add_neg",
  "constType": "∀ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.zero_mul",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "HAdd.hAdd",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "autoParam",
   "Semiring.toNatCast",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Ring",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124",
   "instHSub",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Semiring",
   "HSub.hSub",
   "Neg.neg",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
   "instNatCastInt",
   "Int.negSucc",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "Ring.mk",
  "constType":
  "{R : Type u} →\n  [toSemiring : Semiring R] →\n    [toNeg : Neg R] →\n      [toSub : Sub R] →\n        autoParam (∀ (a b : R), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → R → R) →\n            autoParam (∀ (a : R), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : R), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : R), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  (∀ (a : R), -a + a = 0) →\n                    [toIntCast : IntCast R] →\n                      autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝⁴ →\n                        autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝⁵ → Ring R",
  "constCategory": "Other"},
 {"references": [],
  "name": "IsTrans",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "instZeroAddMonoidHom",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "Iff.symm",
   "And",
   "Iff",
   "and_iff_left",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField",
   "AddMonoidHom"],
  "name": "Real.isROrC.proof_13",
  "constType": "∀ {z w : ℝ}, z ≤ w ↔ z ≤ w ∧ 0 z = 0 z",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddSubmonoid.map",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubsemigroup.carrier",
   "AddMonoidHom"],
  "name": "AddSubgroup.map.proof_2",
  "constType":
  "∀ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup G),\n  0 ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.827"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.add",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Set.subtractionMonoid.proof_9",
   "Set.subtractionMonoid.proof_1",
   "AddMonoid.nsmul",
   "SMul",
   "Set",
   "Sub",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.addMonoid",
   "SubtractionMonoid.mk",
   "Sub.mk",
   "zsmulRec",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "InvolutiveNeg",
   "AddMonoid.toAddSemigroup",
   "Set.subtractionMonoid.proof_4",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "Set.subtractionMonoid.proof_8",
   "Set.sub",
   "Sub.sub",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Set.subtractionMonoid.proof_6",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "AddMonoid",
   "AddMonoid.mk",
   "Set.addSemigroup",
   "Set.subtractionMonoid.proof_7",
   "Set.subtractionMonoid.proof_3",
   "Set.ZSMul",
   "SubtractionMonoid.toSubNegMonoid",
   "Set.subtractionMonoid.proof_11",
   "SubNegMonoid.toAddMonoid",
   "Set.subtractionMonoid.proof_2",
   "Set.subtractionMonoid.proof_10",
   "Set.subtractionMonoid.proof_12",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int",
   "Set.addZeroClass",
   "Set.subtractionMonoid.proof_5"],
  "name": "Set.subtractionMonoid",
  "constType":
  "{α : Type u_2} → [inst : SubtractionMonoid α] → SubtractionMonoid (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.right_distrib",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "NormedCommRing"],
  "name": "NormedCommRing.toNormedRing",
  "constType": "{α : Type u_5} → [self : NormedCommRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CharP",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "AddMonoid.toZero",
   "Nat.instDvdNat",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "CharP.cast_eq_zero_iff'",
   "Nat",
   "Eq"],
  "name": "CharP.cast_eq_zero_iff",
  "constType":
  "∀ (R : Type u) [inst : AddMonoidWithOne R] (p : ℕ) [inst_1 : CharP R p] (x : ℕ), ↑x = 0 ↔ p ∣ x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "AddGroup.mk",
  "constType":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Semiring",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mk",
  "constType":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Field.toSemifield",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.toInv",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionRing.inv_zero",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Inv.inv"],
  "name": "CauSeq.Completion.Cauchy.field.proof_8",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], 0⁻¹ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.iterate.match_1",
  "constType":
  "{α : Sort u_2} →\n  (motive : ℕ → α → Sort u_1) →\n    (x : ℕ) → (x_1 : α) → ((a : α) → motive 0 a) → ((k : ℕ) → (a : α) → motive (Nat.succ k) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Complex.instZeroComplex",
   "Semiring.toNonAssocSemiring",
   "Real.nontrivial",
   "Real.semiring",
   "Real",
   "One.toOfNat1",
   "Complex",
   "pullback_nonzero",
   "Nontrivial",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Complex.instOneComplex",
   "Complex.re"],
  "name": "Complex.instNontrivialComplex",
  "constType": "Nontrivial ℂ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "Mathlib.GroupTheory.Submonoid.Basic._auxAddLemma.7",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Eq.ndrec",
   "Eq.mp",
   "Singleton.singleton",
   "add_zero",
   "AddZeroClass",
   "id"],
  "name": "AddSubmonoid.instBotAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {a b : M}, a ∈ {0} → b ∈ {0} → a + b ∈ {0}",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Bool.false", "Bool.true", "Eq.refl", "Bool", "Eq"],
  "name": "Nat.decEq.match_1",
  "constType":
  "(motive : Bool → Sort u_1) → (x : Bool) → (x = true → motive true) → (x = false → motive false) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace.proof_1",
   "PseudoMetricSpace.toUniformSpace",
   "T0Space",
   "UniformSpace.toTopologicalSpace",
   "MetricSpace.mk",
   "PseudoMetricSpace"],
  "name": "MetricSpace.ofT0PseudoMetricSpace",
  "constType":
  "(α : Type u_3) → [inst : PseudoMetricSpace α] → [inst : T0Space α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "covariant_swap_add_of_covariant_add",
   "le_add_of_nonneg_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt.trans_le",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "zero_lt_one",
   "Nat.cast_nonneg'",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_add_one_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] (n : ℕ), 0 < ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "MulHom.toFun",
   "ZeroHomClass.mk",
   "Semiring.toNonAssocSemiring",
   "ZeroHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "AbsoluteValue",
   "FunLike.mk",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "AbsoluteValue.zeroHomClass.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "MonoidWithZero.toZero",
   "AbsoluteValue.zeroHomClass.proof_1",
   "AbsoluteValue.toMulHom"],
  "name": "AbsoluteValue.zeroHomClass",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} → [inst : Semiring R] → [inst_1 : OrderedSemiring S] → ZeroHomClass (AbsoluteValue R S) R S",
  "constCategory": "Definition"},
 {"references":
  ["Subgroup.subtype_injective",
   "Exists",
   "MulEquiv.toEquiv",
   "PartialOrder.toPreorder",
   "Subgroup.map_subtype_le",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Eq.refl",
   "IsPGroup",
   "Exists.intro",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Nat.Prime",
   "Sylow.exists_subgroup_card_pow_prime_of_le_card",
   "instLENat",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "Subgroup",
   "Group",
   "Nat",
   "Eq.symm",
   "Subtype",
   "id",
   "Membership.mem",
   "HPow.hPow",
   "Subgroup.instCompleteLatticeSubgroup",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "MulEquiv",
   "Subgroup.map",
   "Subgroup.equivMapOfInjective",
   "LE.le",
   "Nat.card_congr",
   "And",
   "Eq.ndrec",
   "Subgroup.toGroup",
   "And.intro",
   "Subgroup.mul",
   "Nat.card",
   "MulEquiv.symm",
   "Subgroup.instSetLikeSubgroup",
   "IsPGroup.to_subgroup",
   "Subgroup.subtype"],
  "name": "Sylow.exists_subgroup_le_card_pow_prime_of_le_card",
  "constType":
  "∀ {G : Type u} [inst : Group G] {n p : ℕ},\n  Nat.Prime p → IsPGroup p G → ∀ {H : Subgroup G}, p ^ n ≤ Nat.card ↥H → ∃ H' ≤ H, Nat.card ↥H' = p ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Membership.mem",
   "upperBounds",
   "IsGLB",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "InfSet",
   "Set.univ",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "completeLatticeOfInf.proof_12",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α], (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (x : α), sInf Set.univ ≤ x",
  "constCategory": "Theorem"},
 {"references": ["One", "NonAssocRing"],
  "name": "NonAssocRing.toOne",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → One α",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl", "Or.inr", "Not", "Or.casesOn"],
  "name": "Classical.propDecidable.match_1",
  "constType":
  "∀ (a : Prop) (motive : a ∨ ¬a → Prop) (x : a ∨ ¬a),\n  (∀ (h : a), motive (_ : a ∨ ¬a)) → (∀ (h : ¬a), motive (_ : a ∨ ¬a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "OfNat.ofNat",
   "Semiring.mul_one",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_8",
  "constType": "∀ (a : ℕ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Zero.toOfNat0",
   "Monoid.toSemigroup",
   "instHMul",
   "Ne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "One.toOfNat1",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toInv",
   "Inv.inv",
   "Eq"],
  "name": "GroupWithZero.mul_inv_cancel",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.val_injective",
   "Subtype.instMeasurableSpace",
   "Set.preimage",
   "MeasurableSingletonClass.measurableSet_singleton",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Set.image_singleton",
   "Eq",
   "Set.preimage_image_eq",
   "MeasurableSingletonClass",
   "And",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Eq.ndrec",
   "MeasurableSet",
   "Singleton.singleton",
   "And.intro",
   "Set.image",
   "Eq.symm",
   "MeasurableSpace",
   "MeasurableSingletonClass.mk",
   "Subtype",
   "id"],
  "name": "Subtype.instMeasurableSingletonClass",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] {p : α → Prop} [inst_1 : MeasurableSingletonClass α],\n  MeasurableSingletonClass (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubmonoid.toAddSubsemigroup",
   "Inf.inf",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubmonoid.instInfAddSubmonoid",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instInfAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G), 0 ∈ (H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid).carrier",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.mk",
  "constType": "{α : Type u} → α → EmptyCollection α",
  "constCategory": "Other"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.add_zero",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_3",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.OuterMeasure.coe_fn_injective",
   "Monoid",
   "Pi.mulAction",
   "Set",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "MulAction.toSMul",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.OuterMeasure.instMulAction.proof_1",
   "Algebra.id",
   "MulAction",
   "Algebra.toSMul",
   "Function.Injective.mulAction",
   "MeasureTheory.OuterMeasure"],
  "name": "MeasureTheory.OuterMeasure.instMulAction",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_3} →\n    [inst : Monoid R] →\n      [inst_1 : MulAction R ENNReal] →\n        [inst_2 : IsScalarTower R ENNReal ENNReal] → MulAction R (MeasureTheory.OuterMeasure α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Eq.ndrec",
   "Iff",
   "RelIso.toEquiv",
   "Function.Injective",
   "RelIso.toEquiv_injective.match_1",
   "Eq.rec",
   "RelIso",
   "Eq.refl",
   "FunLike.coe",
   "RelIso.mk",
   "Equiv.instFunLikeEquiv",
   "Eq"],
  "name": "RelIso.toEquiv_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}, Function.Injective RelIso.toEquiv",
  "constCategory": "Theorem"},
 {"references": ["Decidable.byCases.match_1", "Decidable", "Not"],
  "name": "Decidable.byCases",
  "constType":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedRing"],
  "name": "LinearOrderedRing.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "Exists",
   "OfNat.ofNat",
   "Int.instSubInt",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddGroupWithOne.toSub",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "OrderedRing",
   "CanLift.prf",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Int.linearOrderedCommRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Ring.toIntCast",
   "OrderedRing.toOrderedSemiring",
   "Nat",
   "Eq.symm",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Int.cast_sub",
   "Nat.cast_nonneg",
   "sub_nonneg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Int.cast_ofNat",
   "OrderedRing.toPartialOrder",
   "Eq.ndrec",
   "Int.instAddGroupInt",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Eq.mp",
   "Monotone",
   "instCanLiftIntNatCastInstNatCastIntLeInstLEIntOfNatInstOfNatInt",
   "NegZeroClass.toZero",
   "Int",
   "Int.instLEInt"],
  "name": "Int.cast_mono",
  "constType": "∀ {α : Type u_3} [inst : OrderedRing α], Monotone fun x => ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "Iff",
   "Finset",
   "Finset.filter",
   "Finset.val",
   "Multiset.mem_filter",
   "Finset.instMembershipFinset"],
  "name": "Finset.mem_filter",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, a ∈ Finset.filter p s ↔ a ∈ s ∧ p a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.zero_add",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderTop",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.toOrderTop",
  "constType":
  "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["Inter",
   "Multiset.ndinter",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Inter.mk",
   "Finset.instInterFinset.proof_1",
   "Finset.mk"],
  "name": "Finset.instInterFinset",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Inter (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "NonAssocRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "One",
   "Nat.cast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instAddNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Neg.neg",
   "One.toOfNat1",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "instHMul",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "instNatCastInt",
   "Int.negSucc",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "NonAssocRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] →\n    [toOne : One α] →\n      (∀ (a : α), 1 * a = a) →\n        (∀ (a : α), a * 1 = a) →\n          [toNatCast : NatCast α] →\n            autoParam (NatCast.natCast 0 = 0) _auto✝ →\n              autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                [toIntCast : IntCast α] →\n                  autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝² →\n                    autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝³ → NonAssocRing α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mk",
  "constType":
  "{α : Type u} → [toLinearOrderedRing : LinearOrderedRing α] → (∀ (a b : α), a * b = b * a) → LinearOrderedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddSubgroup.instCompleteLatticeAddSubgroup.proof_7",
   "Inf.inf",
   "AddSubgroup.mem_top",
   "CompleteLattice.mk",
   "Lattice.mk",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_2",
   "SetLike.instMembership",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_5",
   "AddSubgroup.instTopAddSubgroup",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instBotAddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_3",
   "Membership.mem",
   "Bot.bot",
   "Top.top",
   "AddSubgroup.instInfAddSubgroup",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_4",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_8",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_9",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "SetLike.instPartialOrder",
   "CompleteLattice",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_6",
   "CompleteLattice.toInfSet",
   "Bot.mk",
   "Top.mk"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → CompleteLattice (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Complex.instZeroComplex",
   "Complex.instDecidableEqComplex",
   "One.toOfNat1",
   "rfl",
   "Eq",
   "ite",
   "Zero.toOfNat0",
   "instHMul",
   "Complex.instPowComplex",
   "instHPow",
   "HMul.hMul",
   "Complex.log",
   "Complex",
   "Complex.instMulComplex",
   "Complex.instOneComplex",
   "Complex.exp"],
  "name": "Complex.cpow_def",
  "constType":
  "∀ (x y : ℂ), x ^ y = if x = 0 then if y = 0 then 1 else 0 else Complex.exp (Complex.log x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_total.match_1",
   "Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Nat.le_of_lt",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.le_total",
  "constType": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EmbeddingLike.toFunLike",
   "FunLike",
   "EquivLike.toEmbeddingLike",
   "Equiv.instEquivLikeEquiv"],
  "name": "Equiv.instFunLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α fun x => β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["AddCancelCommMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelCommMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [inst : Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CauSeq.const",
   "Real.instLinearOrderedFieldReal",
   "instHasEquiv",
   "PartialOrder.toPreorder",
   "AbsoluteValue",
   "Real",
   "CauSeq.IsComplete",
   "Exists.intro",
   "Preorder.toLE",
   "AbsoluteValue.subadditiveHomClass",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedField.toLinearOrderedSemifield",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Complex.abs",
   "CauSeq.IsComplete.mk",
   "Complex.limAux",
   "Complex.instRingComplex",
   "FunLike.coe",
   "CauSeq",
   "Real.orderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "SubadditiveHomClass.toFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CauSeq.equiv",
   "Complex.equiv_limAux",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "HasEquiv.Equiv",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.instIsComplete",
  "constType": "CauSeq.IsComplete ℂ ⇑Complex.abs",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "CauSeq.const",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "CauSeq.LimZero",
   "dite",
   "Iff.mpr",
   "Eq",
   "IsAbsoluteValue",
   "mul_assoc",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Iff.mp",
   "LinearOrderedField.toLinearOrderedSemifield",
   "not_false",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "DivisionRing",
   "MulOneClass.toOne",
   "Classical.propDecidable",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "instDecidableTrue",
   "SemigroupWithZero.toSemigroup",
   "instDecidableFalse",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "eq_true",
   "of_eq_true",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "congr",
   "mul_one",
   "Not",
   "congrArg",
   "CauSeq.limZero_congr",
   "DivisionRing.toDivisionSemiring",
   "instHasEquiv",
   "DivisionRing.toRing",
   "CauSeq.instZeroCauSeq",
   "Eq.refl",
   "CauSeq.Completion.instOneCauchy",
   "dite_congr",
   "CauSeq.inv_mul_cancel",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedField",
   "CauSeq.mul_inv_cancel",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "CauSeq.instMulCauSeq",
   "CauSeq.Completion.mk_eq",
   "id",
   "eq_self",
   "False",
   "One.toOfNat1",
   "CauSeq",
   "mt",
   "Ring.toSemiring",
   "CauSeq.equiv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "eq_false",
   "Eq.ndrec",
   "CauSeq.inv",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Eq.mpr_not",
   "CauSeq.Completion.mk",
   "HasEquiv.Equiv"],
  "name": "CauSeq.Completion.instInvCauchyToRing.proof_1",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (f g : CauSeq β abv),\n  f ≈ g →\n    CauSeq.Completion.mk (if h : CauSeq.LimZero f then 0 else CauSeq.inv f h) =\n      CauSeq.Completion.mk (if h : CauSeq.LimZero g then 0 else CauSeq.inv g h)",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.instMul",
   "NonUnitalNonAssocRing.toMul",
   "CauSeq.instMulCauSeq.proof_1",
   "Subtype.val",
   "IsCauSeq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Ring.toNonAssocRing",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "instHMul",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Mul",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Subtype.mk",
   "Mul.mk"],
  "name": "CauSeq.instMulCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Mul (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["Complex.im",
   "Complex.ext.match_1",
   "Complex.mk",
   "Real",
   "Complex",
   "rfl",
   "Complex.re",
   "Eq"],
  "name": "Complex.ext",
  "constType": "∀ {z w : ℂ}, z.re = w.re → z.im = w.im → z = w",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "SubNegMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Multiplicative",
   "Monoid.one_mul",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq",
   "Multiplicative.monoid"],
  "name": "Multiplicative.divInvMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SubNegMonoid α] (a : Multiplicative α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.left_distrib",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommSemiring.toMin",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.min_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.SetTheory.Cardinal.Finite._auxLemma.2",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "ZeroHom.zeroHomClass",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.68",
   "Cardinal.partialOrder",
   "instLTNat",
   "Nonempty",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "Cardinal.toNat",
   "Iff",
   "Cardinal.aleph0",
   "ZeroHomClass.toFunLike",
   "Preorder.toLT",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Cardinal.mk",
   "Nat",
   "Eq.trans",
   "Ne",
   "Nat.linearOrderedCommMonoidWithZero",
   "Mathlib.Logic.IsEmpty._auxLemma.4",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.6",
   "Finite",
   "ZeroHom",
   "FunLike.coe",
   "IsEmpty",
   "Cardinal.instZeroCardinal",
   "And",
   "of_eq_true",
   "LT.lt",
   "Cardinal",
   "congr",
   "Not",
   "Nat.card",
   "congrArg",
   "congrFun"],
  "name": "Nat.card_pos_iff",
  "constType": "∀ {α : Type u_1}, 0 < Nat.card α ↔ Nonempty α ∧ Finite α",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InvolutiveNeg",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "Semiring",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
   "StrictOrderedRing.toNontrivial",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
   "StrictOrderedRing.zero_le_one",
   "StrictOrderedRing.toStrictOrderedSemiring.proof_1"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedRing α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "HasCompl",
   "Top.top",
   "Inf.inf",
   "HasCompl.compl",
   "SDiff.sdiff",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8792",
   "autoParam",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "Eq",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "Top",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "DistribLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "_auto._@.Mathlib.Order.BooleanAlgebra._hyg.8764",
   "SDiff",
   "HImp",
   "SemilatticeSup.toPartialOrder"],
  "name": "BooleanAlgebra.mk",
  "constType":
  "{α : Type u} →\n  [toDistribLattice : DistribLattice α] →\n    [toHasCompl : HasCompl α] →\n      [toSDiff : SDiff α] →\n        [toHImp : HImp α] →\n          [toTop : Top α] →\n            [toBot : Bot α] →\n              (∀ (x : α), x ⊓ xᶜ ≤ ⊥) →\n                (∀ (x : α), ⊤ ≤ x ⊔ xᶜ) →\n                  (∀ (a : α), a ≤ ⊤) →\n                    (∀ (a : α), ⊥ ≤ a) →\n                      autoParam (∀ (x y : α), x \\ y = x ⊓ yᶜ) _auto✝ →\n                        autoParam (∀ (x y : α), x ⇨ y = y ⊔ xᶜ) _auto✝¹ → BooleanAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Set",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure.dirac",
   "instENNRealZero",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "MeasureTheory.OuterMeasure.dirac",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Pi.instOne",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.dirac.proof_1",
   "MeasurableSet",
   "MeasurableSpace",
   "MeasureTheory.toMeasure_apply",
   "Set.indicator"],
  "name": "MeasureTheory.Measure.dirac_apply'",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α} (a : α),\n  MeasurableSet s → ↑↑(MeasureTheory.Measure.dirac a) s = Set.indicator s 1 a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3915",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.3933",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.3933",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Real.ext_cauchy_iff",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "Abs.abs",
   "Iff.mpr",
   "Rat.instSupRat",
   "Eq"],
  "name": "Real.ext_cauchy",
  "constType": "∀ {x y : ℝ}, x.cauchy = y.cauchy → x = y",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "HasEquiv", "HasEquiv.mk"],
  "name": "instHasEquiv",
  "constType": "{α : Sort u} → [inst : Setoid α] → HasEquiv α",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Ordering",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Ordering.Compares",
   "Preorder.toLT",
   "StrictMono",
   "StrictMonoOn.compares",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Set.univ",
   "StrictMono.strictMonoOn"],
  "name": "StrictMono.compares",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → ∀ {a b : α} {o : Ordering}, Ordering.Compares o (f a) (f b) ↔ Ordering.Compares o a b",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubmonoid.mem_toSubsemigroup",
   "AddZeroClass.toAdd",
   "Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.instSetLikeSubsemigroup",
   "propext",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Eq",
   "AddSubsemigroup"],
  "name": "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {s : AddSubmonoid M} {x : M}, (x ∈ s.toAddSubsemigroup) = (x ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Or",
   "Rat.nonneg_total",
   "Rat.instLERat",
   "SubNegMonoid.toNeg",
   "Rat",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LE.le",
   "Eq",
   "Rat.instSubRat",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "Rat.addCommGroup",
   "Rat.le_iff_Nonneg",
   "SubtractionMonoid.toSubNegMonoid",
   "propext",
   "Eq.mp",
   "letFun",
   "Rat.instNegRat",
   "Rat.Nonneg",
   "neg_sub",
   "id"],
  "name": "Rat.le_total",
  "constType": "∀ (a b : ℚ), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "Set.indicator_of_mem",
   "MeasureTheory.Measure.dirac_apply_of_mem",
   "dite",
   "nonpos_iff_eq_zero",
   "BooleanAlgebra.toHasCompl",
   "CanonicallyOrderedCommSemiring.toOne",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "MeasurableSingletonClass",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Pi.instOne",
   "Iff.mp",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "not_false_eq_true",
   "Set.subset_compl_comm",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Classical.propDecidable",
   "HasCompl.compl",
   "HasSubset.Subset",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "instTransEq_1",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "propext",
   "Pi.one_apply",
   "Not",
   "Singleton.singleton",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "Set.indicator",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "MeasureTheory.measure_mono",
   "Set.indicator_of_not_mem",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "MeasureTheory.Measure.dirac_apply'",
   "True",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.2",
   "AddMonoid.toZero",
   "MeasurableSet",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "False",
   "One.toOfNat1",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasureTheory.Measure.dirac",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.14",
   "not_true_eq_false"],
  "name": "MeasureTheory.Measure.dirac_apply",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] (a : α) (s : Set α),\n  ↑↑(MeasureTheory.Measure.dirac a) s = Set.indicator s 1 a",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.inv'_def",
   "Neg.toHasAbs",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "letFun",
   "CauSeq.Completion.Cauchy",
   "Real.instInvReal",
   "CauSeq.Completion.instInvCauchyToRing",
   "Rat.instLinearOrderedFieldRat",
   "id",
   "Inv.inv"],
  "name": "Real.ofCauchy_inv",
  "constType":
  "∀ {f : CauSeq.Completion.Cauchy abs}, { cauchy := f⁻¹ } = { cauchy := f }⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasurableSpace.instLEMeasurableSpace",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.OuterMeasure.toMeasure.proof_1",
   "Set",
   "MeasurableSet",
   "MeasureTheory.OuterMeasure.empty",
   "MeasureTheory.OuterMeasure",
   "LE.le",
   "MeasurableSpace",
   "MeasureTheory.Measure.ofMeasurable",
   "MeasureTheory.OuterMeasure.caratheodory"],
  "name": "MeasureTheory.OuterMeasure.toMeasure",
  "constType":
  "{α : Type u_1} →\n  [ms : MeasurableSpace α] →\n    (m : MeasureTheory.OuterMeasure α) → ms ≤ MeasureTheory.OuterMeasure.caratheodory m → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CommSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CommSemiring",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toCommSemiring",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["HAdd.hAdd",
   "Set.Nonempty",
   "Finset.coe_sub",
   "Exists.casesOn",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "Set.Elem",
   "Finset.toSet",
   "Fintype.card_coe",
   "Nat",
   "And.casesOn",
   "Finset.sub",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Subtype",
   "instHSub",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Set.add",
   "Classical.propDecidable",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "And",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "congr",
   "AddCommGroup",
   "Finset.instHasSubsetFinset",
   "congrArg",
   "Finset.add",
   "congrFun",
   "AddZeroClass.toAdd",
   "Finset.card",
   "Exists",
   "Set",
   "CanLift.prf",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "instLENat",
   "Finset",
   "Set.sub",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "id",
   "Finset.coe_add",
   "Membership.mem",
   "instHAdd",
   "HSub.hSub",
   "Fintype.card",
   "Finset.exists_subset_add_sub",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Set.Finite",
   "Mathlib.Data.Set.Finite._auxLemma.22",
   "Mathlib.Data.Finset.Basic._auxLemma.10",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "instMulNat",
   "Nat.card",
   "and_self"],
  "name": "Set.exists_subset_add_sub",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] {s t : Set α},\n  Set.Finite s →\n    Set.Finite t → Set.Nonempty t → ∃ u, Nat.card ↑u * Nat.card ↑t ≤ Nat.card ↑(s + t) ∧ s ⊆ u + t - t ∧ Set.Finite u",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.symm",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "eq_true",
   "NeZero",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "Nat.cast_add_one_pos",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.5",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] (n : ℕ), (0 < ↑n + 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Multiplicative.ofAdd.proof_1",
   "Multiplicative",
   "Equiv.mk",
   "Multiplicative.ofAdd.proof_2"],
  "name": "Multiplicative.ofAdd",
  "constType": "{α : Type u} → α ≃ Multiplicative α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "propext",
   "LT.lt",
   "Mathlib.Tactic.Zify.nat_cast_lt",
   "Nat",
   "Int",
   "instLTNat",
   "Int.instLTInt",
   "Eq"],
  "name": "Mathlib.Tactic.Zify._auxLemma.3",
  "constType": "∀ (a b : ℕ), (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_add_sub_cancel",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "instHSub",
   "instHAdd",
   "instDistribLattice",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMagma.toAdd",
   "abs_add",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "instTransEq",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "abs_sub_le",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] (a b c : α), |a - c| ≤ |a - b| + |b - c|",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.inter_eq_self_of_subset_right",
   "And",
   "Set.instHasSubsetSet",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.sep_eq_of_subset",
  "constType": "∀ {α : Type u} {s t : Set α}, s ⊆ t → {x | x ∈ t ∧ x ∈ s} = s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_5",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "ProbabilityTheory.IdentDistrib",
   "autoParam",
   "MeasurableSpace",
   "Eq"],
  "name": "ProbabilityTheory.IdentDistrib.map_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {f : α → γ} {g : β → γ} {μ : autoParam (MeasureTheory.Measure α) _auto✝}\n  {ν : autoParam (MeasureTheory.Measure β) _auto✝¹},\n  ProbabilityTheory.IdentDistrib f g → MeasureTheory.Measure.map f μ = MeasureTheory.Measure.map g ν",
  "constCategory": "Definition"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "Iff", "False", "Not", "exists_imp"],
  "name": "not_exists",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) ↔ ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Set",
   "Set.mem_preimage",
   "Eq",
   "Set.instMembershipSet"],
  "name": "PFR.Main._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set β} {a : α}, (a ∈ f ⁻¹' s) = (f a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instDecidableEq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "And.left",
   "MulZeroClass.toMul",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "Iff.mpr",
   "LT.lt.ne",
   "Eq",
   "Zero.toOfNat0",
   "And.right",
   "LinearOrderedRing.toLinearOrder",
   "mul_pos_of_neg_of_neg",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "mul_neg_of_pos_of_neg",
   "MulZeroClass.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "mul_neg_of_neg_of_pos",
   "StrictOrderedRing.toPartialOrder",
   "lt_or_gt_of_ne",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "False",
   "Or.inr",
   "Ne.symm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "StrictOrderedSemiring.toSemiring",
   "Decidable.or_iff_not_and_not",
   "GT.gt",
   "NoZeroDivisors",
   "instHMul",
   "And",
   "Or.inl",
   "LT.lt",
   "HMul.hMul",
   "Not",
   "LinearOrder.toPartialOrder",
   "mul_pos",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "MonoidWithZero.toZero"],
  "name": "LinearOrderedRing.noZeroDivisors",
  "constType": "∀ {α : Type u} [inst : LinearOrderedRing α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "LinearOrderedSemiring.toMax",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "OrderedAddCommMonoid.mk",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.mk",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Div",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sSup_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Neg.neg",
   "SetLike.instMembership",
   "Neg",
   "NegMemClass"],
  "name": "NegMemClass.mk",
  "constType":
  "∀ {S : Type u_5} {G : Type u_6} [inst : Neg G] [inst_1 : SetLike S G],\n  (∀ {s : S} {x : G}, x ∈ s → -x ∈ s) → NegMemClass S G",
  "constCategory": "Other"},
 {"references":
  ["Pi.instSub",
   "PartialOrder.toPreorder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "Real.instSubReal",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "MeasureTheory.Measure",
   "Real.linearOrder",
   "MeasurableSingletonClass",
   "SubNegMonoid.toSub",
   "ProbabilityTheory.entropy_sub_mutualInfo_le_entropy_sub'",
   "Eq.mpr",
   "FiniteRange",
   "AddGroup",
   "ProbabilityTheory.mutualInfo",
   "max_sub_sub_right",
   "Measurable",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "LinearOrderedRing.toMax",
   "id",
   "instHSub",
   "Real.instLinearOrderedRingReal",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "HSub.hSub",
   "SemilatticeInf.toPartialOrder",
   "max_le_iff",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "And",
   "Countable",
   "Eq.ndrec",
   "propext",
   "ProbabilityTheory.entropy_sub_mutualInfo_le_entropy_sub",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrderedAddCommGroup.toMax",
   "And.intro",
   "MeasurableSpace",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "ProbabilityTheory.max_entropy_sub_mutualInfo_le_entropy_sub",
  "constType":
  "∀ {Ω : Type uΩ} {G : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable G] [inst : Nonempty G]\n  [inst : MeasurableSpace G] [inst_1 : MeasurableSingletonClass G] [inst_2 : AddGroup G] {X : Ω → G}\n  {μ : MeasureTheory.Measure Ω} [inst_3 : FiniteRange X] [inst_4 : MeasureTheory.IsProbabilityMeasure μ] {Y : Ω → G}\n  [inst_5 : FiniteRange Y], Measurable X → Measurable Y → max H[X ; μ] H[Y ; μ] - I[X : Y ; μ] ≤ H[X - Y ; μ]",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "add_right_neg",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "add_neg_cancel_left",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + (-a + b) = b",
  "constCategory": "Theorem"},
 {"references": ["propext", "Subtype.forall", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop},\n  (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.decidableLE",
   "PartialOrder.toPreorder",
   "Max.max",
   "LE.le",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedAddCommMonoid.toMax",
   "LinearOrderedAddCommMonoid",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommMonoid.max_def",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedAddCommMonoid α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.mk",
  "constType":
  "{α : Type u_5} → [toSeminormedRing : SeminormedRing α] → (∀ (x y : α), x * y = y * x) → SeminormedCommRing α",
  "constCategory": "Other"},
 {"references": ["Norm", "NormedField"],
  "name": "NormedField.toNorm",
  "constType": "{α : Type u_5} → [self : NormedField α] → Norm α",
  "constCategory": "Definition"},
 {"references": ["Pow"],
  "name": "Pow.pow",
  "constType": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid.mk",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubmonoid.rec",
  "constType":
  "{M : Type u_4} →\n  [inst : AddZeroClass M] →\n    {motive : AddSubmonoid M → Sort u} →\n      ((toAddSubsemigroup : AddSubsemigroup M) →\n          (zero_mem' : 0 ∈ toAddSubsemigroup.carrier) →\n            motive { toAddSubsemigroup := toAddSubsemigroup, zero_mem' := zero_mem' }) →\n        (t : AddSubmonoid M) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set.image2",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "And.intro",
   "And.casesOn",
   "id"],
  "name": "Set.image2_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f f' : α → β → γ} {s : Set α} {t : Set β},\n  (∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) → Set.image2 f s t = Set.image2 f' s t",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.sInf_le",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.decidableLT",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "NormedSpace.norm_smul_le",
   "AddCommGroup.toAddCommMonoid",
   "Field.toSemifield",
   "AddCommMonoid.toAddMonoid",
   "NormedField.toNormedCommRing",
   "LE.le",
   "NormedField.toNorm",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Norm.norm",
   "NormedSpace.toModule"],
  "name": "NormedAlgebra.id.proof_3",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (a b : 𝕜), ‖a • b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["propext",
   "Set",
   "Not",
   "Set.not_infinite",
   "Set.Infinite",
   "Set.Finite",
   "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.1",
  "constType": "∀ {α : Type u} {s : Set α}, (¬Set.Infinite s) = Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Real.commRing.proof_25",
   "Semiring.mk",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "nsmulRec",
   "npowRec",
   "CommRing.mk",
   "Real.instOneReal",
   "Real.commRing.proof_24",
   "zsmulRec",
   "Real.commRing.proof_3",
   "Real.commRing.proof_1",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Real.commRing.proof_20",
   "Rat.instNegRat",
   "Sub.sub",
   "Real.commRing.proof_10",
   "Nat",
   "Real.commRing.proof_11",
   "Add.mk",
   "Real.commRing.proof_6",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.commRing.proof_4",
   "AddMonoid.mk",
   "instHMul",
   "IntCast.mk",
   "Real.commRing.proof_21",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Zero.mk",
   "Real.commRing.proof_13",
   "CauSeq.Completion.Cauchy",
   "Ring.mk",
   "Real.commRing.proof_8",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Neg.mk",
   "Mul.mk",
   "CauSeq.Completion.instIntCastCauchy",
   "Real.commRing.proof_15",
   "Real.commRing.proof_5",
   "DivisionRing.toRing",
   "Real",
   "CauSeq.Completion.instNatCastCauchy",
   "Real.commRing.proof_23",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Abs.abs",
   "Real.commRing.proof_17",
   "Rat.instSupRat",
   "Real.instNegReal",
   "Sub.mk",
   "Zero.toOfNat0",
   "Real.commRing.proof_9",
   "Real.commRing.proof_18",
   "Real.commRing.proof_7",
   "Real.commRing.proof_22",
   "Real.commRing.proof_12",
   "Real.commRing.proof_14",
   "Real.commRing.proof_2",
   "Real.commRing.proof_16",
   "Real.commRing.proof_19",
   "Neg.toHasAbs",
   "AddSemigroup.mk",
   "instHAdd",
   "One.mk",
   "Rat",
   "One.toOfNat1",
   "Neg.neg",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "HMul.hMul"],
  "name": "Real.commRing",
  "constType": "CommRing ℝ",
  "constCategory": "Definition"},
 {"references": ["outParam", "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) →\n      [inst : MulZeroOneClass M] → [inst : MulZeroOneClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["Field.zpow_succ'",
   "Real.field",
   "NormedAddCommGroup",
   "Field.zpow_zero'",
   "Real.instLinearOrderedRingReal",
   "NormedField",
   "Real",
   "Field.mk",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "NormedAddCommGroup.toMetricSpace",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "abs_mul",
   "Field",
   "NormedField.mk",
   "Field.inv_zero",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Real.normedAddCommGroup",
   "Field.div_eq_mul_inv"],
  "name": "Real.normedField",
  "constType": "NormedField ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "ZeroHom.zeroHomClass",
   "pos_iff_ne_zero",
   "Cardinal.partialOrder",
   "Nat.canonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "ZeroHom",
   "FunLike.coe",
   "instLTNat",
   "Cardinal.instZeroCardinal",
   "Zero.toOfNat0",
   "And",
   "Cardinal.toNat",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Iff",
   "Cardinal.aleph0",
   "ZeroHomClass.toFunLike",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Iff.trans",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Cardinal.toNat_ne_zero",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Cardinal.toNat_pos",
  "constType":
  "∀ {c : Cardinal.{u_1}}, 0 < Cardinal.toNat c ↔ c ≠ 0 ∧ c < Cardinal.aleph0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Fintype.equivOfCardEq",
   "Cardinal.mk_congr",
   "Fintype.card_ulift",
   "Fintype.card",
   "Fin.fintype",
   "ULift",
   "True",
   "Eq",
   "Fintype.card_fin",
   "Fintype",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "of_eq_true",
   "Cardinal",
   "ULift.fintype",
   "Cardinal.mk",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin"],
  "name": "Cardinal.mk_fintype",
  "constType":
  "∀ (α : Type u) [h : Fintype α], Cardinal.mk α = ↑(Fintype.card α)",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.aleph0_le_lift",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Cardinal.cast_toNat_of_aleph0_le",
   "ZeroHom.zeroHomClass",
   "GE.ge",
   "Eq.refl",
   "Cardinal.partialOrder",
   "Cardinal.lift_lt_aleph0",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Cardinal.toNat",
   "Eq.mpr",
   "Cardinal.natCast_injective",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "ZeroHomClass.toFunLike",
   "Cardinal.cast_toNat_of_lt_aleph0",
   "LinearOrderedCommMonoidWithZero.toZero",
   "lt_or_ge",
   "Nat",
   "Eq.symm",
   "id",
   "Or",
   "Nat.linearOrderedCommMonoidWithZero",
   "Or.inr",
   "Cardinal.lift_zero",
   "ZeroHom",
   "FunLike.coe",
   "Or.casesOn",
   "Cardinal.linearOrder",
   "LE.le",
   "Cardinal.instLECardinal",
   "Cardinal.instZeroCardinal",
   "Cardinal.lift_natCast",
   "Cardinal.instNatCastCardinal",
   "Or.inl",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Cardinal",
   "LinearOrder.toPartialOrder",
   "Cardinal.lift"],
  "name": "Cardinal.toNat_lift",
  "constType":
  "∀ (c : Cardinal.{v}), Cardinal.toNat (Cardinal.lift.{u, v} c) = Cardinal.toNat c",
  "constCategory": "Theorem"},
 {"references": ["congr_fun", "Eq"],
  "name": "congr_fun₂",
  "constType":
  "∀ {α : Sort u_4} {β : α → Sort u_1} {γ : (a : α) → β a → Sort u_2} {f g : (a : α) → (b : β a) → γ a b},\n  f = g → ∀ (a : α) (b : β a), f a b = g a b",
  "constCategory": "Theorem"},
 {"references":
  ["Function.RightInverse",
   "Function.Bijective.surjective",
   "Function.Bijective",
   "Function.surjInv",
   "Function.rightInverse_surjInv"],
  "name": "Equiv.ofBijective.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (hf : Function.Bijective f),\n  Function.RightInverse (Function.surjInv (_ : Function.Surjective f)) f",
  "constCategory": "Theorem"},
 {"references": ["Norm", "Real"],
  "name": "Norm.mk",
  "constType": "{E : Type u_9} → (E → ℝ) → Norm E",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b c : M), a + b = c + b → a = c) → AddCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Iff.intro",
   "Set.Finite.intro",
   "Set.finite_def.match_2",
   "Nonempty.intro",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Set.finite_def.match_1",
   "Nonempty",
   "Set.Finite"],
  "name": "Set.finite_def",
  "constType":
  "∀ {α : Type u} {s : Set α}, Set.Finite s ↔ Nonempty (Fintype ↑s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "Ne.symm",
   "NeZero.out"],
  "name": "NeZero.ne'",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], 0 ≠ n",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.mem_empty_iff_false",
   "False",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Set.instEmptyCollectionSet",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.8",
  "constType": "∀ {α : Type u} (x : α), (x ∈ ∅) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_add",
   "Nat.le.dest.match_2",
   "Exists",
   "Nat.add_comm",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "Exists.intro",
   "LE.le",
   "rfl",
   "Nat.not_succ_le_zero",
   "Eq",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.zero",
   "Nat.le_of_succ_le_succ",
   "Eq.rec",
   "PUnit",
   "letFun",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "Nat.succ"],
  "name": "Nat.le.dest",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Multiplicative",
   "instHAdd",
   "Multiplicative.toAdd",
   "HAdd.hAdd",
   "FunLike.coe",
   "Mul",
   "Add",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv",
   "Mul.mk"],
  "name": "Multiplicative.mul",
  "constType": "{α : Type u} → [inst : Add α] → Mul (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_1",
  "constType":
  "∀ (α : Type u_1) (motive : (∃ n, Nonempty (α ≃ Fin n)) → Prop) (x : ∃ n, Nonempty (α ≃ Fin n)),\n  (∀ (_k : ℕ) (e : α ≃ Fin _k), motive (_ : ∃ n, Nonempty (α ≃ Fin n))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Std.Logic._auxLemma.37",
   "Exists",
   "funext",
   "Set.image2",
   "Std.Logic._auxLemma.39",
   "Mathlib.Data.Set.Image._auxLemma.2",
   "Set",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "congr",
   "Singleton.singleton",
   "Set.image",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image2_singleton_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {b : β},\n  Set.image2 f s {b} = (fun a => f a b) '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "HMul.hMul",
   "Nat.mul_one",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Eq"],
  "name": "Nat.one_mul",
  "constType": "∀ (n : ℕ), 1 * n = n",
  "constCategory": "Theorem"},
 {"references":
  ["Covariant",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "flip",
   "Iff.rfl",
   "Eq.refl",
   "IsSymmOp.flip_eq",
   "IsSymmOp",
   "Eq",
   "id"],
  "name": "covariant_flip_iff",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) (mu : N → N → N) [inst : IsSymmOp N N mu],\n  Covariant N N (flip mu) r ↔ Covariant N N mu r",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "_auto._@.PFR.ForMathlib.Entropy.Measure._hyg.1026",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.FiniteSupport",
  "constType":
  "{S : Type u_2} → [inst : MeasurableSpace S] → autoParam (MeasureTheory.Measure S) _auto✝ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Real",
   "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1334",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1334",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Mathlib.Meta.NormNum.isNat_eq_true.match_1",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a b : α} {c : ℕ},\n  Mathlib.Meta.NormNum.IsNat a c → Mathlib.Meta.NormNum.IsNat b c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.false",
   "Bool.true",
   "Not",
   "Bool",
   "ne_true_of_eq_false.match_1",
   "Eq"],
  "name": "ne_true_of_eq_false",
  "constType": "∀ {b : Bool}, b = false → ¬b = true",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "Disjoint",
  "constType":
  "{α : Type u_1} → [inst : PartialOrder α] → [inst : OrderBot α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["propext", "Not", "IsEmpty", "not_isEmpty_iff", "Nonempty", "Eq"],
  "name": "Mathlib.Logic.IsEmpty._auxLemma.4",
  "constType": "∀ {α : Sort u_1}, (¬IsEmpty α) = Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CharP",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "AddMonoid.toZero",
   "Nat.instDvdNat",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "Nat",
   "Eq"],
  "name": "CharP.cast_eq_zero_iff'",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] {p : ℕ} [self : CharP R p] (x : ℕ), ↑x = 0 ↔ p ∣ x",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "instHMul",
   "instLENat",
   "Finset.card_image₂_le",
   "DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Add",
   "LE.le",
   "Finset.add"],
  "name": "Finset.card_add_le",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] {s t : Finset α},\n  Finset.card (s + t) ≤ Finset.card s * Finset.card t",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "Sup.sup",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_6",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b : AddSubmonoid M), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddRightCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "Complex.addCommGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddCommGroup.toAddGroup",
   "Complex",
   "SubNegMonoid.sub_eq_add_neg",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "Complex.Complex.addGroupWithOne.proof_3",
  "constType": "∀ (a b : ℂ), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "AddMonoid.toZero",
   "add_neg_self",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "add_lt_add_iff_left",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "add_zero"],
  "name": "Left.neg_neg_iff",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "funext",
   "Iff",
   "propext",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.ext",
  "constType":
  "∀ {α : Type u_1} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "Algebra.toRingHom",
  "constType":
  "{R : Type u} → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [self : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.symm",
   "Set.instHasSubsetSet",
   "Iff",
   "Set.subset_empty_iff",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasSubset.Subset",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_empty_iff_forall_not_mem",
  "constType": "∀ {α : Type u} {s : Set α}, s = ∅ ↔ ∀ (x : α), x ∉ s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.Nonempty",
   "Set.Nonempty.image2",
   "Add"],
  "name": "Set.Nonempty.add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α}, Set.Nonempty s → Set.Nonempty t → Set.Nonempty (s + t)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "DivisionRing.toRing",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Iff.mpr",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "RingHomClass.toAddMonoidHomClass",
   "Iff.mp",
   "RingHomClass.toMonoidWithZeroHomClass",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "injective_iff_map_eq_zero",
   "map_eq_zero",
   "DivisionRing",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "MonoidHomClass.toMulHomClass",
   "AddHomClass.toFunLike",
   "Semiring",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "GroupWithZero.toMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "MonoidWithZero.toMulZeroOneClass",
   "DivisionSemiring.toSemiring",
   "Function.Injective",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "SubNegMonoid.toAddMonoid",
   "Nontrivial",
   "AddMonoidHomClass.toAddHomClass",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero"],
  "name": "RingHom.injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DivisionRing α] [inst_1 : Semiring β] [inst_2 : Nontrivial β] (f : α →+* β),\n  Function.Injective ⇑f",
  "constCategory": "Theorem"},
 {"references": ["MeasureTheory.Measure", "MeasurableSpace"],
  "name": "MeasureTheory.IsFiniteMeasure",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real.instLTReal",
   "Real",
   "Rat",
   "CauSeq",
   "Real.mk_lt",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Rat.divisionRing",
   "propext",
   "LT.lt",
   "Real.mk",
   "Rat.instNegRat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.1",
  "constType": "∀ {f g : CauSeq ℚ abs}, (Real.mk f < Real.mk g) = (f < g)",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "instENNRealZero",
   "autoParam",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "ENNReal",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "Singleton.singleton",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform.mk",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] {H : Set S} {X : Ω → S}\n  {μ : autoParam (MeasureTheory.Measure Ω) _auto✝},\n  (∀ (x y : S), x ∈ H → y ∈ H → ↑↑μ (X ⁻¹' {x}) = ↑↑μ (X ⁻¹' {y})) →\n    ↑↑μ (X ⁻¹' Hᶜ) = 0 → ProbabilityTheory.IsUniform H X",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "Ring.zsmul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "Inv"],
  "name": "LinearOrderedSemifield.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.toReal",
   "rfl",
   "Real.instOneReal",
   "Eq"],
  "name": "ENNReal.one_toReal",
  "constType": "1.toReal = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.20",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Set.fintypeEmpty.proof_1",
  "constType": "∀ {α : Type u_1} (a : α), a ∈ ∅ ↔ a ∈ ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "HEq",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Mathlib.Data.Real.Basic._auxLemma.13",
   "Real.commRing",
   "Eq.refl",
   "Real.add_lt_add_iff_left",
   "AddCommMonoid.toAddMonoid",
   "implies_congr",
   "Iff.mpr",
   "True",
   "Preorder.toLE",
   "Eq",
   "Mathlib.Data.Real.Basic._auxLemma.12",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "Preorder.toLT",
   "forall_congr",
   "or_false",
   "Eq.symm",
   "Eq.trans",
   "instNonempty",
   "id",
   "eq_self",
   "Or",
   "False",
   "Real.instLTReal",
   "Or.inr",
   "Real.partialOrder",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Or.casesOn",
   "Ring.toSemiring",
   "LE.le",
   "Real.instInhabitedReal",
   "Mathlib.Data.Real.Basic._auxLemma.14",
   "Eq.ndrec",
   "HEq.refl",
   "of_eq_true",
   "LT.lt",
   "Real.instPreorderReal",
   "congr",
   "PartialOrder.le_antisymm",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Eq.casesOn",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instStrictOrderedCommRingReal.proof_1",
  "constType": "∀ (a b : ℝ), a ≤ b → ∀ (c : ℝ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4095",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "Exists",
   "Set.image2",
   "Prod.snd",
   "Set",
   "Set.mem_prod",
   "Exists.intro",
   "Prod.fst",
   "And.left",
   "Exists.casesOn",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "And.right",
   "Iff.mp",
   "Eq.ndrec",
   "Prod.mk",
   "SProd.sprod",
   "Prod",
   "And.intro",
   "Set.image",
   "And.casesOn"],
  "name": "Set.image_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} (f : α → β → γ) {s : Set α} {t : Set β},\n  (fun x => f x.1 x.2) '' s ×ˢ t = Set.image2 f s t",
  "constCategory": "Theorem"},
 {"references":
  ["Int.zero_mul",
   "OfNat.ofNat",
   "instOfNatInt",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "NonUnitalNonAssocSemiring.mk",
   "Int.mul_comm",
   "Eq",
   "Eq.mpr",
   "Int.add_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Int.one_mul",
   "instOfNatNat",
   "Nat",
   "id",
   "HPow.hPow",
   "Int.instMulInt",
   "instAddNat",
   "AddSemigroup.mk",
   "Int.mul_add",
   "instHAdd",
   "Int.zero_add",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.mk",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "Int.mul_zero",
   "instHMul",
   "Eq.ndrec",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "Int.add_assoc",
   "letFun",
   "HMul.hMul",
   "Int.add_mul",
   "Int.mul_assoc",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Int.instCommRingInt.proof_5",
  "constType":
  "∀ (x : ℕ) (x_1 : ℤ), (fun n x => x ^ n) (x + 1) x_1 = x_1 * (fun n x => x ^ n) x x_1",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "Ord"],
  "name": "LinearOrder.toOrd",
  "constType": "{α : Type u} → [self : LinearOrder α] → Ord α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Zero", "ENNReal", "WithTop.zero", "instNNRealZero", "NNReal"],
  "name": "instENNRealZero",
  "constType": "Zero ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toSubtractionMonoid : SubtractionMonoid G] → (∀ (a b : G), a + b = b + a) → SubtractionCommMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toZero",
   "OfNat.ofNat",
   "Add.add",
   "Set.add",
   "Set",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "AddMonoid.toAddZeroClass",
   "Set.addZeroClass",
   "AddMonoid",
   "Eq",
   "Add.mk"],
  "name": "Set.addMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoid α] (x : Set α), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Nat.cast_nonneg",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "OrderedSemiring.toSemiring",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "id"],
  "name": "Mathlib.Meta.Positivity.nonneg_of_isNat",
  "constType":
  "∀ {A : Type u_1} {e : A} {n : ℕ} [inst : OrderedSemiring A], Mathlib.Meta.NormNum.IsNat e n → 0 ≤ e",
  "constCategory": "Theorem"},
 {"references":
  ["Function.Embedding.subtype.proof_1",
   "Subtype.val",
   "Function.Embedding.mk",
   "Function.Embedding",
   "Subtype"],
  "name": "Function.Embedding.subtype",
  "constType": "{α : Sort u_1} → (p : α → Prop) → Subtype p ↪ α",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.compl",
  "constType": "{α : Type u_3} → [self : HasCompl α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "CauSeq.instNegCauSeq",
   "Subtype.val",
   "instHAdd",
   "IsCauSeq",
   "HAdd.hAdd",
   "CauSeq.instSubCauSeq.proof_1",
   "HSub.hSub",
   "Neg.neg",
   "CauSeq",
   "Sub",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.instAddCauSeq",
   "Sub.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring.toSub",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "CauSeq.ofEq"],
  "name": "CauSeq.instSubCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Sub (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "SemiconjBy",
   "instHAdd",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "True",
   "Eq",
   "Distrib.leftDistribClass",
   "right_distrib",
   "instHMul",
   "SemiconjBy.eq",
   "of_eq_true",
   "HMul.hMul",
   "congr",
   "congrArg",
   "left_distrib",
   "Distrib",
   "Eq.trans",
   "Distrib.toMul"],
  "name": "SemiconjBy.add_left",
  "constType":
  "∀ {R : Type x} [inst : Distrib R] {a b x y : R}, SemiconjBy a x y → SemiconjBy b x y → SemiconjBy (a + b) x y",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "Real.instSupReal",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "MulZeroClass.toMul",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "LinearOrderedRing.toLinearOrder",
   "Mathlib.Data.IsROrC.Basic._auxLemma.26",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "sq",
   "instHPow",
   "MulZeroClass.toZero",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "Neg.toHasAbs",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Real.instMonoidReal",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "abs_mul_self",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.normedCommRing",
   "Monoid.toMulOneClass",
   "DistribLattice.toLattice",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "add_zero",
   "congrArg"],
  "name": "Real.isROrC.proof_11",
  "constType": "∀ (z : ℝ), |z| ^ 2 = z * z + 0 * 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mk",
  "constType":
  "{M₀ : Type u_4} →\n  [toCommMonoid : CommMonoid M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → CommMonoidWithZero M₀",
  "constCategory": "Other"},
 {"references": ["Decidable", "Not"],
  "name": "Decidable.isFalse",
  "constType": "{p : Prop} → ¬p → Decidable p",
  "constCategory": "Other"},
 {"references": ["True.intro", "True"],
  "name": "trivial",
  "constType": "True",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instSubNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Nat.choose",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Finset.range",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Commute.add_pow",
   "HPow.hPow",
   "instHSub",
   "instAddNat",
   "instHAdd",
   "Finset.sum",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Commute.all",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "add_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (x y : R) (n : ℕ),\n  (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * ↑(Nat.choose n m)",
  "constCategory": "Theorem"},
 {"references":
  ["Real.partialOrder",
   "StrictMono.monotone",
   "Real",
   "Real.instPreorderReal",
   "Monotone",
   "Real.exp",
   "Real.exp_strictMono"],
  "name": "Real.exp_monotone",
  "constType": "Monotone Real.exp",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid",
   "AddSubmonoidClass",
   "SetLike",
   "AddSubgroupClass",
   "SubNegMonoid.toNeg",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NegMemClass"],
  "name": "AddSubgroupClass.mk",
  "constType":
  "∀ {S : Type u_5} {G : Type u_6} [inst : SubNegMonoid G] [inst_1 : SetLike S G]\n  [toAddSubmonoidClass : AddSubmonoidClass S G] [toNegMemClass : NegMemClass S G], AddSubgroupClass S G",
  "constCategory": "Other"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Top.top",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "ENNReal.coe_lt_top",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "CompleteLattice.toTop",
   "OrderedSemiring.toSemiring",
   "instNNRealCanonicallyOrderedCommSemiring",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "NNReal",
   "OrderedSemiring.toPartialOrder"],
  "name": "ENNReal.one_lt_top",
  "constType": "1 < ⊤",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "RatCast"],
  "name": "DivisionRing.toRatCast",
  "constType": "{K : Type u} → [self : DivisionRing K] → RatCast K",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "One",
   "PUnit",
   "HMul.hMul",
   "One.toOfNat1",
   "Nat",
   "Mul",
   "Nat.succ",
   "npowRec.match_1"],
  "name": "npowRec",
  "constType": "{M : Type u} → [inst : One M] → [inst : Mul M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "OrderedSemiring",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        0 ≤ 1 →\n          (∀ (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b) →\n            (∀ (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c) → OrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "Monotone.reflect_lt",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "PosMulReflectLT",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Subtype.property",
   "Zero.toOfNat0",
   "monotone_mul_left_of_nonneg",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HMul.hMul",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "ContravariantClass.mk",
   "Subtype"],
  "name": "LinearOrderedSemiring.toPosMulReflectLT",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α], PosMulReflectLT α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoidClass.toZeroMemClass",
   "ZeroMemClass.zero_mem",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "AddSubmonoid.instAddSubmonoidClassAddSubmonoidInstSetLikeAddSubmonoid"],
  "name": "AddSubmonoid.zero_mem",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.LeftInverse",
   "Equiv.casesOn",
   "Equiv.toFun",
   "Eq.ndrec",
   "Function.RightInverse",
   "Equiv.invFun",
   "Eq.rec",
   "Eq.refl",
   "Equiv.mk",
   "Eq.symm",
   "Eq"],
  "name": "Equiv.instEquivLikeEquiv.proof_1",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (e₁ e₂ : α ≃ β), e₁.toFun = e₂.toFun → e₁.invFun = e₂.invFun → e₁ = e₂",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["UniformSpace", "Filter.map", "Preorder", "Filter.atTop", "Cauchy"],
  "name": "CauchySeq",
  "constType":
  "{α : Type u} → {β : Type v} → [uniformSpace : UniformSpace α] → [inst : Preorder β] → (β → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHomClass.toFunLike",
   "ZeroHom.zeroHomClass",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "ZeroHom",
   "FunLike.coe",
   "Cardinal.mk",
   "Nat"],
  "name": "Nat.card",
  "constType": "Type u_3 → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsRat.casesOn",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "HEq",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isRat_eq_true.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x x_1 : α) →\n      (x_2 : ℤ) → (x_3 : ℕ) → Mathlib.Meta.NormNum.IsRat x x_2 x_3 → Mathlib.Meta.NormNum.IsRat x_1 x_2 x_3 → Prop)\n  (x x_1 : α) (x_2 : ℤ) (x_3 : ℕ) (x_4 : Mathlib.Meta.NormNum.IsRat x x_2 x_3)\n  (x_5 : Mathlib.Meta.NormNum.IsRat x_1 x_2 x_3),\n  (∀ (num : ℤ) (denom : ℕ) (inv inv_1 : Invertible ↑denom),\n      motive (↑num * ⅟↑denom) (↑num * ⅟↑denom) num denom (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑denom) num denom)\n        (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑denom) num denom)) →\n    motive x x_1 x_2 x_3 x_4 x_5",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_1",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_9",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_3",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_5",
   "Ring.toNeg",
   "SeminormedRing.toNorm",
   "NonUnitalSeminormedCommRing.mk",
   "Ring.toSub",
   "NonUnitalSeminormedRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_8",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_6",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_13",
   "AddCommGroup.mk",
   "SeminormedCommRing.mul_comm",
   "NonUnitalSeminormedCommRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_10",
   "AddGroup.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_4",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_7",
   "Ring.zsmul",
   "SeminormedRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_2",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_11",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_12"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing",
  "constType":
  "{α : Type u_1} → [β : SeminormedCommRing α] → NonUnitalSeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["CoheytingAlgebra",
   "OrderTop.toTop",
   "GeneralizedCoheytingAlgebra.toSDiff",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedCoheytingAlgebra",
   "HNot",
   "OrderTop",
   "HNot.hnot",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "CoheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toGeneralizedCoheytingAlgebra : GeneralizedCoheytingAlgebra α] →\n    [toOrderTop : OrderTop α] → [toHNot : HNot α] → (∀ (a : α), ⊤ \\ a = ￢a) → CoheytingAlgebra α",
  "constCategory": "Other"},
 {"references": ["Units", "Monoid"],
  "name": "Units.val",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "And.intro",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "le_antisymm_iff.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : PartialOrder α] {a b : α} (motive : a ≤ b ∧ b ≤ a → Prop) (x : a ≤ b ∧ b ≤ a),\n  (∀ (h1 : a ≤ b) (h2 : b ≤ a), motive (_ : a ≤ b ∧ b ≤ a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Rat.instLERat",
   "Bool.false",
   "Decidable",
   "Rat",
   "Rat.blt",
   "inferInstanceAs",
   "Bool",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Rat.instDecidableLeRatInstLERat",
  "constType": "(a b : ℚ) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_2",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "PartialOrder.toPreorder",
   "instSubNat",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "add_tsub_cancel_of_le",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "lt_tsub_iff_left",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Iff",
   "Iff.mp",
   "instLENat",
   "Preorder.toLT",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "tsub_lt_tsub_iff_right",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Lattice.toSemilatticeInf",
   "instAddNat",
   "Nat.le_add_right",
   "instHAdd",
   "instDistribLattice",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "HSub.hSub",
   "SemilatticeInf.toPartialOrder",
   "Nat.canonicallyOrderedCommSemiring",
   "Nat.addCommSemigroup",
   "AddCommMagma.toAdd",
   "LE.le",
   "DistribLattice.toLattice",
   "Iff.intro",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "Eq.ndrec",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "StrictOrderedSemiring.toPartialOrder",
   "AddCancelMonoid.toIsCancelAdd",
   "Nat.orderedSemiring",
   "LT.lt",
   "Nat.canonicallyLinearOrderedAddCommMonoid",
   "Eq.mp",
   "letFun",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.decidableLoHi.proof_1",
  "constType":
  "∀ (lo hi : ℕ) (P : ℕ → Prop), (∀ x < hi - lo, P (lo + x)) ↔ ∀ (x : ℕ), lo ≤ x → x < hi → P x",
  "constCategory": "Theorem"},
 {"references":
  ["Array", "Lean.SyntaxNodeKind", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.node",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Array Lean.Syntax → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Nat.add_assoc",
   "Nat.add_comm",
   "Eq.mpr",
   "Eq.ndrec",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Nat.add_left_comm",
  "constType": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "LinearOrderedRing"],
  "name": "LinearOrderedRing.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.Nonempty",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Set.Basic._auxLemma.11",
   "True",
   "Set.instMembershipSet",
   "Eq",
   "iff_self",
   "Iff",
   "of_eq_true",
   "congr",
   "Not",
   "congrArg",
   "Mathlib.Data.Set.Basic._auxLemma.10",
   "Eq.trans"],
  "name": "Set.not_nonempty_iff_eq_empty",
  "constType": "∀ {α : Type u} {s : Set α}, ¬Set.Nonempty s ↔ s = ∅",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Mem",
  "constType": "{α : Type u} → α → List α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "setOf",
   "Union.union",
   "Set",
   "HasCompl.compl",
   "Inter.inter",
   "Set.Set.completeAtomicBooleanAlgebra",
   "BooleanAlgebra.toHasCompl",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "Set.compl_inter",
   "ENNReal",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.measure_union_null",
   "congrArg",
   "MeasurableSpace",
   "Set.instUnionSet",
   "congrFun",
   "id",
   "Set.instInterSet"],
  "name": "MeasureTheory.Measure.ae.proof_3",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) {x y : Set α},\n  x ∈ {s | ↑↑μ sᶜ = 0} → y ∈ {s | ↑↑μ sᶜ = 0} → x ∩ y ∈ {s | ↑↑μ sᶜ = 0}",
  "constCategory": "Theorem"},
 {"references": ["MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage",
  "constType":
  "(Ω₀₁ : Type u_1) →\n  (Ω₀₂ : Type u_2) →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst : MeasureTheory.MeasureSpace Ω₀₂] → (G : Type uG) → [inst : MeasurableSpace G] → Type (max (max uG u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Real.semiring",
   "Real",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero"],
  "name": "Real.instMonoidWithZeroReal",
  "constType": "MonoidWithZero ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "rfl",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt (Int.rawCast n) n",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "Eq",
   "iff_self",
   "Set.ext",
   "Iff",
   "Set.iUnion",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_5",
  "constType":
  "∀ {α ι : Type u_1} {κ : ι → Type u_1} (f : (a : ι) → κ a → Set α), ⨅ a, ⨆ b, f a b = ⨆ g, ⨅ a, f a (g a)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff",
   "PartialOrder.toPreorder",
   "le_antisymm_iff.match_1",
   "And.intro",
   "le_antisymm",
   "Eq.symm",
   "le_of_eq",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm_iff",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubsemigroup.mk",
   "instHAdd",
   "AddSubsemigroup.rec",
   "HAdd.hAdd",
   "Set",
   "Add",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubsemigroup.casesOn",
  "constType":
  "{M : Type u_4} →\n  [inst : Add M] →\n    {motive : AddSubsemigroup M → Sort u} →\n      (t : AddSubsemigroup M) →\n        ((carrier : Set M) →\n            (add_mem' : ∀ {a b : M}, a ∈ carrier → b ∈ carrier → a + b ∈ carrier) →\n              motive { carrier := carrier, add_mem' := add_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Complex.ofReal'",
   "Complex.ofReal_exp",
   "Complex.instNegComplex",
   "Real",
   "Complex.ofReal_neg",
   "Neg.neg",
   "Complex.instInvComplex",
   "Real.exp",
   "True",
   "Real.instNegReal",
   "Eq",
   "Complex.exp_neg",
   "of_eq_true",
   "Complex.ofReal_injective",
   "congr",
   "Complex",
   "Real.instInvReal",
   "congrArg",
   "Complex.ofReal_inv",
   "Eq.trans",
   "Complex.exp",
   "Inv.inv"],
  "name": "Real.exp_neg",
  "constType": "∀ (x : ℝ), Real.exp (-x) = (Real.exp x)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivisionSemiring",
   "DivisionSemiring.toInv",
   "DivisionSemiring.zpow",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.negSucc n) a = (DivisionSemiring.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toAddCommGroup",
   "instHSub",
   "NormedAddCommGroup.toMetricSpace",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "NormedAddCommGroup",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "NormedAddCommGroup.toNorm",
   "AddGroup.toSubNegMonoid",
   "Dist.dist",
   "Eq"],
  "name": "NormedAddCommGroup.dist_eq",
  "constType":
  "∀ {E : Type u_9} [self : NormedAddCommGroup E] (x y : E), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.one_mul",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Preorder.toLT",
   "LT.lt",
   "Real",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "Real.instDistribLatticeReal.proof_3",
  "constType": "∀ (a b : ℝ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.image_congr",
   "of_eq_true",
   "Set.image_id'",
   "Set",
   "Eq.refl",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "True",
   "Set.instMembershipSet",
   "congrFun",
   "id",
   "Eq"],
  "name": "Set.image_id",
  "constType": "∀ {α : Type u_1} (s : Set α), id '' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "And.right",
   "Iff.mp",
   "Prod.snd",
   "Function.Injective",
   "Prod.map",
   "Prod",
   "Prod.fst",
   "Prod.ext",
   "And.left",
   "Prod.ext_iff",
   "Eq"],
  "name": "Function.Injective.Prod_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {f : α → γ} {g : β → δ},\n  Function.Injective f → Function.Injective g → Function.Injective (Prod.map f g)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "nsmulRec",
   "Eq",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "congr",
   "CauSeq.Completion.Cauchy",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_7",
  "constType": "∀ (a b c : ℝ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Membership.mem",
   "Subtype.val",
   "HSub.hSub",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.sub",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x - x_1) = ↑(x - x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.mk",
   "Rat.commRing.proof_10",
   "OfNat.ofNat",
   "Rat.instIntCastRat",
   "HAdd.hAdd",
   "npowRec",
   "nsmulRec",
   "Rat.commRing.proof_9",
   "Rat.instOfNatRat",
   "Rat.commRing.proof_1",
   "Rat.add_left_neg",
   "Rat.commRing.proof_8",
   "NatCast.mk",
   "NonUnitalNonAssocSemiring.mk",
   "CommRing",
   "Rat.instAddRat",
   "CommRing.mk",
   "Rat.mul_assoc",
   "zsmulRec",
   "Rat.add_zero",
   "Nat.cast",
   "AddCommMonoid.mk",
   "Rat.add_assoc",
   "Rat.instNegRat",
   "Rat.instMulRat",
   "Nat",
   "Rat.commRing.proof_4",
   "Add.mk",
   "AddSemigroup.mk",
   "instHAdd",
   "Rat.zero_add",
   "Rat",
   "Rat.mul_add",
   "One.mk",
   "Neg.neg",
   "Rat.commRing.proof_3",
   "Rat.commRing.proof_6",
   "Rat.neg",
   "Rat.commRing.proof_11",
   "Rat.sub_eq_add_neg",
   "Rat.commRing.proof_2",
   "AddMonoid.mk",
   "Rat.instSubRat",
   "instHMul",
   "Rat.mul_zero",
   "IntCast.mk",
   "Rat.zero_mul",
   "instNatCastInt",
   "Rat.commRing.proof_5",
   "Int.cast",
   "NonUnitalSemiring.mk",
   "Rat.one_mul",
   "Zero.mk",
   "HMul.hMul",
   "Rat.commRing.proof_7",
   "Ring.mk",
   "Rat.add_mul",
   "Rat.mul_comm",
   "Int",
   "Rat.mul_one",
   "Neg.mk",
   "Rat.add_comm",
   "Mul.mk"],
  "name": "Rat.commRing",
  "constType": "CommRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Top",
   "AddSubmonoid.instTopAddSubmonoid.proof_2",
   "AddSubsemigroup.mk",
   "AddSubmonoid.mk",
   "AddSubmonoid.instTopAddSubmonoid.proof_1",
   "Set.univ",
   "AddSubmonoid",
   "Top.mk",
   "AddZeroClass"],
  "name": "AddSubmonoid.instTopAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → Top (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "Nat"],
  "name": "CharP",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["LinearOrderedField", "Div"],
  "name": "LinearOrderedField.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Div α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semifield",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instLESet",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "IsGLB.of_image",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "SetLike.instPartialOrder",
   "isGLB_biInf",
   "SetLike.coe_subset_coe",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Iff",
   "letFun",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (x : Set (AddSubmonoid M)), IsGLB x (sInf x)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop", "Top.top", "OrderTop.le_top", "OrderTop", "LE", "LE.le"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "ContravariantClass.elim",
   "Iff",
   "CovariantClass",
   "ContravariantClass",
   "CovariantClass.elim"],
  "name": "rel_iff_cov",
  "constType":
  "∀ (M : Type u_1) (N : Type u_2) (μ : M → N → N) (r : N → N → Prop) [inst : CovariantClass M N μ r]\n  [inst : ContravariantClass M N μ r] (m : M) {a b : N}, r (μ m a) (μ m b) ↔ r a b",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_irrefl", "Not", "Preorder"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_imp_lt_of_le_imp_le",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "Preorder.toLT",
   "MulZeroClass.toZero",
   "Eq.symm",
   "MulPosMono",
   "mul_nonpos_of_nonneg_of_nonpos",
   "Or",
   "PosMulMono",
   "LinearOrder",
   "LT.lt.le",
   "Or.inr",
   "MulZeroClass",
   "mul_nonpos_of_nonpos_of_nonneg",
   "Or.casesOn",
   "LE.le",
   "instHMul",
   "And",
   "LT.lt.false",
   "Or.inl",
   "Eq.ndrec",
   "False.elim",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "lt_trichotomy"],
  "name": "pos_and_pos_or_neg_and_neg_of_mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : LinearOrder α] [inst_2 : PosMulMono α]\n  [inst_3 : MulPosMono α], 0 < a * b → 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0",
  "constCategory": "Theorem"},
 {"references": ["And", "And.intro"],
  "name": "And.rec",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → ((left : a) → (right : b) → motive (_ : a ∧ b)) → (t : a ∧ b) → motive t",
  "constCategory": "Other"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Complex.abs",
   "Real.instLinearOrderedFieldReal",
   "CauSeq.lim",
   "PartialOrder.toPreorder",
   "Real",
   "AbsoluteValue",
   "Complex.exp'",
   "Complex.instIsComplete",
   "Complex.instRingComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "Complex.exp.proof_1",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.exp",
  "constType": "ℂ → ℂ",
  "constCategory": "Definition"},
 {"references":
  ["OrderIso",
   "Membership.mem",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Function.Surjective",
   "OrderIso.setCongr",
   "instDistribLattice",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "StrictMono.orderIso",
   "Preorder",
   "Subtype.le",
   "Set.univ",
   "Preorder.toLE",
   "Function.Surjective.range_eq",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.range",
   "Set.Elem",
   "StrictMono",
   "OrderIso.trans",
   "OrderIso.Set.univ"],
  "name": "StrictMono.orderIsoOfSurjective",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : LinearOrder α] → [inst_1 : Preorder β] → (f : α → β) → StrictMono f → Function.Surjective f → α ≃o β",
  "constCategory": "Definition"},
 {"references":
  ["NeZero",
   "Fin.ofNat'",
   "Nat.linearOrderedCommMonoidWithZero",
   "OfNat",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Fin.instOfNatFin.proof_1",
   "OfNat.mk",
   "Nat",
   "Fin"],
  "name": "Fin.instOfNatFin",
  "constType": "{n a : ℕ} → [inst : NeZero n] → OfNat (Fin n) a",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "prod",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "Set.Finite.prod",
   "Exists.intro",
   "And.left",
   "Exists.casesOn",
   "Eq",
   "Set.range",
   "And.right",
   "Eq.mpr",
   "FiniteRange",
   "SProd.sprod",
   "FiniteRange.finite",
   "Eq.trans",
   "id",
   "Membership.mem",
   "Set.instSProd",
   "funext",
   "Prod.snd",
   "Prod.mk.injEq",
   "Mathlib.Data.Set.Prod._auxLemma.1",
   "FiniteRange.mk",
   "instFiniteRangeProdProd.match_1",
   "HasSubset.Subset",
   "Prod.fst",
   "Set.Finite",
   "Set.instMembershipSet",
   "Set.Finite.subset",
   "And",
   "Set.instHasSubsetSet",
   "Prod.mk",
   "letFun",
   "Eq.mp",
   "congr",
   "Prod",
   "And.intro",
   "congrArg"],
  "name": "instFiniteRangeProdProd",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} {H : Type u_3} (X : Ω → G) (Y : Ω → H) [hX : FiniteRange X] [hY : FiniteRange Y],\n  FiniteRange (⟨X, Y⟩)",
  "constCategory": "Definition"},
 {"references":
  ["Filter.instPartialOrderFilter.proof_3",
   "Membership.mem",
   "LE.mk",
   "And",
   "Filter.instPartialOrderFilter.proof_1",
   "PartialOrder.mk",
   "Set",
   "Not",
   "Filter",
   "LT.mk",
   "Filter.instPartialOrderFilter.proof_2",
   "Filter.instPartialOrderFilter.proof_4",
   "PartialOrder",
   "instMembershipSetFilter",
   "Preorder.mk"],
  "name": "Filter.instPartialOrderFilter",
  "constType": "{α : Type u} → PartialOrder (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "AbsoluteValue.abs",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "StrictOrderedSemiring.toOrderedSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name": "IsAbsoluteValue.abs_isAbsoluteValue",
  "constType":
  "∀ {S : Type u_1} [inst : LinearOrderedRing S], IsAbsoluteValue abs",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Decidable.lt_or_eq_of_le",
   "Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Or.symm",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "Decidable.eq_or_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "RightDistribClass.right_distrib",
   "Add",
   "Mul",
   "Eq"],
  "name": "right_distrib",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "LE.le.trans",
   "le_iSup",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE"],
  "name": "le_iSup_of_le",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α} (i : ι), a ≤ f i → a ≤ iSup f",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "Eq",
   "AddGroupWithOne.intCast_ofNat"],
  "name": "Int.cast_ofNat",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Filter.EventuallyEq",
   "List.pmap.proof_3",
   "ProbabilityTheory.iIndepFun.ae_eq",
   "MeasureTheory.IsProbabilityMeasure",
   "Exists.casesOn",
   "instLTNat",
   "Nonempty",
   "Eq",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "FiniteRange",
   "Measurable.aemeasurable",
   "Nat.lt_of_succ_lt_succ",
   "List.finRange",
   "Matrix.cons_val_succ'",
   "List.Mem.casesOn",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "Fin.mk",
   "ProbabilityTheory.identDistrib_of_finiteRange",
   "List.pmap",
   "Finset.instMembershipFinset",
   "Fin.fintype",
   "ProbabilityTheory.IdentDistrib",
   "And",
   "eq_true",
   "of_eq_true",
   "HEq.refl",
   "LT.lt",
   "congr",
   "And.intro",
   "Matrix.vecCons",
   "List.pmap.proof_4",
   "congrArg",
   "MeasurableSpace",
   "Fin",
   "Exists",
   "HEq",
   "Eq.refl",
   "Exists.intro",
   "True",
   "MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.trans",
   "Finset",
   "Fintype.elems",
   "ProbabilityTheory.IdentDistrib.of_ae_eq",
   "Measurable",
   "instOfNatNat",
   "List.nil",
   "MeasureTheory.Measure.ae",
   "Nat.succ",
   "id",
   "Membership.mem",
   "Filter.EventuallyEq.symm",
   "Fintype.complete",
   "List.cons",
   "List.finRange.proof_1",
   "ProbabilityTheory.independent_copies3_nondep",
   "List.Mem.tail",
   "List.Mem",
   "ProbabilityTheory.IdentDistrib.symm",
   "Matrix.vecEmpty",
   "Eq.ndrec",
   "List",
   "List.Mem.head",
   "ProbabilityTheory.iIndepFun",
   "List.noConfusion"],
  "name": "ProbabilityTheory.independent_copies3_nondep_finiteRange",
  "constType":
  "∀ {α : Type u} [mS : MeasurableSpace α] [inst : MeasurableSingletonClass α] [inst : Nonempty α] {Ω₁ : Type u_1}\n  {Ω₂ : Type u_2} {Ω₃ : Type u_3} [inst : MeasurableSpace Ω₁] [inst_1 : MeasurableSpace Ω₂]\n  [inst_2 : MeasurableSpace Ω₃] {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α},\n  Measurable X₁ →\n    Measurable X₂ →\n      Measurable X₃ →\n        ∀ [inst_3 : FiniteRange X₁] [inst_4 : FiniteRange X₂] [inst_5 : FiniteRange X₃] (μ₁ : MeasureTheory.Measure Ω₁)\n          (μ₂ : MeasureTheory.Measure Ω₂) (μ₃ : MeasureTheory.Measure Ω₃) [hμ₁ : MeasureTheory.IsProbabilityMeasure μ₁]\n          [hμ₂ : MeasureTheory.IsProbabilityMeasure μ₂] [hμ₃ : MeasureTheory.IsProbabilityMeasure μ₃],\n          ∃ A mA μA X₁' X₂' X₃',\n            MeasureTheory.IsProbabilityMeasure μA ∧\n              ProbabilityTheory.iIndepFun (fun x => mS) ![X₁', X₂', X₃'] ∧\n                Measurable X₁' ∧\n                  Measurable X₂' ∧\n                    Measurable X₃' ∧\n                      ProbabilityTheory.IdentDistrib X₁' X₁ ∧\n                        ProbabilityTheory.IdentDistrib X₂' X₂ ∧\n                          ProbabilityTheory.IdentDistrib X₃' X₃ ∧ FiniteRange X₁' ∧ FiniteRange X₂' ∧ FiniteRange X₃'",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "DivInvMonoid",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "GroupWithZero.toDiv",
   "GroupWithZero.toInv"],
  "name": "GroupWithZero.toDivInvMonoid",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → DivInvMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "inferInstance",
   "Real.strictOrderedCommSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "Real",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Real.orderedSemiring",
  "constType": "OrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "Equiv.toFun",
   "MulOneClass.toMul",
   "MonoidHomClass.toMulHomClass",
   "MulHomClass.toFunLike",
   "MonoidHom.monoidHomClass",
   "MulEquiv",
   "MonoidHom",
   "FunLike.coe",
   "Subgroup.map",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Equiv.Set.image",
   "Subgroup.equivMapOfInjective.proof_2",
   "Equiv.invFun",
   "Function.Injective",
   "Set.Elem",
   "Subgroup.equivMapOfInjective.proof_1",
   "Subgroup.equivMapOfInjective.proof_3",
   "Equiv.mk",
   "Subgroup",
   "Group",
   "MulEquiv.mk",
   "Group.toDivInvMonoid",
   "Subgroup.mul",
   "Set.image",
   "Subtype",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.equivMapOfInjective",
  "constType":
  "{G : Type u_1} →\n  [inst : Group G] →\n    {N : Type u_5} →\n      [inst_1 : Group N] → (H : Subgroup G) → (f : G →* N) → Function.Injective ⇑f → ↥H ≃* ↥(Subgroup.map f H)",
  "constCategory": "Definition"},
 {"references":
  ["Set.countable_coe_iff",
   "Set.Countable",
   "Countable",
   "Iff.mp",
   "Set.Elem",
   "Set"],
  "name": "Set.to_countable",
  "constType":
  "∀ {α : Type u} (s : Set α) [inst : Countable ↑s], Set.Countable s",
  "constCategory": "Theorem"},
 {"references":
  ["Inf.mk", "_private.Mathlib.Data.Real.Basic.0.Real.inf", "Inf", "Real"],
  "name": "Real.instInfReal",
  "constType": "Inf ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "MeasurableSpace",
   "Set.instMembershipSet",
   "MeasurableSpace.measurableSet_generateFrom"],
  "name": "MeasurableSpace.giGenerateFrom.proof_2",
  "constType":
  "∀ {α : Type u_1} (x : MeasurableSpace α), ∀ x_1 ∈ x.1, MeasurableSet x_1",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.toAlgebra'",
   "RingHom.toAlgebra.proof_1",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra"],
  "name": "RingHom.toAlgebra",
  "constType":
  "{R : Type u_1} → {S : Type u_2} → [inst : CommSemiring R] → [inst_1 : CommSemiring S] → (R →+* S) → Algebra R S",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Finite.to_countable.match_1",
   "Countable",
   "Exists",
   "Finite.exists_equiv_fin",
   "Finite",
   "Countable.of_equiv",
   "Nat",
   "instCountableFin",
   "Fin",
   "Nonempty",
   "Equiv.symm"],
  "name": "Finite.to_countable",
  "constType": "∀ {α : Sort u} [inst : Finite α], Countable α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "Iff.mp",
   "Set.Elem",
   "Finset.toSet",
   "Fintype.card_coe",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Subtype",
   "Nat.strictOrderedSemiring",
   "Set.add_empty",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Set.add",
   "Mathlib.Order.Basic._auxLemma.1",
   "Classical.propDecidable",
   "Set.infinite_or_finite",
   "Nat.canonicallyOrderedCommSemiring",
   "Set.instEmptyCollectionSet",
   "Finset.instMembershipFinset",
   "Or.casesOn",
   "And",
   "instHMul",
   "of_eq_true",
   "Set.empty_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrArg",
   "Finset.add",
   "congrFun",
   "Finset.card",
   "Exists",
   "Set.fintypeEmpty",
   "Set",
   "CanLift.prf",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "Zero.toOfNat0",
   "instLENat",
   "Set.finite_add",
   "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
   "Finset",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Finset.card_add_le",
   "Set.Infinite.card_eq_zero",
   "Eq.symm",
   "Set.Infinite",
   "id",
   "Finset.coe_add",
   "Membership.mem",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "Fintype.card",
   "IsCancelAdd",
   "LE.le",
   "Set.Finite",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "HMul.hMul",
   "instMulNat",
   "Add",
   "Nat.card",
   "Nat.semiring"],
  "name": "Set.card_add_le",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsCancelAdd α] {s t : Set α}, Nat.card ↑(s + t) ≤ Nat.card ↑s * Nat.card ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Rat",
   "LinearOrderedCommRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Rat.instLinearOrderedCommRingRat",
  "constType": "LinearOrderedCommRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "ContravariantClass.elim",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "PosMulReflectLT",
   "Preorder",
   "Mul",
   "LE.le",
   "Subtype.mk",
   "Subtype",
   "Preorder.toLE"],
  "name": "lt_of_mul_lt_mul_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulReflectLT α],\n  a * b < a * c → 0 ≤ a → b < c",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "DecidableEq"],
  "name": "LinearOrder.decidableEq",
  "constType": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : StrictOrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["Eq.ndrec", "Eq"],
  "name": "Eq.subst",
  "constType":
  "∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.instNeg",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "neg_injective",
   "Neg.neg",
   "ProbabilityTheory.entropy",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq",
   "MeasureTheory.Measure",
   "Countable",
   "MeasurableSingletonClass",
   "AddGroup",
   "Measurable",
   "NegZeroClass.toNeg",
   "MeasurableSpace",
   "ProbabilityTheory.entropy_comp_of_injective",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "ProbabilityTheory.entropy_neg",
  "constType":
  "∀ {Ω : Type uΩ} {G : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable G] [inst : MeasurableSpace G]\n  [inst_1 : MeasurableSingletonClass G] [inst_2 : AddGroup G] {X : Ω → G} {μ : MeasureTheory.Measure Ω},\n  Measurable X → H[-X ; μ] = H[X ; μ]",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mk'",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.169",
   "autoParam",
   "Inv",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "LinearOrderedField",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.128",
   "Int.natAbs",
   "Inv.inv"],
  "name": "LinearOrderedField.mk",
  "constType":
  "{α : Type u_2} →\n  [toLinearOrderedCommRing : LinearOrderedCommRing α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toRatCast : RatCast α] →\n                    (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) →\n                      0⁻¹ = 0 →\n                        autoParam\n                            (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                              ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                            _auto✝⁴ →\n                          (qsmul : ℚ → α → α) →\n                            autoParam (∀ (a : ℚ) (x : α), qsmul a x = ↑a * x) _auto✝⁵ → LinearOrderedField α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_5",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "VSub"],
  "name": "VSub.vsub",
  "constType":
  "{G : outParam (Type u_1)} → {P : Type u_2} → [self : VSub G P] → P → P → G",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "ProbabilityTheory.identDistrib_id_left",
   "ProbabilityTheory.IdentDistrib.symm",
   "ProbabilityTheory.IdentDistrib",
   "MeasurableSpace",
   "AEMeasurable",
   "id"],
  "name": "ProbabilityTheory.identDistrib_id_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {X : α → β}, AEMeasurable X → ProbabilityTheory.IdentDistrib X id",
  "constCategory": "Theorem"},
 {"references":
  ["MulHomClass",
   "NonUnitalNonAssocSemiring",
   "outParam",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.toMulHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] → [self : NonUnitalRingHomClass F α β] → MulHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Finset.sum",
   "Std.Logic._auxLemma.22",
   "Eq.refl",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "AddCommMonoid.toAddMonoid",
   "SDiff.sdiff",
   "rfl",
   "implies_congr",
   "Eq",
   "Zero.toOfNat0",
   "And",
   "Classical.decEq",
   "Eq.mpr",
   "forall_congr",
   "AddMonoid.toZero",
   "Finset",
   "Not",
   "Finset.instSDiffFinset",
   "Finset.instHasSubsetFinset",
   "Finset.sum_subset_zero_on_sdiff",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.115",
   "id",
   "AddCommMonoid"],
  "name": "Finset.sum_subset",
  "constType":
  "∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {f : α → β} [inst : AddCommMonoid β],\n  s₁ ⊆ s₂ → (∀ x ∈ s₂, x ∉ s₁ → f x = 0) → (Finset.sum s₁ fun x => f x) = Finset.sum s₂ fun x => f x",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Fintype.equivFin", "Finite.intro", "Finite", "Fintype.card"],
  "name": "Fintype.finite",
  "constType": "∀ {α : Type u_4}, Fintype α → Finite α",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Mathlib.Data.Finset.Basic._auxLemma.72",
   "Mathlib.Data.Finset.Basic._auxLemma.45",
   "Eq.refl",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "implies_congr",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Mathlib.Data.Finset.Basic._auxLemma.44",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.43",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "Finset.instHasSubsetFinset",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Finset.insert_subset_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "instHAdd",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "Eq"],
  "name": "AddHomClass.map_add",
  "constType":
  "∀ {F : Type u_9} {M : outParam (Type u_10)} {N : outParam (Type u_11)} [inst : Add M] [inst_1 : Add N]\n  [self : AddHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y",
  "constCategory": "Definition"},
 {"references": ["outParam", "Nat", "AddCommGroup"],
  "name": "ElementaryAddCommGroup",
  "constType": "(G : Type u_1) → [inst : AddCommGroup G] → outParam ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "Real.instLTReal",
   "LT.lt",
   "Real",
   "Exists.intro",
   "Exists.casesOn"],
  "name": "Real.denselyNormedField.match_1",
  "constType":
  "∀ (x x_1 : ℝ) (motive : (∃ a, x < a ∧ a < x_1) → Prop) (x_2 : ∃ a, x < a ∧ a < x_1),\n  (∀ (x_3 : ℝ) (h : x < x_3 ∧ x_3 < x_1), motive (_ : ∃ a, x < a ∧ a < x_1)) → motive x_2",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Set.Elem",
   "Iff.rfl",
   "propext",
   "Set",
   "Finite",
   "Eq.refl",
   "Set.finite_def",
   "finite_iff_nonempty_fintype",
   "Nonempty",
   "Set.Finite",
   "Eq",
   "id"],
  "name": "Set.finite_coe_iff",
  "constType": "∀ {α : Type u} {s : Set α}, Finite ↑s ↔ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "Cardinal",
   "Cardinal.mk",
   "Nat",
   "NatCast.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instNatCastCardinal",
  "constType": "NatCast Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero",
   "Iff.rfl",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "Cardinal.partialOrder",
   "ZeroHom",
   "Cardinal.natCast_le",
   "FunLike.coe",
   "LE.le",
   "Eq",
   "Cardinal.instLECardinal",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Eq.mpr",
   "Eq.ndrec",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "Cardinal.aleph0",
   "Iff",
   "instLENat",
   "Cardinal.cast_toNat_of_lt_aleph0",
   "propext",
   "Preorder.toLT",
   "ZeroHomClass.toFunLike",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Cardinal.toNat_le_iff_le_of_lt_aleph0",
  "constType":
  "∀ {c d : Cardinal.{u_1}}, c < Cardinal.aleph0 → d < Cardinal.aleph0 → (Cardinal.toNat c ≤ Cardinal.toNat d ↔ c ≤ d)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "neg_add_cancel_right",
   "id"],
  "name": "sub_add_cancel",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a - b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonAssocRing",
   "HMul.hMul",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.toOne",
   "Eq"],
  "name": "NonAssocRing.mul_one",
  "constType": "∀ {α : Type u_1} [self : NonAssocRing α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["forall_prop_decidable.proof_2",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "dite",
   "forall_prop_decidable.proof_1",
   "decidable_of_decidable_of_iff"],
  "name": "forall_prop_decidable",
  "constType":
  "{p : Prop} → (P : p → Prop) → [inst : Decidable p] → [inst : (h : p) → Decidable (P h)] → Decidable (∀ (h : p), P h)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "GroupWithZero",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toInv",
   "Inv.inv",
   "Eq"],
  "name": "GroupWithZero.inv_zero",
  "constType": "∀ {G₀ : Type u} [self : GroupWithZero G₀], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_zero'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), AddGroupWithOne.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddSubmonoid.copy.proof_2",
   "AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Set",
   "AddSubmonoid.mk",
   "AddSubmonoid",
   "AddZeroClass",
   "AddSubmonoid.copy.proof_1",
   "SetLike.coe",
   "Eq"],
  "name": "AddSubmonoid.copy",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → (s : Set M) → s = ↑S → AddSubmonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "Eq.mpr",
   "LinearOrderedRing.toLinearOrder",
   "Eq.ndrec",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul_abs_self",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "id"],
  "name": "abs_mul_self",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a * a| = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.toNNReal.proof_1",
   "OfNat.ofNat",
   "Real.instLinearOrderedRingReal",
   "Real.instLEReal",
   "Real",
   "Max.max",
   "LinearOrderedRing.toMax",
   "NNReal",
   "LE.le",
   "Subtype.mk"],
  "name": "Real.toNNReal",
  "constType": "ℝ → NNReal",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.eq",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["SMulZeroClass.mk",
   "instHMul",
   "SMul.mk",
   "SMulWithZero",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "SMulWithZero.mk",
   "MulZeroClass.toMul"],
  "name": "MulZeroClass.toSMulWithZero",
  "constType": "(R : Type u_1) → [inst : MulZeroClass R] → SMulWithZero R R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DivisionSemiring.toInv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Init.Order.LinearOrder._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "LE.le",
   "not_lt_of_le",
   "Abs.abs",
   "CauSeq.equiv",
   "Or.resolve_left",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name": "CauSeq.le_antisymm",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {f g : CauSeq α abs}, f ≤ g → g ≤ f → f ≈ g",
  "constCategory": "Theorem"},
 {"references":
  ["lt_of_le_of_ne",
   "Ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Ne.symm",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "lt_of_le_of_ne'",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≠ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Set",
   "Subsemigroup",
   "Submonoid",
   "One.toOfNat1",
   "Set.instMembershipSet"],
  "name": "Submonoid.mk",
  "constType":
  "{M : Type u_4} → [inst : MulOneClass M] → (toSubsemigroup : Subsemigroup M) → 1 ∈ toSubsemigroup.carrier → Submonoid M",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.Completion.Cauchy.field.proof_10",
   "DivisionRing.toRing",
   "CauSeq.Completion.Cauchy.field.proof_2",
   "CauSeq.Completion.Cauchy.field.proof_4",
   "DivisionRing.toRatCast",
   "CauSeq.Completion.Cauchy.field.proof_7",
   "CommRing",
   "CommRing.mk",
   "DivisionRing.zpow",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Field.toCommRing",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Field",
   "DivisionRing.qsmul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.Cauchy.field.proof_5",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "DivisionRing.toDiv",
   "DivisionRing",
   "CauSeq.Completion.Cauchy.field.proof_8",
   "Field.mk",
   "Field.toSemifield",
   "CauSeq.Completion.Cauchy.field.proof_3",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.toInv",
   "DivisionSemiring.toSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "CauSeq.Completion.Cauchy.commRing",
   "CauSeq.Completion.Cauchy.field.proof_9",
   "CauSeq.Completion.Cauchy.field.proof_1",
   "CauSeq.Completion.Cauchy.field.proof_6",
   "Field.toDivisionRing"],
  "name": "CauSeq.Completion.Cauchy.field",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Field β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Field (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "LinearOrderedSemiring",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedSemiring",
  "constType": "LinearOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "OrderedAddCommGroup.add_le_add_left",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.to_covariantClass_left_le",
  "constType":
  "∀ (α : Type u) [inst : OrderedAddCommGroup α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "Eq.mp",
   "mul_lt_mul_of_pos_right",
   "MulZeroClass.zero_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "Preorder",
   "congrArg",
   "MulPosStrictMono",
   "MulZeroClass.toMul"],
  "name": "mul_neg_of_neg_of_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : MulPosStrictMono α],\n  a < 0 → 0 < b → a * b < 0",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references": ["Or", "propext", "or_true_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references": ["Set.preimage", "Set", "MeasurableSet", "MeasurableSpace"],
  "name": "Measurable",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : MeasurableSpace α] → [inst : MeasurableSpace β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "Units",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "IsUnit.mul_inv_cancel",
   "IsUnit",
   "IsUnit.inv_mul_cancel",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toMonoid",
   "Units.mk",
   "Inv.inv"],
  "name": "IsUnit.unit'",
  "constType":
  "{α : Type u_3} → [inst : DivisionMonoid α] → {a : α} → IsUnit a → αˣ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "nonempty_subtype",
   "Iff",
   "Set.Elem",
   "Set",
   "Set.Nonempty",
   "Nonempty",
   "Set.instMembershipSet"],
  "name": "Set.nonempty_coe_sort",
  "constType": "∀ {α : Type u} {s : Set α}, Nonempty ↑s ↔ Set.Nonempty s",
  "constCategory": "Theorem"},
 {"references": ["trueSetoid", "Setoid.r", "Trunc", "Quot.out"],
  "name": "Trunc.out",
  "constType": "{α : Sort u_1} → Trunc α → α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Prod.snd",
   "Set.univ_prod",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Prod",
   "Set.univ",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.MeasureTheory.Constructions.Prod.Basic._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {t : Set β}, Prod.snd ⁻¹' t = Set.univ ×ˢ t",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "Iff.mp",
   "Cardinal.aleph0",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "Cardinal.partialOrder",
   "Cardinal.lt_aleph0",
   "Nat",
   "Eq"],
  "name": "Cardinal.toNat.proof_1",
  "constType": "∀ c < Cardinal.aleph0, ∃ n, c = ↑n",
  "constCategory": "Theorem"},
 {"references": ["Nonempty"],
  "name": "Classical.choice",
  "constType": "{α : Sort u} → Nonempty α → α",
  "constCategory": "Axiom"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "NonAssocRing.toIntCast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Int.cast_mul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.mul a' b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.eq_zero_of_mul_eq_zero.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → Prop) (x x_1 : ℕ), (∀ (m : ℕ), motive 0 m) → (∀ (n m : ℕ), motive (Nat.succ n) m) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddOpposite.addMonoid",
   "AddMonoid.toOppositeAddAction.proof_1",
   "Add.toHasOppositeVAdd",
   "AddMonoid.toOppositeAddAction.proof_2",
   "AddOpposite",
   "AddAction.mk",
   "HVAdd.hVAdd",
   "AddMonoid.toAddZeroClass",
   "instHVAdd",
   "AddAction",
   "AddMonoid",
   "VAdd.mk"],
  "name": "AddMonoid.toOppositeAddAction",
  "constType": "(α : Type u_1) → [inst : AddMonoid α] → AddAction αᵃᵒᵖ α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroup",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddOpposite.subNegMonoid",
   "AddOpposite",
   "Int",
   "AddGroup.toSubNegMonoid",
   "SubNegMonoid.zsmul_zero'",
   "Eq"],
  "name": "AddOpposite.addGroup.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : AddGroup α] (a : αᵃᵒᵖ), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.casesOn", "Eq.ndrec", "Bool", "Bool.noConfusionType", "Eq"],
  "name": "Bool.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : Bool} → v1 = v2 → Bool.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "StrictOrderedSemiring.to_charZero",
   "CharZero",
   "WithTop",
   "instENNRealAddCommMonoidWithOne",
   "instNNRealStrictOrderedSemiring",
   "WithTop.addMonoidWithOne",
   "inferInstanceAs",
   "WithTop.instCharZeroWithTopAddMonoidWithOne",
   "instNNRealSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NNReal"],
  "name":
  "ENNReal.instCharZeroENNRealToAddMonoidWithOneInstENNRealAddCommMonoidWithOne",
  "constType": "CharZero ENNReal",
  "constCategory": "Definition"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "outParam"],
  "name": "NonUnitalRingHomClass",
  "constType":
  "Type u_5 →\n  (α : outParam (Type u_6)) →\n    (β : outParam (Type u_7)) →\n      [inst : NonUnitalNonAssocSemiring α] → [inst : NonUnitalNonAssocSemiring β] → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Lattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Set.image2_image_left",
   "Set.image2",
   "Set",
   "Set.image2_congr",
   "True",
   "Eq",
   "Set.image_image2",
   "Set.instMembershipSet",
   "Set.image2_image_right",
   "Eq.mpr",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "id",
   "congrFun"],
  "name": "Set.image_image2_distrib",
  "constType":
  "∀ {α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ}\n  {s : Set α} {t : Set β} {g : γ → δ} {f' : α' → β' → δ} {g₁ : α → α'} {g₂ : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g₁ a) (g₂ b)) → g '' Set.image2 f s t = Set.image2 f' (g₁ '' s) (g₂ '' t)",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Mathlib.Analysis.SpecialFunctions.Exp._auxLemma.7",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Set",
   "Real",
   "Real.instSemilatticeSupReal",
   "Subtype.instOrderClosedTopologySubtypeInstTopologicalSpaceSubtypePreorder",
   "Set.Ioi",
   "True",
   "_private.Mathlib.Data.Real.Basic.0.Real.lt",
   "Filter.atBot",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Mathlib.Analysis.SpecialFunctions.Exp._auxLemma.8",
   "OrderTopology.to_orderClosedTopology",
   "Set.Elem",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Filter.Tendsto",
   "nhdsWithin",
   "UniformSpace.toTopologicalSpace",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Subtype",
   "Subtype.preorder",
   "Membership.mem",
   "Function.Surjective",
   "Lattice.toSemilatticeInf",
   "Real.continuous_exp",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "ConditionallyCompleteLattice.toLattice",
   "SemilatticeInf.toPartialOrder",
   "Real.pseudoMetricSpace",
   "Real.exp_pos",
   "Real.exp",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Continuous.subtype_mk",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "of_eq_true",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Real.instPreorderReal",
   "Mathlib.Topology.Order.Basic._auxLemma.53",
   "Subtype.linearOrder",
   "instTopologicalSpaceSubtype",
   "LinearOrderedSemiField.toDenselyOrdered",
   "Continuous.surjective",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "Filter.atTop",
   "Mathlib.Analysis.SpecialFunctions.Exp._auxLemma.9",
   "Subtype.mk"],
  "name": "Real.expOrderIso.proof_2",
  "constType":
  "Function.Surjective fun x => { val := Real.exp x, property := (_ : 0 < Real.exp x) }",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "Subsemigroup.carrier",
   "Submonoid.mk",
   "MulOneClass.toMul",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.one_mem'",
   "Set",
   "Inf.inf",
   "Submonoid.instInfSubmonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Subgroup.inv_mem",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid.toSubsemigroup",
   "Subgroup.instInfSubgroup.match_1",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Submonoid",
   "Group",
   "And.intro",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "SetLike.coe",
   "Inv.inv"],
  "name": "Subgroup.instInfSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G) {x : G},\n  x ∈\n      { toSubsemigroup := (H₁.toSubmonoid ⊓ H₂.toSubmonoid).toSubsemigroup,\n            one_mem' := (_ : 1 ∈ (H₁.toSubmonoid ⊓ H₂.toSubmonoid).carrier) }.toSubsemigroup.carrier →\n    x⁻¹ ∈\n      { toSubsemigroup := (H₁.toSubmonoid ⊓ H₂.toSubmonoid).toSubsemigroup,\n            one_mem' := (_ : 1 ∈ (H₁.toSubmonoid ⊓ H₂.toSubmonoid).carrier) }.toSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "dite",
   "GroupWithZero.div_eq_mul_inv",
   "mul_inv_cancel_left₀",
   "MulZeroClass.toMul",
   "Inv.mk",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "mul_assoc",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "MulZeroClass.toZero",
   "not_false_eq_true",
   "mul_inv_cancel",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "Eq.trans",
   "GroupWithZero.toInv",
   "eq_self",
   "Monoid.toSemigroup",
   "False",
   "Classical.propDecidable",
   "One.toOfNat1",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toDiv",
   "DivInvMonoid.toInv",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "HMul.hMul",
   "congr",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "Inv.inv"],
  "name": "GroupWithZero.toDivisionMonoid.proof_2",
  "constType":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a b : G₀), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_10",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "Subsemigroup.carrier",
   "MulOneClass.toMul",
   "Set",
   "Subgroup.inv_mem'",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "AddGroup",
   "Multiplicative",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid.toSubsemigroup",
   "Multiplicative.group",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "Inv.inv"],
  "name": "AddSubgroup.toSubgroup.proof_3",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] (S : Subgroup (Multiplicative A)) {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.allEq",
  "constType": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AbsoluteValue",
   "Real.instLEReal",
   "Real",
   "Real.instSupReal",
   "Preorder.toLE",
   "Abs.abs",
   "abs_of_nonneg",
   "Eq",
   "Real.instNegReal",
   "Complex.abs_ofReal",
   "Zero.toOfNat0",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Real.linearOrder",
   "Semiring.toNonAssocSemiring",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Complex.ofReal'",
   "Neg.toHasAbs",
   "Complex.abs",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "LE.le",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.instZeroReal",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Real.instAddGroupReal",
   "Complex",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.abs_of_nonneg",
  "constType": "∀ {r : ℝ}, 0 ≤ r → Complex.abs ↑r = r",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DivisionRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "CommMonoidWithZero.toCommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "Eq"],
  "name": "CommMonoidWithZero.mul_zero",
  "constType":
  "∀ {M₀ : Type u_4} [self : CommMonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.mk",
   "Finset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.Subtype.fintype",
  "constType": "{α : Type u_1} → (s : Finset α) → Fintype { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references": ["Countable", "Exists", "Function.Injective", "Nat"],
  "name": "Countable.mk",
  "constType": "∀ {α : Sort u}, (∃ f, Function.Injective f) → Countable α",
  "constCategory": "Other"},
 {"references": ["StarMul", "InvolutiveStar", "Mul"],
  "name": "StarMul.toInvolutiveStar",
  "constType":
  "{R : Type u} → [inst : Mul R] → [self : StarMul R] → InvolutiveStar R",
  "constCategory": "Definition"},
 {"references": ["Group"],
  "name": "Subgroup",
  "constType": "(G : Type u_5) → [inst : Group G] → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Set.finite_empty",
   "eq_true",
   "EmptyCollection.emptyCollection",
   "Set",
   "Set.instEmptyCollectionSet",
   "True",
   "Set.Finite",
   "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.27",
  "constType": "∀ {α : Type u}, Set.Finite ∅ = True",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "OrderTop.toTop",
   "BiheytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "HNot.hnot",
   "SDiff.sdiff",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toSDiff",
   "BiheytingAlgebra.toHNot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "BiheytingAlgebra.top_sdiff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "abs_nonneg",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Abs.abs",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "LinearOrderedRing.toLinearOrder",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AbsoluteValue.abs.proof_1",
  "constType": "∀ {S : Type u_1} [inst : LinearOrderedRing S] (a : S), 0 ≤ |a|",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Set",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_10",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (x x_1 : AddSubmonoid M) (x_2 : M), x_2 ∈ ↑x ∧ x_2 ∈ ↑x_1 → x_2 ∈ ↑x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Trans.trans",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "mul_assoc",
   "one_mul",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "not_false_eq_true",
   "Eq.symm",
   "Eq.trans",
   "mul_inv_cancel",
   "GroupWithZero.toInv",
   "eq_self",
   "Ne",
   "False",
   "One.toOfNat1",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "eq_false",
   "of_eq_true",
   "GroupWithZero",
   "HMul.hMul",
   "instTransEq",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "Inv.inv",
   "congrFun"],
  "name": "mul_inv_cancel_left₀",
  "constType":
  "∀ {G₀ : Type u} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → ∀ (b : G₀), a * (a⁻¹ * b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "rfl",
   "Set.instMembershipSet"],
  "name": "Set.mem_singleton",
  "constType": "∀ {α : Type u} (a : α), a ∈ {a}",
  "constCategory": "Theorem"},
 {"references":
  ["RelIso.toEquiv",
   "RelIso",
   "RelIso.mk",
   "RelIso.symm.proof_1",
   "Equiv.symm"],
  "name": "RelIso.symm",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → s ≃r r",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE", "PartialOrder", "Eq"],
  "name": "PartialOrder.mk",
  "constType":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "instHAdd",
   "Real",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.rpow_add",
   "Eq.refl",
   "CommMagma.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Eq.mpr",
   "Real.instCommSemigroupReal",
   "Eq.ndrec",
   "mul_mul_mul_comm",
   "CommSemigroup.toCommMagma",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "HMul.hMul",
   "id"],
  "name": "Mathlib.Tactic.RPowRing.mul_pp_pf_overlap",
  "constType":
  "∀ {x a₂ b₂ c : ℝ} (ea eb : ℝ), 0 < x → a₂ * b₂ = c → x ^ ea * a₂ * (x ^ eb * b₂) = x ^ (ea + eb) * c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toOrd",
   "LinearOrder",
   "LinearOrderedAddCommMonoid.decidableLE",
   "LinearOrder.mk",
   "LinearOrderedAddCommMonoid.decidableEq",
   "LinearOrderedAddCommMonoid.toMin",
   "LinearOrderedAddCommMonoid.min_def",
   "LinearOrderedAddCommMonoid.le_total",
   "LinearOrderedAddCommMonoid.toMax",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommMonoid.max_def",
   "LinearOrderedAddCommMonoid.decidableLT"],
  "name": "LinearOrderedAddCommMonoid.toLinearOrder",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references": ["NormedRing", "Norm"],
  "name": "NormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references": ["Nat.rec", "Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.casesOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → motive Nat.zero → ((n : ℕ) → motive (Nat.succ n)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec", "List", "Eq.refl", "List.casesOn", "List.noConfusionType", "Eq"],
  "name": "List.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {v1 v2 : List α} → v1 = v2 → List.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["Bot", "Bot.bot", "LE", "OrderBot", "LE.le"],
  "name": "OrderBot.mk",
  "constType":
  "{α : Type u} → [inst : LE α] → [toBot : Bot α] → (∀ (a : α), ⊥ ≤ a) → OrderBot α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "CompleteSpace",
   "NormedAlgebra.toAlgebra",
   "PartialOrder.toPreorder",
   "Real.instLEReal",
   "Real.normedField",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real.instAddReal",
   "Semifield.toCommSemiring",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "NonUnitalRingHomClass.toMulHomClass",
   "semiOutParam",
   "Preorder.toLE",
   "NormedField.toNorm",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Ring.toNeg",
   "Real.instCommSemiringReal",
   "Nat",
   "NormedAlgebra",
   "HPow.hPow",
   "instHSub",
   "Or",
   "NormedField.toMetricSpace",
   "PseudoMetricSpace.toUniformSpace",
   "MetricSpace.toPseudoMetricSpace",
   "PartialOrder",
   "And",
   "instHMul",
   "DecidableEq",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddZeroClass.toAdd",
   "RingHom",
   "Real",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "NormedField.toField",
   "RingHomClass.toNonUnitalRingHomClass",
   "starRingEnd",
   "instHPow",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "StarRing",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Real.instMonoidReal",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSemigroup.toAdd",
   "algebraMap",
   "HSub.hSub",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Real.instZeroReal",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "DenselyNormedField",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoidHom"],
  "name": "IsROrC.mk",
  "constType":
  "{K : semiOutParam (Type u_1)} →\n  [toDenselyNormedField : DenselyNormedField K] →\n    [toStarRing : StarRing K] →\n      [toNormedAlgebra : NormedAlgebra ℝ K] →\n        [toCompleteSpace : CompleteSpace K] →\n          (re im : K →+ ℝ) →\n            (I : K) →\n              re I = 0 →\n                I = 0 ∨ I * I = -1 →\n                  (∀ (z : K), (algebraMap ℝ K) (re z) + (algebraMap ℝ K) (im z) * I = z) →\n                    (∀ (r : ℝ), re ((algebraMap ℝ K) r) = r) →\n                      (∀ (r : ℝ), im ((algebraMap ℝ K) r) = 0) →\n                        (∀ (z w : K), re (z * w) = re z * re w - im z * im w) →\n                          (∀ (z w : K), im (z * w) = re z * im w + im z * re w) →\n                            (∀ (z : K), re ((starRingEnd K) z) = re z) →\n                              (∀ (z : K), im ((starRingEnd K) z) = -im z) →\n                                (starRingEnd K) I = -I →\n                                  (∀ (z : K), ‖z‖ ^ 2 = re z * re z + im z * im z) →\n                                    (∀ (z : K), im z * im I = im z) →\n                                      [toPartialOrder : PartialOrder K] →\n                                        (∀ {z w : K}, z ≤ w ↔ re z ≤ re w ∧ im z = im w) →\n                                          [toDecidableEq : DecidableEq K] → IsROrC K",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    (∀ (a b c : α), a + b ≤ a + c → b ≤ c) → OrderedCancelAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "Real.rec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.casesOn",
  "constType":
  "{motive : ℝ → Sort u} → (t : ℝ) → ((cauchy : CauSeq.Completion.Cauchy abs) → motive { cauchy := cauchy }) → motive t",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "le_max_right",
   "Preorder.toLE"],
  "name": "Real.toNNReal.proof_1",
  "constType": "∀ (r : ℝ), 0 ≤ max r 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.zero_add.match_1",
   "Unit",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.zero_add",
  "constType": "∀ (n : ℕ), 0 + n = n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedSemifield α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "Subgroup.instInfSetSubgroup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "CompleteLattice.sSup_le",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)) (a : Subgroup G), (∀ b ∈ s, b ≤ a) → sSup s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "instHAdd",
   "AddSemigroup.toAdd",
   "eq_of_heq",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_add.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℕ) →\n          x = HAdd.hAdd →\n            Mathlib.Meta.NormNum.IsNat x_1 x_3 → Mathlib.Meta.NormNum.IsNat x_2 x_4 → Nat.add x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℕ) (x_6 : x = HAdd.hAdd) (x_7 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsNat x_2 x_4) (x_9 : Nat.add x_3 x_4 = x_5),\n  (∀ (n n_1 : ℕ),\n      motive HAdd.hAdd (↑n) (↑n_1) n n_1 (Nat.add n n_1) (_ : HAdd.hAdd = HAdd.hAdd)\n        (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1)\n        (_ : Nat.add n n_1 = Nat.add n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references": ["NatCast", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toNatCast",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSeminormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_1",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra.proof_2",
   "GeneralizedBooleanAlgebra",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toBot",
   "GeneralizedBooleanAlgebra.mk",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.toGeneralizedBooleanAlgebra",
  "constType":
  "{α : Type u} → [inst : BooleanAlgebra α] → GeneralizedBooleanAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "completeLatticeOfInf",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "LE.le",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "CompleteLattice.toLattice",
   "SetLike.instPartialOrder",
   "And",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "And.intro",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder",
   "SetLike.coe"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b _c : AddSubgroup G),\n  _a ≤ _b → _a ≤ _c → ∀ _x ∈ _a, _x ∈ ↑_b.toAddSubmonoid ∧ _x ∈ ↑_c.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "Iff.intro",
   "Iff",
   "Real",
   "Complex",
   "congrArg",
   "Complex.re",
   "Eq"],
  "name": "Complex.ofReal_inj",
  "constType": "∀ {z w : ℝ}, ↑z = ↑w ↔ z = w",
  "constCategory": "Theorem"},
 {"references":
  ["Real.negMulLog",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Finset.sum",
   "Real",
   "Set",
   "ProbabilityTheory.entropy_eq_sum_finset",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "ProbabilityTheory.entropy",
   "MeasureTheory.Measure.real",
   "MeasureTheory.IsProbabilityMeasure",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Finset.toSet",
   "Finset",
   "Singleton.singleton",
   "Measurable",
   "Real.instAddCommMonoidReal",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.entropy_eq_sum_finset'",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] {X : Ω → S},\n  Measurable X →\n    ∀ {μ : MeasureTheory.Measure Ω} [inst_1 : MeasureTheory.IsProbabilityMeasure μ] {A : Finset S},\n      ↑↑(MeasureTheory.Measure.map X μ) (↑A)ᶜ = 0 →\n        H[X ; μ] = Finset.sum A fun x => Real.negMulLog ((MeasureTheory.Measure.map X μ).real {x})",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references": ["Ne", "Function.Injective", "mt", "Eq"],
  "name": "Function.Injective.ne",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a₁ a₂ : α}, a₁ ≠ a₂ → f a₁ ≠ f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Subgroup.instInfSubgroup",
   "Subgroup.instCompleteLatticeSubgroup.proof_3",
   "Inf.inf",
   "Subgroup.instBotSubgroup",
   "CompleteLattice.mk",
   "Subgroup.instCompleteLatticeSubgroup.proof_8",
   "Subgroup.instTopSubgroup",
   "Lattice.mk",
   "SetLike.instMembership",
   "Subgroup.instCompleteLatticeSubgroup.proof_5",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "Subgroup.instCompleteLatticeSubgroup.proof_7",
   "Membership.mem",
   "Bot.bot",
   "Subgroup.instCompleteLatticeSubgroup.proof_4",
   "Top.top",
   "Subgroup.instCompleteLatticeSubgroup.proof_2",
   "completeLatticeOfInf",
   "Subgroup.instInfSetSubgroup",
   "SetLike.instPartialOrder",
   "Subgroup.instCompleteLatticeSubgroup.proof_6",
   "Subgroup.instCompleteLatticeSubgroup.proof_9",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Subgroup.mem_top",
   "Bot.mk",
   "Top.mk",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup",
  "constType":
  "{G : Type u_1} → [inst : Group G] → CompleteLattice (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommMonoid.toOrderedCommMonoid",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "False",
   "instENNRealZero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "True",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Mathlib.Algebra.Order.WithZero._auxLemma.3",
   "of_eq_true",
   "Preorder.toLT",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Not",
   "not_false_eq_true",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder"],
  "name": "ENNReal.not_lt_zero",
  "constType": "∀ {a : ENNReal}, ¬a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.image",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "ZeroMemClass",
   "Zero",
   "OfNat.ofNat",
   "SetLike",
   "SetLike.instMembership"],
  "name": "ZeroMemClass.zero_mem",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ∈ s",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.mk",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, a = ↑n → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "IsUnit.div_self",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "InvOneClass.toOne",
   "DivInvOneMonoid.toInvOneClass",
   "GroupWithZero",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "DivisionMonoid.toDivInvOneMonoid"],
  "name": "div_self",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a / a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield",
   "PartialOrder.toPreorder",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "Iff",
   "inv_le_inv",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "lt_iff_lt_of_le_iff_le",
   "Inv.inv"],
  "name": "inv_lt_inv",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ < b⁻¹ ↔ b < a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "TopologicalSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add_assoc.match_1",
  "constType":
  "∀ (motive : ℕ → ℕ → ℕ → Prop) (x x_1 x_2 : ℕ),\n  (∀ (x x_3 : ℕ), motive x x_3 0) → (∀ (n m k : ℕ), motive n m (Nat.succ k)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Norm", "SeminormedRing"],
  "name": "SeminormedRing.toNorm",
  "constType": "{α : Type u_5} → [self : SeminormedRing α] → Norm α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Ring", "CommRing.toRing", "Int", "Int.instCommRingInt"],
  "name": "Int.instRingInt",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["GeneralizedCoheytingAlgebra.toSDiff",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.sdiff_le_iff",
  "constType":
  "∀ {α : Type u_4} [self : GeneralizedCoheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "mul_mul_invOf_self_cancel'",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) {x : Invertible b}, a * b * ⅟b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.mul_comm",
   "HPow.hPow",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "instNatPowNat",
   "Eq.refl",
   "HMul.hMul",
   "Nat.pow_succ",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "instPowNat",
   "id",
   "Eq"],
  "name": "Nat.pow_succ'",
  "constType": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "LinearOrder",
   "Int.mul_pos",
   "LinearOrder.max_def",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "CommRing.mul_comm",
   "Int.linearOrderedCommRing.proof_2",
   "CommRing",
   "LinearOrder.toOrd",
   "Int.add_le_add_left",
   "Int.linearOrderedCommRing.proof_1",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "CommRing.toRing",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "Int.instLinearOrderInt",
   "Nontrivial",
   "Int.instNontrivialInt",
   "LinearOrderedRing.mk",
   "Int",
   "Int.instCommRingInt"],
  "name": "Int.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mul_comm",
  "constType": "∀ {α : Type u} [self : CommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedDivisionRing"],
  "name": "NormedDivisionRing.toNorm",
  "constType": "{α : Type u_5} → [self : NormedDivisionRing α] → Norm α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.refl"],
  "name": "Iff.rfl",
  "constType": "∀ {a : Prop}, a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["refPackage", "Real", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.η",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike",
   "SetLike.mk",
   "AddSubsemigroup.instSetLikeSubsemigroup.proof_1",
   "Add",
   "AddSubsemigroup.carrier",
   "AddSubsemigroup"],
  "name": "AddSubsemigroup.instSetLikeSubsemigroup",
  "constType":
  "{M : Type u_1} → [inst : Add M] → SetLike (AddSubsemigroup M) M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "OfNat.ofNat",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_5",
  "constType": "∀ (r : ℝ), 0 ((algebraMap ℝ ℝ) r) = 0 ((algebraMap ℝ ℝ) r)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "instHDiv",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toInv",
   "DivisionRing.toDiv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.div_eq_mul_inv",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a b : K), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrder.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubgroupClass",
   "SubNegMonoid.toNeg",
   "AddSubmonoid.toAddSubsemigroup",
   "ZeroMemClass.mk",
   "AddSubsemigroup.add_mem'",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubgroupClass.mk",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "AddSubmonoidClass.mk",
   "AddGroup",
   "AddMemClass.mk",
   "NegMemClass.mk",
   "AddSubgroup.neg_mem'",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.instSetLikeAddSubgroup"],
  "name":
  "AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G], AddSubgroupClass (AddSubgroup G) G",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "Set",
   "InfSet.sInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sInf",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "Mul",
   "Submonoid.mul",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Subtype",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.mul",
  "constType": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Mul ↥H",
  "constCategory": "Definition"},
 {"references": ["Fin.cons", "Nat", "Nat.succ", "Fin"],
  "name": "Matrix.vecCons",
  "constType":
  "{α : Type u} → {n : ℕ} → α → (Fin n → α) → Fin (Nat.succ n) → α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma",
   "add_comm",
   "IsCommutative.mk",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "IsCommutative"],
  "name": "AddCommMagma.to_isCommutative",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G], IsCommutative G fun x x_1 => x + x_1",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.image2_empty_left",
   "Set.instEmptyCollectionSet",
   "Add",
   "Eq"],
  "name": "Set.empty_add",
  "constType": "∀ {α : Type u_2} [inst : Add α] {s : Set α}, ∅ + s = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Eq.ndrec",
   "DecidableEq",
   "Function.update",
   "dif_neg",
   "Not",
   "Eq.symm",
   "Eq"],
  "name": "Function.update_noteq",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {a a' : α},\n  a ≠ a' → ∀ (v : β a') (f : (a : α) → β a), Function.update f a' v a = f a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_1",
  "constType": "∀ (a : ℕ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Real.ofCauchy_zero",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "CauSeq.Completion.instZeroCauchy",
   "Eq",
   "Rat.instSupRat",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.19",
  "constType": "0 = { cauchy := 0 }",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Neg.toHasAbs",
   "Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "abs_pos",
   "Real",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "Abs.abs",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "DistribLattice.toLattice",
   "Real.linearOrder",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "LT.lt",
   "Real.instAddGroupReal",
   "Not",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Real.log.proof_1",
  "constType": "∀ (x : ℝ), ¬x = 0 → 0 < |x|",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Preorder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam", "FunLike", "Function.Injective"],
  "name": "FunLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (α → Sort u_3)} → (coe : F → (a : α) → β a) → Function.Injective coe → FunLike F α β",
  "constCategory": "Other"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Zero.toOfNat0",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "id"],
  "name": "AddGroup.toSubtractionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "CommMagma.toMul", "Eq"],
  "name": "CommMagma.mul_comm",
  "constType": "∀ {G : Type u} [self : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["False", "Not", "id"],
  "name": "not_false",
  "constType": "¬False",
  "constCategory": "Theorem"},
 {"references": ["Rat.mul", "Rat", "Mul", "Mul.mk"],
  "name": "Rat.instMulRat",
  "constType": "Mul ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "Nat.brecOn",
   "Nat.below",
   "False",
   "Eq",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "Nat.ne_of_beq_eq_false.match_1",
   "Nat.zero",
   "Bool.false",
   "Nat.noConfusion",
   "PUnit",
   "letFun",
   "Not",
   "Bool",
   "Nat.beq",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.ne_of_beq_eq_false",
  "constType": "∀ {n m : ℕ}, Nat.beq n m = false → ¬n = m",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Nat.le.refl", "Nat", "LE.le"],
  "name": "Nat.le_refl",
  "constType": "∀ (n : ℕ), n ≤ n",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Nonempty.intro",
   "Exists",
   "Iff",
   "nonempty_subtype.match_1",
   "nonempty_subtype.match_2",
   "Exists.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty"],
  "name": "nonempty_subtype",
  "constType":
  "∀ {α : Sort u_2} {p : α → Prop}, Nonempty (Subtype p) ↔ ∃ a, p a",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "Field",
   "Rat.cast",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Field.qsmul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Field.toRatCast",
   "Eq"],
  "name": "Field.qsmul_eq_mul'",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℚ) (x : K), Field.qsmul a x = ↑a * x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.nonempty",
   "AddGroup",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "Nonempty",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "addGroupIsAddTorsor.proof_1",
  "constType": "∀ (G : Type u_1) [inst : AddGroup G], Nonempty G",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteSemilatticeInf",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SemilatticeSup",
   "Exists",
   "PartialOrder.toPreorder",
   "propext",
   "Set",
   "Filter.mem_atTop_sets",
   "GE.ge",
   "Filter",
   "Filter.atTop",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Nonempty",
   "Eq",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.4",
  "constType":
  "∀ {α : Type u_3} [inst : Nonempty α] [inst : SemilatticeSup α] {s : Set α}, (s ∈ Filter.atTop) = ∃ a, ∀ b ≥ a, b ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "Real.instAddMonoidReal",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "Real.orderedRing",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "IsROrC.charZero_isROrC",
   "SemilatticeSup.toSup",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_not_gt",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddTorsor.nonempty",
   "HDiv.hDiv",
   "addGroupIsAddTorsor",
   "instOfNat",
   "HPow.hPow",
   "instHSub",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "instHDiv",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "instDistribLattice",
   "Real.instRingReal",
   "DivisionRing.toInv",
   "Prod.instMeasurableSpace",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "Int",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "Inv.inv",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Abs.abs",
   "Mathlib.Tactic.Ring.sub_pf",
   "Field.toCommRing",
   "MeasureTheory.Measure",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedRing.toOrderedSemiring",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "Field.toSemifield",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Countable",
   "sub_neg_of_lt",
   "Int.mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "le_max_left",
   "Bool.false",
   "Mathlib.Tactic.Ring.one_mul",
   "letFun",
   "Real.instPreorderReal",
   "Semifield.toDivisionSemiring",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toNeg",
   "Real.orderedAddCommGroup",
   "Mathlib.Tactic.Ring.mul_congr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "OrderedAddCommGroup.toPartialOrder",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.isROrC",
   "Real.commRing",
   "Real.instSupReal",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "ProbabilityTheory.max_entropy_le_entropy_sub",
   "Semiring.toNonAssocSemiring",
   "rdist",
   "FiniteRange",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "Real.instCommSemiringReal",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "And.casesOn",
   "LinearOrderedRing.toMax",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Real.field",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Real.partialOrder",
   "Nat.rawCast",
   "ProbabilityTheory.IndepFun.rdist_eq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "DistribLattice.toLattice",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "LinearOrder.toMax",
   "Real.instAddGroupReal",
   "le_max_right",
   "Mathlib.Tactic.Ring.mul_one",
   "ProbabilityTheory.IndepFun",
   "OrderedAddCommGroup.toAddCommGroup",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Linarith.lt_irrefl",
   "DivisionRing.toRing",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "ProbabilityTheory.independent_copies_finiteRange",
   "MeasurableSub₂",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedField.toDiv",
   "Ring.toNonAssocRing",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Linarith.mul_nonpos",
   "instHPow",
   "Preorder.toLT",
   "Ring.toSub",
   "Linarith.mul_neg",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "CancelDenoms.neg_subst",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Real.strictOrderedRing",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "ProbabilityTheory.IdentDistrib.entropy_eq",
   "Eq.symm",
   "id",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "abs_le",
   "GT.gt",
   "Semiring.toOne",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Max.max",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Bool"],
  "name": "diff_ent_le_rdist",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [hG : MeasurableSpace G]\n  [inst : MeasurableSingletonClass G] [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G]\n  {X : Ω → G} {Y : Ω' → G} [inst_3 : FiniteRange X] [inst_4 : FiniteRange Y]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure μ] [inst_6 : MeasureTheory.IsProbabilityMeasure μ'],\n  Measurable X → Measurable Y → |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ']",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MulActionWithZero",
  "constType":
  "(R : Type u_1) → (M : Type u_3) → [inst : MonoidWithZero R] → [inst : Zero M] → Type (max u_1 u_3)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Subgroup.instCompleteLatticeSubgroup",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le.trans",
   "Subgroup.map",
   "MonoidHom.range",
   "LE.le",
   "le_of_eq",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Subgroup.toGroup",
   "Subgroup.subtype_range",
   "Subgroup",
   "Group",
   "Subgroup.map_le_range",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Subtype",
   "Subgroup.instSetLikeSubgroup",
   "Subgroup.subtype"],
  "name": "Subgroup.map_subtype_le",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} (K : Subgroup ↥H), Subgroup.map (Subgroup.subtype H) K ≤ H",
  "constCategory": "Theorem"},
 {"references": ["AddGroupWithOne", "Sub"],
  "name": "AddGroupWithOne.toSub",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Sub R",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le.match_1",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "And.intro",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "lt_of_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["true_and",
   "EmptyCollection.emptyCollection",
   "Set.infinite_image2",
   "Set",
   "Mathlib.Data.Set.Finite._auxLemma.35",
   "Set.Nonempty",
   "Eq.refl",
   "Mathlib.Data.Set.Finite._auxLemma.1",
   "Set.not_infinite",
   "Set.InjOn",
   "True",
   "Eq",
   "Eq.mpr",
   "Iff",
   "true_or",
   "Mathlib.Data.Set.Finite._auxLemma.27",
   "Eq.symm",
   "And.casesOn",
   "Set.Infinite",
   "Eq.trans",
   "id",
   "or_self",
   "eq_self",
   "Membership.mem",
   "Or",
   "Set.image2",
   "Set.instEmptyCollectionSet",
   "or_true",
   "Mathlib.Data.Set.Finite._auxLemma.34",
   "Or.casesOn",
   "and_true",
   "Set.Finite",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "eq_true",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "congr",
   "Not",
   "Mathlib.Data.Set.Finite._auxLemma.36",
   "congrArg",
   "and_self",
   "congrFun"],
  "name": "Set.finite_image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} {f : α → β → γ} {s : Set α} {t : Set β},\n  (∀ b ∈ t, Set.InjOn (fun x => f x b) s) →\n    (∀ a ∈ s, Set.InjOn (f a) t) → (Set.Finite (Set.image2 f s t) ↔ Set.Finite s ∧ Set.Finite t ∨ s = ∅ ∨ t = ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "Ring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ring.toNonAssocRing.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddLeftCancelMonoid.add_zero",
   "AddCommMonoid.mk",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddCancelCommMonoid.add_comm",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddMonoid.mk",
   "AddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCommMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelCommMonoid M] → AddCommMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "ProbabilityTheory.kernel.IndepSets",
   "setOf",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "autoParam",
   "AddSubmonoid",
   "SetLike.instMembership",
   "MeasureTheory.Measure",
   "_auto._@.Mathlib.Probability.Independence.Kernel._hyg.367",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "MeasurableSet",
   "ProbabilityTheory.kernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Pi.addZeroClass",
   "MeasurableSpace",
   "Subtype"],
  "name": "ProbabilityTheory.kernel.Indep",
  "constType":
  "{α : Type u_1} →\n  {Ω : Type u_2} →\n    {_mα : MeasurableSpace α} →\n      MeasurableSpace Ω →\n        MeasurableSpace Ω →\n          {_mΩ : MeasurableSpace Ω} →\n            ↥(ProbabilityTheory.kernel α Ω) → autoParam (MeasureTheory.Measure α) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "Or.inr", "LT.lt", "Or.casesOn", "Nat", "instLTNat", "Eq"],
  "name": "Nat.lt_or_ge.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : m = n ∨ m < n → Prop) (x : m = n ∨ m < n),\n  (∀ (h1 : m = n), motive (_ : m = n ∨ m < n)) → (∀ (h1 : m < n), motive (_ : m = n ∨ m < n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "False",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "implies_true",
   "Finset.instMembershipFinset",
   "Set.instEmptyCollectionSet",
   "Mathlib.Data.Finset.Basic._auxLemma.20",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Set.ext",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "Finset.toSet",
   "Finset",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.coe_empty",
  "constType": "∀ {α : Type u_1}, ↑∅ = ∅",
  "constCategory": "Theorem"},
 {"references": ["Units", "Exists", "Monoid", "Units.val", "Eq"],
  "name": "IsUnit",
  "constType": "{M : Type u_1} → [inst : Monoid M] → M → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.prop",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "PosMulStrictMono",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype"],
  "name": "StrictOrderedSemiring.toPosMulStrictMono",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedSemiring α], PosMulStrictMono α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "instLTNat",
   "rfl",
   "Iff.mpr",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.ble",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "instLENat",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Preorder.toLT",
   "Bool.true",
   "instOfNatNat",
   "Nat",
   "id",
   "Mathlib.Meta.NormNum.IsNat.to_eq",
   "instNontrivial",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Nat.ble_eq",
   "StrictOrderedSemiring.to_charZero",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Eq.mp",
   "OrderedSemiring.toSemiring",
   "Bool",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.Positivity.pos_of_isNat",
  "constType":
  "∀ {A : Type u_1} {e : A} {n : ℕ} [inst : StrictOrderedSemiring A],\n  Mathlib.Meta.NormNum.IsNat e n → Nat.ble 1 n = true → 0 < e",
  "constCategory": "Theorem"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set",
   "MeasurableSpace.measurableSet_injective.match_1",
   "HasCompl.compl",
   "Eq.refl",
   "Set.instEmptyCollectionSet",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.mk",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Set.iUnion",
   "Eq.ndrec",
   "Function.Injective",
   "Eq.rec",
   "MeasurableSet",
   "Nat",
   "MeasurableSpace"],
  "name": "MeasurableSpace.measurableSet_injective",
  "constType": "∀ {α : Type u_1}, Function.Injective (@MeasurableSet α)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "Semifield.toCommSemiring",
   "One.toOfNat1",
   "Int",
   "Semifield.zpow",
   "Semifield",
   "Eq"],
  "name": "Semifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (a : α), Semifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["funext",
   "PartialOrder.toPreorder",
   "sup_of_le_right",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "Or.resolve_left",
   "SemilatticeSup",
   "if_pos",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "maxDefault",
   "sup_of_le_left",
   "IsTotal",
   "Not",
   "Sup.sup",
   "total_of",
   "congrArg",
   "if_neg",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel",
   "id"],
  "name": "sup_eq_maxDefault",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1], (fun x x_1 => x ⊔ x_1) = maxDefault",
  "constCategory": "Theorem"},
 {"references": ["Equiv"],
  "name": "Equiv.invFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["Prod.mk",
   "Prod",
   "Measurable.prod",
   "Measurable",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "Measurable.prod_mk",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} {β : Type u_6} {γ : Type u_7} {x : MeasurableSpace β} {x_1 : MeasurableSpace γ}\n  {f : α → β} {g : α → γ}, Measurable f → Measurable g → Measurable fun a => (f a, g a)",
  "constCategory": "Theorem"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Subsemigroup.carrier",
   "Equiv",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "AddSubsemigroup.mk",
   "MulOneClass",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Submonoid.casesOn",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "Iff",
   "Additive.toMul",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "Membership.mem",
   "Submonoid.mk",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.one_mem'",
   "MulOneClass.toOne",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "Subsemigroup",
   "AddSubmonoid.toAddSubsemigroup",
   "One.toOfNat1",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "Additive.ofMul",
   "Additive.addZeroClass",
   "AddSubmonoid",
   "LE.le",
   "AddSubsemigroup",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Subsemigroup.mul_mem'",
   "Equiv.mk",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubsemigroup.carrier",
   "Additive",
   "SetLike.coe"],
  "name": "Submonoid.toAddSubmonoid.proof_6",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] {a b : Submonoid M},\n  {\n          toFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : Additive M},\n                        a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                          b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : Submonoid M),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : M},\n                                  a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : Additive M},\n                                    a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                      b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid (Additive M)),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : Additive M},\n                                  a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                    b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : M},\n                                    a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : Additive M},\n                        a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                          b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : Submonoid M),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : M},\n                                  a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : Additive M},\n                                    a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                      b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid (Additive M)),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : Additive M},\n                                  a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                    b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : M},\n                                    a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x) }\n        b ↔\n    {\n          toFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : Additive M},\n                        a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                          b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : Submonoid M),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : M},\n                                  a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : Additive M},\n                                    a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                      b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid (Additive M)),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : Additive M},\n                                  a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                    b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : M},\n                                    a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            {\n              toAddSubsemigroup :=\n                { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                  add_mem' :=\n                    (_ :\n                      ∀ {a b : Additive M},\n                        a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                          b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n              zero_mem' := (_ : 1 ∈ S.carrier) },\n          invFun := fun S =>\n            {\n              toSubsemigroup :=\n                { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                  mul_mem' :=\n                    (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n              one_mem' := (_ : 0 ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : Submonoid M),\n                (fun S =>\n                      {\n                        toSubsemigroup :=\n                          { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                            mul_mem' :=\n                              (_ :\n                                ∀ {a b : M},\n                                  a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                        one_mem' := (_ : 0 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toAddSubsemigroup :=\n                            { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                              add_mem' :=\n                                (_ :\n                                  ∀ {a b : Additive M},\n                                    a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                      b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                          zero_mem' := (_ : 1 ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : AddSubmonoid (Additive M)),\n                (fun S =>\n                      {\n                        toAddSubsemigroup :=\n                          { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                            add_mem' :=\n                              (_ :\n                                ∀ {a b : Additive M},\n                                  a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                                    b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n                        zero_mem' := (_ : 1 ∈ S.carrier) })\n                    ((fun S =>\n                        {\n                          toSubsemigroup :=\n                            { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                              mul_mem' :=\n                                (_ :\n                                  ∀ {a b : M},\n                                    a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n                          one_mem' := (_ : 0 ∈ S.carrier) })\n                      x) =\n                  x) }\n        b",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "_private.Mathlib.Data.Real.Basic.0.Real.add_def",
   "instHAdd",
   "Real.instAddReal",
   "Real",
   "HAdd.hAdd",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.ext_cauchy_iff.match_1",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "_private.Mathlib.Data.Real.Basic.0.Real.add",
   "letFun",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "id"],
  "name": "Real.cauchy_add",
  "constType": "∀ (a b : ℝ), (a + b).cauchy = a.cauchy + b.cauchy",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.add_zero",
  "constType": "∀ (n : ℕ), n + 0 = n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "ZeroHom", "AddZeroClass", "AddMonoidHom"],
  "name": "AddMonoidHom.toZeroHom",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → (M →+ N) → ZeroHom M N",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd", "Prod.ext.match_1", "Prod.mk", "Prod", "Prod.fst", "rfl", "Eq"],
  "name": "Prod.ext",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x y : α × β}, x.1 = y.1 → x.2 = y.2 → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "instHAdd",
   "Real",
   "HAdd.hAdd",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.827",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Quotient.liftOn₂",
   "Iff.rfl",
   "Cardinal.instLECardinal.proof_1",
   "Function.Embedding.trans",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Nonempty",
   "Quotient.sound",
   "Eq",
   "Nonempty.casesOn",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "Setoid.r",
   "And",
   "Nonempty.intro",
   "Function.Embedding.antisymm",
   "LT.lt",
   "Function.Embedding.refl",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Not",
   "Cardinal.isEquivalent",
   "Quot.mk"],
  "name": "Cardinal.partialOrder.proof_4",
  "constType": "∀ (a b : Cardinal.{u_1}), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Exists",
   "HasSSubset.SSubset",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Insert.insert",
   "Iff.mpr",
   "And",
   "Finset.ssubset_iff",
   "DecidableEq",
   "Finset.Subset.rfl",
   "Finset",
   "Not",
   "And.intro",
   "Finset.instHasSSubsetFinset",
   "Finset.instHasSubsetFinset"],
  "name": "Finset.ssubset_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a : α}, a ∉ s → s ⊂ insert a s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "DivInvMonoid",
   "Nat",
   "Nat.succ",
   "Int",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_neg'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references":
  ["disjointed",
   "PartialOrder.toPreorder",
   "MeasureTheory.SFinite.mk",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "MeasureTheory.Measure.restrict",
   "Exists.intro",
   "MeasureTheory.IsFiniteMeasure",
   "Eq",
   "MeasureTheory.Measure",
   "inferInstance",
   "ENNReal",
   "MeasureTheory.Restrict.isFiniteMeasure",
   "MeasureTheory.OuterMeasure.measureOf",
   "Preorder.toLT",
   "MeasureTheory.SigmaFinite",
   "MeasureTheory.sum_restrict_disjointed_spanningSets",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat",
   "Eq.symm",
   "CompletelyDistribLattice.toCompleteLattice",
   "MeasureTheory.spanningSets",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "MeasureTheory.SFinite",
   "LE.le.trans_lt",
   "disjointed_subset",
   "ENNReal.instCompleteLinearOrderENNReal",
   "And",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.Measure.toOuterMeasure",
   "Fact.mk",
   "MeasureTheory.measure_spanningSets_lt_top",
   "LT.lt",
   "letFun",
   "CompleteLattice.toTop",
   "And.intro",
   "Fact",
   "MeasureTheory.Measure.sum",
   "MeasurableSpace",
   "MeasureTheory.measure_mono"],
  "name": "MeasureTheory.instSFinite",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SigmaFinite μ],\n  MeasureTheory.SFinite μ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "GE.ge",
   "HasSubset.Subset",
   "exists_congr",
   "Set.Ici",
   "Filter.HasBasis.mem_iff",
   "Filter.atTop_basis",
   "Preorder.toLE",
   "Nonempty",
   "True",
   "Set.instMembershipSet",
   "SemilatticeSup",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "true_and_iff",
   "Iff.trans",
   "Filter",
   "Filter.atTop",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter"],
  "name": "Filter.mem_atTop_sets",
  "constType":
  "∀ {α : Type u_3} [inst : Nonempty α] [inst : SemilatticeSup α] {s : Set α}, s ∈ Filter.atTop ↔ ∃ a, ∀ b ≥ a, b ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group.toDivisionMonoid.proof_1",
   "Group.toDivisionMonoid.proof_2",
   "DivisionMonoid.mk",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Group.toDivisionMonoid",
  "constType": "{G : Type u_1} → [inst : Group G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NormedAlgebra.id.proof_3",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "NormedField.toField",
   "Algebra.toRingHom",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MonoidWithZero.toMonoid",
   "NormedField.toNormedSpace",
   "Algebra",
   "NormedAlgebra.id.proof_1",
   "NormedAlgebra",
   "DistribMulAction.toMulAction",
   "NormedAlgebra.id.proof_2",
   "NormedField",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionSemiring.toSemiring",
   "SeminormedRing.toRing",
   "MulAction.toSMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Semifield.toDivisionSemiring",
   "Algebra.mk",
   "Algebra.id",
   "NormedSpace.toModule",
   "NormedAlgebra.mk"],
  "name": "NormedAlgebra.id",
  "constType": "(𝕜 : Type u_5) → [inst : NormedField 𝕜] → NormedAlgebra 𝕜 𝕜",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mk",
  "constType": "{α : Type u} → (α → α → α) → Mul α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_11",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references": ["Trans", "Eq.rec", "Eq.symm", "Trans.mk", "Eq"],
  "name": "instTransEq",
  "constType":
  "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Sort u) → Trans Eq r r",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "List.mem_filter",
   "List.filter",
   "decide_eq_true_eq",
   "List.instMembershipList",
   "List.isSetoid",
   "Mathlib.Data.Multiset.Basic._auxLemma.5",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq",
   "DecidablePred",
   "Decidable.decide",
   "Setoid.r",
   "And",
   "Eq.mpr",
   "Iff",
   "List",
   "Bool.true",
   "Eq.mp",
   "Multiset",
   "congr",
   "Multiset.filter",
   "Bool",
   "Multiset.ofList",
   "congrArg",
   "congrFun",
   "Quot.mk",
   "id"],
  "name": "Multiset.mem_filter",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {s : Multiset α}, a ∈ Multiset.filter p s ↔ a ∈ s ∧ p a",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Complex.log_one",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Complex.instNormedFieldComplex",
   "OfNat.ofNat",
   "Real.instLEReal",
   "MulZeroClass.mul_zero",
   "dite",
   "Real.pi",
   "MulZeroClass.toMul",
   "ite",
   "Eq",
   "Complex.Complex.addGroupWithOne",
   "mul_assoc",
   "SeminormedCommRing.toSeminormedRing",
   "Eq.mpr",
   "IsDomain.to_noZeroDivisors",
   "Complex.instField",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.trans",
   "Complex.instOneComplex",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "or_self",
   "HPow.hPow",
   "Complex.instZeroComplex",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Complex.charZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.exp_zero",
   "SemigroupWithZero.toSemigroup",
   "Complex.im",
   "instHMul",
   "False.elim",
   "of_eq_true",
   "LT.lt",
   "Mathlib.Analysis.SpecialFunctions.Pow.Complex._auxLemma.1",
   "Eq.mp",
   "congr",
   "Complex.log",
   "Not",
   "congrArg",
   "Complex.exp",
   "congrFun",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Complex.instDecidableEqComplex",
   "Real",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "NeZero.charZero_one",
   "if_neg",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Real.instLTReal",
   "One.toOfNat1",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "Complex.log_exp",
   "LE.le",
   "ite_congr",
   "Field.isDomain",
   "NormedCommRing.toSeminormedCommRing",
   "eq_false",
   "if_pos",
   "SeminormedRing.toRing",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "not_true_eq_false",
   "Complex",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1",
   "Complex.instMulComplex"],
  "name": "Complex.cpow_mul",
  "constType":
  "∀ {x y : ℂ} (z : ℂ), -Real.pi < (Complex.log x * y).im → (Complex.log x * y).im ≤ Real.pi → x ^ (y * z) = (x ^ y) ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "congr",
   "HMul.hMul",
   "congrArg",
   "CommMagma.toMul",
   "CommSemigroup",
   "Eq.trans",
   "mul_left_comm",
   "True",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "mul_mul_mul_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c d : G), a * b * (c * d) = a * c * (b * d)",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff",
   "LT.lt",
   "LT",
   "LE",
   "Not",
   "Preorder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
   "autoParam",
   "LE.le"],
  "name": "Preorder.mk",
  "constType":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) →\n        (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → autoParam (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) _auto✝ → Preorder α",
  "constCategory": "Other"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "instHSMul",
   "AddGroup",
   "Subtype.val",
   "AddSubgroup.zsmul_mem",
   "HSMul.hSMul",
   "AddSubgroup",
   "SubNegMonoid.SMulInt",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "Int",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubgroup.zsmul.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} (n : ℤ) (a : ↥H), n • ↑a ∈ H",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.lt",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["MetricSpace", "PseudoMetricSpace"],
  "name": "MetricSpace.toPseudoMetricSpace",
  "constType": "{α : Type u} → [self : MetricSpace α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.sum",
   "Set",
   "instENNRealAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "map_sum",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Pi.addCommMonoid",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.coeAddHom",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "Finset",
   "MeasureTheory.Measure.instAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "Pi.addZeroClass",
   "MeasurableSpace",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "MeasureTheory.Measure.coe_finset_sum",
  "constType":
  "∀ {α : Type u_1} {ι : Type u_5} {_m : MeasurableSpace α} (I : Finset ι) (μ : ι → MeasureTheory.Measure α),\n  ↑↑(Finset.sum I fun i => μ i) = Finset.sum I fun i => ↑↑(μ i)",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "HEq.refl",
   "Ring",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsNat x x_1 → Prop) (x : α)\n  (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsNat x x_1),\n  (∀ (n : ℕ), motive (↑n) n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Ne",
   "AbsoluteValue.eq_zero",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "AbsoluteValue",
   "Semiring.toMonoidWithZero",
   "Ne.symm",
   "FunLike.coe",
   "mt",
   "SubadditiveHomClass.toFunLike",
   "AbsoluteValue.nonneg",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "lt_of_le_of_ne",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.pos",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) {x : R},\n  x ≠ 0 → 0 < abv x",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Bool.decEq", "Bool"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "Int.zero_mul",
   "Int.instSubInt",
   "instOfNatInt",
   "Zero.ofOfNat0",
   "Int.add_comm",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Int.mul_comm",
   "CommRing.mk",
   "Int.instCommRingInt.proof_9",
   "Int.instCommRingInt.proof_1",
   "Int.mul_one",
   "Int.add_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Int.one_mul",
   "Int.instNegInt",
   "Int.instCommRingInt.proof_2",
   "Int.instCommRingInt.proof_4",
   "Nat",
   "Int.sub_eq_add_neg",
   "HPow.hPow",
   "Int.instMulInt",
   "AddSemigroup.mk",
   "Int.mul_add",
   "Int.instCommRingInt.proof_6",
   "One.ofOfNat1",
   "Int.zero_add",
   "AddMonoid.mk",
   "Int.instHPowIntNat",
   "Int.instAddInt",
   "Int.mul_zero",
   "Int.instCommRingInt.proof_5",
   "instHMul",
   "IntCast.mk",
   "instNatCastInt",
   "Int.instCommRingInt.proof_7",
   "NonUnitalSemiring.mk",
   "Int.add_assoc",
   "HMul.hMul",
   "Int.instCommRingInt.proof_8",
   "Int.add_mul",
   "Ring.mk",
   "Int.mul_assoc",
   "Int.instCommRingInt.proof_3",
   "Int",
   "Int.add_left_neg"],
  "name": "Int.instCommRingInt",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "PartialOrder.toPreorder",
   "Iff",
   "LinearOrder",
   "not_congr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Iff.trans",
   "LinearOrder.toPartialOrder",
   "not_le",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_iff_lt_of_le_iff_le",
  "constType":
  "∀ {α : Type u} {β : Type u_3} [inst : LinearOrder α] [inst_1 : LinearOrder β] {a b : α} {c d : β},\n  (a ≤ b ↔ c ≤ d) → (b < a ↔ d < c)",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "compareOfLessAndEq",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.decidableEq",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Lattice.inf_le_left",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_8",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec", "Ring.toNeg", "Ring", "Eq.refl", "Neg.neg", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "le_of_not_gt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Nonempty.intro",
   "Setoid.r",
   "Function.Embedding.refl",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Cardinal.isEquivalent",
   "LE.le",
   "Cardinal.instLECardinal"],
  "name": "Cardinal.partialOrder.proof_1",
  "constType": "∀ (a : Cardinal.{u_1}), a ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group",
   "mul_left_inv",
   "Group.toDivInvMonoid",
   "Eq",
   "DivInvMonoid.toInv",
   "Inv.inv"],
  "name": "Group.toDivisionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Ring.toSemiring",
   "Int",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "completeLatticeOfInf",
   "Subgroup.instInfSetSubgroup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "CompleteLattice.toInfSet",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_8",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)) (a : Subgroup G), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Real",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "AddMonoid"],
  "name": "Real.instAddMonoidReal",
  "constType": "AddMonoid ℝ",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references": ["inferInstance", "Classical.propDecidable", "DecidableRel"],
  "name": "Classical.decRel",
  "constType": "{α : Sort u_1} → (p : α → α → Prop) → DecidableRel p",
  "constCategory": "Definition"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "PFR.ForMathlib.Uniform._auxLemma.2",
  "constType": "∀ {α : Type u} (x : α), (x ∈ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Set.ext",
   "Membership.mem",
   "Iff.intro",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "id",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.ext_iff",
  "constType": "∀ {α : Type u} {s t : Set α}, s = t ↔ ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references": ["instHAdd", "HAdd.hAdd", "IsRightCancelAdd", "Add", "Eq"],
  "name": "IsRightCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G], (∀ (a b c : G), a + b = c + b → a = c) → IsRightCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "GeneralizedCoheytingAlgebra",
   "GeneralizedCoheytingAlgebra.toLattice",
   "OrderBot",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.toOrderBot",
  "constType":
  "{α : Type u_4} → [self : GeneralizedCoheytingAlgebra α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Top.top",
   "Set",
   "CompleteLattice.toTop",
   "MeasurableSet",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "MeasurableSpace"],
  "name": "MeasurableSpace.measurableSet_top",
  "constType": "∀ {α : Type u_1} {s : Set α}, MeasurableSet s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Membership.mem",
   "Exists",
   "funext",
   "setOf",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "Set.image_univ",
   "Set.univ",
   "and_true",
   "Std.Logic._auxLemma.51",
   "True",
   "Iff.of_eq",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "And",
   "Eq.mpr",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "Eq.ndrec",
   "of_eq_true",
   "Set.image",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "Subtype.coe_image",
   "Subtype.mk",
   "Subtype",
   "exists_prop_congr'",
   "congrFun",
   "id"],
  "name": "Subtype.range_coe",
  "constType": "∀ {α : Type u_1} {s : Set α}, Set.range Subtype.val = s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MeasureTheory.Measure.map",
   "MeasureTheory.isFiniteMeasureZero",
   "MeasureTheory.Measure.map_of_not_aemeasurable",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Eq.refl",
   "dite",
   "MeasureTheory.IsFiniteMeasure",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Preorder.toLT",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasureTheory.Measure.map_apply_of_aemeasurable",
   "AEMeasurable",
   "id",
   "CompletelyDistribLattice.toCompleteLattice",
   "MeasureTheory.IsFiniteMeasure.mk",
   "Set.preimage",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "Classical.propDecidable",
   "Set.univ",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasurableSet.univ",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.instZero",
   "LT.lt",
   "CompleteLattice.toTop",
   "Not",
   "MeasurableSpace",
   "MeasureTheory.measure_lt_top"],
  "name": "MeasureTheory.Measure.isFiniteMeasure_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace β] {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst_1 : MeasureTheory.IsFiniteMeasure μ] (f : α → β), MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.map f μ)",
  "constCategory": "Theorem"},
 {"references": ["Dist", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toDist",
  "constType": "{α : Type u} → [self : PseudoMetricSpace α] → Dist α",
  "constCategory": "Definition"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.compare",
  "constType": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "Decidable.le_iff_lt_or_eq",
   "LT.lt",
   "Classical.propDecidable",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_iff_lt_or_eq",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "SetLike.instPartialOrder.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "PartialOrder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Preorder.mk",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "SetLike.instPartialOrder.proof_3",
   "Set.instBooleanAlgebraSet",
   "Preorder.toLT",
   "SetLike.instPartialOrder.proof_2",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → PartialOrder A",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "if_pos",
   "Eq.mpr",
   "Or",
   "Eq.ndrec",
   "Or.inl",
   "Or.inr",
   "Decidable",
   "Eq.refl",
   "Not",
   "Or.casesOn",
   "Eq.symm",
   "if_neg",
   "id",
   "ite",
   "Eq"],
  "name": "ite_congr",
  "constType":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.le_trans",
   "Real.instSupReal",
   "Sup.mk",
   "implies_congr",
   "Preorder.toLE",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.mpr",
   "Preorder.toLT",
   "Rat.instNegRat",
   "Real.ind_mk",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Preorder.le_refl",
   "Rat",
   "CauSeq",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.15",
   "Preorder.mk",
   "CauSeq.sup_le",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le",
   "congrFun"],
  "name": "Real.instDistribLatticeReal.proof_6",
  "constType": "∀ (a b c : ℝ), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Finset.mem_add",
   "Exists",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "HasSubset.Subset",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "And",
   "DecidableEq",
   "Finset",
   "And.intro",
   "Finset.instHasSubsetFinset",
   "add_zero",
   "AddZeroClass",
   "Finset.add"],
  "name": "Finset.subset_add_left",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : AddZeroClass α] (s : Finset α) {t : Finset α}, 0 ∈ t → s ⊆ s + t",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "div_eq_mul_inv",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Ring.toNeg",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.cast_negOfNat",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HDiv.hDiv",
   "Nat",
   "neg_mul",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "DivisionRing.toDiv",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHDiv",
   "DivisionRing",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Int.negOfNat",
   "Mathlib.Meta.NormNum.IsRat",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "Int.cast",
   "congr",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsRat.neg_to_eq.match_1",
   "congrArg",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.neg_to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ} {a n' d' : α},\n  Mathlib.Meta.NormNum.IsRat a (Int.negOfNat n) d → ↑n = n' → ↑d = d' → a = -(n' / d')",
  "constCategory": "Theorem"},
 {"references": ["Rat", "RatCast"],
  "name": "RatCast.ratCast",
  "constType": "{K : Type u} → [self : RatCast K] → ℚ → K",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "Bool.casesOn",
   "instDecidableNot",
   "Bool.false",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "Eq.symm",
   "instDecidableIff",
   "instDecidableEqProp",
   "instDecidableEqBool",
   "Eq"],
  "name": "Bool.not_eq_true",
  "constType": "∀ (b : Bool), (¬b = true) = (b = false)",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "CompleteLattice.toBoundedOrder",
   "SupSet.mk",
   "Lattice.mk",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "GaloisInsertion.liftCompleteLattice.proof_1",
   "OrderTop.toTop",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "GaloisInsertion.liftCompleteLattice.proof_2",
   "GaloisInsertion.liftBoundedOrder",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "GaloisInsertion.liftCompleteLattice.proof_4",
   "BoundedOrder.toOrderBot",
   "CompleteLattice.toSupSet",
   "BoundedOrder",
   "GaloisInsertion.liftCompleteLattice.proof_6",
   "SupSet.sSup",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "GaloisInsertion.choice",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.liftCompleteLattice.proof_5",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "GaloisInsertion.liftCompleteLattice.proof_7",
   "OrderBot.toBot",
   "Lattice",
   "CompleteLattice.toCompleteSemilatticeInf",
   "GaloisInsertion.liftCompleteLattice.proof_3"],
  "name": "GaloisInsertion.liftCompleteLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} → [inst : PartialOrder β] → [inst_1 : CompleteLattice α] → GaloisInsertion l u → CompleteLattice β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Fintype.subtype",
   "Set.instMembershipSet"],
  "name": "Fintype.ofFinset",
  "constType":
  "{α : Type u_1} → {p : Set α} → (s : Finset α) → (∀ (x : α), x ∈ s ↔ x ∈ p) → Fintype ↑p",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le",
   "instLENat",
   "Nat.lt_of_le_of_lt",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "instLTNat",
   "absurd",
   "Nat.succ",
   "rfl",
   "LE.le",
   "Eq",
   "Nat.le_antisymm.match_1"],
  "name": "Nat.le_antisymm",
  "constType": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.mk",
   "PartialOrder.toPreorder",
   "GaloisInsertion.liftBoundedOrder.proof_1",
   "GaloisInsertion.liftBoundedOrder.proof_2",
   "OrderBot",
   "Preorder",
   "BoundedOrder.toOrderTop",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder",
   "OrderTop.toTop",
   "GaloisInsertion.liftBoundedOrder.proof_3",
   "GaloisInsertion.liftOrderTop",
   "BoundedOrder.mk",
   "OrderBot.toBot",
   "GaloisConnection.liftOrderBot",
   "OrderTop",
   "OrderBot.mk",
   "BoundedOrder.toOrderBot",
   "BoundedOrder"],
  "name": "GaloisInsertion.liftBoundedOrder",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} →\n      {u : β → α} →\n        [inst : PartialOrder β] →\n          [inst_1 : Preorder α] → [inst_2 : BoundedOrder α] → GaloisInsertion l u → BoundedOrder β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalRing",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "One.toOfNat1",
   "Real.rpow_def_of_nonneg",
   "Real.exp",
   "Real.instOneReal",
   "Eq",
   "ite",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "ne_of_gt",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "HMul.hMul",
   "le_of_lt",
   "if_neg",
   "id"],
  "name": "Real.rpow_def_of_pos",
  "constType":
  "∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), x ^ y = Real.exp (Real.log x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "IsUnit.div_mul_cancel",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "GroupWithZero.toDiv",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "div_mul_cancel",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → a / b * b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "Multiset.sum_map_le_sum_map",
   "Finset.sum",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.sum_le_sum",
  "constType":
  "∀ {ι : Type u_1} {N : Type u_5} [inst : OrderedAddCommMonoid N] {f g : ι → N} {s : Finset ι},\n  (∀ i ∈ s, f i ≤ g i) → (Finset.sum s fun i => f i) ≤ Finset.sum s fun i => g i",
  "constCategory": "Theorem"},
 {"references":
  ["Int.natAbs_mul_self.match_1",
   "Int.ofNat",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Nat.one_mul",
   "Eq.ndrec",
   "Int.negSucc",
   "letFun",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Int",
   "id"],
  "name": "Int.one_mul",
  "constType": "∀ (a : ℤ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Eq.ndrec",
   "instHPow",
   "Real.instPowReal",
   "Real",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.pow_congr",
  "constType": "∀ {a a' b c : ℝ}, a = a' → a' ^ b = c → a ^ b = c",
  "constCategory": "Theorem"},
 {"references": ["Multiset.Mem", "Multiset", "Membership.mk", "Membership"],
  "name": "Multiset.instMembershipMultiset",
  "constType": "{α : Type u_1} → Membership α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "neg_add_cancel_left",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -a + (a + b) = b",
  "constCategory": "Theorem"},
 {"references": ["Classical.choice", "Nonempty"],
  "name": "Classical.arbitrary",
  "constType": "(α : Sort u_2) → [h : Nonempty α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Filter.sets_of_superset",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.mem_of_superset",
  "constType":
  "∀ {α : Type u} {f : Filter α} {x y : Set α}, x ∈ f → x ⊆ y → y ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MeasureTheory.IsFiniteMeasure.mk",
   "Mathlib.Data.Real.ENNReal._auxLemma.17",
   "Top.top",
   "MeasureTheory.IsFiniteMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instENNRealZero",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "of_eq_true",
   "Preorder.toLT",
   "MeasureTheory.Measure.instZero",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace",
   "OrderedSemiring.toPartialOrder"],
  "name": "MeasureTheory.isFiniteMeasureZero",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α}, MeasureTheory.IsFiniteMeasure 0",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff"],
  "name": "Iff.refl",
  "constType": "∀ (a : Prop), a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "NatCast",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "CauSeq.Completion.instNatCastCauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "NatCast.mk",
   "Abs.abs",
   "Rat.instSupRat",
   "Nat.cast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.natCast",
  "constType": "NatCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["inf_le_left",
   "eq_true",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "True",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.11",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, (a ⊓ b ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "instHasEquiv",
   "Setoid",
   "HasEquiv.Equiv",
   "Quotient",
   "Eq"],
  "name": "Quotient.liftOn",
  "constType":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → Quotient s → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "Add",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.add",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubgroup.add",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Add ↥H",
  "constCategory": "Definition"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Set.Finite",
   "Set.Finite.casesOn"],
  "name": "Set.finite_def.match_1",
  "constType":
  "∀ {α : Type u_1} {s : Set α} (motive : Set.Finite s → Prop) (x : Set.Finite s),\n  (∀ (h : Fintype ↑s), motive (_ : Set.Finite s)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalNonAssocRing",
   "InvolutiveNeg.toNeg",
   "Neg.neg",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubtractionMonoid.toInvolutiveNeg",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a : α), - -a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Iff", "RelIso", "FunLike.coe", "Equiv.instFunLikeEquiv"],
  "name": "RelIso.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (toEquiv : α ≃ β) → (∀ {a b : α}, s (toEquiv a) (toEquiv b) ↔ r a b) → r ≃r s",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible",
   "Eq"],
  "name": "Invertible.mk",
  "constType":
  "{α : Type u} → [inst : Mul α] → [inst_1 : One α] → {a : α} → (invOf : α) → invOf * a = 1 → a * invOf = 1 → Invertible a",
  "constCategory": "Other"},
 {"references": ["Bot", "LE", "OrderBot"],
  "name": "OrderBot.toBot",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderBot α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat"],
  "name": "rdist.proof_1",
  "constType": "Nat.AtLeastTwo (0 + 2)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Field.toNontrivial",
   "EuclideanDomain.mk",
   "Semifield.toCommGroupWithZero",
   "Field.toEuclideanDomain.proof_3",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Field.toEuclideanDomain.proof_4",
   "Field",
   "Ring.toSub",
   "Field.toEuclideanDomain.proof_1",
   "HDiv.hDiv",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "HSub.hSub",
   "Field.toSemifield",
   "CommGroupWithZero.toCommMonoidWithZero",
   "instHMul",
   "And",
   "Field.toEuclideanDomain.proof_2",
   "HMul.hMul",
   "Field.toDiv",
   "EuclideanDomain",
   "Field.toDivisionRing",
   "Field.toEuclideanDomain.proof_5"],
  "name": "Field.toEuclideanDomain",
  "constType": "{K : Type u_1} → [inst : Field K] → EuclideanDomain K",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "CommSemiring",
   "AddMonoid.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "le_antisymm",
   "mt",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "lt_of_le_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["Int.lt", "LT", "LT.mk", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.val",
   "Finite.of_injective",
   "Finite",
   "Subtype.coe_injective",
   "Subtype"],
  "name": "Subtype.finite",
  "constType":
  "∀ {α : Sort u_4} [inst : Finite α] {p : α → Prop}, Finite { x // p x }",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "Mul",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocRing α",
  "constCategory": "Other"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Iff",
   "RelEmbedding",
   "Function.Embedding",
   "FunLike.coe"],
  "name": "RelEmbedding.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} → (toEmbedding : α ↪ β) → (∀ {a b : α}, s (toEmbedding a) (toEmbedding b) ↔ r a b) → r ↪r s",
  "constCategory": "Other"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : ContravariantClass M N μ r],\n  Contravariant M N μ r",
  "constCategory": "Definition"},
 {"references": ["IsTrans", "IsTrans.trans"],
  "name": "trans",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoidHomClass.toZeroHomClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Iff.mp",
   "ZeroHomClass.toFunLike",
   "add_neg_eq_zero",
   "add_neg_self",
   "AddMonoid.toZero",
   "map_zero",
   "Eq.symm",
   "AddZeroClass",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "AddHomClass.toFunLike",
   "instHAdd",
   "Neg.neg",
   "map_add",
   "FunLike.coe",
   "AddMonoidHomClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.intro",
   "Eq.ndrec",
   "Function.Injective",
   "map_eq_zero_iff",
   "SubNegMonoid.toAddMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "injective_iff_map_eq_zero",
  "constType":
  "∀ {F : Type u_8} {G : Type u_9} {H : Type u_10} [inst : AddGroup G] [inst_1 : AddZeroClass H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F), Function.Injective ⇑f ↔ ∀ (a : G), f a = 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "Subsemigroup.carrier",
   "Submonoid.mk",
   "MulOneClass.toMul",
   "Submonoid.instTopSubmonoid",
   "Submonoid.one_mem'",
   "Top.top",
   "Set",
   "Set.univ",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid.toSubsemigroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "Set.mem_univ",
   "Inv.inv"],
  "name": "Subgroup.instTopSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {x : G},\n  x ∈ { toSubsemigroup := ⊤.toSubsemigroup, one_mem' := (_ : 1 ∈ ⊤.carrier) }.toSubsemigroup.carrier → x⁻¹ ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.mk",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → (α → β) → Singleton α β",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "Complex.abs",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "CauSeq.lim",
   "Real",
   "AbsoluteValue",
   "Complex.exp'",
   "Complex.instIsComplete",
   "Eq.refl",
   "Complex.instRingComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "Complex.exp.proof_1",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "OrderedSemiring.toPartialOrder",
   "Complex.exp"],
  "name": "_private.Mathlib.Data.Complex.Exponential.0.Complex.exp._eq_1",
  "constType": "∀ (z : ℂ), Complex.exp z = CauSeq.lim (Complex.exp' z)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedRing",
   "AddGroup.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "OrderedRing.toRing",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "OrderedRing.mul_nonneg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "OrderedRing.toOrderedAddCommGroup",
   "sub_mul",
   "HSub.hSub",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.2",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "sub_nonneg",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "OrderedRing.toPartialOrder",
   "instHMul",
   "Eq.mp",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedRing.toOrderedSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedRing α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["List.finRange.proof_1",
   "List.pmap",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "List.range"],
  "name": "List.finRange",
  "constType": "(n : ℕ) → List (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Top",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddGroup",
   "Top.top",
   "AddSubgroup.instTopAddSubgroup.proof_2",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.instTopAddSubgroup.proof_1",
   "AddSubmonoid.mk",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Top.mk"],
  "name": "AddSubgroup.instTopAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Top (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["ZeroMemClass",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddSubmonoidClass",
   "SetLike",
   "AddZeroClass",
   "AddMemClass"],
  "name": "AddSubmonoidClass.mk",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : AddZeroClass M] [inst_1 : SetLike S M] [toAddMemClass : AddMemClass S M]\n  [toZeroMemClass : ZeroMemClass S M], AddSubmonoidClass S M",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Monoid.toMulAction.proof_2",
   "MulOneClass.toMul",
   "SMul.mk",
   "Monoid",
   "MulAction.mk",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulAction.proof_1",
   "Monoid.toMulOneClass"],
  "name": "Monoid.toMulAction",
  "constType": "(M : Type u_1) → [inst : Monoid M] → MulAction M M",
  "constCategory": "Definition"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_trans", "Preorder"],
  "name": "LT.lt.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedSemiring.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "DivisionRing",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "DivisionRing.toRing",
   "div_eq_mul_inv",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "DivisionRing.toInv",
   "Ring.toNonAssocRing",
   "DivInvMonoid.toInv",
   "Eq",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "HMul.hMul",
   "HDiv.hDiv",
   "congrArg",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "DivisionRing.toDiv",
   "congrFun",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "Mathlib.Tactic.Ring.div_pf",
  "constType":
  "∀ {R : Type u_1} [inst : DivisionRing R] {a b c d : R}, b⁻¹ = c → a * c = d → a / b = d",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "Norm",
   "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1438",
   "PseudoMetricSpace.toDist",
   "Real",
   "HSub.hSub",
   "SeminormedAddCommGroup",
   "AddCommGroup.toAddGroup",
   "Norm.norm",
   "AddCommGroup",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "PseudoMetricSpace",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedAddCommGroup.mk",
  "constType":
  "{E : Type u_9} →\n  [toNorm : Norm E] →\n    [toAddCommGroup : AddCommGroup E] →\n      [toPseudoMetricSpace : PseudoMetricSpace E] →\n        autoParam (∀ (x y : E), dist x y = ‖x - y‖) _auto✝ → SeminormedAddCommGroup E",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.add_zero",
  "constType": "∀ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SeminormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_17",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.nsmul_succ",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (n : ℕ) (x : α),\n  AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references":
  ["Sup", "_private.Mathlib.Data.Real.Basic.0.Real.sup", "Real", "Sup.mk"],
  "name": "Real.instSupReal",
  "constType": "Sup ℝ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedSemiring", "Ord"],
  "name": "LinearOrderedSemiring.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "ZeroHom", "Eq"],
  "name": "ZeroHom.mk",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → (toFun : M → N) → toFun 0 = 0 → ZeroHom M N",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Equivalence.mk",
   "Equiv.refl",
   "Equivalence",
   "Equiv.trans",
   "Nonempty",
   "Equiv.symm",
   "Cardinal.isEquivalent.match_1"],
  "name": "Cardinal.isEquivalent.proof_1",
  "constType": "Equivalence fun α β => Nonempty (α ≃ β)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "HMul.hMul",
   "MulZeroOneClass",
   "Eq"],
  "name": "MulZeroOneClass.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "constCategory": "Other"},
 {"references":
  ["Set.addMonoid.proof_1",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "Eq.refl",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq",
   "Set.addSemigroup",
   "zsmulRec",
   "AddZeroClass.toZero",
   "Int.negSucc",
   "SubtractionMonoid.toSubNegMonoid",
   "InvolutiveNeg.toNeg",
   "SubNegMonoid.toAddMonoid",
   "Nat",
   "Set.addZeroClass"],
  "name": "Set.subtractionMonoid.proof_9",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (n : ℕ) (a : Set α),\n  zsmulRec (Int.negSucc n) a = zsmulRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "Distrib.rightDistribClass",
   "npowRec",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Semiring.toNatCast",
   "Real.instOneReal",
   "mul_assoc",
   "Nat.cast",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Real.cauchy_one",
   "instHSub",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "add_left_neg",
   "Rat.field",
   "Real.ofCauchy",
   "Nat.cast_add",
   "CauSeq.Completion.instZeroCauchy",
   "NatCast.natCast",
   "CauSeq.Completion.Cauchy.ring",
   "AddMonoidWithOne.toOne",
   "congr",
   "Ring.mk",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "congrFun",
   "Mul.mk",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "instOfNatInt",
   "Real",
   "Eq.refl",
   "CauSeq.Completion.instNatCastCauchy",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.mk",
   "True",
   "Abs.abs",
   "Rat.instSupRat",
   "zero_add",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "CauSeq.Completion.instMulCauchy",
   "Nat.succ",
   "CauSeq.Completion.Cauchy.field",
   "Neg.toHasAbs",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "Real.cauchy_add",
   "One.mk",
   "Field.toSemifield",
   "One.toOfNat1",
   "Neg.neg",
   "Distrib.leftDistribClass",
   "instNatCastInt",
   "Rat.divisionRing",
   "Ring.toAddCommGroup",
   "CauSeq.Completion.Cauchy.commRing",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy",
   "Semiring.mk",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instMulReal",
   "Real.instSubReal",
   "nsmulRec",
   "MulZeroClass.mul_zero",
   "Eq",
   "zsmulRec",
   "Real.cauchy_zero",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "Sub.sub",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "Add.mk",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "IntCast.mk",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Int.negSucc",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "mul_one",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "IntCast.intCast",
   "Neg.mk",
   "Int.ofNat",
   "CauSeq.Completion.instIntCastCauchy",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "CauSeq.Completion.instNegCauchy",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CauSeq.Completion.instOneCauchy",
   "NatCast.mk",
   "Real.instNegReal",
   "Sub.mk",
   "mul_comm",
   "Zero.toOfNat0",
   "Rat.commRing",
   "one_mul",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.cast_negSucc",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_neg",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "SubtractionMonoid.toSubNegMonoid",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "neg_add_rev"],
  "name": "Real.commRing.proof_25",
  "constType": "∀ (a b : ℝ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Real.log",
   "Real.instMulReal",
   "Real",
   "HMul.hMul",
   "Neg.neg",
   "Real.instNegReal"],
  "name": "Real.negMulLog",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.128",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Finset.Nonempty",
   "Or",
   "Finset.instEmptyCollectionFinset",
   "Or.inl",
   "EmptyCollection.emptyCollection",
   "Or.inr",
   "Finset.nonempty_of_ne_empty",
   "Finset",
   "Not",
   "by_cases",
   "Eq"],
  "name": "Finset.eq_empty_or_nonempty",
  "constType": "∀ {α : Type u_1} (s : Finset α), s = ∅ ∨ Finset.Nonempty s",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["OrderedCommRing", "OrderedRing"],
  "name": "OrderedCommRing.toOrderedRing",
  "constType": "{α : Type u} → [self : OrderedCommRing α] → OrderedRing α",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass"],
  "name": "AddMonoidHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references":
  ["map_natCast'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MulOneClass.toOne",
   "map_one",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "RingHomClass.toAddMonoidHomClass",
   "Nat.cast",
   "RingHomClass.toMonoidHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MonoidHomClass.toOneHomClass",
   "NonAssocSemiring.toNatCast",
   "Nat"],
  "name": "map_natCast",
  "constType":
  "∀ {R : Type u_3} {S : Type u_4} {F : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S]\n  [inst_2 : RingHomClass F R S] (f : F) (n : ℕ), f ↑n = ↑n",
  "constCategory": "Theorem"},
 {"references": ["Nonempty.intro", "Fintype", "Nonempty", "Nonempty.casesOn"],
  "name": "finite_iff_nonempty_fintype.match_2",
  "constType":
  "∀ (α : Type u_1) (motive : Nonempty (Fintype α) → Prop) (x : Nonempty (Fintype α)),\n  (∀ (val : Fintype α), motive (_ : Nonempty (Fintype α))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "LT.lt", "Nat", "LE.le", "Nat.le_of_succ_le", "instLTNat"],
  "name": "Nat.le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "Semifield.toCommGroupWithZero",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "Iff",
   "Preorder.toLT",
   "Eq.rec",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "One.toOfNat1",
   "GroupWithZero.toDivInvMonoid",
   "CommGroupWithZero.toCommMonoidWithZero",
   "DivInvMonoid.toMonoid",
   "StrictOrderedSemiring.toSemiring",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "inv_eq_one_div",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "Semifield.toDivisionSemiring",
   "inv_pos",
   "Inv.inv"],
  "name": "one_div_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 < 1 / a ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.ext",
   "Set.image2",
   "DecidableEq",
   "Set",
   "Finset.toSet",
   "Finset.image₂",
   "Finset",
   "Finset.mem_image₂",
   "Eq"],
  "name": "Finset.coe_image₂",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] (f : α → β → γ) (s : Finset α) (t : Finset β),\n  ↑(Finset.image₂ f s t) = Set.image2 f ↑s ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Real.mk_le",
   "Rat",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Rat.divisionRing",
   "propext",
   "Real.mk",
   "Rat.instNegRat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.8",
  "constType": "∀ {f g : CauSeq ℚ abs}, (Real.mk f ≤ Real.mk g) = (f ≤ g)",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass",
   "AddZeroClass.toZero",
   "AddSubmonoidClass",
   "SetLike",
   "AddZeroClass"],
  "name": "AddSubmonoidClass.toZeroMemClass",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : AddZeroClass M] [inst_1 : SetLike S M] [self : AddSubmonoidClass S M],\n  ZeroMemClass S M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass",
   "Set.preimage",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "Additive.ofMul",
   "Additive.addZeroClass",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.carrier",
   "Additive",
   "SetLike.coe"],
  "name": "Submonoid.toAddSubmonoid.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : AddSubmonoid (Additive M)) {a b : M},\n  a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "inferInstance",
   "Real.instLinearOrderedRingReal",
   "Real",
   "LinearOrderedRing.toLinearOrderedAddCommGroup"],
  "name": "Real.instLinearOrderedAddCommGroupReal",
  "constType": "LinearOrderedAddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Inv",
   "Inv.inv"],
  "name": "DivInvMonoid.div'",
  "constType": "{G : Type u} → [inst : Monoid G] → [inst : Inv G] → G → G → G",
  "constCategory": "Definition"},
 {"references": ["MeasureTheory.Measure", "MeasurableSpace"],
  "name": "MeasureTheory.SFinite",
  "constType":
  "{α : Type u_1} → {m0 : MeasurableSpace α} → MeasureTheory.Measure α → Prop",
  "constCategory": "Other"},
 {"references": ["WithTop", "Option.some"],
  "name": "WithTop.some",
  "constType": "{α : Type u_1} → α → WithTop α",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableAnd.proof_2",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "And.intro",
   "instDecidableAnd.proof_1"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv"],
  "name": "DivInvMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toMonoid : Monoid G] →\n    [toInv : Inv G] →\n      [toDiv : Div G] →\n        autoParam (∀ (a b : G), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G → G) →\n            autoParam (∀ (a : G), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  DivInvMonoid G",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "eq_self",
   "Set",
   "Set.image_singleton",
   "True",
   "Eq",
   "Set.instSingletonSet",
   "of_eq_true",
   "Prod.mk",
   "SProd.sprod",
   "Set.prod_singleton",
   "Prod",
   "Singleton.singleton",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.singleton_prod_singleton",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {a : α} {b : β}, {a} ×ˢ {b} = {(a, b)}",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name":
  "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α], IsAbsoluteValue abs",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.RightInverse",
   "EquivLike.coe_injective'",
   "Eq.rec",
   "Function.LeftInverse.eq_rightInverse",
   "EquivLike.right_inv",
   "Eq.symm",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Eq"],
  "name": "EquivLike.toEmbeddingLike.proof_1",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → e = g",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Complex.commRing",
   "CommSemiring",
   "Complex"],
  "name": "Complex.instCommSemiringComplex",
  "constType": "CommSemiring ℂ",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Filter.instCompleteLatticeFilter.proof_10",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Filter.instCompleteLatticeFilter.proof_11",
   "Filter.instCompleteLatticeFilter.proof_2",
   "Inf.inf",
   "Set",
   "Filter.instCompleteLatticeFilter.proof_4",
   "CompleteLattice.mk",
   "SupSet.mk",
   "Filter.generate",
   "CompleteLattice.toBot",
   "Lattice.mk",
   "Filter.join",
   "Filter.instCompleteLatticeFilter.proof_7",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "Filter.principal",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "Filter.instTopFilter",
   "Preorder.toLT",
   "Filter",
   "Lattice.toSemilatticeSup",
   "Filter.mem_inf_of_right",
   "Filter.instCompleteLatticeFilter.proof_5",
   "GaloisInsertion.liftCompleteLattice",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Filter.instCompleteLatticeFilter.proof_12",
   "Membership.mem",
   "Filter.sets",
   "CompletelyDistribLattice.toCompleteLattice",
   "OrderDual.instPartialOrder",
   "Filter.instCompleteLatticeFilter.proof_8",
   "Top.top",
   "Function.comp",
   "SemilatticeSup.mk",
   "Filter.instCompleteLatticeFilter.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "SupSet.sSup",
   "LE.le",
   "Set.instMembershipSet",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Preorder.mk",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "OrderDual.completeLattice",
   "Filter.instInfFilter",
   "Filter.instPartialOrderFilter",
   "OrderDual",
   "Filter.giGenerate",
   "Filter.instCompleteLatticeFilter.proof_9",
   "Filter.instCompleteLatticeFilter.proof_1",
   "Filter.instCompleteLatticeFilter.proof_6",
   "Top.mk",
   "Filter.mem_inf_of_left"],
  "name": "Filter.instCompleteLatticeFilter",
  "constType": "{α : Type u} → CompleteLattice (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.mk",
  "constType":
  "{R : Type u_1} → [toAddMonoidWithOne : AddMonoidWithOne R] → (∀ (a b : R), a + b = b + a) → AddCommMonoidWithOne R",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "propext",
   "Set",
   "Set.mem_image2",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.NAry._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {c : γ},\n  (c ∈ Set.image2 f s t) = ∃ a b, a ∈ s ∧ b ∈ t ∧ f a b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "AddSubmonoid",
   "AddSubsemigroup.carrier",
   "AddZeroClass",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubmonoid.mk",
  "constType":
  "{M : Type u_4} →\n  [inst : AddZeroClass M] → (toAddSubsemigroup : AddSubsemigroup M) → 0 ∈ toAddSubsemigroup.carrier → AddSubmonoid M",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompleteAtomicBooleanAlgebra",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nontrivial.exists_pair_ne",
   "Nontrivial",
   "Nontrivial.mk",
   "Int.instNontrivialInt",
   "Int"],
  "name": "Int.linearOrderedCommRing.proof_1",
  "constType": "Nontrivial ℤ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "sub_self",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "GE.ge",
   "AddGroup.toSubtractionMonoid",
   "Semifield.toCommGroupWithZero",
   "Exists.intro",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Eq.mpr",
   "instLENat",
   "Preorder.toLT",
   "Ring",
   "Ring.toSub",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "IsAbsoluteValue.abv_zero",
   "GT.gt",
   "Std.Classes.Order._auxLemma.4",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "Eq.mp",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "CauSeq.const.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Ring β] (abv : β → α)\n  [inst_2 : IsAbsoluteValue abv] (x : β), ∀ ε > 0, ∃ i, ∀ j ≥ i, abv ((fun x_1 => x) j - (fun x_1 => x) i) < ε",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.OuterMeasure.dirac.proof_1",
   "ENNReal",
   "OfNat.ofNat",
   "MeasureTheory.OuterMeasure.dirac.proof_3",
   "MeasureTheory.OuterMeasure.mk",
   "Set",
   "MeasureTheory.OuterMeasure.dirac.proof_2",
   "One.toOfNat1",
   "MeasureTheory.OuterMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "instENNRealZero",
   "Set.indicator"],
  "name": "MeasureTheory.OuterMeasure.dirac",
  "constType": "{α : Type u_1} → α → MeasureTheory.OuterMeasure α",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Int"],
  "name": "DivInvMonoid.zpow",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "SemilatticeSup.toSup",
   "Sup",
   "Rat",
   "Rat.instSemilatticeSupRat"],
  "name": "Rat.instSupRat",
  "constType": "Sup ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "abs_pos",
   "Real",
   "Real.instLEReal",
   "Set",
   "Real.log_of_ne_zero",
   "Real.coe_expOrderIso_apply",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Subtype.coe_mk",
   "Set.Ioi",
   "Abs.abs",
   "Iff.mpr",
   "Real.instNegReal",
   "Eq",
   "Real.expOrderIso",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "RelIso.instRelHomClassRelIso",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Preorder.toLT",
   "RelIso",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "Membership.mem",
   "Ne",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Subtype.le",
   "OrderIso.apply_symm_apply",
   "Real.exp",
   "LE.le",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "Real.log",
   "Eq.ndrec",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Subtype.mk",
   "OrderIso.symm"],
  "name": "Real.exp_log_eq_abs",
  "constType": "∀ {x : ℝ}, x ≠ 0 → Real.exp (Real.log x) = |x|",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "map_add",
   "Exists.intro",
   "AddMonoidHomClass",
   "FunLike.coe",
   "Exists.casesOn",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.add_mem",
   "And.intro",
   "AddMonoidHomClass.toAddHomClass",
   "Set.image",
   "And.casesOn",
   "AddZeroClass",
   "id",
   "SetLike.coe"],
  "name": "AddSubmonoid.map.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (S : AddSubmonoid M) {a b : N}, a ∈ ⇑f '' ↑S → b ∈ ⇑f '' ↑S → a + b ∈ ⇑f '' ↑S",
  "constCategory": "Theorem"},
 {"references": ["inferInstance", "Classical.propDecidable", "Decidable"],
  "name": "Classical.dec",
  "constType": "(p : Prop) → Decidable p",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "ULift.down_up",
   "ULift.up",
   "ULift.down",
   "Equiv.mk",
   "ULift.up_down",
   "ULift"],
  "name": "Equiv.ulift",
  "constType": "{α : Type v} → ULift.{u, v} α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set.image2",
   "EmptyCollection.emptyCollection",
   "False",
   "false_and",
   "Set",
   "implies_true",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Set.ext",
   "And",
   "Std.Logic._auxLemma.31",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "congr",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image2_empty_left",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {t : Set β}, Set.image2 f ∅ t = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "HPow.hPow",
   "InvOneClass.toOne",
   "Exists",
   "OfNat.ofNat",
   "DivInvOneMonoid.toInvOneClass",
   "instHPow",
   "Nat.monoid",
   "Monoid.toNatPow",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "Nat",
   "DivisionMonoid.toDivInvOneMonoid",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "IsPGroup",
  "constType": "ℕ → (G : Type u_1) → [inst : Group G] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "SMul",
   "OfNat.ofNat",
   "instHSMul",
   "AddSemigroup.mk",
   "Function.Injective.addZeroClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddMonoid.toAddZeroClass",
   "AddSemigroup",
   "AddMonoid.mk",
   "AddMonoid",
   "Eq",
   "AddMonoid.toNatSMul",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Function.Injective.addMonoid.proof_1",
   "AddZeroClass.add_zero",
   "AddSemigroup.add_assoc",
   "Function.Injective",
   "AddMonoid.toAddSemigroup",
   "Function.Injective.addSemigroup",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Add",
   "Nat",
   "Function.Injective.addMonoid.proof_2",
   "AddZeroClass"],
  "name": "Function.Injective.addMonoid",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : AddMonoid M₂] →\n            (f : M₁ → M₂) →\n              Function.Injective f →\n                f 0 = 0 →\n                  (∀ (x y : M₁), f (x + y) = f x + f y) → (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) → AddMonoid M₁",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.definition._@.Mathlib.MeasureTheory.Constructions.Prod.Basic._hyg.2696",
   "Prod",
   "MeasurableSpace",
   "Subtype",
   "Eq",
   "Prod.instMeasurableSpace"],
  "name":
  "MeasureTheory.Measure.wrapped._@.Mathlib.MeasureTheory.Constructions.Prod.Basic._hyg.2696",
  "constType": "Subtype (Eq @MeasureTheory.Measure.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "CauSeq.LimZero",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.Completion.instZeroCauchy",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "CauSeq.Completion.mk_eq_zero",
   "propext",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Mathlib.Data.Real.CauSeqCompletion._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {f : CauSeq β abv}, (CauSeq.Completion.mk f = 0) = CauSeq.LimZero f",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedCommRing",
   "StrictOrderedCommSemiring.mk",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_2",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_1",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "Ring.toSemiring",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_3",
   "StrictOrderedCommRing.mul_comm",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedCommRing.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommRing α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "FunLike.coe",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "PartialOrder"],
  "name": "OmegaCompletePartialOrder.mk",
  "constType":
  "{α : Type u_1} →\n  [toPartialOrder : PartialOrder α] →\n    (ωSup : OmegaCompletePartialOrder.Chain α → α) →\n      (∀ (c : OmegaCompletePartialOrder.Chain α) (i : ℕ), c i ≤ ωSup c) →\n        (∀ (c : OmegaCompletePartialOrder.Chain α) (x : α), (∀ (i : ℕ), c i ≤ x) → ωSup c ≤ x) →\n          OmegaCompletePartialOrder α",
  "constCategory": "Other"},
 {"references":
  ["AddGroupWithOne.mk",
   "AddCommGroupWithOne.toIntCast",
   "AddCommGroupWithOne.natCast_succ",
   "SubNegMonoid.toNeg",
   "AddCommGroupWithOne.toAddCommGroup",
   "SubNegMonoid.zsmul_neg'",
   "AddCommGroupWithOne",
   "AddCommGroupWithOne.intCast_ofNat",
   "AddCommGroupWithOne.toNatCast",
   "SubNegMonoid.sub_eq_add_neg",
   "AddCommGroupWithOne.toOne",
   "AddGroup.toSubNegMonoid",
   "AddGroup.add_left_neg",
   "SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "AddCommGroupWithOne.intCast_negSucc",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddGroupWithOne",
   "AddCommGroup.toAddGroup",
   "AddCommGroupWithOne.natCast_zero",
   "AddMonoidWithOne.mk",
   "SubNegMonoid.zsmul_zero'"],
  "name": "AddCommGroupWithOne.toAddGroupWithOne",
  "constType":
  "{R : Type u} → [self : AddCommGroupWithOne R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": ["Div", "Semifield"],
  "name": "Semifield.toDiv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommRing",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_2} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "LinearOrderedRing.toStrictOrderedRing",
   "HEq",
   "Eq.refl",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Decidable.decide",
   "Nat.cast",
   "LinearOrderedRing",
   "Bool.true",
   "Ring.toIntCast",
   "Nat",
   "Eq.symm",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Int.decLt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Int.instLTInt",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "HEq.refl",
   "instNatCastInt",
   "Int.cast",
   "LT.lt",
   "HMul.hMul",
   "Bool",
   "Eq.casesOn",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isRat_lt_true.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α]\n  (motive :\n    (x x_1 : α) →\n      (x_2 x_3 : ℤ) →\n        (x_4 x_5 : ℕ) →\n          Mathlib.Meta.NormNum.IsRat x x_2 x_4 →\n            Mathlib.Meta.NormNum.IsRat x_1 x_3 x_5 → decide (x_2 * ↑x_5 < x_3 * ↑x_4) = true → Prop)\n  (x x_1 : α) (x_2 x_3 : ℤ) (x_4 x_5 : ℕ) (x_6 : Mathlib.Meta.NormNum.IsRat x x_2 x_4)\n  (x_7 : Mathlib.Meta.NormNum.IsRat x_1 x_3 x_5) (x_8 : decide (x_2 * ↑x_5 < x_3 * ↑x_4) = true),\n  (∀ (num num_1 : ℤ) (da db : ℕ) (inv : Invertible ↑da) (inv_1 : Invertible ↑db)\n      (h : decide (num * ↑db < num_1 * ↑da) = true),\n      motive (↑num * ⅟↑da) (↑num_1 * ⅟↑db) num num_1 da db (_ : Mathlib.Meta.NormNum.IsRat (↑num * ⅟↑da) num da)\n        (_ : Mathlib.Meta.NormNum.IsRat (↑num_1 * ⅟↑db) num_1 db) h) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Complex.exp_ne_zero",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "Complex",
   "Complex.exp",
   "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Complex._auxLemma.1",
  "constType": "∀ (x : ℂ), (Complex.exp x = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.14",
  "constType": "∀ {α : Type u} (x : α), (x ∈ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references": ["PProd"],
  "name": "PProd.fst",
  "constType": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "prod",
   "MeasureTheory.Measure.map",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real.instMulReal",
   "ProbabilityTheory.entropy",
   "ProbabilityTheory.finiteSupport_of_prod",
   "MeasureTheory.Measure.prod.instIsFiniteMeasure",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.Measure.prod",
   "Iff.mpr",
   "Eq",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Iff",
   "FiniteRange",
   "Measurable.aemeasurable",
   "ProbabilityTheory.mutualInfo",
   "Set.image",
   "Eq.trans",
   "measurable_snd",
   "ProbabilityTheory.finiteSupport_of_finiteRange",
   "Set.instSProd",
   "instHSub",
   "pi_congr",
   "Prod.snd",
   "Function.comp",
   "eq_of_heq",
   "Prod.fst",
   "MeasureTheory.Measure.real",
   "ProbabilityTheory.measureMutualInfo_eq_zero_iff",
   "Prod.instMeasurableSpace",
   "instHMul",
   "of_eq_true",
   "HEq.refl",
   "propext",
   "instFiniteRangeProdProd",
   "Set.prod_singleton",
   "Singleton.singleton",
   "iff_of_eq",
   "Prod.instMeasurableSingletonClass",
   "congrArg",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun",
   "HEq",
   "MeasureTheory.isProbabilityMeasure_map",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "measurable_fst",
   "Set",
   "Eq.refl",
   "True",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "outParam",
   "Set.instSingletonSet",
   "SProd.sprod",
   "Eq.rec",
   "ProbabilityTheory.Measure.ext_iff_measureReal_singleton_finiteSupport",
   "MeasureTheory.Measure.map_map",
   "Measurable",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "id",
   "eq_self",
   "ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map",
   "instHAdd",
   "MeasureTheory.measureReal_prod_prod",
   "HSub.hSub",
   "Set.image_singleton",
   "ProbabilityTheory.measureEntropy",
   "ProbabilityTheory.measureMutualInfo",
   "Prod.mk.eta",
   "Real.instZeroReal",
   "Measurable.prod_mk",
   "Eq.ndrec",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "Prod.mk",
   "letFun",
   "HMul.hMul",
   "Prod",
   "Eq.casesOn",
   "HMul"],
  "name": "ProbabilityTheory.IndepFun.mutualInfo_eq_zero",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSpace T] [inst_2 : MeasurableSingletonClass S] [inst_3 : MeasurableSingletonClass T] {X : Ω → S}\n  {Y : Ω → T},\n  Measurable X →\n    Measurable Y →\n      ∀ {μ : MeasureTheory.Measure Ω} [inst_4 : MeasureTheory.IsProbabilityMeasure μ] [inst_5 : FiniteRange X]\n        [inst_6 : FiniteRange Y], ProbabilityTheory.IndepFun X Y → I[X : Y ; μ] = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Fintype.ofBijective",
   "Fintype",
   "Equiv.bijective",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Fintype.ofEquiv",
  "constType":
  "{β : Type u_2} → (α : Type u_4) → [inst : Fintype α] → α ≃ β → Fintype β",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.ofCauchy",
  "constType": "CauSeq.Completion.Cauchy abs → ℝ",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_eq_left", "Eq"],
  "name": "Std.Logic._auxLemma.37",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderedRing.zero_le_one",
  "constType": "∀ {α : Type u} [self : OrderedRing α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.mk_le",
   "Real",
   "Real.instLEReal",
   "Rat",
   "Eq.refl",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.ndrec",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "le_refl",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_1",
  "constType": "∀ (a : ℝ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Eq",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "congr",
   "CauSeq.Completion.Cauchy",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocSemiring.mk",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Real.cauchy_mul",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "Real.cauchy_add",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_11",
  "constType": "∀ (a b c : ℝ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubsemigroup.instSetLikeSubsemigroup",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Eq.refl",
   "SetLike.coe_injective'",
   "AddSubmonoid",
   "Eq",
   "AddSubsemigroup",
   "Set.instMembershipSet",
   "AddSubmonoid.casesOn",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "Eq.rec",
   "AddSubmonoid.mk",
   "Eq.symm",
   "AddZeroClass",
   "AddSubsemigroup.carrier"],
  "name": "AddSubmonoid.instSetLikeAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (p q : AddSubmonoid M), (fun s => s.carrier) p = (fun s => s.carrier) q → p = q",
  "constCategory": "Theorem"},
 {"references": ["PreOpposite.op'", "AddOpposite"],
  "name": "AddOpposite.op",
  "constType": "{α : Type u_1} → α → αᵃᵒᵖ",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Not", "mt", "Iff.mpr"],
  "name": "not_congr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Filter.EventuallyEq",
   "Measurable",
   "And.intro",
   "Exists.intro",
   "MeasureTheory.ae_eq_refl",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace",
   "AEMeasurable"],
  "name": "Measurable.aemeasurable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [inst : MeasurableSpace β] {f : α → β}\n  {μ : MeasureTheory.Measure α}, Measurable f → AEMeasurable f",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "Max.max",
   "LinearOrderedRing.toMax",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Covariant",
   "Iff.mp",
   "AddGroup",
   "Contravariant",
   "AddGroup.covariant_iff_contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "CovariantClass.elim"],
  "name": "AddGroup.covconv",
  "constType":
  "∀ {N : Type u_2} {r : N → N → Prop} [inst : AddGroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  ContravariantClass N N (fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "iSup",
   "LE.le",
   "isLUB_le_iff",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "Set.range",
   "upperBounds",
   "Iff",
   "CompleteLattice",
   "Iff.trans",
   "Set.forall_range_iff",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet",
   "isLUB_iSup"],
  "name": "iSup_le_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, iSup f ≤ a ↔ ∀ (i : ι), f i ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.mk",
  "constType": "∀ {α : Type u_3}, (∃ x y, x ≠ y) → Nontrivial α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toCommRing",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Field.toSemifield.proof_1",
  "constType": "∀ {K : Type u_1} [inst : Field K] (a b : K), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Subtype.val",
   "Real",
   "Set",
   "Real.instLEReal",
   "FunLike.coe",
   "Subtype.le",
   "Set.Ioi",
   "Real.exp",
   "rfl",
   "LE.le",
   "Eq",
   "Real.expOrderIso",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "RelIso.instRelHomClassRelIso",
   "Set.Elem",
   "Real.instPreorderReal",
   "RelIso"],
  "name": "Real.coe_expOrderIso_apply",
  "constType": "∀ (x : ℝ), ↑(Real.expOrderIso x) = Real.exp x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "DecidableEq",
   "Finset.toSet",
   "Set",
   "Finset.coe_image₂",
   "HSub.hSub",
   "Finset",
   "Set.sub",
   "Sub",
   "Finset.sub",
   "Eq"],
  "name": "Finset.coe_sub",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Sub α] (s t : Finset α), ↑(s - t) = ↑s - ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.le_of_lt_succ",
  "constType": "∀ {m n : ℕ}, m < Nat.succ n → m ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddLeftCancelSemigroup.add_left_cancel",
  "constType":
  "∀ {G : Type u} [self : AddLeftCancelSemigroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "Rat.cast",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedField.qsmul",
   "Rat",
   "HMul.hMul",
   "LinearOrderedField.toRatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.qsmul_eq_mul'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : ℚ) (x : α), LinearOrderedField.qsmul a x = ↑a * x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "completeLatticeOfInf",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "SetLike.instPartialOrder",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Submonoid",
   "Not",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_4",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b : Submonoid M), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "LT.lt.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "instDistribLattice",
   "AddGroup.toSubtractionMonoid",
   "SemilatticeInf.toPartialOrder",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Abs.abs",
   "abs_of_nonneg",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "AddGroup",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_of_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 < a → |a| = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.attach.proof_1",
   "Multiset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Finset.mk",
   "Subtype"],
  "name": "Finset.attach",
  "constType": "{α : Type u_1} → (s : Finset α) → Finset { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalCommRing.mk",
  "constType":
  "{α : Type u} → [toNonUnitalRing : NonUnitalRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalCommRing α",
  "constCategory": "Other"},
 {"references": ["CompleteLattice", "InfSet"],
  "name": "CompleteLattice.toInfSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → InfSet α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Rat",
   "Rat.instDistribLatticeRat",
   "Lattice"],
  "name": "Rat.instLatticeRat",
  "constType": "Lattice ℚ",
  "constCategory": "Definition"},
 {"references":
  ["le_self_add",
   "AddZeroClass.toAdd",
   "Exists",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "LE.le",
   "ExistsAddOfLE.exists_add_of_le",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Iff",
   "Eq.ndrec",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "le_iff_exists_add",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b ↔ ∃ c, b = a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.empty_subset",
   "Finset.instEmptyCollectionFinset",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "Finset",
   "Bot.mk",
   "Finset.partialOrder",
   "OrderBot",
   "OrderBot.mk",
   "Preorder.toLE"],
  "name": "Finset.instOrderBotFinsetToLEToPreorderPartialOrder",
  "constType": "{α : Type u_1} → OrderBot (Finset α)",
  "constCategory": "Definition"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.577"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.zero",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LE.le",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.le_total",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedAddCommMonoid α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Eq",
   "Zero.toOfNat0",
   "Function.swap",
   "SubNegMonoid.toSub",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "LE",
   "add_le_add_iff_right",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_nonneg",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a - b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "MulEquiv",
  "constType":
  "(M : Type u_12) → (N : Type u_13) → [inst : Mul M] → [inst : Mul N] → Type (max u_12 u_13)",
  "constCategory": "Other"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "Iff",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "OrderDual",
   "OrderDual.semilatticeSup",
   "LE.le",
   "sup_le_iff",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "le_inf_iff",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b ⊓ c ↔ a ≤ b ∧ a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Monoid",
   "Real.instMonoidWithZeroReal",
   "MonoidWithZero.toMonoid",
   "Real"],
  "name": "Real.instMonoidReal",
  "constType": "Monoid ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.140",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Countable",
   "MeasurableSingletonClass",
   "SetCoe.countable",
   "DiscreteMeasurableSpace",
   "Set",
   "DiscreteMeasurableSpace.mk",
   "Set.Countable.measurableSet",
   "Set.to_countable",
   "MeasurableSpace"],
  "name": "MeasurableSingletonClass.toDiscreteMeasurableSpace",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] [inst_2 : Countable α],\n  DiscreteMeasurableSpace α",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "LeftCommutative",
  "constType": "{α : Type u} → {β : Type v} → (α → β → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.one_mul",
   "letFun",
   "HMul.hMul",
   "Int.add_mul",
   "Nat",
   "Int",
   "id"],
  "name": "Int.instCommRingInt.proof_1",
  "constType": "∀ (n : ℕ) (x : ℤ), (↑n + 1) * x = x + ↑n * x",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.rec", "le_refl", "Preorder", "LE.le", "Preorder.toLE", "Eq"],
  "name": "le_of_eq",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["FinsetCoe.fintype",
   "Set.Elem",
   "Finset.toSet",
   "Finset",
   "Finite.of_fintype",
   "Set.Finite",
   "Set.toFinite"],
  "name": "Finset.finite_toSet",
  "constType": "∀ {α : Type u} (s : Finset α), Set.Finite ↑s",
  "constCategory": "Theorem"},
 {"references": ["outParam", "NonAssocSemiring"],
  "name": "RingHomClass",
  "constType":
  "Type u_5 →\n  (α : outParam (Type u_6)) →\n    (β : outParam (Type u_7)) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references":
  ["LE.le.antisymm",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "LE.le",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder β] (f : α → β),\n  Function.Injective f → ∀ (x x_1 : α), x ≤ x_1 → x_1 ≤ x → x = x_1",
  "constCategory": "Theorem"},
 {"references": ["Subtype.rec", "Subtype.mk", "Subtype"],
  "name": "Subtype.casesOn",
  "constType":
  "{α : Sort u} →\n  {p : α → Prop} →\n    {motive : Subtype p → Sort u_1} →\n      (t : Subtype p) → ((val : α) → (property : p val) → motive { val := val, property := property }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.toAlgebra",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "RingHom.id"],
  "name": "Algebra.id",
  "constType": "(R : Type u) → [inst : CommSemiring R] → Algebra R R",
  "constCategory": "Definition"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "Real.metricSpace",
   "Real",
   "MetricSpace.toPseudoMetricSpace",
   "rfl",
   "Eq",
   "Dist.dist"],
  "name": "Real.normedAddCommGroup.proof_1",
  "constType": "∀ (_r _y : ℝ), dist _r _y = dist _r _y",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "sub_self",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "MulZeroClass.mul_zero",
   "Semifield.toCommGroupWithZero",
   "div_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Eq",
   "CommGroupWithZero.toDiv",
   "Field",
   "sub_zero",
   "HDiv.hDiv",
   "not_false_eq_true",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Classical.propDecidable",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "of_eq_true",
   "CommRing.toRing",
   "congr",
   "Not",
   "Field.toDiv",
   "mul_div_cancel'",
   "MonoidWithZero.toZero",
   "add_zero",
   "Field.toDivisionRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "congrFun",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "mul_div_cancel",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "zero_add",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "CommGroupWithZero.toGroupWithZero",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "eq_false",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero"],
  "name": "Field.toEuclideanDomain.proof_2",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b * (fun x x_1 => x / x_1) a b + (fun a b => a - a * b / b) a b = a",
  "constCategory": "Theorem"},
 {"references":
  ["ContravariantClass.elim",
   "PartialOrder.toPreorder",
   "Contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "contravariant_le_iff_contravariant_lt_and_eq",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "PartialOrder",
   "Eq",
   "add_left_cancel",
   "And",
   "Preorder.toLT",
   "LT.lt",
   "And.intro",
   "Add",
   "IsLeftCancelAdd",
   "ContravariantClass",
   "ContravariantClass.mk"],
  "name": "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : ContravariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  ContravariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Equiv", "Cardinal.toNat_congr", "Nat", "Nat.card", "Eq"],
  "name": "Nat.card_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2}, α ≃ β → Nat.card α = Nat.card β",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_comm", "Eq"],
  "name": "PFR.Main._auxLemma.2",
  "constType": "∀ {α : Sort u_1} {a b : α}, (a = b) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "DivisionRing",
   "Eq.ndrec",
   "Eq.refl",
   "HDiv.hDiv",
   "Eq.symm",
   "DivisionRing.toDiv",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.div_congr",
  "constType":
  "∀ {R : Type u_1} [inst : DivisionRing R] {a a' b b' c : R}, a = a' → b = b' → a' / b' = c → a / b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_4",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real.exp_zero",
   "OfNat.ofNat",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Real",
   "Eq.refl",
   "One.toOfNat1",
   "Real.orderedSemiring",
   "Real.exp",
   "Real.instOneReal",
   "Eq",
   "Real.exp_injective",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.exp_log",
   "Real.log",
   "Eq.mpr",
   "Eq.ndrec",
   "zero_lt_one",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "id"],
  "name": "Real.log_one",
  "constType": "Real.log 1 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Or",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "or_assoc",
   "CauSeq",
   "LE.le",
   "Or.imp_right",
   "Iff.mpr",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Or.inl",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "CauSeq.lt_total",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name": "CauSeq.le_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (f g : CauSeq α abs), f ≤ g ∨ g ≤ f",
  "constCategory": "Theorem"},
 {"references":
  ["Ord.compare",
   "Ordering",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Eq.refl",
   "SemilatticeInf.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "Eq",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableEq α] [inst_2 : DecidableRel fun x x_1 => x < x_1] (a b : α),\n  compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["le_of_not_lt.match_1",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "le_refl",
   "LinearOrder.toPartialOrder",
   "Not",
   "le_of_lt",
   "absurd",
   "LE.le",
   "Preorder.toLE",
   "lt_trichotomy",
   "Eq"],
  "name": "le_of_not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "MeasureTheory.Measure.ae.proof_2",
   "Filter.EventuallyEq",
   "Mathlib.Order.Filter.Basic._auxLemma.1",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "dite",
   "BooleanAlgebra.toHasCompl",
   "implies_congr",
   "MeasureTheory.measure_empty",
   "Nonempty",
   "ite",
   "Eq",
   "ENNReal",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Iff",
   "MeasureTheory.OuterMeasure.measureOf",
   "FiniteRange",
   "Finset.toSet",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "FiniteRange.toFinset",
   "Filter.eventuallyEq_of_mem",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Filter",
   "Eq.trans",
   "Or",
   "Finset.decidableMem",
   "setOf",
   "measurable_const",
   "eq_of_heq",
   "Classical.propDecidable",
   "HasCompl.compl",
   "Set.instEmptyCollectionSet",
   "MeasurableSet.preimage",
   "Finset.instMembershipFinset",
   "ProbabilityTheory.IdentDistrib",
   "instENNRealZero",
   "Finset.measurableSet",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "instDecidableTrue",
   "Set.instMembershipSet",
   "Std.Logic._auxLemma.30",
   "And",
   "eq_true",
   "Std.Logic._auxLemma.69",
   "False.elim",
   "HEq.refl",
   "MeasureTheory.Measure.toOuterMeasure",
   "Nonempty.some",
   "of_eq_true",
   "Eq.mp",
   "PFR.ForMathlib.FiniteRange._auxLemma.1",
   "congr",
   "Singleton.singleton",
   "Not",
   "And.intro",
   "Mathlib.Data.Finset.Basic._auxLemma.78",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "Exists",
   "HEq",
   "Measurable.ite",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "True",
   "iff_self",
   "Set.ext",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.2",
   "Std.Logic._auxLemma.28",
   "Decidable",
   "MeasurableSet",
   "Finset",
   "Measurable",
   "MeasureTheory.Measure.ae",
   "Std.Logic._auxLemma.52",
   "Eq.symm",
   "Finset.instUnionFinset",
   "instMembershipSetFilter",
   "id",
   "Membership.mem",
   "funext",
   "Set.preimage_compl",
   "False",
   "ProbabilityTheory.IdentDistrib.measure_preimage_eq",
   "Or.inr",
   "Set.preimage",
   "MeasureTheory.Measure.ae.proof_1",
   "Union.union",
   "MeasureTheory.Measure.ae.proof_3",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Std.Logic._auxLemma.70",
   "ite_congr",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Set.instBooleanAlgebraSet",
   "Or.inl",
   "Eq.ndrec",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "letFun",
   "finiteRange_of_finset",
   "not_true_eq_false",
   "Eq.casesOn",
   "MeasureTheory.OuterMeasure",
   "Finset.instSingletonFinset"],
  "name": "ProbabilityTheory.identDistrib_of_finiteRange",
  "constType":
  "∀ {Ω : Type u_11} {Ω₀ : Type u_12} {S : Type u_13} [inst : MeasurableSpace Ω] [inst_1 : MeasurableSpace Ω₀]\n  [inst_2 : MeasurableSpace S] [inst_3 : MeasurableSingletonClass S] [hS : Nonempty S] {μ : MeasureTheory.Measure Ω}\n  {μ₀ : MeasureTheory.Measure Ω₀} {X₀ : Ω₀ → S} [inst_4 : FiniteRange X₀] {X : Ω → S},\n  Measurable X →\n    ProbabilityTheory.IdentDistrib X₀ X → ∃ X', Measurable X' ∧ FiniteRange X' ∧ X' =ᶠ[MeasureTheory.Measure.ae μ] X",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddMonoidHom.rec",
   "AddZeroClass",
   "AddMonoidHom.mk",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.casesOn",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        {motive : (M →+ N) → Sort u} →\n          (t : M →+ N) →\n            ((toZeroHom : ZeroHom M N) →\n                (map_add' :\n                    ∀ (x y : M),\n                      ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n                  motive { toZeroHom := toZeroHom, map_add' := map_add' }) →\n              motive t",
  "constCategory": "Definition"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "Mathlib.Tactic.PushNeg.not_forall_eq",
  "constType": "∀ {α : Sort u_1} (s : α → Prop), (¬∀ (x : α), s x) = ∃ x, ¬s x",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMulActionWithZero.proof_3",
   "MonoidWithZero.toMulActionWithZero.proof_1",
   "SMulWithZero",
   "MulActionWithZero.mk",
   "MulZeroClass.toSMulWithZero",
   "MulActionWithZero",
   "MonoidWithZero.toMulActionWithZero.proof_2",
   "MulZeroOneClass.toMulZeroClass",
   "SMulZeroClass.toSMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Monoid.toMulAction",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "MulZeroClass.toZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "MonoidWithZero.toMulActionWithZero.proof_4",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero",
  "constType":
  "(R : Type u_1) → [inst : MonoidWithZero R] → MulActionWithZero R R",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.himp_eq",
   "HImp.himp",
   "SemilatticeSup.toSup",
   "Set.instBooleanAlgebraSet",
   "BooleanAlgebra.toHImp",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_10",
  "constType": "∀ {α : Type u_1} (x y : Set α), x ⇨ y = y ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Nat"],
  "name": "Semiring.npow",
  "constType": "{α : Type u} → [self : Semiring α] → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "instHDiv",
   "MeasureTheory.Measure.map",
   "Prod.snd",
   "Real.natCast",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.407",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "ProbabilityTheory.entropy",
   "Prod.fst",
   "MeasureTheory.Measure.prod",
   "autoParam",
   "AddGroup.toSubNegMonoid",
   "LinearOrderedField.toDiv",
   "Prod.instMeasurableSpace",
   "MeasureTheory.Measure",
   "SubNegMonoid.toSub",
   "rdist.proof_1",
   "Prod",
   "AddCommGroup.toAddGroup",
   "HDiv.hDiv",
   "AddCommGroup",
   "instOfNat",
   "MeasurableSpace",
   "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.380"],
  "name": "rdist",
  "constType":
  "{Ω : Type u_1} →\n  {Ω' : Type u_2} →\n    {G : Type u_5} →\n      [mΩ : MeasurableSpace Ω] →\n        [mΩ' : MeasurableSpace Ω'] →\n          [hG : MeasurableSpace G] →\n            [inst : AddCommGroup G] →\n              (Ω → G) →\n                (Ω' → G) → autoParam (MeasureTheory.Measure Ω) _auto✝ → autoParam (MeasureTheory.Measure Ω') _auto✝¹ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Monoid",
   "instHSMul",
   "MeasureTheory.Measure.instSMul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure.smul_toOuterMeasure",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulAction.toSMul",
   "MeasureTheory.OuterMeasure.instSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "HSMul.hSMul",
   "OrderedSemiring.toSemiring",
   "Algebra.id",
   "MulAction",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.instMulAction.proof_1",
  "constType":
  "∀ {α : Type u_1} {R : Type u_2} [inst : Monoid R] [inst_1 : MulAction R ENNReal]\n  [inst_2 : IsScalarTower R ENNReal ENNReal] [inst_3 : MeasurableSpace α] (c : R) (μ : MeasureTheory.Measure α),\n  ↑(c • μ) = c • ↑μ",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "add_zero",
   "Eq.symm",
   "id"],
  "name": "left_neg_eq_right_neg",
  "constType":
  "∀ {M : Type u} [inst : AddMonoid M] {a b c : M}, b + a = 0 → a + c = 0 → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "Field.toEuclideanDomain.match_1",
   "OfNat.ofNat",
   "WellFounded.intro",
   "False.elim",
   "Field",
   "Field.toSemifield",
   "WellFounded",
   "Semifield.toCommGroupWithZero",
   "Acc.intro",
   "Acc",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_3",
  "constType":
  "∀ {K : Type u_1} [inst : Field K], WellFounded fun a b => a = 0 ∧ b ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "MeasureTheory.MeasureSpace.mk",
  "constType":
  "{α : Type u_6} → [toMeasurableSpace : MeasurableSpace α] → MeasureTheory.Measure α → MeasureTheory.MeasureSpace α",
  "constCategory": "Other"},
 {"references":
  ["Real", "_private.Mathlib.Data.Real.Basic.0.Real.mul", "Mul", "Mul.mk"],
  "name": "Real.instMulReal",
  "constType": "Mul ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LinearOrderedAddCommMonoid.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoid.decidableLT",
   "Eq"],
  "name": "LinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u_3} [self : LinearOrderedAddCommMonoid α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references": ["HasEquiv"],
  "name": "HasEquiv.Equiv",
  "constType": "{α : Sort u} → [self : HasEquiv α] → α → α → Sort v",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegMonoid.zsmul_succ'",
   "AddOpposite.unop",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "add_neg_self",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "AddOpposite.subNegMonoid",
   "SubNegMonoid.zsmul",
   "AddOpposite",
   "AddOpposite.unop_injective",
   "SubNegMonoid.zsmul_zero'"],
  "name": "AddOpposite.addGroup.proof_5",
  "constType": "∀ (α : Type u_1) [inst : AddGroup α] (x : αᵃᵒᵖ), -x + x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "OfNat.ofNat",
   "Nat.cast",
   "instOfNatInt",
   "instNatCastInt",
   "Int.natAbs_of_nonneg",
   "CanLift.mk",
   "Exists.intro",
   "Nat",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.natAbs",
   "Eq"],
  "name": "instCanLiftIntNatCastInstNatCastIntLeInstLEIntOfNatInstOfNatInt",
  "constType": "CanLift ℤ ℕ (fun n => ↑n) fun x => 0 ≤ x",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "NonUnitalSemiring.mul_assoc",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_1",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a b c : CauSeq.Completion.Cauchy abv), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "One",
   "one_ne_zero",
   "One.toOfNat1",
   "Eq"],
  "name": "Mathlib.Algebra.NeZero._auxLemma.4",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Distrib.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semifield.toCommGroupWithZero",
   "Real.pi",
   "Real.decidableLE",
   "Real.cos_sub_pi",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "Real.orderedRing",
   "Semiring.toNatCast",
   "Real.instOneReal",
   "ite",
   "Real.linearOrder",
   "Complex.instField",
   "HasDistribNeg.toInvolutiveNeg",
   "Mathlib.Algebra.GroupPower.Ring._auxLemma.4",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "IsAbsoluteValue.abv_nonneg",
   "instOfNat",
   "HPow.hPow",
   "instHSub",
   "Complex.abs",
   "_private.Mathlib.Analysis.SpecialFunctions.Complex.Arg.0.Complex.arg._eq_1",
   "instHDiv",
   "Complex.instZeroComplex",
   "Complex.instNontrivialComplex",
   "MulOneClass.toOne",
   "Real.normedCommRing",
   "Real.sqrt",
   "SubadditiveHomClass.toFunLike",
   "neg_div'",
   "sub_div'",
   "Complex.im",
   "MonoidWithZero.toMulZeroOneClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "congr",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "congrFun",
   "Real",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "neg_neg",
   "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.4",
   "NonAssocSemiring.toMulZeroOneClass",
   "Abs.abs",
   "True",
   "AbsoluteValue.subadditiveHomClass",
   "Field.toCommRing",
   "Complex.instSemiringComplex",
   "InvolutiveNeg.toNeg",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "not_le",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Mathlib.Algebra.Parity._auxLemma.18",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "if_neg",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Real.sqrt_div",
   "Neg.toHasAbs",
   "Real.arcsin",
   "NonUnitalNonAssocRing.toMul",
   "Real.instLinearOrderedRingReal",
   "MonoidHomClass.toMulHomClass",
   "Real.nontrivial",
   "Field.toSemifield",
   "Even",
   "One.toOfNat1",
   "Neg.neg",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "LE.le",
   "GroupWithZero.toMonoidWithZero",
   "NormedCommRing.toSeminormedCommRing",
   "Eq.ndrec",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "NegZeroClass.toNeg",
   "AbsoluteValue.monoidWithZeroHomClass",
   "Real.orderedAddCommGroup",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "Real.instMulReal",
   "Real.instSubReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "AbsoluteValue",
   "Real.instLEReal",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "dite",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "AbsoluteValue.isAbsoluteValue",
   "Nat",
   "LinearOrderedRing.noZeroDivisors",
   "not_false_eq_true",
   "Eq.trans",
   "Real.cos",
   "Ne",
   "Real.field",
   "DivisionSemiring.toGroupWithZero",
   "sq_nonneg",
   "Real.sqrt_sq_eq_abs",
   "Real.orderedSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Real.cos_add_pi",
   "instHMul",
   "of_eq_true",
   "Real.instIsDomainRealSemiring",
   "Real.instAddGroupReal",
   "Not",
   "congrArg",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "Real.cos_arcsin",
   "Complex.instNegComplex",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "div_mul_eq_mul_div",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "Real.instNegReal",
   "mul_div_cancel",
   "Zero.toOfNat0",
   "pow_bit0_nonneg",
   "one_mul",
   "Preorder.toLT",
   "instHPow",
   "Ring.toSub",
   "instOfNatNat",
   "Complex.sq_abs_sub_sq_im",
   "id",
   "eq_self",
   "Real.instMonoidReal",
   "Real.instMonoidWithZeroReal",
   "False",
   "abs_of_neg",
   "instHAdd",
   "HSub.hSub",
   "Complex.abs_abs",
   "Even.neg_pow",
   "StrictOrderedSemiring.toSemiring",
   "Complex.re",
   "Real.instZeroReal",
   "Real.sqrt_sq",
   "if_pos",
   "eq_false",
   "div_pow",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.2",
   "Complex",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "NegZeroClass.toZero",
   "OrderedSemiring.toPartialOrder",
   "Nat.semiring"],
  "name": "Complex.cos_arg",
  "constType":
  "∀ {x : ℂ}, x ≠ 0 → Real.cos (Complex.arg x) = x.re / Complex.abs x",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance", "DivisionRing", "Rat", "Rat.field", "Field.toDivisionRing"],
  "name": "Rat.divisionRing",
  "constType": "DivisionRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Finset.coe_subset",
   "Set.instHasSubsetSet",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "HasSubset.Subset",
   "Finset.instHasSubsetFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.10",
  "constType": "∀ {α : Type u_1} {s₁ s₂ : Finset α}, (↑s₁ ⊆ ↑s₂) = (s₁ ⊆ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "Nat.succ_mul",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Eq.rec",
   "PUnit",
   "Nat.zero_mul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.mul_comm",
  "constType": "∀ (n m : ℕ), n * m = m * n",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "SemilatticeSup.sup_le",
   "Submonoid",
   "Sup.sup",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_8",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b c : Submonoid M), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "upperBounds",
   "And.right",
   "IsGLB",
   "setOf",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "InfSet",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "completeLatticeOfInf.proof_2",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α],\n  (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a b : α), b ≤ sInf {x | a ≤ x ∧ b ≤ x}",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq"],
  "name": "LeftDistribClass.left_distrib",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Nat.cast_commute",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Ring",
   "Commute.invOf_right",
   "Int.cast_mul",
   "invertibleMul",
   "Nat",
   "Eq.trans",
   "Mathlib.Meta.NormNum.invertibleOfMul'",
   "Invertible.invOf",
   "congr_arg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Commute.right_comm",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Int.cast",
   "Eq.mp",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Commute.invOf_left",
   "AddGroupWithOne.toIntCast",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "mul_mul_invOf_self_cancel'",
   "True",
   "Ring.toNonAssocRing",
   "Nat.cast_mul",
   "mul_mul_invOf_self_cancel",
   "AddMonoidWithOne.toNatCast",
   "Eq.symm",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsRat",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "instMulNat",
   "Nat.mul"],
  "name": "Mathlib.Meta.NormNum.isRat_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {na nb nc : ℤ} {da db dc k : ℕ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsRat a na da →\n      Mathlib.Meta.NormNum.IsRat b nb db →\n        Int.mul na nb = Int.mul (↑k) nc → Nat.mul da db = Nat.mul k dc → Mathlib.Meta.NormNum.IsRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "BiheytingAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Iff",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "SDiff.sdiff",
   "Lattice.toSemilatticeSup",
   "BiheytingAlgebra.toSDiff",
   "LE.le",
   "BiheytingAlgebra.toHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "BiheytingAlgebra.sdiff_le_iff",
  "constType":
  "∀ {α : Type u_4} [self : BiheytingAlgebra α] (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "inv_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HMul.hMul",
   "HDiv.hDiv",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_rev",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "DivInvMonoid.toDiv",
   "Inv.inv"],
  "name": "div_div_eq_mul_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a b c : α), a / (b / c) = a * c / b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Iff.mp",
   "not_iff_comm",
   "Not",
   "IsEmpty",
   "not_nonempty_iff",
   "Nonempty"],
  "name": "not_isEmpty_iff",
  "constType": "∀ {α : Sort u_1}, ¬IsEmpty α ↔ Nonempty α",
  "constCategory": "Theorem"},
 {"references":
  ["Ordering",
   "DecidableEq",
   "Ordering.gt",
   "LT.lt",
   "Ordering.eq",
   "Ordering.lt",
   "Decidable",
   "LT",
   "Eq",
   "ite"],
  "name": "compareOfLessAndEq",
  "constType":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "neg_eq_of_add_eq_zero_left",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "Eq.symm",
   "Eq"],
  "name": "eq_neg_of_add_eq_zero_left",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] {a b : G}, a + b = 0 → a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["GaloisInsertion.liftLattice",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "GaloisInsertion.gc",
   "Set",
   "InfSet.sInf",
   "Eq.refl",
   "Lattice.mk",
   "And.left",
   "GaloisConnection.monotone_u",
   "GaloisInsertion",
   "Preorder.toLE",
   "Eq",
   "CompleteLattice.toLattice",
   "Lattice.toInf",
   "Eq.mpr",
   "And.right",
   "upperBounds",
   "Lattice.toSemilatticeSup",
   "Set.image",
   "SemilatticeSup.toPartialOrder",
   "GaloisInsertion.isGLB_of_u_image",
   "id",
   "Membership.mem",
   "isGLB_sInf",
   "Monotone.mem_lowerBounds_image",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "LE.le",
   "GaloisInsertion.choice",
   "Set.instMembershipSet",
   "PartialOrder",
   "InfSet.mk",
   "GaloisInsertion.choice_eq",
   "Eq.ndrec",
   "CompleteLattice",
   "CompleteLattice.toInfSet",
   "CompleteSemilatticeInf.toInfSet",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_4",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (s : Set β), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "HEq",
   "measurable_fst",
   "Real",
   "Real.instLEReal",
   "MeasureTheory.MeasureSpace.mk",
   "Eq.refl",
   "Exists.intro",
   "MeasureTheory.IsProbabilityMeasure",
   "And.left",
   "MeasureTheory.Measure.prod",
   "MeasureTheory.MeasureSpace.volume",
   "tau_minimizes",
   "ProbabilityTheory.IdentDistrib.tau_eq",
   "Eq",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.prod.instIsProbabilityMeasure",
   "MeasurableSingletonClass",
   "inferInstance",
   "Eq.mpr",
   "Fintype",
   "And.right",
   "LE",
   "tau",
   "Measurable",
   "Eq.symm",
   "measurable_snd",
   "id",
   "tau_min_exists_measure",
   "Prod.snd",
   "refPackage",
   "Exists.choose_spec",
   "eq_of_heq",
   "Prod.fst",
   "LE.le",
   "ProbabilityTheory.IdentDistrib.snd_id",
   "Prod.instMeasurableSpace",
   "And",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Eq.ndrec",
   "HEq.refl",
   "ProbabilityTheory.IdentDistrib.fst_id",
   "Exists.choose",
   "MeasureTheory.MeasureSpace",
   "letFun",
   "Prod",
   "Eq.casesOn",
   "And.intro",
   "AddCommGroup",
   "MeasurableSpace"],
  "name": "tau_minimizer_exists",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [inst_4 : AddCommGroup G]\n  [inst_5 : Fintype G] [inst_6 : MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [inst_7 : MeasurableSingletonClass G],\n  ∃ Ω mΩ X₁ X₂,\n    Measurable X₁ ∧ Measurable X₂ ∧ MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧ tau_minimizes p X₁ X₂",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred",
   "Finset",
   "Finset.val",
   "Multiset.filter",
   "Finset.filter.proof_1",
   "Finset.mk"],
  "name": "Finset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → Finset α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "Bot.bot",
   "Iff",
   "AddGroup",
   "Iff.rfl",
   "AddSubgroup",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.instBotAddSubgroup",
   "NegZeroClass.toZero",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.instMembership",
   "Eq"],
  "name": "AddSubgroup.mem_bot",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] {x : G}, x ∈ ⊥ ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulOneClass.toMul",
   "MonoidHomClass.map_one",
   "MulOneClass",
   "MonoidHomClass.toMulHomClass",
   "MulOneClass.toOne",
   "OneHomClass.mk",
   "OneHomClass",
   "MulHomClass.toFunLike"],
  "name": "MonoidHomClass.toOneHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [self : MonoidHomClass F M N] → OneHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Real.casesOn",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
  "constType":
  "(motive : ℝ → ℝ → Sort u_1) →\n  (x x_1 : ℝ) → ((a b : CauSeq.Completion.Cauchy abs) → motive { cauchy := a } { cauchy := b }) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "Prod.instMeasurableSingletonClass.match_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (motive : α × β → Prop) (x : α × β), (∀ (a : α) (b : β), motive (a, b)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_add'",
  "constType":
  "∀ {M : Type u_9} {N : Type u_10} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M →+ N) (x y : M),\n  ZeroHom.toFun (↑self) (x + y) = ZeroHom.toFun (↑self) x + ZeroHom.toFun (↑self) y",
  "constCategory": "Definition"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → SProd α β γ",
  "constCategory": "Other"},
 {"references":
  ["instHasEquiv",
   "False",
   "Setoid",
   "Quotient.exact",
   "Not",
   "Quotient",
   "HasEquiv.Equiv",
   "absurd",
   "Quotient.mk",
   "Eq"],
  "name": "Quotient.decidableEq.proof_2",
  "constType":
  "∀ {α : Sort u_1} {s : Setoid α} (a₁ a₂ : α), ¬a₁ ≈ a₂ → ⟦a₁⟧ = ⟦a₂⟧ → False",
  "constCategory": "Theorem"},
 {"references": ["OrderHom", "Monotone", "Preorder"],
  "name": "OrderHom.mk",
  "constType":
  "{α : Type u_6} →\n  {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (toFun : α → β) → Monotone toFun → α →o β",
  "constCategory": "Other"},
 {"references":
  ["Countable",
   "Function.Injective.countable",
   "Fin.eq_of_veq",
   "Fin.val",
   "Nat",
   "Fin",
   "instCountableNat"],
  "name": "instCountableFin",
  "constType": "∀ {n : ℕ}, Countable (Fin n)",
  "constCategory": "Definition"},
 {"references": ["HEq", "HEq.refl", "Eq.subst", "Eq"],
  "name": "heq_of_eq",
  "constType": "∀ {α : Sort u} {a a' : α}, a = a' → HEq a a'",
  "constCategory": "Theorem"},
 {"references": ["BiheytingAlgebra", "SDiff"],
  "name": "BiheytingAlgebra.toSDiff",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.decLt",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "Nat.choose_zero_right",
   "AddMonoid.toAddZeroClass",
   "CanonicallyOrderedCommSemiring.toOne",
   "instLTNat",
   "True",
   "Eq",
   "PProd",
   "Eq.mpr",
   "instLENat",
   "Nat.addMonoid",
   "Nat.choose",
   "Nat.le_of_succ_le_succ",
   "Bool.true",
   "PUnit",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Nat",
   "add_pos_of_pos_of_nonneg",
   "Nat.succ",
   "Eq.trans",
   "Nat.choose_succ_succ",
   "Nat.strictOrderedSemiring",
   "id",
   "NeZero.succ",
   "Nat.below",
   "Nat.brecOn",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
   "Nat.linearOrderedCommMonoidWithZero",
   "instAddNat",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.canonicallyOrderedCommSemiring",
   "LE.le",
   "Nat.choose_pos.match_1",
   "Nat.rec",
   "PProd.fst",
   "Nat.zero",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "Nat.orderedSemiring",
   "LT.lt",
   "Nat.eq_zero_of_le_zero",
   "Bool",
   "Nat.zero_le",
   "congrArg"],
  "name": "Nat.choose_pos",
  "constType": "∀ {n k : ℕ}, k ≤ n → 0 < Nat.choose n k",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "div_eq_mul_inv",
   "DivInvMonoid",
   "one_div",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "div_eq_mul_one_div",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b : G), a / b = a * (1 / b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubmonoid.comap",
   "AddSubsemigroup.carrier",
   "AddMonoidHom"],
  "name": "AddSubgroup.comap.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup N),\n  0 ∈ (AddSubmonoid.comap f H.toAddSubmonoid).toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid"],
  "name": "AddSubgroup.toAddSubmonoid",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → AddSubgroup G → AddSubmonoid G",
  "constCategory": "Definition"},
 {"references": ["VAdd"],
  "name": "VAdd.vadd",
  "constType": "{G : Type u} → {P : Type v} → [self : VAdd G P] → G → P → P",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toZero",
   "AddSubmonoid.instBotAddSubmonoid",
   "OfNat.ofNat",
   "Bot.bot",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.mem_bot",
   "propext",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Eq"],
  "name": "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.9",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {x : M}, (x ∈ ⊥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Real.ratCast",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "rfl",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_ratCast",
  "constType": "∀ (q : ℚ), { cauchy := ↑q } = ↑q",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Left.neg_pos_iff",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "propext",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Group.Defs._auxLemma.10",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, (0 < -a) = (a < 0)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Int.instSubInt",
   "_private.Init.Data.Int.Basic.0.Int.decNonneg",
   "Decidable",
   "HSub.hSub",
   "LE.le",
   "Int",
   "Int.instLEInt"],
  "name": "Int.decLe",
  "constType": "(a b : ℤ) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "GroupWithZero",
   "Nat",
   "Nat.succ",
   "Int",
   "GroupWithZero.toInv",
   "Inv.inv",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_neg'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.negSucc n) a = (GroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["MulEquiv.symm_map_mul",
   "MulEquiv.toEquiv",
   "MulEquiv.mk",
   "MulEquiv",
   "Mul",
   "Equiv.symm"],
  "name": "MulEquiv.symm",
  "constType":
  "{M : Type u_12} → {N : Type u_13} → [inst : Mul M] → [inst_1 : Mul N] → M ≃* N → N ≃* M",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_neg",
  "constType": "∀ {G : Type u} [self : SubtractionMonoid G] (x : G), - -x = x",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Set.Elem",
   "Nonempty.some",
   "Set",
   "Set.Finite.nonempty_fintype",
   "Set.Finite"],
  "name": "Set.Finite.fintype",
  "constType": "{α : Type u} → {s : Set α} → Set.Finite s → Fintype ↑s",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.lift_mk_eq",
   "Equiv",
   "Cardinal.toNat_lift",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHom.zeroHomClass",
   "Eq.refl",
   "ZeroHom",
   "FunLike.coe",
   "Nonempty",
   "Iff.mpr",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Nonempty.intro",
   "Cardinal.toNat",
   "Eq.mpr",
   "Eq.ndrec",
   "ZeroHomClass.toFunLike",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Cardinal.mk",
   "Eq.symm",
   "Cardinal.lift",
   "id"],
  "name": "Cardinal.toNat_congr",
  "constType":
  "∀ {α : Type u} {β : Type v}, α ≃ β → Cardinal.toNat (Cardinal.mk α) = Cardinal.toNat (Cardinal.mk β)",
  "constCategory": "Theorem"},
 {"references": ["Ne", "OfNat.ofNat", "Rat", "Rat.den", "instOfNatNat", "Nat"],
  "name": "Rat.den_nz",
  "constType": "∀ (self : ℚ), self.den ≠ 0",
  "constCategory": "Definition"},
 {"references":
  ["Complex.abs",
   "Real",
   "AbsoluteValue",
   "AbsoluteValue.mulHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.orderedSemiring",
   "Eq",
   "Complex.instSemiringComplex",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "map_mul",
   "HMul.hMul",
   "Complex"],
  "name": "Complex.instNormedFieldComplex.proof_2",
  "constType":
  "∀ (x y : ℂ), Complex.abs (x * y) = Complex.abs x * Complex.abs y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toSemiring",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "of_eq_true",
   "Ring",
   "Ring.toAddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_1} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Iff.mp", "Iff", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.subtype.proof_1",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α), (∀ (x : α), x ∈ s ↔ p x) → ∀ x ∈ s, p x",
  "constCategory": "Theorem"},
 {"references": ["CompleteAtomicBooleanAlgebra", "CompletelyDistribLattice"],
  "name": "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → CompletelyDistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup",
   "NormedCommRing",
   "Real.normedCommRing.proof_1",
   "Real",
   "Real.commRing",
   "CommRing.toRing",
   "NormedRing.mk",
   "CommRing.mul_comm",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "NormedCommRing.mk",
   "CommRing",
   "Real.normedAddCommGroup"],
  "name": "Real.normedCommRing",
  "constType": "NormedCommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Real", "Real.commRing", "Ring", "CommRing.toRing"],
  "name": "Real.instRingReal",
  "constType": "Ring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "absurd",
   "rfl",
   "Eq"],
  "name": "dif_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "Subtype.val",
   "Set",
   "Exists.intro",
   "rfl",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Subtype.coe_image.match_2",
   "Subtype.coe_image.match_1",
   "Eq.rec",
   "And.intro",
   "Set.image",
   "Subtype",
   "Subtype.mk"],
  "name": "Subtype.coe_image",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} {s : Set (Subtype p)},\n  Subtype.val '' s = {x | ∃ (h : p x), { val := x, property := h } ∈ s}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "And.right",
   "Set",
   "HasSubset.Subset",
   "Inter.inter",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Set.inter_subset_right",
  "constType": "∀ {α : Type u} (s t : Set α), s ∩ t ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["Norm", "NormedAddCommGroup"],
  "name": "NormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} → [self : NormedAddCommGroup E] → Norm E",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "Algebra",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst : Semiring A] → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.zero_add",
   "AddRightCancelMonoid.nsmul_succ",
   "AddRightCancelMonoid.toZero",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddRightCancelMonoid.nsmul_zero",
   "AddRightCancelMonoid.nsmul",
   "AddMonoid",
   "AddRightCancelMonoid.add_zero",
   "AddMonoid.mk"],
  "name": "AddRightCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddRightCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, a = ↑n → Mathlib.Meta.NormNum.IsInt a n",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "LE.le",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "LinearOrderedAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedAddCommMonoid.decidableLE",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_insert",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Set.mem_singleton",
   "lowerBounds_insert",
   "Set",
   "InfSet.sInf",
   "Inter.inter",
   "Set.Iic",
   "Lattice.mk",
   "Sup.mk",
   "And.left",
   "Insert.insert",
   "Preorder.toLE",
   "True",
   "Inf.mk",
   "Set.instSingletonSet",
   "And.right",
   "upperBounds",
   "lowerBounds_singleton",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "Mathlib.Data.Set.Basic._auxLemma.25",
   "SemilatticeSup.toPartialOrder",
   "Membership.mem",
   "IsGLB",
   "setOf",
   "SemilatticeSup.mk",
   "InfSet",
   "LE.le",
   "Set.instMembershipSet",
   "PartialOrder",
   "And",
   "eq_true",
   "of_eq_true",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
   "lowerBounds",
   "Set.mem_insert_of_mem",
   "PartialOrder.le_antisymm",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "and_self",
   "Set.instInterSet",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf.proof_8",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α] (isGLB_sInf : ∀ (s : Set α), IsGLB s (sInf s)) (s : Set α)\n  (a : α), (∀ b ∈ s, b ≤ a) → sInf (upperBounds s) ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring.npow",
   "instHAdd",
   "Semiring",
   "HAdd.hAdd",
   "HMul.hMul",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.npow_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ) (x : α), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "OrderDual.instPreorder",
   "Finset.Nonempty",
   "Preorder.toLT",
   "LT.lt",
   "Finset",
   "OrderDual",
   "Not",
   "Finset.instMembershipFinset",
   "Preorder",
   "Finset.exists_minimal"],
  "name": "Finset.exists_maximal",
  "constType":
  "∀ {α : Type u_4} [inst : Preorder α] (s : Finset α), Finset.Nonempty s → ∃ m ∈ s, ∀ x ∈ s, ¬m < x",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "Equiv",
   "MulOneClass.toMul",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Set",
   "FunLike.coe",
   "Multiplicative.ofAdd",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "instHMul",
   "Multiplicative",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mul_mem'",
   "HMul.hMul",
   "Submonoid",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid.proof_2",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] (S : Submonoid (Multiplicative A)) {a b : A},\n  a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "InvolutiveNeg",
   "funext",
   "Set.preimage",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "Set",
   "Neg.neg",
   "neg_neg",
   "congrArg",
   "Eq.trans",
   "True",
   "congrFun",
   "Eq"],
  "name": "Set.involutiveNeg.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : InvolutiveNeg α] (s : Set α), (fun x => - -x) ⁻¹' s = s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_zero'",
  "constType": "∀ {R : Type u} [self : Ring R] (a : R), Ring.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderBot",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "HeytingAlgebra.toOrderBot",
  "constType": "{α : Type u_4} → [self : HeytingAlgebra α] → OrderBot α",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "instHMul",
   "outParam",
   "FunLike",
   "HMul.hMul",
   "FunLike.coe",
   "Mul",
   "Eq"],
  "name": "MulHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Mul M] →\n        [inst_1 : Mul N] →\n          [toFunLike : FunLike F M fun x => N] → (∀ (f : F) (x y : M), f (x * y) = f x * f y) → MulHomClass F M N",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references": ["Inter"],
  "name": "Inter.mk",
  "constType": "{α : Type u} → (α → α → α) → Inter α",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["outParam", "Mul"],
  "name": "MulHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Mul M] → [inst : Mul N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "ne_of_lt",
   "div_eq_mul_one_div",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "mul_mul_div",
   "Preorder.toLT",
   "div_mul_cancel",
   "Eq.rec",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "LT.lt.le",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "One.toOfNat1",
   "Ne.symm",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Monoid.toMulOneClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Semiring.toOne",
   "Iff.intro",
   "instTransEq_1",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "one_div_pos",
   "instTransEq",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "OrderedSemiring.toMulPosMono"],
  "name": "le_div_iff",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → (a ≤ b / c ↔ a * c ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "pos_of_mul_pos_left",
   "Invertible",
   "True",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "mul_invOf_self",
   "Iff",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Eq.trans",
   "Mathlib.Algebra.Order.Invertible._auxLemma.1",
   "Invertible.invOf",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "OrderedSemiring.zeroLEOneClass",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "pos_of_mul_pos_right",
   "Iff.intro",
   "Semiring.toOne",
   "instHMul",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "LinearOrderedSemiring.toMulPosReflectLT",
   "congrArg"],
  "name": "invOf_pos",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedSemiring α] {a : α} [inst_1 : Invertible a], 0 < ⅟a ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["refPackage",
   "instHAdd",
   "refPackage.η",
   "HAdd.hAdd",
   "Real",
   "Real.instAddReal",
   "Real.instMulReal",
   "MeasureTheory.MeasureSpace.volume",
   "refPackage.X₀₁",
   "MeasureTheory.Measure",
   "instHMul",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "refPackage.X₀₂",
   "rdist",
   "MeasureTheory.MeasureSpace",
   "HMul.hMul",
   "AddCommGroup",
   "MeasurableSpace"],
  "name": "tau",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} →\n          [inst_2 : AddCommGroup G] →\n            [inst_3 : MeasurableSpace G] →\n              refPackage Ω₀₁ Ω₀₂ G →\n                {Ω₁ : Type u_7} →\n                  {Ω₂ : Type u_8} →\n                    [inst : MeasurableSpace Ω₁] →\n                      [inst_4 : MeasurableSpace Ω₂] →\n                        (Ω₁ → G) → (Ω₂ → G) → MeasureTheory.Measure Ω₁ → MeasureTheory.Measure Ω₂ → ℝ",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.casesOn",
  "constType": "(motive : False → Sort u) → (t : False) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "lt_irrefl",
   "Not",
   "Preorder",
   "absurd",
   "Eq"],
  "name": "ne_of_gt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u_1} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m < ↑n) = (m < n)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "mul_mul_invOf_self_cancel",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) [inst_1 : Invertible b], a * b * ⅟b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedCommSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedCommSemiring α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemigroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "invOf_mul_self",
   "Eq.refl",
   "One.toOfNat1",
   "Invertible",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "one_mul",
   "Eq.ndrec",
   "HMul.hMul",
   "Eq.symm",
   "id"],
  "name": "invOf_mul_self_assoc'",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) {x : Invertible a}, ⅟a * (a * b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.EventuallyEq.symm",
   "ProbabilityTheory.identDistrib_of_finiteRange",
   "Exists",
   "Filter.EventuallyEq",
   "ProbabilityTheory.independent_copies",
   "Eq.refl",
   "ProbabilityTheory.IdentDistrib.symm",
   "Exists.intro",
   "MeasureTheory.IsProbabilityMeasure",
   "ProbabilityTheory.IdentDistrib",
   "Exists.casesOn",
   "Nonempty",
   "Prod.instMeasurableSpace",
   "MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.trans",
   "MeasurableSingletonClass",
   "And",
   "Eq.mpr",
   "FiniteRange",
   "Measurable.aemeasurable",
   "ProbabilityTheory.IndepFun.ae_eq'",
   "ProbabilityTheory.IdentDistrib.of_ae_eq",
   "Measurable",
   "Prod",
   "And.intro",
   "MeasureTheory.Measure.ae",
   "And.casesOn",
   "MeasurableSpace",
   "id",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.independent_copies_finiteRange",
  "constType":
  "∀ {Ω : Type u_5} {Ω' : Type u_6} {α : Type u_7} {β : Type u_9} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {X : Ω → α} {Y : Ω' → β},\n  Measurable X →\n    Measurable Y →\n      ∀ [inst_2 : FiniteRange X] [inst_3 : FiniteRange Y] [inst_4 : MeasurableSingletonClass α] [inst_5 : Nonempty α]\n        [inst_6 : MeasurableSingletonClass β] [inst_7 : Nonempty β] (μ : MeasureTheory.Measure Ω)\n        (μ' : MeasureTheory.Measure Ω') [inst_8 : MeasureTheory.IsProbabilityMeasure μ]\n        [inst_9 : MeasureTheory.IsProbabilityMeasure μ'],\n        ∃ ν X' Y',\n          MeasureTheory.IsProbabilityMeasure ν ∧\n            Measurable X' ∧\n              Measurable Y' ∧\n                ProbabilityTheory.IndepFun X' Y' ∧\n                  ProbabilityTheory.IdentDistrib X' X ∧\n                    ProbabilityTheory.IdentDistrib Y' Y ∧ FiniteRange X' ∧ FiniteRange Y'",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "RelIso.toEquiv",
   "Function.Injective",
   "Equiv.coe_fn_injective",
   "Function.comp",
   "RelIso",
   "Function.Injective.comp",
   "FunLike.coe",
   "RelIso.toEquiv_injective",
   "Equiv.instFunLikeEquiv"],
  "name": "RelIso.instRelHomClassRelIso.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop},\n  Function.Injective ((fun e => ⇑e) ∘ fun x => x.toEquiv)",
  "constCategory": "Theorem"},
 {"references": ["Min"],
  "name": "Min.mk",
  "constType": "{α : Type u} → (α → α → α) → Min α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["AddGroupWithOne", "Int"],
  "name": "AddGroupWithOne.zsmul",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "Lattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.mk",
  "constType":
  "{α : Type u} →\n  [toSemilatticeSup : SemilatticeSup α] →\n    [toInf : Inf α] →\n      (∀ (a b : α), a ⊓ b ≤ a) → (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → Lattice α",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Dvd",
   "Eq"],
  "name": "Nat.instDvdNat",
  "constType": "Dvd ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PLift",
  "constType": "Sort u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "propext",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "neg_lt_zero",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.8",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, (-a < 0) = (0 < a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OmegaCompletePartialOrder", "PartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_1} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "LT.lt",
   "Eq.rec",
   "HSub.hSub",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Eq.symm",
   "instLTNat",
   "Nat.succ",
   "Nat.lt_of_sub_pos",
   "Eq"],
  "name": "Nat.lt_of_sub_eq_succ",
  "constType": "∀ {m n l : ℕ}, m - n = Nat.succ l → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "DivisionRing",
   "DivisionRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Exists", "Classical.indefiniteDescription", "Subtype.val"],
  "name": "Classical.choose",
  "constType": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "constCategory": "Definition"},
 {"references":
  ["Group.toDivisionMonoid",
   "Subgroup.instInfSetSubgroup.proof_1",
   "Membership.mem",
   "Subsemigroup.carrier",
   "Submonoid.mk",
   "MulOneClass.toMul",
   "Set.mem_iInter₂",
   "Submonoid.one_mem'",
   "Submonoid.instInfSetSubmonoid",
   "Set.mem_biInter",
   "Set",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Subgroup.inv_mem",
   "Submonoid.copy",
   "Iff.mp",
   "iInf",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Set.iInter",
   "Subgroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "Inv.inv",
   "Subgroup.instSetLikeSubgroup",
   "SetLike.coe"],
  "name": "Subgroup.instInfSetSubgroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)) {x : G},\n  x ∈\n      {\n            toSubsemigroup :=\n              (Submonoid.copy (⨅ S ∈ s, S.toSubmonoid) (⋂ S ∈ s, ↑S)\n                  (_ : ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toSubmonoid))).toSubsemigroup,\n            one_mem' :=\n              (_ :\n                1 ∈\n                  (Submonoid.copy (⨅ S ∈ s, S.toSubmonoid) (⋂ S ∈ s, ↑S)\n                        (_ :\n                          ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toSubmonoid))).toSubsemigroup.carrier) }.toSubsemigroup.carrier →\n    x⁻¹ ∈ ⋂ x ∈ s, ↑x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NonUnitalNonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "HAdd.hAdd",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.toAddAction.proof_2",
  "constType":
  "∀ (M : Type u_1) [inst : AddMonoid M] (a b c : M), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Subsingleton.intro",
   "Decidable.isFalse",
   "Subsingleton",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "Eq"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "OrderedAddCommMonoid",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "LinearOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "DecidableRel"],
  "name": "LinearOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² →\n                        LinearOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "OfNat.ofNat", "NeZero"],
  "name": "NeZero.out",
  "constType":
  "∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Set",
   "MeasurableSet",
   "Singleton.singleton",
   "MeasurableSpace"],
  "name": "MeasurableSingletonClass.mk",
  "constType":
  "∀ {α : Type u_7} [inst : MeasurableSpace α], (∀ (x : α), MeasurableSet {x}) → MeasurableSingletonClass α",
  "constCategory": "Other"},
 {"references":
  ["EquivLike",
   "Function.LeftInverse",
   "outParam",
   "Function.RightInverse",
   "Eq"],
  "name": "EquivLike.mk",
  "constType":
  "{E : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      (coe : E → α → β) →\n        (inv : E → β → α) →\n          (∀ (e : E), Function.LeftInverse (inv e) (coe e)) →\n            (∀ (e : E), Function.RightInverse (inv e) (coe e)) →\n              (∀ (e g : E), coe e = coe g → inv e = inv g → e = g) → EquivLike E α β",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toCommRing",
   "instHMul",
   "Rat",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Rat.field",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.instLinearOrderedFieldRat.proof_4",
  "constType": "∀ (a b : ℚ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "Preorder",
   "MulZeroClass.toMul",
   "Left.mul_pos"],
  "name": "mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "instHPow",
   "HAdd.hAdd",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Monoid.npow_succ",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "pow_succ",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a * a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Pi.addCommMonoid",
   "Finset.sum",
   "Finset",
   "Pi.evalAddMonoidHom",
   "AddCommMonoid.toAddMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "Pi.addZeroClass",
   "map_sum",
   "AddMonoidHom",
   "Eq",
   "AddCommMonoid"],
  "name": "Finset.sum_apply",
  "constType":
  "∀ {α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [inst : (a : α) → AddCommMonoid (β a)] (a : α) (s : Finset γ)\n  (g : γ → (a : α) → β a), Finset.sum s (fun c => g c) a = Finset.sum s fun c => g c a",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "dite",
   "Not",
   "rfl",
   "absurd",
   "Eq"],
  "name": "dif_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "True",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "Int.neg_mul",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "HMul.hMul",
   "Int.instNegInt",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.instCommRingInt.proof_7",
  "constType": "∀ (m : ℕ) (n : ℤ), -(↑m + 1) * n = -((↑m + 1) * n)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Inf.inf",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Preorder.le_trans",
   "Sup.mk",
   "implies_congr",
   "Preorder.toLE",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Inf.mk",
   "Eq.mpr",
   "Real.mk_inf",
   "Preorder.toLT",
   "Rat.instNegRat",
   "Real.ind_mk",
   "CauSeq.inf_le_right",
   "Eq.symm",
   "SemilatticeSup.toPartialOrder",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Real.mk_le",
   "Preorder.le_refl",
   "Rat",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "CauSeq",
   "CauSeq.instInfCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.15",
   "Preorder.mk",
   "CauSeq.le_sup_left",
   "Eq.ndrec",
   "CauSeq.sup_le",
   "CauSeq.le_sup_right",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.mk_sup",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le",
   "congrFun"],
  "name": "Real.instDistribLatticeReal.proof_8",
  "constType": "∀ (a b : ℝ), a ⊓ b ≤ b",
  "constCategory": "Theorem"},
 {"references": ["CommGroupWithZero", "Nontrivial"],
  "name": "CommGroupWithZero.toNontrivial",
  "constType": "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀], Nontrivial G₀",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "AddGroup",
   "NegMemClass.neg_mem",
   "AddSubgroup",
   "AddSubgroupClass.toNegMemClass",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toNeg",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.neg_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x : G}, x ∈ H → -x ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "Int.instSubInt",
   "PartialOrder.toPreorder",
   "instOfNatInt",
   "AddGroupWithOne.toSub",
   "Iff.rfl",
   "AddGroupWithOne.toIntCast",
   "OrderedRing",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "Int.cast_nonneg",
   "Preorder.toLE",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "OrderedRing.toRing",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "Iff",
   "Ring.toIntCast",
   "OrderedRing.toOrderedSemiring",
   "Eq.symm",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "sub_nonneg",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "OrderedRing.toPartialOrder",
   "Int.instAddGroupInt",
   "Eq.ndrec",
   "Int.cast",
   "propext",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "Int",
   "Int.instLEInt"],
  "name": "Int.cast_le",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedRing α] [inst_1 : Nontrivial α] {m n : ℤ}, ↑m ≤ ↑n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "Std.Logic._auxLemma.32",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "OfNat.ofNat",
   "SubmonoidClass.toOneMemClass",
   "SubgroupClass.toSubmonoidClass",
   "One.toOfNat1",
   "Subgroup.instSubgroupClassSubgroupToDivInvMonoidInstSetLikeSubgroup",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "InvOneClass.toOne",
   "OneMemClass.one_mem",
   "DivInvOneMonoid.toInvOneClass",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.one_mem",
  "constType": "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "ENNReal.instInvolutiveInvENNReal.proof_1",
   "ENNReal.instInvENNReal",
   "InvolutiveInv",
   "InvolutiveInv.mk"],
  "name": "ENNReal.instInvolutiveInvENNReal",
  "constType": "InvolutiveInv ENNReal",
  "constCategory": "Definition"},
 {"references": ["Equiv"],
  "name": "Equiv.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → α ≃ β → α → β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PreOpposite",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "add_left_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "neg_add_self",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid",
   "OrderTop",
   "LinearOrderedAddCommMonoidWithTop",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE"],
  "name": "LinearOrderedAddCommMonoidWithTop.toOrderTop",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoidWithTop α] → OrderTop α",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "Group.toDivisionMonoid",
   "Subgroup.mk",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulOneClass",
   "Set",
   "Eq.refl",
   "Submonoid.casesOn",
   "Eq",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subsemigroup.mk",
   "Eq.rec",
   "Subsemigroup.casesOn",
   "Subgroup",
   "Group",
   "Mul",
   "InvOneClass.toInv",
   "Membership.mem",
   "Submonoid.mk",
   "MulOneClass.toOne",
   "Subsemigroup",
   "Subgroup.casesOn",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "instHMul",
   "Eq.ndrec",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid",
   "HMul.hMul",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "Subgroup.instSetLikeSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (p q : Subgroup G), (fun s => s.carrier) p = (fun s => s.carrier) q → p = q",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.image2",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "Finite.Set.finite_image2",
   "Finite.of_fintype",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} {s : Set α} {t : Set β} (f : α → β → γ),\n  Set.Finite s → Set.Finite t → Set.Finite (Set.image2 f s t)",
  "constCategory": "Theorem"},
 {"references": ["Max.max", "Eq.refl", "Nat", "Nat.instMaxNat", "Eq"],
  "name": "Nat.linearOrder.proof_2",
  "constType": "∀ (a b : ℕ), max a b = max a b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instMulReal",
   "Real",
   "NormedDivisionRing.toNorm",
   "HMul.hMul",
   "Norm.norm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NormedDivisionRing.norm_mul'",
   "NormedDivisionRing",
   "NormedRing.toRing",
   "Ring.toNonAssocRing",
   "Eq"],
  "name": "norm_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NormedDivisionRing α] (a b : α), ‖a * b‖ = ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["One", "Mul"],
  "name": "Invertible",
  "constType": "{α : Type u} → [inst : Mul α] → [inst : One α] → α → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toInv",
   "Inv.inv",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "GroupWithZero.div_eq_mul_inv",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a b : G₀), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "Iff.rfl",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "Eq.ndrec",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "add_neg_eq_iff_eq_add",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a - b = c ↔ a = c + b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.5",
   "AddGroup.toSubtractionMonoid",
   "sub_pos",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Iff.mpr",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "AddGroup.toAddCancelMonoid",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "StrictOrderedRing.toPartialOrder",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "instHMul",
   "mul_sub",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.out_eq",
   "Setoid",
   "Quotient.mk''",
   "Quotient.out'",
   "Quotient",
   "Eq"],
  "name": "Quotient.out_eq'",
  "constType":
  "∀ {α : Sort u_1} {s₁ : Setoid α} (q : Quotient s₁), Quotient.mk'' (Quotient.out' q) = q",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonAssocSemiring",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u} [self : NonAssocSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Or",
   "and_congr_right",
   "Nat.le_of_dvd",
   "Nat.instDvdNat",
   "Nat.ne_of_lt",
   "Or.resolve_right",
   "Dvd.dvd",
   "Nat.le_of_succ_le",
   "LE.le",
   "instLTNat",
   "Eq",
   "Iff.intro",
   "And",
   "Or.imp_left",
   "Nat.Prime",
   "Iff",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "LE.le.lt_or_eq_dec",
   "Iff.trans",
   "instOfNatNat",
   "Nat",
   "Nat.prime_def_lt''",
   "Nat.succ",
   "Nat.decLe",
   "Nat.strictOrderedSemiring",
   "forall_congr'"],
  "name": "Nat.prime_def_lt",
  "constType": "∀ {p : ℕ}, Nat.Prime p ↔ 2 ≤ p ∧ ∀ m < p, m ∣ p → m = 1",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.add", "Real", "Add", "Add.mk"],
  "name": "Real.instAddReal",
  "constType": "Add ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "flip",
  "constType":
  "{α : Sort u} → {β : Sort v} → {φ : Sort w} → (α → β → φ) → β → α → φ",
  "constCategory": "Definition"},
 {"references": ["CompleteSemilatticeInf", "PartialOrder"],
  "name": "CompleteSemilatticeInf.toPartialOrder",
  "constType":
  "{α : Type u_9} → [self : CompleteSemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Mul"],
  "name": "Mul.mul",
  "constType": "{α : Type u} → [self : Mul α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "implies_congr",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Preorder.toLE",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.mpr",
   "Iff",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "id",
   "Neg.toHasAbs",
   "CauSeq.le_antisymm",
   "Real.instLTReal",
   "Mathlib.Data.Real.Basic._auxLemma.7",
   "Real.mk_le",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "LE.le",
   "Preorder.mk",
   "CauSeq.equiv",
   "And",
   "Eq.ndrec",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "propext",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "LT.lt",
   "Real.mk",
   "le_refl",
   "congr",
   "Not",
   "HasEquiv.Equiv",
   "congrArg",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.partialOrder.proof_4",
  "constType": "∀ (a b : ℝ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "constCategory": "Other"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Singleton.singleton",
   "Finset.instMembershipFinset",
   "Eq",
   "Finset.instSingletonFinset"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.28",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "Semiring",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_mul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Mathlib.Meta.NormNum.isNat_mul.match_1",
   "Nat.mul",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → Nat.mul a' b' = c → Mathlib.Meta.NormNum.IsNat (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "LeftDistribClass.mk",
   "LeftDistribClass",
   "Distrib.left_distrib",
   "Distrib",
   "Distrib.toMul"],
  "name": "Distrib.leftDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], LeftDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.mk",
   "PartialOrder.toPreorder",
   "lowerBounds_insert",
   "Set",
   "InfSet.sInf",
   "Inter.inter",
   "Set.Iic",
   "Sup.mk",
   "And.left",
   "Insert.insert",
   "Preorder.toLE",
   "True",
   "And.right",
   "upperBounds",
   "Set.instSingletonSet",
   "lowerBounds_singleton",
   "Eq.trans",
   "Mathlib.Data.Set.Basic._auxLemma.25",
   "SemilatticeSup.toPartialOrder",
   "Membership.mem",
   "IsGLB",
   "setOf",
   "SemilatticeSup.mk",
   "InfSet",
   "LE.le",
   "PartialOrder",
   "Set.instMembershipSet",
   "And",
   "eq_true",
   "of_eq_true",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
   "lowerBounds",
   "PartialOrder.le_antisymm",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "and_self",
   "Set.instInterSet",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf.proof_6",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α] (isGLB_sInf : ∀ (s : Set α), IsGLB s (sInf s)) (a b c : α),\n  a ≤ b → a ≤ c → a ≤ sInf {b, c}",
  "constCategory": "Theorem"},
 {"references": ["propext", "IsEmpty.forall_iff", "IsEmpty", "True", "Eq"],
  "name": "Mathlib.Logic.IsEmpty._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} [inst : IsEmpty α] {p : α → Prop}, (∀ (a : α), p a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Subtype.mk",
   "Subtype",
   "Preorder.toLE",
   "MulPosMono",
   "CovariantClass.elim"],
  "name": "mul_le_mul_of_nonneg_right",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],\n  b ≤ c → 0 ≤ a → b * a ≤ c * a",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "RatCast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ratCast",
  "constType": "RatCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "inferInstance",
   "Fintype",
   "AddGroup",
   "letFun",
   "AddSubgroup",
   "Subtype.fintype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership"],
  "name":
  "AddSubgroup.instFintypeSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
  "constType":
  "{G : Type u_1} →\n  [inst : AddGroup G] →\n    (K : AddSubgroup G) → [inst_1 : DecidablePred fun x => x ∈ K] → [inst_2 : Fintype G] → Fintype ↥K",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Subtype.property",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "Set.image",
   "Set.instMembershipSet"],
  "name": "Equiv.Set.imageOfInjOn.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (s : Set α) (p : ↑(f '' s)), ↑p ∈ f '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedAddCommGroup",
   "OrderedRing",
   "OrderedRing.add_le_add_left",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "OrderedRing.toPartialOrder",
   "OrderedRing.toRing",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "OrderedRing.toOrderedAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "add_nonpos",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Real.instOneReal",
   "DiscreteMeasurableSpace.toMeasurableAdd₂",
   "Semiring.toNatCast",
   "Linarith.le_of_le_of_eq",
   "Real.linearOrder",
   "inferInstance",
   "IsROrC.charZero_isROrC",
   "instOfNat",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "AddCommMagma.toAdd",
   "DivisionRing.toInv",
   "refPackage.X₀₁",
   "Prod.instMeasurableSpace",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Linarith.le_of_eq_of_le",
   "instNatAtLeastTwo",
   "congr",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "DivisionRing.toDivisionSemiring",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "sub_nonpos_of_le",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "is_tau_min",
   "IsCancelAdd.toIsRightCancelAdd",
   "tau_minimizes",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedRing.toOrderedSemiring",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.instLTReal",
   "Mathlib.Tactic.Ring.mul_add",
   "add_lt_of_le_of_neg",
   "Field.toSemifield",
   "Neg.neg",
   "LE.le",
   "Real.instDivisionRingReal",
   "OrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.isNat_mul",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "AddSubgroup.instSetLikeAddSubgroup",
   "And.casesOn",
   "Eq.trans",
   "Nat.cast_one",
   "Finite.to_countable",
   "Real.field",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Eq.mp",
   "Real.instAddGroupReal",
   "refPackage.hmeas2",
   "Mathlib.Tactic.Ring.mul_one",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "tau",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "sub_eq_zero_of_eq",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "refPackage",
   "IsCancelAdd.toIsLeftCancelAdd",
   "tau_strictly_decreases",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "NonUnitalNonAssocSemiring.toMul",
   "instCountableProd",
   "MeasureTheory.MeasureSpace",
   "Bool",
   "ProbabilityTheory.IsUniform",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Iff.mpr",
   "Real.orderedRing",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.neg_congr",
   "HDiv.hDiv",
   "instHSub",
   "HPow.hPow",
   "neg_eq_zero",
   "_private.PFR.EntropyPFR.0.tau._eq_1",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Mathlib.Meta.NormNum.isRat_div",
   "Field.toDiv",
   "AddCommGroup",
   "Finite.of_fintype",
   "Int",
   "refPackage.hmeas1",
   "SetLike.coe",
   "Inv.inv",
   "Exists",
   "Real",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Real.instAddCommGroupReal",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "tau_minimizer_exists",
   "CancelDenoms.add_subst",
   "Linarith.mul_eq",
   "Mathlib.Meta.NormNum.isRat_mul",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "rdist_symm",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "Int.mul",
   "sub_neg_of_lt",
   "Bool.false",
   "Real.instPreorderReal",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "Real.instLEReal",
   "Real.instMulReal",
   "Real.commRing",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "AddZeroClass.toZero",
   "MeasurableSingletonClass",
   "Fintype",
   "rdist",
   "Linarith.eq_of_eq_of_eq",
   "Nat",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "exists_isUniform_of_rdist_eq_zero",
   "Real.partialOrder",
   "Nat.rawCast",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "refPackage.X₀₂",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "congrArg",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "refPackage.η",
   "Mathlib.Meta.NormNum.isNat_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "instFiniteRange",
   "Preorder.toLT",
   "rdist_triangle",
   "instHPow",
   "Ring.toSub",
   "AddSubgroup",
   "AddCommMonoid.toAddCommSemigroup",
   "DivisionRing.toDiv",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero"],
  "name": "entropic_PFR_conjecture",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [inst_4 : AddCommGroup G]\n  [inst_5 : ElementaryAddCommGroup G 2] [inst_6 : Fintype G] [inst_7 : MeasurableSpace G]\n  [inst_8 : MeasurableSingletonClass G] (p : refPackage Ω₀₁ Ω₀₂ G),\n  p.η = 1 / 9 →\n    ∃ H Ω mΩ U,\n      MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n        Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ d[p.X₀₁ # U] + d[p.X₀₂ # U] ≤ 11 * d[p.X₀₁ # p.X₀₂]",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.negSucc_mul_subNatNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Int.add_comm",
   "True",
   "Eq",
   "Nat.right_distrib",
   "Int.ofNat_mul_subNatNat",
   "Eq.mpr",
   "Nat.cast",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.left_distrib",
   "Nat.succ",
   "id",
   "Nat.succ_add",
   "eq_self",
   "Int.instMulInt",
   "Int.mul_add.match_1",
   "instAddNat",
   "Int.negOfNat",
   "instHAdd",
   "Int.instAddInt",
   "Nat.mul_comm",
   "Int.negOfNat_add",
   "instHMul",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "Int.negSucc",
   "Int.negOfNat_eq_subNatNat_zero",
   "Int.subNatNat_add",
   "HMul.hMul",
   "congr",
   "instMulNat",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.mul_add",
  "constType": "∀ (a b c : ℤ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddCommGroupWithOne",
   "autoParam",
   "Eq",
   "Zero.toOfNat0",
   "One",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Nat",
   "instAddNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instHAdd",
   "AddSemigroup.toAdd",
   "One.toOfNat1",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "instNatCastInt",
   "Int.negSucc",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "Int",
   "IntCast.intCast",
   "IntCast"],
  "name": "AddCommGroupWithOne.mk",
  "constType":
  "{R : Type u} →\n  [toAddCommGroup : AddCommGroup R] →\n    [toIntCast : IntCast R] →\n      [toNatCast : NatCast R] →\n        [toOne : One R] →\n          autoParam (NatCast.natCast 0 = 0) _auto✝ →\n            autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ), IntCast.intCast ↑n = ↑n) _auto✝² →\n                autoParam (∀ (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)) _auto✝³ → AddCommGroupWithOne R",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHSMul",
   "Trans.trans",
   "instOfNatInt",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "zero_zsmul",
   "succ_nsmul",
   "Eq",
   "Zero.toOfNat0",
   "zero_nsmul",
   "PProd",
   "Nat.cast",
   "AddMonoid.toZero",
   "PUnit",
   "HSMul.hSMul",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "SubNegMonoid",
   "Nat.below",
   "Nat.brecOn",
   "congr_arg",
   "instAddNat",
   "instHAdd",
   "Unit",
   "SubNegMonoid.SMulInt",
   "AddMonoid.toNatSMul",
   "zpow_ofNat.match_1",
   "SubNegMonoid.zsmul_succ'",
   "Nat.rec",
   "PProd.fst",
   "instNatCastInt",
   "SubNegMonoid.toAddMonoid",
   "instTransEq",
   "Int"],
  "name": "ofNat_zsmul",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a : G) (n : ℕ), ↑n • a = n • a",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.powerset",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.pmap",
   "Finset.powerset.proof_2",
   "Finset.mk",
   "Finset.powerset.proof_1"],
  "name": "Finset.powerset",
  "constType": "{α : Type u_1} → Finset α → Finset (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Monoid.toMulOneClass",
   "pow_one",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "pow_two",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Iff.mp", "Finite", "finite_iff_nonempty_fintype", "Nonempty"],
  "name": "nonempty_fintype",
  "constType": "∀ (α : Type u_4) [inst : Finite α], Nonempty (Fintype α)",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.elim.match_1"],
  "name": "Or.elim",
  "constType": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "constCategory": "Theorem"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "lt_iff_not_ge"],
  "name": "not_le",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Ne",
   "Finset.instEmptyCollectionFinset",
   "Finset.Nonempty",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.ne_empty_of_mem",
   "Finset.instMembershipFinset",
   "Exists.elim"],
  "name": "Finset.Nonempty.ne_empty",
  "constType": "∀ {α : Type u_1} {s : Finset α}, Finset.Nonempty s → s ≠ ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "ZeroHomClass.toFunLike",
   "ZeroHomClass",
   "FunLike.coe",
   "ZeroHomClass.map_zero",
   "Eq"],
  "name": "map_zero",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Zero M] [inst_1 : Zero N] [inst_2 : ZeroHomClass F M N] (f : F),\n  f 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le.dest.match_1",
   "LE.le",
   "rfl",
   "Eq",
   "instHMul",
   "instLENat",
   "Nat.le.dest",
   "Nat.le.intro",
   "Eq.rec",
   "letFun",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "Nat.left_distrib"],
  "name": "Nat.mul_le_mul_left",
  "constType": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Iff",
   "instOfNatInt",
   "instHAdd",
   "Iff.rfl",
   "LT.lt",
   "HAdd.hAdd",
   "LE.le",
   "Int",
   "Int.instLTInt",
   "Int.instLEInt",
   "Int.instAddInt"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "One",
   "NeZero.ne'",
   "One.toOfNat1"],
  "name": "zero_ne_one",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 0 ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "one_div",
   "MeasureTheory.IsProbabilityMeasure",
   "CanonicallyOrderedCommSemiring.toOne",
   "Real.instOneReal",
   "Eq",
   "MeasurableSingletonClass",
   "ENNReal",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "MeasureTheory.OuterMeasure.measureOf",
   "Nat.cast",
   "ENNReal.toReal_nat",
   "Finset.toSet",
   "HDiv.hDiv",
   "Real.instInvReal",
   "Fintype.card_coe",
   "Nat",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "Finset.Subtype.fintype",
   "Subtype",
   "instHDiv",
   "ProbabilityTheory.IsUniform.measure_preimage_of_mem",
   "Finset.instMembershipFinset",
   "MeasureTheory.Measure.real",
   "DivInvMonoid.toInv",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "ENNReal.instDivInvMonoidENNReal",
   "congr",
   "Singleton.singleton",
   "MeasureTheory.measureReal_def",
   "ENNReal.toReal",
   "congrArg",
   "MeasurableSpace",
   "Inv.inv",
   "Finset.card",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "Set",
   "Real",
   "Eq.refl",
   "LinearOrderedField.toDiv",
   "True",
   "MeasureTheory.Measure",
   "Set.instSingletonSet",
   "ENNReal.toReal_inv",
   "Finset",
   "Measurable",
   "id",
   "DivInvMonoid.toDiv",
   "eq_self",
   "Membership.mem",
   "Set.preimage",
   "One.toOfNat1",
   "Fintype.card",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "Real.instDivisionRingReal",
   "Countable",
   "Eq.ndrec",
   "Nat.card",
   "ProbabilityTheory.IsUniform"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_of_mem",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Finset S}\n  [inst_2 : MeasureTheory.IsProbabilityMeasure μ],\n  ProbabilityTheory.IsUniform (↑H) X →\n    Measurable X → ∀ {s : S}, s ∈ H → μ.real (X ⁻¹' {s}) = 1 / ↑(Nat.card { x // x ∈ H })",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Real.instSubReal",
   "Real.instMulReal",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instAddMonoidReal",
   "Real.commRing",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "MulZeroClass.toZero",
   "sub_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "Complex.ofReal'",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.ext_iff",
   "Complex.re",
   "Complex.im",
   "Real.instZeroReal",
   "And",
   "instHMul",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Complex",
   "add_zero",
   "congrArg",
   "Complex.instMulComplex",
   "and_self"],
  "name": "Complex.ofReal_mul",
  "constType": "∀ (r s : ℝ), ↑(r * s) = ↑r * ↑s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
   "Semiring.mk",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.npow",
   "OrderedSemiring.mk",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
   "CanonicallyOrderedCommSemiring.toOne",
   "OrderedCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "OrderedCommSemiring.mk",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : CanonicallyOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Inter",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "And",
   "Exists",
   "Iff",
   "DecidableEq",
   "HSub.hSub",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_image₂",
   "Sub",
   "Finset.sub",
   "Eq"],
  "name": "Finset.mem_sub",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Sub α] {s t : Finset α} {a : α},\n  a ∈ s - t ↔ ∃ b c, b ∈ s ∧ c ∈ t ∧ b - c = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SubNegMonoid.toSub",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toSub",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "GE.ge", "LE", "LE.le"],
  "name": "ge_iff_le",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, x ≥ y ↔ y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedCommRing",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial"],
  "name": "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedCommRing α], Nontrivial α",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "OfNat.ofNat",
   "Set",
   "Classical.decPred",
   "Set.instMembershipSet",
   "ite"],
  "name": "Set.indicator",
  "constType":
  "{α : Type u_1} → {M : Type u_4} → [inst : Zero M] → Set α → (α → M) → α → M",
  "constCategory": "Definition"},
 {"references": ["Set", "Add", "AddSubsemigroup"],
  "name": "AddSubsemigroup.carrier",
  "constType": "{M : Type u_4} → [inst : Add M] → AddSubsemigroup M → Set M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.card",
   "Finset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Multiset.card_attach",
   "Nat",
   "Subtype",
   "Eq"],
  "name": "Finset.card_attach",
  "constType":
  "∀ {α : Type u_1} {s : Finset α}, Finset.card (Finset.attach s) = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instLinearOrderedRingReal",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedCommRing.toOrderedCommRing",
   "CanonicallyOrderedCommSemiring",
   "LinearOrderedRing.noZeroDivisors",
   "NNReal",
   "Nonneg.canonicallyOrderedCommSemiring"],
  "name": "instNNRealCanonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring NNReal",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "Multiplicative",
   "AddGroup",
   "DivInvMonoid.zpow_succ'",
   "HMul.hMul",
   "Nat",
   "DivInvMonoid.toMonoid",
   "Nat.succ",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.zpow",
   "Eq",
   "Multiplicative.divInvMonoid"],
  "name": "Multiplicative.group.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] (n : ℕ) (a : Multiplicative α),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references": ["Covariant", "CovariantClass"],
  "name": "CovariantClass.elim",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [self : CovariantClass M N μ r], Covariant M N μ r",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Or",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "Real",
   "instENNRealZero",
   "Iff.not",
   "Eq",
   "not_or",
   "ENNReal.toReal_eq_zero_iff",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "And",
   "Iff",
   "CompleteLattice.toTop",
   "Iff.trans",
   "Not",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "ENNReal.toReal"],
  "name": "ENNReal.toReal_ne_zero",
  "constType": "∀ {a : ENNReal}, a.toReal ≠ 0 ↔ a ≠ 0 ∧ a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Real",
   "And.left",
   "True",
   "Eq",
   "Complex.re",
   "Iff.intro",
   "Complex.im",
   "And",
   "And.right",
   "Iff",
   "of_eq_true",
   "congr",
   "Complex",
   "Complex.ext",
   "congrArg",
   "Eq.trans",
   "and_self",
   "congrFun"],
  "name": "Complex.ext_iff",
  "constType": "∀ {z w : ℂ}, z = w ↔ z.re = w.re ∧ z.im = w.im",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "zero_add",
   "AddZeroClass.toZero",
   "Set.instSingletonSet",
   "Set.image2",
   "OfNat.ofNat",
   "Set.image2_left_identity",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Singleton.singleton",
   "AddZeroClass",
   "Eq"],
  "name": "Set.addZeroClass.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] (t : Set α), Set.image2 (fun x x_1 => x + x_1) {0} t = t",
  "constCategory": "Theorem"},
 {"references":
  ["disjointed",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet",
   "disjointed_le",
   "Set",
   "HasSubset.Subset",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "Nat"],
  "name": "disjointed_subset",
  "constType": "∀ {α : Type u_1} (f : ℕ → Set α) (n : ℕ), disjointed f n ⊆ f n",
  "constCategory": "Theorem"},
 {"references": ["HVAdd.mk", "VAdd.vadd", "VAdd", "HVAdd"],
  "name": "instHVAdd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : VAdd α β] → HVAdd α β β",
  "constCategory": "Definition"},
 {"references": ["InvolutiveInv.toInv", "InvolutiveInv", "Inv.inv", "Eq"],
  "name": "InvolutiveInv.inv_inv",
  "constType": "∀ {G : Type u_2} [self : InvolutiveInv G] (x : G), x⁻¹⁻¹ = x",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Norm",
   "Real",
   "Real.instSupReal",
   "Norm.mk",
   "Abs.abs",
   "Real.instNegReal"],
  "name": "Real.norm",
  "constType": "Norm ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Additive.ofMul.proof_1",
   "Additive.ofMul.proof_2",
   "Equiv.mk",
   "Additive"],
  "name": "Additive.ofMul",
  "constType": "{α : Type u} → α ≃ Additive α",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ c₁ a₂ b₂ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.1",
   "HAdd.hAdd",
   "Eq.refl",
   "IsCancelAdd.toIsRightCancelAdd",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddMonoid.toZero",
   "AddGroup.toAddCancelMonoid",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Eq.symm",
   "Nat.succ",
   "Eq.trans",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddRightCancelMonoid.toZero",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "AddMonoidWithOne.toOne",
   "Eq.mp",
   "congr",
   "congrArg",
   "Nat.casesOn"],
  "name": "charZero_of_inj_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddGroupWithOne R], (∀ (n : ℕ), ↑n = 0 → n = 0) → CharZero R",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedCommRing",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "add_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveInv", "Inv", "Inv.inv", "Eq"],
  "name": "InvolutiveInv.mk",
  "constType":
  "{G : Type u_2} → [toInv : Inv G] → (∀ (x : G), x⁻¹⁻¹ = x) → InvolutiveInv G",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "Equiv.mk"],
  "name": "Equiv.symm",
  "constType": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "Preorder.lift", "Preorder", "Subtype"],
  "name": "Subtype.preorder",
  "constType":
  "{α : Type u} → [inst : Preorder α] → (p : α → Prop) → Preorder (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "congrArg",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul"],
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → b ≤ 0 → a * b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_succ",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Complex.arg",
   "Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Complex.arg_zero",
   "OfNat.ofNat",
   "Real",
   "AbsoluteValue",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.zero_mul",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Eq",
   "Complex.Complex.addGroupWithOne",
   "Zero.toOfNat0",
   "Real.log_zero",
   "Complex.instSemiringComplex",
   "AbsoluteValue.zeroHomClass",
   "ZeroHomClass.toFunLike",
   "map_zero",
   "MulZeroClass.toZero",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Complex.I",
   "eq_self",
   "Complex.ofReal'",
   "Complex.abs",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Complex.instZeroComplex",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Complex.instAddComplex",
   "NormedField.toNormedCommRing",
   "Real.orderedSemiring",
   "Real.instZeroReal",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "Real.log",
   "of_eq_true",
   "OrderedSemiring.toSemiring",
   "congr",
   "HMul.hMul",
   "Complex.log",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Complex",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Complex.instMulComplex",
   "congrFun"],
  "name": "Complex.log_zero",
  "constType": "Complex.log 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "DivInvMonoid.div_eq_mul_inv",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "refPackage",
   "Real.instLTReal",
   "Real.natCast",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "One.toOfNat1",
   "LE.le",
   "Real.instOneReal",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "instHMul",
   "MeasureTheory.MeasureSpace",
   "LT.lt",
   "instNatAtLeastTwo",
   "HMul.hMul",
   "instOfNatNat",
   "Measurable",
   "Nat",
   "MeasurableSpace",
   "instOfNat"],
  "name": "refPackage.mk",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} →\n          [inst_2 : MeasurableSpace G] →\n            (X₀₁ : Ω₀₁ → G) →\n              (X₀₂ : Ω₀₂ → G) → Measurable X₀₁ → Measurable X₀₂ → (η : ℝ) → 0 < η → 8 * η ≤ 1 → refPackage Ω₀₁ Ω₀₂ G",
  "constCategory": "Other"},
 {"references":
  ["Decidable.decide",
   "Decidable.isFalse",
   "Bool.false",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Bool",
   "rfl",
   "absurd",
   "decide_eq_false.match_1",
   "Eq"],
  "name": "decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬p → decide p = false",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Function.Bijective",
   "Function.bijective_iff_existsUnique",
   "Subtype.val",
   "Set",
   "Quotient",
   "QuotientAddGroup.leftRel",
   "AddSubgroup.mem_leftTransversals_iff_existsUnique_quotient_mk''_eq",
   "Set.restrict",
   "Set.instMembershipSet",
   "Eq",
   "Iff.symm",
   "Iff",
   "AddGroup",
   "Set.Elem",
   "Quotient.mk''",
   "AddSubgroup",
   "AddSubgroup.leftTransversals",
   "Iff.trans",
   "ExistsUnique",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.mem_leftTransversals_iff_bijective",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {S : Set G},\n  S ∈ AddSubgroup.leftTransversals ↑H ↔ Function.Bijective (Set.restrict S Quotient.mk'')",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.ext_cauchy",
   "AddMonoid.toAddZeroClass",
   "True",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "Real.cauchy_zero",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "Rat.instNegRat",
   "Eq.trans",
   "Add.mk",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "add_assoc",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "CauSeq.Completion.Cauchy.ring",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "congr",
   "add_zero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "congrFun"],
  "name": "Real.commRing.proof_3",
  "constType": "∀ (a : ℝ), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DivisionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "MulOneClass",
   "Set",
   "Preorder.le_trans",
   "LT.mk",
   "Preorder.toLE",
   "SetLike.instMembership",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Membership.mem",
   "SemilatticeSup.le_sup_left",
   "Submonoid.instSetLikeSubmonoid",
   "Preorder.le_refl",
   "SemilatticeSup.mk",
   "completeLatticeOfInf",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "SetLike.instPartialOrder",
   "And",
   "LT.lt",
   "SemilatticeSup.le_sup_right",
   "SemilatticeSup.sup_le",
   "Submonoid",
   "PartialOrder.le_antisymm",
   "And.intro",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.lt_iff_le_not_le",
   "SetLike.coe"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_11",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x x_1 x_2 : Submonoid M),\n  x ≤ x_1 → x ≤ x_2 → ∀ x_3 ∈ x, x_3 ∈ ↑x_1 ∧ x_3 ∈ ↑x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Real.cos",
   "Membership.mem",
   "OfNat.ofNat",
   "Set.Icc",
   "Classical.choose",
   "Real.natCast",
   "Real",
   "Real.instMulReal",
   "Set",
   "One.toOfNat1",
   "Eq",
   "Set.instMembershipSet",
   "Real.instOneReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "instHMul",
   "And",
   "Real.instPreorderReal",
   "Real.exists_cos_eq_zero",
   "HMul.hMul",
   "instOfNat",
   "Real.pi.proof_1"],
  "name": "Real.pi",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.wrapped._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.18520",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.map",
  "constType":
  "{α : Type u_8} →\n  {β : Type u_9} →\n    [inst : MeasurableSpace β] →\n      [inst_1 : MeasurableSpace α] → (α → β) → MeasureTheory.Measure α → MeasureTheory.Measure β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or.inl",
   "Set",
   "Insert.insert",
   "rfl",
   "Set.instInsertSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.mem_insert",
  "constType": "∀ {α : Type u} (x : α) (s : Set α), x ∈ insert x s",
  "constCategory": "Theorem"},
 {"references": ["Set.insert", "Set", "Insert", "Insert.mk"],
  "name": "Set.instInsertSet",
  "constType": "{α : Type u_1} → Insert α (Set α)",
  "constCategory": "Definition"},
 {"references": ["Quot"],
  "name": "Quot.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → α → Quot r",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["AddSubmonoid.instInfAddSubmonoid.proof_1",
   "AddZeroClass.toAdd",
   "Inf.mk",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.mk",
   "Inf",
   "Set",
   "Inter.inter",
   "AddSubmonoid.mk",
   "AddSubmonoid",
   "AddZeroClass",
   "AddSubmonoid.instInfAddSubmonoid.proof_2",
   "SetLike.coe",
   "Set.instInterSet"],
  "name": "AddSubmonoid.instInfAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → Inf (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "OrderedAddCommGroup.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedAddCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidHom.addMonoidHomClass.proof_2",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "AddMonoidHom.map_add'",
   "ZeroHom.toFun",
   "FunLike.mk",
   "AddMonoidHomClass",
   "AddMonoidHomClass.mk",
   "AddMonoidHom.toZeroHom",
   "AddZeroClass",
   "AddMonoidHom.addMonoidHomClass.proof_1",
   "AddMonoidHom"],
  "name": "AddMonoidHom.addMonoidHomClass",
  "constType":
  "{M : Type u_3} → {N : Type u_4} → [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → AddMonoidHomClass (M →+ N) M N",
  "constCategory": "Definition"},
 {"references":
  ["NNReal.toReal",
   "Exists",
   "PartialOrder.toPreorder",
   "Real",
   "Real.instLEReal",
   "ENNReal.ofReal",
   "CanLift.prf",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal.canLift",
   "Eq.mpr",
   "Iff",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "NNReal",
   "id",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "instNNRealStrictOrderedSemiring",
   "Real.toNNReal",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "CompleteLattice.toTop",
   "Mathlib.Data.Real.ENNReal._auxLemma.19",
   "congrArg",
   "ENNReal.toReal",
   "Real.toNNReal_le_iff_le_coe",
   "OrderedSemiring.toPartialOrder",
   "congrFun",
   "ENNReal.ofNNReal"],
  "name": "ENNReal.ofReal_le_iff_le_toReal",
  "constType":
  "∀ {a : ℝ} {b : ENNReal}, b ≠ ⊤ → (ENNReal.ofReal a ≤ b ↔ a ≤ b.toReal)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "IntCast.mk",
   "instNatCastInt",
   "Nat",
   "Int",
   "rfl",
   "IntCast.intCast",
   "Eq"],
  "name": "Int.instCommRingInt.proof_8",
  "constType": "∀ (x : ℕ), IntCast.intCast ↑x = IntCast.intCast ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Real.instCommSemiringReal",
   "Semiring",
   "Real"],
  "name": "Real.semiring",
  "constType": "Semiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Membership.mem",
   "OfNat.ofNat",
   "Set",
   "Real",
   "Real.instLEReal",
   "Real.instSupReal",
   "dite",
   "FunLike.coe",
   "Real.log.proof_1",
   "Subtype.le",
   "Set.Ioi",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.expOrderIso",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.decidableEq",
   "RelIso.instRelHomClassRelIso",
   "Set.Elem",
   "RelIso",
   "Real.instPreorderReal",
   "Not",
   "Subtype.mk",
   "OrderIso.symm"],
  "name": "Real.log",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_add",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.succ.injEq",
   "implies_congr",
   "Eq",
   "Nat.zero_add",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "id"],
  "name": "Nat.add_left_cancel",
  "constType": "∀ {n m k : ℕ}, n + m = n + k → m = k",
  "constCategory": "Theorem"},
 {"references": ["Setoid"],
  "name": "Setoid.r",
  "constType": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "starMulOfComm",
   "MulOneClass.toMul",
   "Star.star",
   "InvolutiveStar.toStar",
   "CommSemiring",
   "HMul.hMul",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "StarMul.toInvolutiveStar",
   "StarMul.star_mul",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "starRingOfComm.proof_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (r s : R), star (r * s) = star s * star r",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "propext",
   "And.intro",
   "And.left",
   "True",
   "Eq"],
  "name": "and_true",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHAdd",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "HAdd.hAdd",
   "FunLike.coe",
   "Add",
   "AddHomClass.map_add",
   "Eq"],
  "name": "map_add",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Add M] [inst_1 : Add N] [inst_2 : AddHomClass F M N] (f : F)\n  (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references": ["AddCancelMonoid", "AddLeftCancelMonoid"],
  "name": "AddCancelMonoid.toAddLeftCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddLeftCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrder.le_total",
  "constType": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references": ["SMul"],
  "name": "SMul.mk",
  "constType": "{M : Type u} → {α : Type v} → (M → α → α) → SMul M α",
  "constCategory": "Other"},
 {"references":
  ["Subgroup.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddSubgroup.toSubgroup.proof_2",
   "AddSubgroup.toSubgroup.proof_4",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "RelIso.instRelHomClassRelIso",
   "Submonoid.toAddSubmonoid",
   "AddGroup",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "AddSubgroup",
   "RelIso",
   "Subgroup",
   "AddSubmonoid.mk",
   "AddSubgroup.toSubgroup.proof_5",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Multiplicative.mulOneClass",
   "OrderIso",
   "Submonoid.mk",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoid.toSubmonoid",
   "AddSubgroup.toSubgroup.proof_3",
   "FunLike.coe",
   "Additive.addZeroClass",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Monoid.toMulOneClass",
   "RelHomClass.toFunLike",
   "SetLike.instPartialOrder",
   "Multiplicative",
   "AddSubgroup.neg_mem'",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "Submonoid",
   "Equiv.mk",
   "Submonoid.instCompleteLatticeSubmonoid",
   "AddSubgroup.toSubgroup.proof_1",
   "Group.toDivInvMonoid",
   "AddSubgroup.toSubgroup.proof_6",
   "AddSubgroup.mk",
   "RelIso.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Additive",
   "Subgroup.instSetLikeSubgroup"],
  "name": "AddSubgroup.toSubgroup",
  "constType":
  "{A : Type u_4} → [inst : AddGroup A] → AddSubgroup A ≃o Subgroup (Multiplicative A)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Pi.instSub",
   "MeasurableSub₂.measurable_sub",
   "Measurable.prod_mk",
   "Prod.snd",
   "Prod.mk",
   "HSub.hSub",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Measurable.comp",
   "Prod.instMeasurableSpace"],
  "name": "Measurable.sub'",
  "constType":
  "∀ {G : Type u_2} {α : Type u_3} [inst : MeasurableSpace G] [inst_1 : Sub G] {m : MeasurableSpace α} {f g : α → G}\n  [inst_2 : MeasurableSub₂ G], Measurable f → Measurable g → Measurable (f - g)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing.toRing",
   "Field.toSemifield",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.toInv",
   "DivisionRing.zpow",
   "DivisionRing.zpow_neg'",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Nat",
   "Field.toDivisionRing",
   "Nat.succ",
   "Int",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Inv.inv"],
  "name": "CauSeq.Completion.Cauchy.field.proof_5",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℕ) (a : CauSeq.Completion.Cauchy abv),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "ProbabilityTheory.IdentDistrib",
   "autoParam",
   "MeasurableSpace",
   "AEMeasurable"],
  "name": "ProbabilityTheory.IdentDistrib.aemeasurable_fst",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {f : α → γ} {g : β → γ} {μ : autoParam (MeasureTheory.Measure α) _auto✝}\n  {ν : autoParam (MeasureTheory.Measure β) _auto✝¹}, ProbabilityTheory.IdentDistrib f g → AEMeasurable f",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "of_eq_true",
   "sub_add_eq_sub_sub_swap",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "add_sub_cancel",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "add_sub_add_right_eq_sub",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] (a b c : G), a + c - (b + c) = a - b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "CancelDenoms.neg_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e t : α}, n * e = t → n * -e = -t",
  "constCategory": "Theorem"},
 {"references": ["Set", "lowerBounds", "Set.Nonempty", "Preorder"],
  "name": "BddBelow",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["IsUnit.mul_mul_div",
   "Ne",
   "Ne.isUnit",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "GroupWithZero.toDiv",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "InvOneClass.toOne",
   "instHMul",
   "DivInvOneMonoid.toInvOneClass",
   "GroupWithZero",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "DivisionMonoid.toDivInvOneMonoid",
   "Eq.symm",
   "DivInvMonoid.toDiv"],
  "name": "mul_mul_div",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → a = a * b * (1 / b)",
  "constCategory": "Theorem"},
 {"references": ["funext", "Eq.rec", "rfl", "Eq"],
  "name": "forall_congr",
  "constType":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "inferInstance",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Semigroup"],
  "name": "Real.instSemigroupReal",
  "constType": "Semigroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["CompleteDistribLattice.iInf_sup_le_sup_sInf",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "SemilatticeSup.toSup",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "CompleteDistribLattice.toFrame",
   "Set.instMembershipSet",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "iInf",
   "of_eq_true",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Sup.sup",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_12",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), ⨅ b ∈ s, a ⊔ b ≤ a ⊔ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "add_le_add_left",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "instTransEq_1",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "zero_le_one",
   "AddMonoid.toZero",
   "CovariantClass",
   "instTransEq",
   "instNatAtLeastTwo",
   "LE",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "Eq.symm",
   "instOfNat"],
  "name": "one_le_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : LE α] [inst_2 : ZeroLEOneClass α]\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 1 ≤ 2",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "Classical.em"],
  "name": "em",
  "constType": "∀ (p : Prop), p ∨ ¬p",
  "constCategory": "Theorem"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.cast_add.match_1",
  "constType":
  "∀ (motive : ℤ → ℤ → Prop) (x x_1 : ℤ),\n  (∀ (m n : ℕ), motive (Int.ofNat m) (Int.ofNat n)) →\n    (∀ (m n : ℕ), motive (Int.ofNat m) (Int.negSucc n)) →\n      (∀ (m n : ℕ), motive (Int.negSucc m) (Int.ofNat n)) →\n        (∀ (m n : ℕ), motive (Int.negSucc m) (Int.negSucc n)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocRing.toIntCast",
   "NonAssocRing",
   "NonAssocRing.intCast_negSucc",
   "AddCommGroupWithOne.mk",
   "NonAssocRing.natCast_succ",
   "NonAssocRing.intCast_ofNat",
   "AddCommGroupWithOne",
   "NonAssocRing.toNatCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.natCast_zero",
   "NonAssocRing.toOne",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.toAddCommGroupWithOne",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → AddCommGroupWithOne α",
  "constCategory": "Definition"},
 {"references": ["And", "setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Icc",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → α → Set α",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LE α",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instLEReal",
   "Real.instSubReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Eq",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_2",
  "constType": "∀ (x y : ℝ), 0 ≤ |x - y|",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "NatCast.natCast",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.natCast_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references": ["Setoid.r", "List", "Multiset", "List.isSetoid", "Quot.mk"],
  "name": "Multiset.ofList",
  "constType": "{α : Type u_1} → List α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring",
   "Eq"],
  "name": "NonAssocSemiring.one_mul",
  "constType": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references": ["VAdd", "AddAction", "AddMonoid"],
  "name": "AddAction.toVAdd",
  "constType":
  "{G : Type u_10} → {P : Type u_11} → [inst : AddMonoid G] → [self : AddAction G P] → VAdd G P",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "PartialOrder.lift",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "Preorder.le_trans",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe_injective",
   "SetLike.coe",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "SetLike.instPartialOrder.proof_2",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] (a b c : A), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff.mp",
   "AddGroup",
   "Iff",
   "AddMonoid.toZero",
   "add_neg_self",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "add_lt_add_iff_left",
   "add_zero",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "neg_of_neg_pos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a → a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "AddSubgroup.toAddSubmonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.neg_mem'",
  "constType":
  "∀ {G : Type u_5} [inst : AddGroup G] (self : AddSubgroup G) {x : G}, x ∈ self.carrier → -x ∈ self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["Function.Injective", "Set", "Set.InjOn", "Set.injOn_of_injective"],
  "name": "Function.Injective.injOn",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "Preorder",
   "lt_self_iff_false",
   "Eq"],
  "name": "Mathlib.Order.Basic._auxLemma.2",
  "constType": "∀ {α : Type u} [inst : Preorder α] (x : α), (x < x) = False",
  "constCategory": "Theorem"},
 {"references": ["upperBounds", "Set", "Set.Nonempty", "Preorder"],
  "name": "BddAbove",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "Not", "not_and", "Eq"],
  "name": "Std.Logic._auxLemma.23",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (a → ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "Subtype"],
  "name": "MulPosStrictMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Rat.commSemiring",
   "Semiring",
   "Rat"],
  "name": "Rat.semiring",
  "constType": "Semiring ℚ",
  "constCategory": "Definition"},
 {"references":
  ["AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "Membership.mem",
   "OfNat.ofNat",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubgroupClass.toAddSubmonoidClass",
   "SetLike.instMembership",
   "Zero.toOfNat0",
   "AddGroup",
   "AddSubmonoidClass.toZeroMemClass",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "AddSubgroup.instSetLikeAddSubgroup",
   "ZeroMemClass.zero_mem",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.zero_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), 0 ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "PartialOrder.toPreorder",
   "Preorder.le_refl",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a : AddSubmonoid M), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommGroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "ProbabilityTheory.kernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "ProbabilityTheory.kernel.const.proof_1",
   "Pi.addZeroClass",
   "AddSubmonoid",
   "MeasurableSpace",
   "Subtype",
   "SetLike.instMembership",
   "Subtype.mk"],
  "name": "ProbabilityTheory.kernel.const",
  "constType":
  "(α : Type u_4) →\n  {β : Type u_5} →\n    [inst : MeasurableSpace α] → {x : MeasurableSpace β} → MeasureTheory.Measure β → ↥(ProbabilityTheory.kernel α β)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.toOne",
   "zpowRec",
   "Rat.commRing",
   "Int.negSucc",
   "Rat.instInvRat",
   "Rat",
   "CommRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Rat.field.proof_4",
  "constType":
  "∀ (n : ℕ) (a : ℚ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "outParam",
   "MonoidHomClass"],
  "name": "RingHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] →\n        [inst_1 : NonAssocSemiring β] →\n          [toMonoidHomClass : MonoidHomClass F α β] →\n            (∀ (f : F) (x y : α), f (x + y) = f x + f y) → (∀ (f : F), f 0 = 0) → RingHomClass F α β",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "AddGroup",
   "Subtype.val",
   "AddSubgroup.zero",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Subtype",
   "SetLike.instMembership",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), ↑0 = ↑0",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NormedField",
   "Eq.le",
   "Real",
   "Real.instMulReal",
   "NormedDivisionRing.toNorm",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "norm_mul",
   "instHMul",
   "NormedDivisionRing.toNormedRing",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Norm.norm",
   "NormedField.toNormedDivisionRing",
   "NormedRing.toRing"],
  "name": "NormedField.toNormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Semigroup", "Eq"],
  "name": "Semigroup.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "constCategory": "Other"},
 {"references": ["SeminormedRing", "NormedField"],
  "name": "NormedAlgebra",
  "constType":
  "(𝕜 : Type u_5) → (𝕜' : Type u_6) → [inst : NormedField 𝕜] → [inst : SeminormedRing 𝕜'] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["PseudoMetricSpace.toDist",
   "setOf",
   "Real.instLTReal",
   "Set",
   "LT.lt",
   "Real",
   "PseudoMetricSpace",
   "Dist.dist"],
  "name": "Metric.ball",
  "constType": "{α : Type u} → [inst : PseudoMetricSpace α] → α → ℝ → Set α",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Fintype.ofFinite",
   "Finite",
   "instFintypeProd",
   "Prod",
   "Finite.of_fintype"],
  "name": "Finite.instFiniteProd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Finite α] [inst : Finite β], Finite (α × β)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "WellFounded",
  "constType": "{α : Sort u} → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["OrderedCommMonoid", "PartialOrder"],
  "name": "OrderedCommMonoid.toPartialOrder",
  "constType": "{α : Type u_3} → [self : OrderedCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "lt_or_eq_of_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "LE.le.lt_or_eq",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a < b ∨ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["outParam", "FunLike", "Function.Injective", "EmbeddingLike", "FunLike.coe"],
  "name": "EmbeddingLike.mk",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} →\n    {β : outParam (Sort u_3)} →\n      [toFunLike : FunLike F α fun x => β] → (∀ (f : F), Function.Injective ⇑f) → EmbeddingLike F α β",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "HMul.hMul",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalRing.mul_assoc",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
  "constType":
  "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHSMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSMul.hSMul",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "AddMonoid.toAddZeroClass",
   "Nat",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq"],
  "name": "succ_nsmul",
  "constType":
  "∀ {M : Type u_2} [inst : AddMonoid M] (a : M) (n : ℕ), (n + 1) • a = a + n • a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegZeroMonoid",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.mk",
  "constType":
  "{G : Type u_2} → [toSubNegMonoid : SubNegMonoid G] → -0 = 0 → SubNegZeroMonoid G",
  "constCategory": "Other"},
 {"references":
  ["InvOneClass.toOne",
   "OfNat.ofNat",
   "InvOneClass.inv_one",
   "InvOneClass",
   "One.toOfNat1",
   "InvOneClass.toInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_one",
  "constType": "∀ {G : Type u_1} [inst : InvOneClass G], 1⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "OfNat",
  "constType": "Type u → ℕ → Type u",
  "constCategory": "Other"},
 {"references": ["AddLeftCancelSemigroup", "AddSemigroup"],
  "name": "AddLeftCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddLeftCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk", "_private.Mathlib.Data.Real.Basic.0.Real.le", "Real", "LE"],
  "name": "Real.instLEReal",
  "constType": "LE ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "HEq",
   "instHAdd",
   "eq_of_heq",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int.add",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HAdd.hAdd →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.add x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HAdd.hAdd) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.add x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HAdd.hAdd (↑n) (↑n_1) n n_1 (Int.add n n_1) (_ : HAdd.hAdd = HAdd.hAdd)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.add n n_1 = Int.add n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "Function.Injective",
   "Subtype.val",
   "AddSubgroup",
   "Subtype.coe_injective",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership"],
  "name": "AddSubgroup.toAddGroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedField.toField",
   "Field.toCommRing",
   "instHMul",
   "NormedField",
   "CommRing.toRing",
   "HMul.hMul",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NormedField.toNormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid", "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.OuterMeasure.trim_congr",
   "Set",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "Eq.refl",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Eq.ndrec",
   "MeasureTheory.Measure.trimmed",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasurableSet",
   "MeasureTheory.OuterMeasure",
   "Eq.symm",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim",
   "id"],
  "name": "MeasureTheory.Measure.ext",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ₁ μ₂ : MeasureTheory.Measure α},\n  (∀ (s : Set α), MeasurableSet s → ↑↑μ₁ s = ↑↑μ₂ s) → μ₁ = μ₂",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["MulHomClass",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "Semiring",
   "OrderedRing",
   "IsDomain",
   "AbsoluteValue",
   "MonoidWithZeroHomClass",
   "MulHomClass.toFunLike",
   "AbsoluteValue.mulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "MonoidWithZeroHomClass.mk",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "AbsoluteValue.monoidWithZeroHomClass.proof_2",
   "AbsoluteValue.map_one",
   "AbsoluteValue.monoidWithZeroHomClass.proof_1",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "OrderedRing.toOrderedSemiring",
   "Nontrivial",
   "MonoidHomClass.mk"],
  "name": "AbsoluteValue.monoidWithZeroHomClass",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : OrderedRing S] →\n        [inst_2 : IsDomain S] → [inst_3 : Nontrivial R] → MonoidWithZeroHomClass (AbsoluteValue R S) R S",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass", "FunLike.coe"],
  "name": "RelHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} →\n          [toFunLike : FunLike F α fun x => β] → (∀ (f : F) {a b : α}, r a b → s (f a) (f b)) → RelHomClass F r s",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.mk",
  "constType":
  "{G : Type u_5} →\n  [inst : AddGroup G] →\n    (toAddSubmonoid : AddSubmonoid G) →\n      (∀ {x : G}, x ∈ toAddSubmonoid.carrier → -x ∈ toAddSubmonoid.carrier) → AddSubgroup G",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "instOfNatInt",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references": ["Nonempty"],
  "name": "Nonempty.intro",
  "constType": "∀ {α : Sort u}, α → Nonempty α",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "Or.inl",
   "instLENat",
   "Or.inr",
   "LT.lt",
   "GE.ge",
   "Or.casesOn",
   "Nat",
   "instLTNat"],
  "name": "Nat.lt_or_ge.match_2",
  "constType":
  "∀ (n m : ℕ) (motive : n < m ∨ n ≥ m → Prop) (x : n < m ∨ n ≥ m),\n  (∀ (h : n < m), motive (_ : n < m ∨ n ≥ m)) → (∀ (h : n ≥ m), motive (_ : n < m ∨ n ≥ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHMul",
   "mul_neg",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "congr",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "neg_mul",
   "congrArg",
   "Eq.trans",
   "True",
   "Eq"],
  "name": "neg_mul_comm",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = a * -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toOne",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Nat",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.mk",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} (inv : Invertible ↑denom),\n  a = ↑num * ⅟↑denom → Mathlib.Meta.NormNum.IsRat a num denom",
  "constCategory": "Other"},
 {"references":
  ["Equiv.plift", "PLift", "Finite", "Finite.of_equiv", "Equiv.symm"],
  "name": "instFinitePLift",
  "constType": "∀ {α : Sort u_1} [inst : Finite α], Finite (PLift α)",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Complex.commRing", "Ring", "CommRing.toRing", "Complex"],
  "name": "Complex.instRingComplex",
  "constType": "Ring ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Multiplicative.toAdd",
   "Set",
   "Eq.refl",
   "Submonoid.casesOn",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "Submonoid.mk",
   "Membership.mem",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.one_mem'",
   "MulOneClass.toOne",
   "AddSubmonoid.toAddSubsemigroup",
   "Subsemigroup",
   "One.toOfNat1",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "AddSubmonoid",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Multiplicative",
   "Subsemigroup.mul_mem'",
   "Submonoid",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid.proof_5",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] (x : Submonoid (Multiplicative A)),\n  (fun S =>\n        {\n          toSubsemigroup :=\n            { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n              mul_mem' :=\n                (_ :\n                  ∀ {a b : Multiplicative A},\n                    a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                      b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S → Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n          one_mem' := (_ : 0 ∈ S.carrier) })\n      ((fun S =>\n          {\n            toAddSubsemigroup :=\n              { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n                add_mem' :=\n                  (_ :\n                    ∀ {a b : A},\n                      a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n            zero_mem' := (_ : 1 ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.EventuallyEq", "Filter", "Eq.symm", "Filter.Eventually.mono", "Eq"],
  "name": "Filter.EventuallyEq.symm",
  "constType":
  "∀ {α : Type u} {β : Type v} {f g : α → β} {l : Filter α}, f =ᶠ[l] g → g =ᶠ[l] f",
  "constCategory": "Theorem"},
 {"references": ["DivInvMonoid", "Div"],
  "name": "DivInvMonoid.toDiv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Semiring.toModule.proof_1",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Semiring.toModule.proof_2",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Semiring.toModule.proof_4",
   "Module",
   "Semiring.toModule.proof_3",
   "MulActionWithZero.toMulAction",
   "Module.mk"],
  "name": "Semiring.toModule",
  "constType": "{R : Type u_2} → [inst : Semiring R] → Module R R",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Decidable.isFalse",
   "propext",
   "instDecidableEqProp.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "instDecidableEqProp.proof_1",
   "Eq"],
  "name": "instDecidableEqProp",
  "constType": "{p q : Prop} → [d : Decidable (p ↔ q)] → Decidable (p = q)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.IsUniform.mk",
   "Eq",
   "ProbabilityTheory.IsUniform.measure_preimage_compl",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasurableSet",
   "Eq.symm",
   "id",
   "Membership.mem",
   "Set.preimage",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "ProbabilityTheory.IdentDistrib",
   "MeasurableSet.singleton",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Set.instMembershipSet",
   "ProbabilityTheory.IsUniform.eq_of_mem",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "ProbabilityTheory.IdentDistrib.measure_mem_eq",
   "MeasurableSet.compl",
   "Singleton.singleton",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform.of_identDistrib",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S]\n  {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Set S} {Ω' : Type u_1} [inst_2 : MeasurableSpace Ω'],\n  ProbabilityTheory.IsUniform H X →\n    ∀ {X' : Ω' → S} {μ' : MeasureTheory.Measure Ω'},\n      ProbabilityTheory.IdentDistrib X X' → MeasurableSet H → ProbabilityTheory.IsUniform H X'",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "EquivLike.coe",
   "RingHomClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "RingEquivClass.toRingHomClass.proof_5",
   "FunLike.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "RingEquivClass.toRingHomClass.proof_2",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "RingEquivClass.toRingHomClass.proof_1",
   "MulEquivClass.toEquivLike",
   "RingEquivClass.toRingHomClass.proof_3",
   "RingEquivClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingEquivClass.toMulEquivClass",
   "RingEquivClass.toRingHomClass.proof_4",
   "MonoidHomClass.mk"],
  "name": "RingEquivClass.toRingHomClass",
  "constType":
  "{F : Type u_1} →\n  {R : Type u_4} →\n    {S : Type u_5} →\n      [inst : NonAssocSemiring R] → [inst_1 : NonAssocSemiring S] → [h : RingEquivClass F R S] → RingHomClass F R S",
  "constCategory": "Definition"},
 {"references":
  ["Group.toDivisionMonoid",
   "Subsemigroup.carrier",
   "Subgroup.mk",
   "MulOneClass.toMul",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Eq.refl",
   "Subgroup.inv_mem'",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "RelIso.instRelHomClassRelIso",
   "Submonoid.toAddSubmonoid",
   "AddGroup",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "RelIso",
   "AddSubgroup",
   "Subgroup",
   "AddSubmonoid.mk",
   "Eq.symm",
   "InvOneClass.toInv",
   "Multiplicative.mulOneClass",
   "Membership.mem",
   "Submonoid.mk",
   "Submonoid.one_mem'",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoid.toSubmonoid",
   "Subgroup.casesOn",
   "FunLike.coe",
   "Additive.addZeroClass",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "Eq.ndrec",
   "Multiplicative",
   "AddSubgroup.neg_mem'",
   "DivInvOneMonoid.toInvOneClass",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Group.toDivInvMonoid",
   "AddSubgroup.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv",
   "Additive"],
  "name": "AddSubgroup.toSubgroup.proof_5",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] (x : Subgroup (Multiplicative A)),\n  (fun S =>\n        let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n        { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n          inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n      ((fun S =>\n          let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n          { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n            neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveInv", "Inv"],
  "name": "InvolutiveInv.toInv",
  "constType": "{G : Type u_2} → [self : InvolutiveInv G] → Inv G",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a (_ : a = a) → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.SigmaFinite",
   "MeasureTheory.Measure.FiniteSpanningSetsIn",
   "Set",
   "Set.univ",
   "MeasurableSpace",
   "Nonempty"],
  "name": "MeasureTheory.SigmaFinite.mk",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α},\n  Nonempty (MeasureTheory.Measure.FiniteSpanningSetsIn μ Set.univ) → MeasureTheory.SigmaFinite μ",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "eq_self",
   "Set.image2",
   "Prod.snd",
   "Set",
   "Prod.fst",
   "Mathlib.Data.Set.NAry._auxLemma.6",
   "True",
   "Eq",
   "of_eq_true",
   "Set.image_image",
   "SProd.sprod",
   "congr",
   "Prod",
   "Set.image",
   "congrArg",
   "Eq.trans"],
  "name": "Set.image_image2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {s : Set α} {t : Set β} (f : α → β → γ) (g : γ → δ),\n  g '' Set.image2 f s t = Set.image2 (fun a b => g (f a b)) s t",
  "constCategory": "Theorem"},
 {"references":
  ["add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "Add.add",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.toAdd",
   "left_comm",
   "Eq"],
  "name": "add_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + (b + c) = b + (a + c)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Dvd.intro",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderTop.toTop",
   "Ne",
   "Top.top",
   "Preorder.toLT",
   "LT.lt",
   "OrderTop",
   "ne_top_of_lt",
   "Preorder",
   "Preorder.toLE"],
  "name": "LT.lt.ne_top",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] {a b : α}, a < b → a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.not_not", "Iff", "Set", "Not", "Set.Infinite", "Set.Finite"],
  "name": "Set.not_infinite",
  "constType": "∀ {α : Type u} {s : Set α}, ¬Set.Infinite s ↔ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero",
   "Cardinal.toNat_pos",
   "ZeroHom.zeroHomClass",
   "Cardinal.partialOrder",
   "ZeroHom",
   "FunLike.coe",
   "instLTNat",
   "Eq",
   "Zero.toOfNat0",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "And",
   "Cardinal.aleph0",
   "Preorder.toLT",
   "propext",
   "ZeroHomClass.toFunLike",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Nat"],
  "name": "Mathlib.SetTheory.Cardinal.Basic._auxLemma.68",
  "constType":
  "∀ {c : Cardinal.{u_1}}, (0 < Cardinal.toNat c) = (c ≠ 0 ∧ c < Cardinal.aleph0)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SeminormedAddCommGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["inv_div",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid.zpow_succ'",
   "DivInvMonoid.zpow_zero'",
   "one_div",
   "One.toOfNat1",
   "inv_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "Eq",
   "DivInvMonoid.toInv",
   "DivInvMonoid.zpow",
   "DivInvMonoid.zpow_neg'",
   "DivisionMonoid",
   "Eq.mp",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "congrArg",
   "Eq.trans",
   "id",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "DivisionMonoid.toDivInvOneMonoid.proof_1",
  "constType": "∀ {α : Type u_1} [inst : DivisionMonoid α], 1⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "instOfNatNat",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "instAddNat",
   "instHAdd",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_5",
  "constType":
  "∀ (n : ℕ) (x : ℝ), Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Bool.false", "Rat", "LE", "Rat.blt", "Bool", "Eq"],
  "name": "Rat.instLERat",
  "constType": "LE ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Finset.coe_preimage",
   "HAdd.hAdd",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "add_left_injective",
   "Eq",
   "AddGroup",
   "Finset.image",
   "Finset.toSet",
   "Finset",
   "AddGroup.toAddCancelMonoid",
   "Set.image",
   "Finset.coe_image",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "Set.preimage",
   "instHAdd",
   "Neg.neg",
   "Finset.preimage",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Function.Injective.injOn",
   "DecidableEq",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Set.image_add_right",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "NegZeroClass.toNeg",
   "congrArg",
   "Finset.coe_injective"],
  "name": "Finset.image_add_right",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : AddGroup α] {t : Finset α} {b : α},\n  Finset.image (fun x => x + b) t =\n    Finset.preimage t (fun x => x + -b) (_ : Set.InjOn (fun x => x + -b) ((fun x => x + -b) ⁻¹' ↑t))",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "Subtype.val",
   "AddSubgroup.zero",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Subtype",
   "SetLike.instMembership",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), ↑0 = ↑0",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.decidableLT",
   "Decidable",
   "LinearOrder.toPartialOrder"],
  "name": "instDecidableLtToLTToPreorderToPartialOrder",
  "constType":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a < b)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubsemigroup.mem_carrier",
   "AddSubsemigroup.instSetLikeSubsemigroup",
   "propext",
   "Set",
   "Add",
   "AddSubsemigroup.carrier",
   "SetLike.instMembership",
   "Eq",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "Mathlib.GroupTheory.Subsemigroup.Basic._auxLemma.2",
  "constType":
  "∀ {M : Type u_1} [inst : Add M] {s : AddSubsemigroup M} {x : M}, (x ∈ s.carrier) = (x ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references": ["Real", "Complex"],
  "name": "Complex.im",
  "constType": "ℂ → ℝ",
  "constCategory": "Definition"},
 {"references": ["implies_dep_congr_ctx", "Eq"],
  "name": "implies_congr_ctx",
  "constType":
  "∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Set.Subset", "Set", "LE"],
  "name": "Set.instLESet",
  "constType": "{α : Type u_1} → LE (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "sub_self",
   "PartialOrder.toPreorder",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "AddGroupWithOne.toAddGroup",
   "Semiring.toNatCast",
   "Complex.Complex.addGroupWithOne",
   "Nat.cast",
   "AbsoluteValue.zeroHomClass",
   "Complex.instField",
   "Finset.range",
   "LinearOrderedCommMonoidWithZero.toZero",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Std.Classes.Order._auxLemma.3",
   "HDiv.hDiv",
   "Complex.instOneComplex",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Nat.strictOrderedSemiring",
   "Finset.sum_range_succ",
   "instHSub",
   "HPow.hPow",
   "Complex.abs",
   "Complex.instZeroComplex",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "eq_of_heq",
   "CauSeq.instSubCauSeq",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "SubadditiveHomClass.toFunLike",
   "Nat.zero",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.orderedSemiring",
   "LT.lt",
   "congr",
   "Field.toDiv",
   "MonoidWithZero.toZero",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "HEq",
   "Subtype.val",
   "IsCauSeq",
   "Real",
   "LT",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "CauSeq.lim_eq_of_equiv_const",
   "True",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
   "Finset",
   "map_zero",
   "Monoid.toNatPow",
   "zero_lt_one",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "absurd",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "CauSeq.lim",
   "Nat.linearOrderedCommMonoidWithZero",
   "Finset.sum",
   "Field.toSemifield",
   "Complex.instRingComplex",
   "One.toOfNat1",
   "CauSeq",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Monoid.toMulOneClass",
   "LE.le",
   "GroupWithZero.toMonoidWithZero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "InvOneClass.toOne",
   "Eq.ndrec",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "letFun",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Finset.instSingletonFinset",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "AbsoluteValue",
   "AddGroup.toSubtractionMonoid",
   "CanonicallyOrderedCommSemiring.toOne",
   "Preorder.toLE",
   "Eq",
   "Nat.factorial",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "not_le_of_gt",
   "MonoidWithZero.toMonoid",
   "Finset.sum_singleton",
   "Nat",
   "not_false_eq_true",
   "_private.Mathlib.Data.Complex.Exponential.0.Complex.exp._eq_1",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "zero_div",
   "Complex.commRing",
   "DivisionSemiring.toGroupWithZero",
   "OrderedSemiring.zeroLEOneClass",
   "Complex.charZero",
   "Mathlib.Data.Complex.Exponential._auxLemma.2",
   "Nat.canonicallyOrderedCommSemiring",
   "Real.orderedSemiring",
   "pow_zero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Nat.rec",
   "HEq.refl",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "pow_succ",
   "Not",
   "Singleton.singleton",
   "add_zero",
   "congrArg",
   "Complex.exp",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "CommRing.toNonUnitalCommRing",
   "GroupWithZero.toDivisionMonoid",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "Zero.toOfNat0",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "AddMonoid.toZero",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "div_self",
   "NeZero.charZero_one",
   "Eq.symm",
   "id",
   "eq_self",
   "NeZero.succ",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "instAddNat",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Complex.instIsComplete",
   "Complex.exp'",
   "Ring.toSemiring",
   "GT.gt",
   "Complex.exp.proof_1",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Complex",
   "Eq.casesOn",
   "NegZeroClass.toZero",
   "OrderedSemiring.toPartialOrder",
   "Nat.casesOn"],
  "name": "Complex.exp_zero",
  "constType": "Complex.exp 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set.mem_iInter₂",
   "Set.mem_biInter",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddSubgroup.toAddSubmonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.instInfSetAddSubgroup.proof_1",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.copy",
   "AddSubgroup.neg_mem",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Iff.mp",
   "AddGroup",
   "iInf",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "Set.iInter",
   "AddSubmonoid.mk",
   "NegZeroClass.toNeg",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddSubsemigroup.carrier",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfSetAddSubgroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)) {x : G},\n  x ∈\n      {\n            toAddSubsemigroup :=\n              (AddSubmonoid.copy (⨅ S ∈ s, S.toAddSubmonoid) (⋂ S ∈ s, ↑S)\n                  (_ : ⋂ S ∈ s, ↑S = ↑(⨅ i ∈ s, i.toAddSubmonoid))).toAddSubsemigroup,\n            zero_mem' :=\n              (_ :\n                0 ∈\n                  (AddSubmonoid.copy (⨅ S ∈ s, S.toAddSubmonoid) (⋂ S ∈ s, ↑S)\n                        (_ :\n                          ⋂ S ∈ s, ↑S =\n                            ↑(⨅ i ∈ s, i.toAddSubmonoid))).toAddSubsemigroup.carrier) }.toAddSubsemigroup.carrier →\n    -x ∈ ⋂ x ∈ s, ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "CommRing.toNonUnitalCommRing",
   "IsCauSeq",
   "AbsoluteValue",
   "Real",
   "Semiring.toMonoidWithZero",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.factorial",
   "AbsoluteValue.subadditiveHomClass",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Complex.instField",
   "Finset.range",
   "instHPow",
   "Monoid.toNatPow",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "Nat",
   "isCauSeq_series_of_abv_isCauSeq",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "HPow.hPow",
   "Complex.abs",
   "instHDiv",
   "Complex.commRing",
   "Finset.sum",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.instRingComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "SubadditiveHomClass.toFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Complex.isCauSeq_abs_exp",
   "Field.toDiv",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.isCauSeq_exp",
  "constType":
  "∀ (z : ℂ), IsCauSeq ⇑Complex.abs fun n => Finset.sum (Finset.range n) fun m => z ^ m / ↑(Nat.factorial m)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommMonoidWithZero",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["ConditionallyCompleteLinearOrder", "ConditionallyCompleteLinearOrderBot"],
  "name":
  "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLinearOrderBot α] → ConditionallyCompleteLinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Subtype.property",
   "ENNReal",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "ENNReal.toReal",
   "ENNReal.toNNReal",
   "LE.le"],
  "name": "ENNReal.toReal_nonneg",
  "constType": "∀ {a : ENNReal}, 0 ≤ a.toReal",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "CanLift",
  "constType":
  "(α : Sort u_1) → (β : Sort u_2) → outParam (β → α) → outParam (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Iff.symm",
   "Set.finite_coe_iff",
   "Set.Elem",
   "Infinite",
   "Set",
   "Finite",
   "Not",
   "Iff.trans",
   "not_finite_iff_infinite",
   "Iff.not",
   "Set.Infinite",
   "Set.Finite",
   "Iff.mpr"],
  "name": "Set.Infinite.to_subtype",
  "constType": "∀ {α : Type u} {s : Set α}, Set.Infinite s → Infinite ↑s",
  "constCategory": "Theorem"},
 {"references": ["DivInvOneMonoid", "DivInvMonoid"],
  "name": "DivInvOneMonoid.toDivInvMonoid",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "SemigroupWithZero.mk",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "SemigroupWithZero",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toSemigroupWithZero",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → SemigroupWithZero M₀",
  "constCategory": "Definition"},
 {"references": ["Irreducible", "Nat.monoid", "Nat"],
  "name": "Nat.Prime",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Top",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMax",
   "StrictOrderedSemiring.toPartialOrder",
   "Max.max",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "Preorder.toLE",
   "ite",
   "Eq",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.max_def",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedCommSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubmonoidClass",
   "SetLike",
   "AddZeroClass",
   "AddMemClass"],
  "name": "AddSubmonoidClass.toAddMemClass",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : AddZeroClass M] [inst_1 : SetLike S M] [self : AddSubmonoidClass S M],\n  AddMemClass S M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "eq_neg_add_iff_add_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a = -b + c ↔ b + a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv", "Multiplicative", "Multiplicative.ofAdd", "Equiv.symm"],
  "name": "Multiplicative.toAdd",
  "constType": "{α : Type u} → Multiplicative α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Cardinal.mk_toNat_of_infinite",
   "Infinite",
   "instOfNatNat",
   "Nat",
   "Nat.card",
   "Eq"],
  "name": "Nat.card_eq_zero_of_infinite",
  "constType": "∀ {α : Type u_1} [inst : Infinite α], Nat.card α = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Iff",
   "Iff.rfl",
   "Finset.toSet",
   "Set",
   "Finset",
   "HasSubset.Subset",
   "Finset.instHasSubsetFinset"],
  "name": "Finset.coe_subset",
  "constType": "∀ {α : Type u_1} {s₁ s₂ : Finset α}, ↑s₁ ⊆ ↑s₂ ↔ s₁ ⊆ s₂",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Ne",
   "Exists",
   "OfNat.ofNat",
   "Real",
   "Real.instPreorderReal",
   "Real.zero_lt_one",
   "One.toOfNat1",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "LT.lt.ne",
   "Real.instOneReal"],
  "name": "Real.instStrictOrderedCommRingReal.proof_2",
  "constType": "Nontrivial ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomClass.mk",
   "RingHom",
   "MulOneClass.toMul",
   "RingHom.instRingHomClass.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MulOneClass.toOne",
   "FunLike.mk",
   "RingHom.instRingHomClass.proof_2",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulHomClass.mk",
   "NonAssocSemiring",
   "OneHom.toFun",
   "RingHom.instRingHomClass.proof_1",
   "MonoidHom.toOneHom",
   "RingHom.map_zero'",
   "RingHom.map_add'",
   "RingHom.toMonoidHom",
   "MonoidHomClass.mk"],
  "name": "RingHom.instRingHomClass",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → RingHomClass (α →+* β) α β",
  "constCategory": "Definition"},
 {"references":
  ["refPackage",
   "Real",
   "Real.instLEReal",
   "Eq.refl",
   "ProbabilityTheory.IdentDistrib",
   "MeasureTheory.IsProbabilityMeasure",
   "implies_congr",
   "MeasureTheory.MeasureSpace.volume",
   "tau_minimizes",
   "LE.le",
   "True",
   "iff_self",
   "ProbabilityTheory.IdentDistrib.tau_eq",
   "MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "MeasureTheory.MeasureSpace",
   "tau",
   "AddCommGroup",
   "congrArg",
   "Eq.trans",
   "MeasurableSpace",
   "congrFun",
   "id"],
  "name": "ProbabilityTheory.IdentDistrib.tau_minimizes",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {G : Type uG} [inst_2 : AddCommGroup G] [inst_3 : MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω : Type u_7}\n  {Ω' : Type u_8} [inst_4 : MeasureTheory.MeasureSpace Ω] [inst_5 : MeasureTheory.MeasureSpace Ω'] {X₁ X₂ : Ω → G}\n  {X₁' X₂' : Ω' → G},\n  ProbabilityTheory.IdentDistrib X₁ X₁' →\n    ProbabilityTheory.IdentDistrib X₂ X₂' → (tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂')",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupNorm.toNormedAddCommGroup",
   "Complex.abs",
   "NormedAddCommGroup",
   "Complex.addCommGroup",
   "AbsoluteValue.add_le'",
   "AddGroupNorm.mk",
   "AbsoluteValue",
   "Real",
   "AddGroupSeminorm.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.orderedSemiring",
   "Complex.instNormedAddCommGroupComplex.proof_1",
   "AbsoluteValue.toMulHom",
   "Complex.instNormedAddCommGroupComplex.proof_2",
   "Complex.instSemiringComplex",
   "MulHom.toFun",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "AddCommGroup.toAddGroup",
   "Complex.instNormedAddCommGroupComplex.proof_3"],
  "name": "Complex.instNormedAddCommGroupComplex",
  "constType": "NormedAddCommGroup ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Units.mk0",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Or",
   "Eq.refl",
   "NoZeroDivisors.mk",
   "And.left",
   "implies_congr",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Units.ne_zero",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "Units",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "And",
   "And.right",
   "Eq.mpr",
   "Mathlib.Tactic.PushNeg.not_or_eq",
   "Units.instMulOneClassUnits",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.toNontrivial",
   "GroupWithZero",
   "HMul.hMul",
   "Not",
   "Mathlib.Tactic.Contrapose.mtr",
   "MonoidWithZero.toZero",
   "id"],
  "name": "GroupWithZero.noZeroDivisors",
  "constType": "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀], NoZeroDivisors G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "EuclideanDomain",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a (_ : a = a) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "lowerBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["Quotient", "Cardinal.isEquivalent"],
  "name": "Cardinal",
  "constType": "Type (u + 1)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddHomClass.toFunLike",
   "SubtractionMonoid.toSubNegMonoid",
   "map_neg",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHom.addMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.map_neg",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (a : α), f (-a) = -f a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MeasureTheory.MeasureSpace",
  "constType": "Type u_6 → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Pi.booleanAlgebra",
   "Not",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_3",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "Or",
   "eq_or_ne",
   "NeZero.mk",
   "NeZero",
   "OfNat.ofNat",
   "Or.imp_right",
   "Eq"],
  "name": "eq_zero_or_neZero",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (a : R), a = 0 ∨ NeZero a",
  "constCategory": "Theorem"},
 {"references":
  ["SeminormedAddCommGroup.mk",
   "NonUnitalSeminormedRing.dist_eq",
   "NonUnitalSeminormedRing.toNorm",
   "SeminormedAddCommGroup",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalSeminormedRing.toPseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
  "constType":
  "{α : Type u_1} → [inst : NonUnitalSeminormedRing α] → SeminormedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["AddMonoid.nsmul", "SMul", "SMul.mk", "Nat", "AddMonoid"],
  "name": "AddMonoid.toNatSMul",
  "constType": "{M : Type u_2} → [inst : AddMonoid M] → SMul ℕ M",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instCommSemiringReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.commRing",
   "StarRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "starRingOfComm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name":
  "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
  "constType": "StarRing ℝ",
  "constCategory": "Definition"},
 {"references": ["Dvd"],
  "name": "Dvd.dvd",
  "constType": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "neg_eq_of_add_eq_zero_right",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "neg_injective",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "eq_of_sub_eq_zero",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a b : α}, a - b = 0 → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Real.exp_zero",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Real.instAddMonoidReal",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Real.instOneReal",
   "Zero.toOfNat0",
   "_private.Mathlib.Data.Complex.Exponential.0.Real.add_one_lt_exp_of_pos",
   "AddZeroClass.toZero",
   "zero_add",
   "Preorder.toLT",
   "Eq.trans",
   "Or",
   "LT.lt.le",
   "Real.partialOrder",
   "Mathlib.Order.Basic._auxLemma.1",
   "instHAdd",
   "One.toOfNat1",
   "Or.casesOn",
   "LE.le",
   "Real.exp",
   "Real.instZeroReal",
   "Eq.ndrec",
   "of_eq_true",
   "LT.lt",
   "Real.instPreorderReal",
   "congr",
   "congrArg",
   "eq_or_lt_of_le"],
  "name":
  "_private.Mathlib.Data.Complex.Exponential.0.Real.add_one_le_exp_of_nonneg",
  "constType": "∀ {x : ℝ}, 0 ≤ x → x + 1 ≤ Real.exp x",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["OneHomClass.toFunLike",
   "OfNat.ofNat",
   "One",
   "One.toOfNat1",
   "OneHomClass",
   "FunLike.coe",
   "OneHomClass.map_one",
   "Eq"],
  "name": "map_one",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : One M] [inst_1 : One N] [inst_2 : OneHomClass F M N] (f : F),\n  f 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Top.top",
   "AddSubmonoid",
   "Set.mem_univ",
   "AddZeroClass",
   "SetLike.instMembership"],
  "name": "AddSubmonoid.mem_top",
  "constType": "∀ {M : Type u_1} [inst : AddZeroClass M] (x : M), x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "PosMulMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "AbsoluteValue",
   "Semiring.toMonoidWithZero",
   "FunLike.coe",
   "SubadditiveHomClass.toFunLike",
   "AbsoluteValue.eq_zero'",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "AbsoluteValue.subadditiveHomClass",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.eq_zero",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) {x : R},\n  abv x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "MulAction", "AddMonoid", "DistribMulAction"],
  "name": "DistribMulAction.toMulAction",
  "constType":
  "{M : Type u_10} →\n  {A : Type u_11} → [inst : Monoid M] → [inst_1 : AddMonoid A] → [self : DistribMulAction M A] → MulAction M A",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.map",
   "CanonicallyOrderedCommSemiring.toMul",
   "MeasureTheory.Measure.instSFiniteMap",
   "Set",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "Inter.inter",
   "And.left",
   "MeasureTheory.Measure.prod_eq",
   "MeasureTheory.Measure.prod",
   "MeasureTheory.IsFiniteMeasure",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "And.right",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Iff",
   "SProd.sprod",
   "MeasurableSet",
   "MeasureTheory.Measure.map_apply_of_aemeasurable",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "AEMeasurable",
   "id",
   "AEMeasurable.prod_mk",
   "Set.instSProd",
   "Set.preimage",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Prod.instMeasurableSpace",
   "Iff.intro",
   "instHMul",
   "And",
   "Eq.ndrec",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "MeasureTheory.Measure.toOuterMeasure",
   "Prod.mk",
   "propext",
   "MeasurableSet.prod",
   "letFun",
   "HMul.hMul",
   "Prod",
   "And.intro",
   "MeasureTheory.Measure.prod_prod",
   "MeasurableSpace",
   "ProbabilityTheory.indepFun_iff_measure_inter_preimage_eq_mul",
   "ProbabilityTheory.IndepFun",
   "Set.instInterSet"],
  "name": "ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map",
  "constType":
  "∀ {Ω : Type u_1} {β : Type u_6} {β' : Type u_7} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {f : Ω → β}\n  {g : Ω → β'} {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} [inst : MeasureTheory.IsFiniteMeasure μ],\n  AEMeasurable f →\n    AEMeasurable g →\n      (ProbabilityTheory.IndepFun f g ↔\n        MeasureTheory.Measure.map (fun ω => (f ω, g ω)) μ =\n          MeasureTheory.Measure.prod (MeasureTheory.Measure.map f μ) (MeasureTheory.Measure.map g μ))",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalSeminormedRing",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Eq",
   "Dist.dist",
   "instHMul",
   "Norm",
   "SubNegMonoid.toSub",
   "PseudoMetricSpace.toDist",
   "HMul.hMul",
   "NonUnitalRing",
   "Norm.norm",
   "AddCommGroup.toAddGroup",
   "PseudoMetricSpace",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalSeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toNonUnitalRing : NonUnitalRing α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NonUnitalSeminormedRing α",
  "constCategory": "Other"},
 {"references": ["instHSub", "Set.image2", "Set", "HSub.hSub", "Sub", "Sub.mk"],
  "name": "Set.sub",
  "constType": "{α : Type u_2} → [inst : Sub α] → Sub (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "MeasureTheory.Measure.restrict",
   "Inter.inter",
   "MeasureTheory.IsFiniteMeasure",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Preorder.toLT",
   "MeasurableSet",
   "Fact.elim",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.trans",
   "MeasureTheory.Measure.restrict_apply",
   "id",
   "CompletelyDistribLattice.toCompleteLattice",
   "MeasureTheory.IsFiniteMeasure.mk",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set.univ",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "LT.lt",
   "CompleteLattice.toTop",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.3",
   "Set.univ_inter",
   "Fact",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "Set.instInterSet"],
  "name": "MeasureTheory.Restrict.isFiniteMeasure",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {s : Set α} (μ : MeasureTheory.Measure α) [hs : Fact (↑↑μ s < ⊤)],\n  MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.restrict μ s)",
  "constCategory": "Definition"},
 {"references":
  ["Or.resolve_left",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Not",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "le_total"],
  "name": "le_of_not_le",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b → b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "SemiconjBy.one_left",
   "Commute"],
  "name": "Commute.one_left",
  "constType": "∀ {M : Type u_2} [inst : MulOneClass M] (a : M), Commute 1 a",
  "constCategory": "Theorem"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Finset.Nonempty",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Finset.instMembershipFinset",
   "LE.le",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "And",
   "Finset.exists_max_image",
   "Finset",
   "OrderDual",
   "OrderDual.instLinearOrder"],
  "name": "Finset.exists_min_image",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : LinearOrder α] (s : Finset β) (f : β → α),\n  Finset.Nonempty s → ∃ x ∈ s, ∀ x' ∈ s, f x ≤ f x'",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "eq_self",
   "Nat.add_comm",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "True",
   "Int.add_comm.match_1",
   "Eq",
   "Int.instAddInt",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans"],
  "name": "Int.add_comm",
  "constType": "∀ (a b : ℤ), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.inter_eq_compl_compl_union_compl",
   "Set",
   "Union.union",
   "MeasurableSet.union",
   "HasCompl.compl",
   "Eq.refl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Inter.inter",
   "BooleanAlgebra.toHasCompl",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Eq.mpr",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "MeasurableSet",
   "MeasurableSet.compl",
   "MeasurableSpace",
   "Set.instUnionSet",
   "Set.instInterSet",
   "id"],
  "name": "MeasurableSet.inter",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} {s₁ s₂ : Set α}, MeasurableSet s₁ → MeasurableSet s₂ → MeasurableSet (s₁ ∩ s₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "AddZeroClass",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instTopAddSubmonoid.proof_2",
  "constType": "∀ {M : Type u_1} [inst : AddZeroClass M], 0 ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield.zpow_neg'",
   "LinearOrderedSemifield.mul_inv_cancel",
   "CommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Semifield",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.div_eq_mul_inv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedSemifield.inv_zero",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toNontrivial",
   "Semifield.mk",
   "LinearOrderedSemifield.zpow_succ'",
   "LinearOrderedSemifield.zpow_zero'",
   "StrictOrderedCommSemiring.mul_comm"],
  "name": "LinearOrderedSemifield.toSemifield",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedSemifield α] → Semifield α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "mul_one",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_one",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * Nat.rawCast 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "True",
   "Eq",
   "ite",
   "min_def",
   "le_of_not_le",
   "Eq.mpr",
   "if_pos",
   "of_eq_true",
   "Decidable",
   "LinearOrder.toMin",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id",
   "congrFun"],
  "name": "min_le_left",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.MeasureSpace.toMeasurableSpace",
   "refPackage.X₀₂",
   "refPackage",
   "MeasureTheory.MeasureSpace",
   "Measurable",
   "MeasurableSpace"],
  "name": "refPackage.hmeas2",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {G : Type uG} [inst_2 : MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G), Measurable self.X₀₂",
  "constCategory": "Definition"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references": ["Set.range", "InfSet.sInf", "InfSet"],
  "name": "iInf",
  "constType":
  "{α : Type u_1} → [inst : InfSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.zero",
   "Subtype.val",
   "Set",
   "rfl",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Subtype",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.toAddZeroClass.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), ↑0 = ↑0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Set.eq_univ_iff_forall",
   "Set.univ",
   "Iff.mpr",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_of_forall",
  "constType": "∀ {α : Type u} {s : Set α}, (∀ (x : α), x ∈ s) → s = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Eq",
   "Add.mk"],
  "name": "Real.commRing.proof_4",
  "constType": "∀ (x : ℝ), nsmulRec 0 x = nsmulRec 0 x",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalCommRing", "NonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalRing",
  "constType": "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Rat",
   "Rat.instLinearOrderedCommRingRat"],
  "name": "Rat.instLinearOrderedRingRat",
  "constType": "LinearOrderedRing ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "Dvd.dvd",
   "mul_one",
   "One.toOfNat1",
   "semigroupDvd",
   "Dvd.intro",
   "Monoid.toMulOneClass"],
  "name": "dvd_refl",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), a ∣ a",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid",
   "Nat.cast",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_neg'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "DecidableEq",
   "propext",
   "Finset.mem_inter",
   "Finset",
   "Finset.instInterFinset",
   "Inter.inter",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.90",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s₁ s₂ : Finset α}, (a ∈ s₁ ∩ s₂) = (a ∈ s₁ ∧ a ∈ s₂)",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "Rat", "HMul.hMul", "Mul"],
  "name": "qsmulRec",
  "constType": "{K : Type u_3} → (ℚ → K) → [inst : Mul K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references": ["Monoid"],
  "name": "Irreducible",
  "constType": "{α : Type u_1} → [inst : Monoid α] → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Zero.zero",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Add.add",
   "Eq.mpr",
   "Eq.ndrec",
   "Function.Injective",
   "Zero.mk",
   "Add",
   "add_zero",
   "AddZeroClass",
   "Add.mk",
   "id"],
  "name": "Function.Injective.addZeroClass.proof_2",
  "constType":
  "∀ {M₁ : Type u_1} {M₂ : Type u_2} [inst : Add M₁] [inst_1 : Zero M₁] [inst_2 : AddZeroClass M₂] (f : M₁ → M₂),\n  Function.Injective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → ∀ (x : M₁), x + 0 = x",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "GeneralizedHeytingAlgebra"],
  "name": "GeneralizedHeytingAlgebra.toLattice",
  "constType":
  "{α : Type u_4} → [self : GeneralizedHeytingAlgebra α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Complex.ofReal'",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "Iff",
   "Real",
   "Complex.ofReal_inj",
   "Complex",
   "Eq"],
  "name": "Complex.ofReal_eq_zero",
  "constType": "∀ {z : ℝ}, ↑z = 0 ↔ z = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set",
   "Eq.refl",
   "MeasurableSet.singleton",
   "Set.instMembershipSet",
   "Eq",
   "Set.Countable",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Set.biUnion_of_singleton",
   "MeasurableSet.biUnion",
   "Set.iUnion",
   "Eq.ndrec",
   "MeasurableSet",
   "Singleton.singleton",
   "Eq.symm",
   "MeasurableSpace",
   "id"],
  "name": "Set.Countable.measurableSet",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] {s : Set α},\n  Set.Countable s → MeasurableSet s",
  "constCategory": "Theorem"},
 {"references": ["Rat", "Rat.neg", "Neg", "Neg.mk"],
  "name": "Rat.instNegRat",
  "constType": "Neg ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Function.Injective",
   "Subtype.val",
   "Subtype.coe_injective",
   "AddSubmonoid",
   "AddZeroClass",
   "Subtype",
   "SetLike.instMembership"],
  "name": "AddSubmonoid.toAddZeroClass.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSingletonSet",
   "Set",
   "lowerBounds",
   "Singleton.singleton",
   "Set.Iic",
   "Preorder",
   "IsGLB.lowerBounds_eq",
   "Eq",
   "isGLB_singleton"],
  "name": "lowerBounds_singleton",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a : α}, lowerBounds {a} = Set.Iic a",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Subsingleton.intro",
   "left_inv_eq_right_inv",
   "Eq.refl",
   "One.toOfNat1",
   "Invertible",
   "Monoid.toMulOneClass",
   "Eq",
   "Invertible.subsingleton.match_1",
   "instHMul",
   "One",
   "Eq.ndrec",
   "Eq.rec",
   "Subsingleton",
   "HMul.hMul",
   "Invertible.mk",
   "Mul"],
  "name": "Invertible.subsingleton",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a : α), Subsingleton (Invertible a)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Or",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq.le_total",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "IsTotal",
   "Rat.instNegRat",
   "congr",
   "IsTotal.mk",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.instIsTotalRealLeInstLEReal",
  "constType": "IsTotal ℝ fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Multiset.card",
   "OfNat.ofNat",
   "instHSMul",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Nat.addMonoid",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Finset",
   "Multiset",
   "Finset.val",
   "nsmul_zero",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.sum_replicate",
   "Multiset.map_const'",
   "Eq.trans",
   "AddCommMonoid",
   "eq_self",
   "AddHomClass.toFunLike",
   "Finset.sum",
   "Multiset.sum",
   "FunLike.coe",
   "Multiset.replicate",
   "AddMonoid.toNatSMul",
   "Multiset.map",
   "of_eq_true",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "congrArg",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "congrFun",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.sum_const_zero",
  "constType":
  "∀ {β : Type u} {α : Type v} {s : Finset α} [inst : AddCommMonoid β], (Finset.sum s fun _x => 0) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Set",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
   "Prop.partialOrder",
   "LT.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "MeasurableSpace.instLEMeasurableSpace",
   "And",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_1",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_3",
   "Pi.partialOrder",
   "PartialOrder.lift",
   "MeasurableSet",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSpace.instPartialOrderMeasurableSpace.proof_4",
   "Not",
   "MeasurableSpace"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace",
  "constType": "{α : Type u_1} → PartialOrder (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "PLift.up",
   "PLift.down",
   "PLift.down_up",
   "PLift",
   "Equiv.mk",
   "PLift.up_down"],
  "name": "Equiv.plift",
  "constType": "{α : Sort u} → PLift α ≃ α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Trans.trans",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "mul_assoc",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "not_false_eq_true",
   "Eq.trans",
   "mul_inv_cancel",
   "GroupWithZero.toInv",
   "eq_self",
   "Ne",
   "False",
   "One.toOfNat1",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "eq_false",
   "of_eq_true",
   "GroupWithZero",
   "HMul.hMul",
   "instTransEq",
   "Not",
   "mul_one",
   "MonoidWithZero.toZero",
   "congrArg",
   "Inv.inv",
   "congrFun"],
  "name": "mul_inv_cancel_right₀",
  "constType":
  "∀ {G₀ : Type u} [inst : GroupWithZero G₀] {b : G₀}, b ≠ 0 → ∀ (a : G₀), a * b * b⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Zero.zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Add.add",
   "Eq.mpr",
   "Eq.ndrec",
   "Function.Injective",
   "Zero.mk",
   "Add",
   "AddZeroClass",
   "Add.mk",
   "id"],
  "name": "Function.Injective.addZeroClass.proof_1",
  "constType":
  "∀ {M₁ : Type u_1} {M₂ : Type u_2} [inst : Add M₁] [inst_1 : Zero M₁] [inst_2 : AddZeroClass M₂] (f : M₁ → M₂),\n  Function.Injective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → ∀ (x : M₁), 0 + x = x",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Min", "minOfLe", "Nat", "Nat.decLe"],
  "name": "instMinNat",
  "constType": "Min ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "EquivLike.injective_comp",
   "Iff",
   "Function.Injective",
   "Function.comp",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.injective_comp",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {γ : Sort w} (e : α ≃ β) (f : β → γ), Function.Injective (f ∘ ⇑e) ↔ Function.Injective f",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "Nat"],
  "name": "Mathlib.Meta.NormNum.IsNat",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → α → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["SeminormedRing", "Ring"],
  "name": "SeminormedRing.toRing",
  "constType": "{α : Type u_5} → [self : SeminormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "ENNReal",
   "Set.instSingletonSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.preimage",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set",
   "Singleton.singleton",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "autoParam",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "Eq",
   "Set.instMembershipSet"],
  "name": "ProbabilityTheory.IsUniform.eq_of_mem",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] {H : Set S} {X : Ω → S}\n  {μ : autoParam (MeasureTheory.Measure Ω) _auto✝},\n  ProbabilityTheory.IsUniform H X → ∀ (x y : S), x ∈ H → y ∈ H → ↑↑μ (X ⁻¹' {x}) = ↑↑μ (X ⁻¹' {y})",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "Real",
   "ProbabilityTheory.entropy",
   "ProbabilityTheory.measureEntropy",
   "rfl",
   "MeasurableSpace",
   "Eq"],
  "name": "ProbabilityTheory.entropy_def",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S] (X : Ω → S)\n  (μ : MeasureTheory.Measure Ω), H[X ; μ] = ProbabilityTheory.measureEntropy",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.zsmul",
   "instHSMul",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Int",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℤ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "MetricSpace"],
  "name": "NormedRing.toMetricSpace",
  "constType": "{α : Type u_5} → [self : NormedRing α] → MetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["And", "instLENat", "Not", "And.intro", "Nat", "And.casesOn", "LE.le"],
  "name": "Nat.lt_iff_le_not_le.match_1",
  "constType":
  "∀ {m n : ℕ} (motive : m ≤ n ∧ ¬n ≤ m → Prop) (x : m ≤ n ∧ ¬n ≤ m),\n  (∀ (left : m ≤ n) (h : ¬n ≤ m), motive (_ : m ≤ n ∧ ¬n ≤ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Exists",
   "IsAbsoluteValue",
   "instHasEquiv",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.IsComplete",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "HasEquiv.Equiv",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.IsComplete.mk",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], (∀ (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b) → CauSeq.IsComplete β abv",
  "constCategory": "Other"},
 {"references": ["Function.comp", "Nat", "Fin.succ", "Nat.succ", "Fin"],
  "name": "Matrix.vecTail",
  "constType": "{α : Type u} → {n : ℕ} → (Fin (Nat.succ n) → α) → Fin n → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Set.preimage",
   "Set",
   "Real",
   "Eq.refl",
   "MeasureTheory.Measure.real",
   "instENNRealZero",
   "Set.instMembershipSet",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "ENNReal.zero_toReal",
   "ProbabilityTheory.IsUniform.measure_preimage_of_nmem",
   "ENNReal",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Not",
   "Singleton.singleton",
   "MeasureTheory.measureReal_def",
   "ENNReal.toReal",
   "MeasurableSpace",
   "ProbabilityTheory.IsUniform",
   "id"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_of_nmem",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Set S},\n  ProbabilityTheory.IsUniform H X → ∀ {s : S}, s ∉ H → μ.real (X ⁻¹' {s}) = 0",
  "constCategory": "Theorem"},
 {"references": ["RelIso", "LE", "LE.le"],
  "name": "OrderIso",
  "constType":
  "(α : Type u_6) → (β : Type u_7) → [inst : LE α] → [inst : LE β] → Type (max u_6 u_7)",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedCommRing α] → LinearOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.FiniteSpanningSetsIn.mk",
   "Nonempty.intro",
   "MeasureTheory.SigmaFinite.mk",
   "MeasureTheory.SigmaFinite",
   "MeasureTheory.Measure.FiniteSpanningSetsIn",
   "Set",
   "instInhabitedNat",
   "Nat",
   "Set.iUnion_const",
   "Set.univ",
   "MeasureTheory.IsFiniteMeasure",
   "MeasureTheory.measure_lt_top",
   "MeasurableSpace",
   "instNonempty"],
  "name": "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
  "constType":
  "∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\n  MeasureTheory.SigmaFinite μ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "ExistsAddOfLE.mk",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "ExistsAddOfLE",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "CanonicallyOrderedAddCommMonoid.exists_add_of_le",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
  "constType":
  "∀ (α : Type u) [h : CanonicallyOrderedAddCommMonoid α], ExistsAddOfLE α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Nat.cast_zero",
   "Eq",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NatCast.natCast",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Real.cauchy_mul",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "Real.cauchy_add",
   "AddSemigroup.toAdd",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_14",
  "constType": "NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Group",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Membership.mem",
   "AddGroup",
   "Subtype.val",
   "HSub.hSub",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.sub",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x - x_1) = ↑(x - x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Fintype", "Finset", "Finset.instMembershipFinset"],
  "name": "Fintype.mk",
  "constType":
  "{α : Type u_4} → (elems : Finset α) → (∀ (x : α), x ∈ elems) → Fintype α",
  "constCategory": "Other"},
 {"references":
  ["MeasurableAdd.mk",
   "instHAdd",
   "HAdd.hAdd",
   "DiscreteMeasurableSpace",
   "measurable_discrete",
   "Add",
   "MeasurableSpace",
   "MeasurableAdd"],
  "name": "DiscreteMeasurableSpace.toMeasurableAdd",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : Add α] [inst_2 : DiscreteMeasurableSpace α], MeasurableAdd α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "Invertible",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "inv_mul_cancel",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "Invertible.mk",
   "MonoidWithZero.toZero",
   "mul_inv_cancel",
   "Inv.inv",
   "GroupWithZero.toInv"],
  "name": "invertibleOfNonzero",
  "constType":
  "{α : Type u} → [inst : GroupWithZero α] → {a : α} → a ≠ 0 → Invertible a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "Semigroup",
   "Dvd",
   "Eq"],
  "name": "semigroupDvd",
  "constType": "{α : Type u_1} → [inst : Semigroup α] → Dvd α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_trans",
  "constType":
  "∀ {α : Type u} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Definition"},
 {"references": ["Int.cast", "Ring.toIntCast", "Ring", "Int"],
  "name": "Int.rawCast",
  "constType": "{α : Type u_1} → [inst : Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivisionSemiring",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Bool.noConfusion",
   "OfNat.ofNat",
   "Nat.ble",
   "HEq",
   "Nat.zero",
   "HEq.refl",
   "Bool.false",
   "Bool.true",
   "Eq.refl",
   "instOfNatNat",
   "Eq.casesOn",
   "Bool",
   "Nat",
   "Nat.succ",
   "Nat.casesOn",
   "Eq"],
  "name": "Nat.le_of_ble_eq_true.match_1",
  "constType":
  "∀ (motive : (n m : ℕ) → Nat.ble n m = true → Prop) (n m : ℕ) (h : Nat.ble n m = true),\n  (∀ (x : ℕ) (h : Nat.ble 0 x = true), motive 0 x h) →\n    (∀ (n n_1 : ℕ) (h : Nat.ble (Nat.succ n) (Nat.succ n_1) = true), motive (Nat.succ n) (Nat.succ n_1) h) →\n      motive n m h",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing.mul_inv_cancel",
   "DivisionRing",
   "DivisionRing.div_eq_mul_inv",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "DivisionSemiring",
   "DivisionRing.zpow_zero'",
   "DivisionSemiring.mk",
   "DivisionRing.inv_zero",
   "Ring.toSemiring",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toDiv",
   "DivisionRing.toInv"],
  "name": "DivisionRing.toDivisionSemiring",
  "constType": "{α : Type u_1} → [inst : DivisionRing α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.decidableLT",
   "Ord.compare",
   "Ordering",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Ne",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "LinearOrderedField",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Set",
   "Set.singleton_prod_singleton",
   "MeasurableSet.singleton",
   "Prod.instMeasurableSpace",
   "Eq",
   "MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Prod.instMeasurableSingletonClass.match_1",
   "Prod.mk",
   "Eq.rec",
   "SProd.sprod",
   "MeasurableSet",
   "MeasurableSet.prod",
   "Prod",
   "Singleton.singleton",
   "MeasurableSpace",
   "MeasurableSingletonClass.mk"],
  "name": "Prod.instMeasurableSingletonClass",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β} [inst : MeasurableSingletonClass α]\n  [inst : MeasurableSingletonClass β], MeasurableSingletonClass (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "PartialOrder.toPreorder",
   "Set.mem_insert",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "And.left",
   "Insert.insert",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "Set.instSingletonSet",
   "upperBounds",
   "lowerBounds",
   "Singleton.singleton",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf.proof_4",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α], (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a b : α), sInf {a, b} ≤ a",
  "constCategory": "Theorem"},
 {"references": ["iInf", "Set", "Set.instInfSetSet"],
  "name": "Set.iInter",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedRing",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toRing : Ring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → 0 ≤ 1 → (∀ (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b) → OrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "Distrib.toAdd",
   "HAdd.hAdd",
   "CauSeq.LimZero",
   "CauSeq.IsComplete",
   "Eq",
   "Setoid.symm",
   "IsAbsoluteValue",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Pi.instAdd",
   "Ring",
   "CauSeq.ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.mul_limZero_right",
   "Nat",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Subtype",
   "instHSub",
   "CauSeq.instSubCauSeq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CauSeq.eq_lim_of_const_equiv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CauSeq.equiv_lim",
   "of_eq_true",
   "CauSeq.add_limZero",
   "congr",
   "congrArg",
   "Pi.instMul",
   "Pi.instSub",
   "Subtype.val",
   "IsCauSeq",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "sub_add_sub_cancel'",
   "Ring.toNonAssocRing",
   "True",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedField",
   "Ring.toSub",
   "AddCommGroup.toAddGroup",
   "CauSeq.instMulCauSeq",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "CauSeq.lim",
   "instHAdd",
   "sub_mul",
   "HSub.hSub",
   "Function.const",
   "Subtype.ext",
   "CauSeq",
   "CauSeq.instAddCauSeq",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "CauSeq.mul_limZero_left",
   "CauSeq.equiv",
   "mul_sub",
   "Eq.ndrec",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.coe_add",
   "letFun",
   "HMul.hMul",
   "Ring.toAddCommGroup",
   "Pi.addCommGroup"],
  "name": "CauSeq.lim_mul_lim",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] (f g : CauSeq β abv),\n  CauSeq.lim f * CauSeq.lim g = CauSeq.lim (f * g)",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure", "MeasureTheory.OuterMeasure", "MeasurableSpace"],
  "name": "MeasureTheory.Measure.toOuterMeasure",
  "constType":
  "{α : Type u_6} → [inst : MeasurableSpace α] → MeasureTheory.Measure α → MeasureTheory.OuterMeasure α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "ProbabilityTheory.IdentDistrib",
   "autoParam",
   "MeasurableSpace",
   "AEMeasurable",
   "Eq"],
  "name": "ProbabilityTheory.IdentDistrib.mk",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {f : α → γ} {g : β → γ} {μ : autoParam (MeasureTheory.Measure α) _auto✝}\n  {ν : autoParam (MeasureTheory.Measure β) _auto✝¹},\n  AEMeasurable f →\n    AEMeasurable g → MeasureTheory.Measure.map f μ = MeasureTheory.Measure.map g ν → ProbabilityTheory.IdentDistrib f g",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Semiring.toMonoidWithZero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.ofRat",
   "MonoidWithZero.toZero",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instZeroCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Zero (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["MeasurableSingletonClass",
   "Set.instSingletonSet",
   "MeasurableSingletonClass.measurableSet_singleton",
   "Set",
   "MeasurableSet",
   "Singleton.singleton",
   "MeasurableSpace"],
  "name": "MeasurableSet.singleton",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] (a : α), MeasurableSet {a}",
  "constCategory": "Theorem"},
 {"references":
  ["Set.neg",
   "InvolutiveNeg",
   "neg_involutive",
   "Set.image_eq_preimage_of_inverse",
   "Set.preimage",
   "congr_fun",
   "InvolutiveNeg.toNeg",
   "Set",
   "Function.Involutive.leftInverse",
   "Neg.neg",
   "Set.image",
   "Function.Involutive.rightInverse",
   "Eq"],
  "name": "Set.image_neg",
  "constType":
  "∀ {α : Type u_2} [inst : InvolutiveNeg α] {s : Set α}, Neg.neg '' s = -s",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddAction.proof_2",
   "AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddAction.mk",
   "AddMonoid.toAddZeroClass",
   "AddAction",
   "AddMonoid.toAddAction.proof_1",
   "AddMonoid",
   "VAdd.mk"],
  "name": "AddMonoid.toAddAction",
  "constType": "(M : Type u_1) → [inst : AddMonoid M] → AddAction M M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalNonAssocCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "Setoid",
   "Quotient.lift₂",
   "HasEquiv.Equiv",
   "Quotient",
   "Eq"],
  "name": "Quotient.liftOn₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → φ) → (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) → φ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Classical.choose",
   "ZeroHom.zeroHomClass",
   "Cardinal.partialOrder",
   "Cardinal.toNat.proof_1",
   "Eq",
   "Cardinal.toNat",
   "Iff.mp",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "ZeroHomClass.toFunLike",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Nat.linearOrderedCommMonoidWithZero",
   "Cardinal.infinite_iff",
   "Infinite",
   "ZeroHom",
   "FunLike.coe",
   "Cardinal.linearOrder",
   "LE.le",
   "Cardinal.instLECardinal",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "LE.le.not_lt",
   "LT.lt",
   "Cardinal",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "dif_neg",
   "Not"],
  "name": "Cardinal.mk_toNat_of_infinite",
  "constType":
  "∀ {α : Type u} [h : Infinite α], Cardinal.toNat (Cardinal.mk α) = 0",
  "constCategory": "Theorem"},
 {"references": ["BiheytingAlgebra", "HNot"],
  "name": "BiheytingAlgebra.toHNot",
  "constType": "{α : Type u_4} → [self : BiheytingAlgebra α] → HNot α",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "DecidableEq",
   "HSub.hSub",
   "Finset.image₂",
   "Finset",
   "Sub",
   "Sub.mk"],
  "name": "Finset.sub",
  "constType":
  "{α : Type u_2} → [inst : DecidableEq α] → [inst : Sub α] → Sub (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "HEq",
   "Real.natCast",
   "Iff.rfl",
   "Real",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "autoParam",
   "True",
   "Set.toFinite",
   "Eq",
   "Mathlib.Data.Set.Finite._auxLemma.3",
   "MeasureTheory.Measure",
   "inferInstance",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "Set.Elem",
   "Finset.toSet",
   "Finset",
   "Measurable",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Subtype",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "eq_of_heq",
   "Finite",
   "Finset.instMembershipFinset",
   "Set.Finite.coe_toFinset",
   "ProbabilityTheory.IsUniform.entropy_eq",
   "Set.instMembershipSet",
   "Countable",
   "Real.log",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "propext",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "Eq.casesOn",
   "congrArg",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace",
   "Set.Finite.toFinset",
   "congrFun"],
  "name": "ProbabilityTheory.IsUniform.entropy_eq'",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {H : Set S} [inst_2 : Finite ↑H] {X : Ω → S} {μ : MeasureTheory.Measure Ω}\n  [inst_3 : MeasureTheory.IsProbabilityMeasure μ],\n  ProbabilityTheory.IsUniform H X → Measurable X → H[X ; μ] = Real.log ↑(Nat.card ↑H)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembershipFinset"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references": ["Real", "Dist"],
  "name": "Dist.dist",
  "constType": "{α : Type u_3} → [self : Dist α] → α → α → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.140",
   "MeasureTheory.Measure",
   "MeasureTheory.Measure.map",
   "Real",
   "autoParam",
   "ProbabilityTheory.measureEntropy",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.entropy",
  "constType":
  "{Ω : Type uΩ} →\n  {S : Type uS} →\n    [mΩ : MeasurableSpace Ω] → [inst : MeasurableSpace S] → (Ω → S) → autoParam (MeasureTheory.Measure Ω) _auto✝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Invertible.invOf",
   "One",
   "Invertible.invOf_mul_self",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible",
   "Eq"],
  "name": "invOf_mul_self",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) [inst_2 : Invertible a], ⅟a * a = 1",
  "constCategory": "Theorem"},
 {"references": ["Max"],
  "name": "Max.mk",
  "constType": "{α : Type u} → (α → α → α) → Max α",
  "constCategory": "Other"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Real",
   "Lattice",
   "Real.instDistribLatticeReal"],
  "name": "Real.lattice",
  "constType": "Lattice ℝ",
  "constCategory": "Definition"},
 {"references": ["SProd", "SProd.mk", "Finset", "Finset.product", "Prod"],
  "name": "Finset.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Finset α) (Finset β) (Finset (α × β))",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Subtype.val",
   "rel_iff_cov",
   "PosMulStrictMono",
   "Preorder",
   "PosMulReflectLT",
   "Zero.toOfNat0",
   "instHMul",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Mul",
   "Subtype",
   "Subtype.mk",
   "PosMulReflectLT.to_contravariantClass_pos_mul_lt"],
  "name": "mul_lt_mul_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α]\n  [inst_4 : PosMulReflectLT α], 0 < a → (a * b < a * c ↔ b < c)",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Prop.heytingAlgebra",
   "Prop.booleanAlgebra.proof_5",
   "Top.top",
   "GeneralizedHeytingAlgebra.toHImp",
   "Inf.inf",
   "DistribLattice.mk",
   "Classical.em",
   "HasCompl.mk",
   "HeytingAlgebra.toOrderBot",
   "GeneralizedHeytingAlgebra.toDistribLattice",
   "BooleanAlgebra",
   "BooleanAlgebra.mk",
   "Preorder.toLE",
   "Prop.booleanAlgebra.proof_4",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Lattice.toInf",
   "OrderTop.toTop",
   "DistribLattice",
   "SDiff.mk",
   "OrderBot.toBot",
   "DistribLattice.le_sup_inf",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "Prop.booleanAlgebra.proof_3",
   "Not",
   "Prop.booleanAlgebra.proof_1",
   "Lattice.toSemilatticeSup",
   "Prop.booleanAlgebra.proof_2",
   "SemilatticeSup.toPartialOrder"],
  "name": "Prop.booleanAlgebra",
  "constType": "BooleanAlgebra Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "sub_self",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "CauSeq.LimZero",
   "AddGroup.toSubtractionMonoid",
   "sub_add_sub_cancel",
   "Semifield.toCommGroupWithZero",
   "implies_congr",
   "Eq",
   "IsAbsoluteValue",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Ring",
   "CauSeq.ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Std.Classes.Order._auxLemma.3",
   "Nat",
   "Eq.trans",
   "Subtype",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "CauSeq.instSubCauSeq",
   "Mathlib.Data.Real.CauSeq._auxLemma.13",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CauSeq.addGroup",
   "Equivalence.mk",
   "of_eq_true",
   "Equivalence",
   "LT.lt",
   "CauSeq.add_limZero",
   "Eq.mp",
   "CauSeq.neg_limZero",
   "congrArg",
   "neg_sub",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "GE.ge",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "forall_congr",
   "Ring.toSub",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "funext",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "CauSeq",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "GT.gt",
   "SubtractionMonoid.toSubNegMonoid",
   "OrderedCommSemiring.toOrderedSemiring",
   "SubNegMonoid.toAddMonoid",
   "Ring.toAddCommGroup",
   "NegZeroClass.toZero"],
  "name": "CauSeq.equiv.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrderedField α] [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], Equivalence fun f g => CauSeq.LimZero (f - g)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 0) = (n = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Ord.compare",
   "Ordering",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Preorder.toLT",
   "LinearOrderedRing.decidableEq",
   "compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "Eq"],
  "name": "LinearOrderedRing.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_sInf",
   "CompleteLattice.toLattice",
   "CompleteLattice",
   "CompleteSemilatticeInf.mk",
   "CompleteLattice.toInfSet",
   "CompleteLattice.sInf_le",
   "Lattice.toSemilatticeSup",
   "CompleteSemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toCompleteSemilatticeInf",
  "constType":
  "{α : Type u_9} → [self : CompleteLattice α] → CompleteSemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Field.toSemifield",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Field.toCommRing",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy",
   "CommRing.toRing",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.field.proof_1",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a b : CauSeq.Completion.Cauchy abv), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Complex",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Function.Injective",
   "Equiv.instEquivLikeEquiv",
   "FunLike.coe",
   "EquivLike.injective",
   "Equiv.instFunLikeEquiv"],
  "name": "Equiv.injective",
  "constType": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Injective ⇑e",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "Nontrivial"],
  "name": "StrictOrderedSemiring.toNontrivial",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "CompletelyDistribLattice.toCompleteLattice",
   "CanonicallyOrderedCommSemiring.toMul",
   "Top.top",
   "NonUnitalCommSemiring.toCommSemigroup",
   "One.toOfNat1",
   "ENNReal.instInvENNReal",
   "CommSemiring.toNonUnitalCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "instENNRealZero",
   "CommMagma.toMul",
   "Eq",
   "mul_comm",
   "Zero.toOfNat0",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "CommSemigroup.toCommMagma",
   "Eq.rec",
   "CompleteLattice.toTop",
   "HMul.hMul",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "ENNReal.mul_inv_cancel",
   "Inv.inv"],
  "name": "ENNReal.inv_mul_cancel",
  "constType": "∀ {a : ENNReal}, a ≠ 0 → a ≠ ⊤ → a⁻¹ * a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "ite",
   "Eq"],
  "name": "if_pos",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Add",
   "Function.Injective.eq_iff",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_right_inj",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b = a + c ↔ b = c",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Ring.zsmul",
  "constType": "{R : Type u} → [self : Ring R] → ℤ → R → R",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "Finset.map.proof_1",
   "EmbeddingLike.toFunLike",
   "Function.instEmbeddingLikeEmbedding",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "FunLike.coe",
   "Finset.mk"],
  "name": "Finset.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real.instLinearOrderedFieldReal",
   "Real.instLinearOrderedRingReal",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "CauSeq.IsComplete.mk",
   "Real",
   "CauSeq.IsComplete",
   "Real.instSupReal",
   "Real.instRingReal",
   "Abs.abs",
   "Real.cauSeq_converges",
   "Real.instNegReal"],
  "name":
  "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
  "constType": "CauSeq.IsComplete ℝ abs",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Quotient.liftOn₂",
   "Cardinal",
   "LE",
   "Function.Embedding",
   "Cardinal.instLECardinal.proof_1",
   "Cardinal.isEquivalent",
   "Nonempty"],
  "name": "Cardinal.instLECardinal",
  "constType": "LE Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Min.min",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LinearOrderedRing.toMin",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedRing.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["HEq",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "heq_of_eq",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Subsingleton.elim",
   "outParam",
   "Invertible.subsingleton",
   "Nat.cast",
   "One",
   "MonoidWithZero.toMonoid",
   "Eq.rec",
   "Ring.toIntCast",
   "Ring",
   "Nat",
   "Mul",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "HEq.refl",
   "Int.cast",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isRat_eq_true.match_1",
   "Int",
   "HMul"],
  "name": "Mathlib.Meta.NormNum.isRat_eq_true",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a b : α} {n : ℤ} {d : ℕ},\n  Mathlib.Meta.NormNum.IsRat a n d → Mathlib.Meta.NormNum.IsRat b n d → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.exp_conj",
   "Complex.ofReal'",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "Complex.instCommSemiringComplex",
   "Complex.conj_ofReal",
   "Real",
   "Eq.refl",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Complex.conj_eq_iff_re",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Complex.instStarRingComplexToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Complex.re",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "starRingEnd",
   "Eq.ndrec",
   "Iff.mp",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Complex",
   "Eq.symm",
   "Complex.exp",
   "id"],
  "name": "Complex.ofReal_exp_ofReal_re",
  "constType": "∀ (x : ℝ), ↑(Complex.exp ↑x).re = Complex.exp ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubgroup.instInfAddSubgroup.proof_2",
   "Inf.mk",
   "AddGroup",
   "Inf",
   "AddSubmonoid.toAddSubsemigroup",
   "Inf.inf",
   "AddSubgroup.instInfAddSubgroup.proof_1",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "AddSubgroup.toAddSubmonoid",
   "AddSubgroup.mk",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.instInfAddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid"],
  "name": "AddSubgroup.instInfAddSubgroup",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Inf (AddSubgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "Ne",
   "OfNat.ofNat",
   "Complex.instZeroComplex",
   "False",
   "Real",
   "True",
   "Eq",
   "Complex.re",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "eq_false",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Not",
   "Complex",
   "Complex.zero_cpow",
   "not_false_eq_true",
   "Mathlib.Data.Complex.Basic._auxLemma.2",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Real.zero_rpow",
  "constType": "∀ {x : ℝ}, x ≠ 0 → 0 ^ x = 0",
  "constCategory": "Theorem"},
 {"references": ["IsSymmOp", "Eq"],
  "name": "IsSymmOp.mk",
  "constType":
  "∀ {α : Type u} {β : Type v} {op : α → α → β}, (∀ (a b : α), op a b = op b a) → IsSymmOp α β op",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Monoid",
   "MonoidWithZero.toMonoid",
   "Semiring.toMonoidWithZero",
   "Nat"],
  "name": "Nat.monoid",
  "constType": "Monoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "Nat.pow.match_1", "Unit", "instOfNatNat", "Nat"],
  "name": "Nat.pred",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass",
   "Neg",
   "Eq"],
  "name": "NegZeroClass.mk",
  "constType":
  "{G : Type u_2} → [toZero : Zero G] → [toNeg : Neg G] → -0 = 0 → NegZeroClass G",
  "constCategory": "Other"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Subsingleton.intro", "Subsingleton", "Subsingleton.elim"],
  "name": "instSubsingletonForAll",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.mk",
  "constType": "{R : Type u} → (ℕ → R) → NatCast R",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "abs_pos",
   "Real.instLEReal",
   "Real",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Set.Ioi",
   "Abs.abs",
   "Iff.mpr",
   "Eq",
   "Real.expOrderIso",
   "Real.instNegReal",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "RelIso.instRelHomClassRelIso",
   "SemilatticeSup.toSup",
   "Set.Elem",
   "Preorder.toLT",
   "RelIso",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "Neg.toHasAbs",
   "Ne",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Subtype.le",
   "Real.log.proof_1",
   "LE.le",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "Real.log",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "dif_neg",
   "Not",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Subtype.mk",
   "OrderIso.symm"],
  "name": "Real.log_of_ne_zero",
  "constType":
  "∀ {x : ℝ} (hx : x ≠ 0), Real.log x = (OrderIso.symm Real.expOrderIso) { val := |x|, property := (_ : 0 < |x|) }",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "instHSub",
   "Distrib.toAdd",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "IsCauSeq",
   "HSub.hSub",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "sub_eq_add_neg",
   "Neg.neg",
   "CauSeq",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SubNegMonoid.toSub",
   "LinearOrderedField",
   "Ring.toNeg",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "CauSeq.instSubCauSeq.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrderedField α] [inst_1 : Ring β] {abv : β → α} (f g : CauSeq β abv)\n  (i : ℕ), ↑f i + -↑g i = ↑f i - ↑g i",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.prf",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {coe : outParam (β → α)} {cond : outParam (α → Prop)} [self : CanLift α β coe cond]\n  (x : α), cond x → ∃ y, coe y = x",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toMul",
   "AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.mk",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "le_of_eq", "Preorder.toLE", "Eq"],
  "name": "Eq.le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{K : Type u} → [self : DivisionRing K] → Ring K",
  "constCategory": "Definition"},
 {"references":
  ["Quotient.map₂",
   "instHasEquiv",
   "instHAdd",
   "HAdd.hAdd",
   "CauSeq.add_equiv_add",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.instAddCauSeq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Add",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Add.mk"],
  "name": "CauSeq.Completion.instAddCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Add (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1334", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "HasSubset.Subset",
   "LE.le",
   "Preorder.toLE",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "Set.instHasSubsetSet",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.mono",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace"],
  "name": "MeasureTheory.measure_mono",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s₁ s₂ : Set α}, s₁ ⊆ s₂ → ↑↑μ s₁ ≤ ↑↑μ s₂",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "LE", "Int.le", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "ExistsAddOfLE",
   "LE.le",
   "Eq"],
  "name": "ExistsAddOfLE.mk",
  "constType":
  "∀ {α : Type u} [inst : Add α] [inst_1 : LE α], (∀ {a b : α}, a ≤ b → ∃ c, b = a + c) → ExistsAddOfLE α",
  "constCategory": "Other"},
 {"references":
  ["BiheytingAlgebra",
   "HeytingAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HNot",
   "HNot.hnot",
   "SDiff.sdiff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "OrderTop.toTop",
   "Iff",
   "SemilatticeSup.toSup",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "GeneralizedHeytingAlgebra.toLattice",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "SemilatticeSup.toPartialOrder"],
  "name": "BiheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toHeytingAlgebra : HeytingAlgebra α] →\n    [toSDiff : SDiff α] →\n      [toHNot : HNot α] → (∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) → (∀ (a : α), ⊤ \\ a = ￢a) → BiheytingAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "AddCommMonoid.toAddMonoid",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Semiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionSemiring.mk",
  "constType":
  "{α : Type u_4} →\n  [toSemiring : Semiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → DivisionSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "One.toOfNat1",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instOneCauchy",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.702",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_irrefl.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a : α) (motive : _a ≤ _a ∧ ¬_a ≤ _a → Prop) (x : _a ≤ _a ∧ ¬_a ≤ _a),\n  (∀ (h1 : _a ≤ _a) (h2 : ¬_a ≤ _a), motive (_ : _a ≤ _a ∧ ¬_a ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "LinearOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddZeroClass.toAdd",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "NormedAlgebra.toAlgebra",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "rfl",
   "Eq",
   "NormedField.toField",
   "Field.toCommRing",
   "RingHomClass.toNonUnitalRingHomClass",
   "SeminormedCommRing.toSeminormedRing",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "Real.denselyNormedField",
   "AddMonoidHom.id",
   "AddHomClass.toFunLike",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC.proof_4",
  "constType":
  "∀ (f : ℝ), (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f) = (AddMonoidHom.id ℝ) ((algebraMap ℝ ℝ) f)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "mul_le_mul_of_nonpos_right",
   "OrderedRing",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Ring.toNonAssocRing",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "OrderedRing.toRing",
   "OrderedRing.toPartialOrder",
   "Zero.toOfNat0",
   "instHMul",
   "OrderedSemiring.toSemiring",
   "Eq.mp",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "OrderedRing.toOrderedSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun"],
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "constType":
  "∀ {α : Type u} [inst : OrderedRing α] {a b : α}, a ≤ 0 → b ≤ 0 → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Real.natCast",
   "Real",
   "NatCast.mk",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Nat",
   "Complex.ext",
   "Eq.trans",
   "eq_self",
   "Complex.addCommGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.im",
   "of_eq_true",
   "Complex.mk",
   "SubNegMonoid.toAddMonoid",
   "Complex",
   "congrArg",
   "congrFun"],
  "name": "Complex.Complex.addGroupWithOne.proof_1",
  "constType": "NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommRing.toOrderedCommRing.proof_2",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedCommRing α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Max.mk",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "SemilatticeSup.toSup",
   "sup_eq_maxDefault",
   "IsTotal",
   "Max.max",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "congr_fun₂",
   "SemilatticeSup.toPartialOrder",
   "DecidableRel"],
  "name": "Lattice.toLinearOrder.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1]\n  [inst_2 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "instHAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "HAdd.hAdd",
   "Eq.rec",
   "Set",
   "AddSubsemigroup.add_mem'",
   "Eq.symm",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet",
   "SetLike.coe",
   "Eq"],
  "name": "AddSubmonoid.copy.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) (s : Set M),\n  s = ↑S → ∀ {a b : M}, a ∈ s → b ∈ s → a + b ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "Real.arcsin_zero",
   "AbsoluteValue",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "Real.instAddMonoidReal",
   "Semifield.toCommGroupWithZero",
   "Real.decidableLE",
   "Real.pi",
   "Preorder.toLE",
   "Real.orderedRing",
   "Eq",
   "ite",
   "Real.instOneReal",
   "OneHomClass.toFunLike",
   "Semiring.toNonAssocSemiring",
   "DivisionCommMonoid.toDivisionMonoid",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "Eq.trans",
   "Complex.instOneComplex",
   "instHSub",
   "Complex.abs",
   "instHDiv",
   "Complex.instNontrivialComplex",
   "Mathlib.Order.Basic._auxLemma.1",
   "MulOneClass.toOne",
   "OrderedSemiring.zeroLEOneClass",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "instDecidableTrue",
   "div_one",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1",
   "Complex.im",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Real.instIsDomainRealSemiring",
   "congr",
   "Real.instAddGroupReal",
   "Not",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "Complex.instNegComplex",
   "Real",
   "zero_sub",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "LinearOrderedField.toDiv",
   "True",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "AbsoluteValue.subadditiveHomClass",
   "zero_add",
   "Complex.instSemiringComplex",
   "MonoidHomClass.toOneHomClass",
   "OrderedRing.toOrderedSemiring",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "CommGroupWithZero.toDivisionCommMonoid",
   "eq_self",
   "Real.arcsin",
   "instHAdd",
   "map_one",
   "HSub.hSub",
   "One.toOfNat1",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "ite_congr",
   "Complex.re",
   "Real.instZeroReal",
   "Real.instPreorderReal",
   "OrderedSemiring.toSemiring",
   "Complex",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "AbsoluteValue.monoidWithZeroHomClass",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.arg_one",
  "constType": "Complex.arg 1 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.succ_le_succ",
   "LE.le",
   "Eq",
   "Nat.succ_sub_succ",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Eq.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.zero_le",
   "Nat.succ",
   "Nat.le_of_sub_eq_zero.match_1"],
  "name": "Nat.le_of_sub_eq_zero",
  "constType": "∀ {n m : ℕ}, n - m = 0 → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submonoid.instTopSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Top.top",
   "Submonoid",
   "Set.mem_univ",
   "SetLike.instMembership"],
  "name": "Submonoid.mem_top",
  "constType": "∀ {M : Type u_1} [inst : MulOneClass M] (x : M), x ∈ ⊤",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} → [self : Ring R] → Neg R",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Nat.cast_injective",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Monotone.strictMono_of_injective",
   "Nat.mono_cast",
   "StrictOrderedSemiring.toPartialOrder",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toZero",
   "StrictMono",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne",
   "Nat.strictOrderedSemiring"],
  "name": "Nat.strictMono_cast",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α], StrictMono Nat.cast",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.3933"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.lt",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "SemilatticeSup.le_sup_right",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "Sup.sup",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_7",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b : AddSubmonoid M), b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references": ["And", "not_imp", "propext", "Not", "Eq"],
  "name": "Mathlib.Tactic.PushNeg.not_implies_eq",
  "constType": "∀ (p q : Prop), (¬(p → q)) = (p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "BooleanAlgebra.toHasCompl",
   "isCompl_compl",
   "Preorder.toLE",
   "BooleanAlgebra",
   "Eq",
   "Lattice.toInf",
   "HImp.himp",
   "Eq.mpr",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "GeneralizedHeytingAlgebra.toLattice",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "id",
   "OrderTop.mk",
   "BooleanAlgebra.le_top",
   "Bot.bot",
   "Lattice.toSemilatticeInf",
   "himp_eq",
   "HasCompl.compl",
   "SemilatticeInf.toPartialOrder",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "LE.le",
   "DistribLattice.toLattice",
   "Eq.ndrec",
   "bot_sup_eq",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "propext",
   "OrderBot.toBot",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "GeneralizedCoheytingAlgebra.toOrderBot",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_2",
  "constType": "∀ {α : Type u_1} [inst : BooleanAlgebra α] (x : α), x ⇨ ⊥ = xᶜ",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSMul α β γ",
  "constCategory": "Other"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Filter.inter_mem",
   "Set.preimage",
   "Set",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "instMembershipSetFilter",
   "Set.instMembershipSet"],
  "name": "Filter.map.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (m : α → β) (f : Filter α) {x y : Set β},\n  x ∈ Set.preimage m ⁻¹' f.sets → y ∈ Set.preimage m ⁻¹' f.sets → ((fun x_1 => x (m x_1)) ∩ fun x => y (m x)) ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Eq.rec",
   "Set",
   "letFun",
   "Eq.symm",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet",
   "SetLike.coe",
   "Eq"],
  "name": "AddSubmonoid.copy.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) (s : Set M), s = ↑S → 0 ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "instTransEq",
   "LE",
   "add_zero",
   "Eq.symm",
   "LE.le",
   "AddZeroClass",
   "add_le_add_left",
   "Eq"],
  "name": "le_add_of_nonneg_right",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ b → a ≤ a + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "PseudoMetricSpace.toDist",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real",
   "Ring.toSub",
   "HSub.hSub",
   "SeminormedRing.toPseudoMetricSpace",
   "Norm.norm",
   "SeminormedCommRing",
   "SeminormedRing.dist_eq",
   "Dist.dist",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_12",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Theorem"},
 {"references":
  ["neg_eq_of_add_eq_zero_right",
   "Set.neg_singleton",
   "Set.zero",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "Exists.casesOn",
   "Set.addMonoid",
   "AddMonoid.add_zero",
   "Eq",
   "zsmulRec",
   "SubNegMonoid.toSub",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff.mp",
   "Sub.sub",
   "Set.image",
   "Nat",
   "And.casesOn",
   "instHSub",
   "Set.add",
   "Set.involutiveNeg",
   "Set.image_neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubNegMonoid.mk",
   "AddMonoid.mk",
   "And",
   "Int.negSucc",
   "Singleton.singleton",
   "Int",
   "Set.addMonoid.proof_1",
   "Int.ofNat",
   "AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "Exists",
   "instOfNatInt",
   "Set",
   "Eq.refl",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Sub.mk",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "Set.image_image2_distrib_right",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toAddSemigroup",
   "Set.image_id",
   "AddMonoid.toZero",
   "Set.sub",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Set.neg",
   "Set.add_eq_zero_iff",
   "AddSemigroup.mk",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.addSemigroup",
   "Eq.ndrec",
   "AddMonoid.nsmul_zero",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "NegZeroClass.toZero",
   "Set.addZeroClass"],
  "name": "Set.subtractionMonoid.proof_12",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (s t : Set α), s + t = 0 → -s = t",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "LT.lt",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DecidableRel",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.decidableLT",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "Nat.not_succ_le_self", "Not", "Nat", "instLTNat"],
  "name": "Nat.lt_irrefl",
  "constType": "∀ (n : ℕ), ¬n < n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Set",
   "Finset.zero",
   "Finset.subtractionMonoid.proof_6",
   "Finset.subtractionMonoid.proof_3",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "Finset.nsmul",
   "Finset.subtractionMonoid.proof_4",
   "AddMonoid.toAddSemigroup",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "Finset.toSet",
   "Finset",
   "Finset.subtractionMonoid.proof_1",
   "Finset.sub",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "AddSemigroup.toAdd",
   "Function.Injective.subtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Set.subtractionMonoid",
   "Finset.zsmul",
   "DecidableEq",
   "SubtractionMonoid.toSubNegMonoid",
   "Finset.subtractionMonoid.proof_2",
   "SubNegMonoid.toAddMonoid",
   "Finset.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Finset.subtractionMonoid.proof_5",
   "Finset.add",
   "Finset.coe_injective"],
  "name": "Finset.subtractionMonoid",
  "constType":
  "{α : Type u_2} → [inst : DecidableEq α] → [inst : SubtractionMonoid α] → SubtractionMonoid (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "InvolutiveNeg",
   "Iff",
   "InvolutiveNeg.toNeg",
   "Eq.rec",
   "Neg.neg",
   "neg_neg",
   "Eq.symm",
   "Eq"],
  "name": "neg_eq_iff_eq_neg",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = b ↔ a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Countable",
   "Iff.symm",
   "Countable",
   "Iff",
   "Set.Elem",
   "Set",
   "Encodable",
   "Nonempty",
   "Encodable.nonempty_encodable"],
  "name": "Set.countable_coe_iff",
  "constType": "∀ {α : Type u} {s : Set α}, Countable ↑s ↔ Set.Countable s",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Exists", "Nontrivial"],
  "name": "Nontrivial.exists_pair_ne",
  "constType": "∀ {α : Type u_3} [self : Nontrivial α], ∃ x y, x ≠ y",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Multiplicative",
   "Submonoid.one_mem'",
   "Submonoid.toSubsemigroup",
   "MulOneClass.toOne",
   "Set",
   "Submonoid",
   "One.toOfNat1",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.toSubmonoid.proof_3",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] (S : Submonoid (Multiplicative A)), 1 ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["nonzero_of_invertible",
   "MonoidWithZero.toMulZeroOneClass",
   "Invertible.invOf",
   "Monoid.toOne",
   "GroupWithZero.toNontrivial",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "invOf_eq_right_inv",
   "mul_inv_cancel",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "Invertible",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toInv",
   "Inv.inv"],
  "name": "invOf_eq_inv",
  "constType":
  "∀ {α : Type u} [inst : GroupWithZero α] (a : α) [inst_1 : Invertible a], ⅟a = a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "Function.Injective.subNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Function.Injective.addGroup.proof_1",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddGroup",
   "HSMul.hSMul",
   "Nat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg",
   "instHSub",
   "SubNegMonoid",
   "instHAdd",
   "AddGroup.mk",
   "HSub.hSub",
   "SubNegMonoid.zsmul_neg'",
   "Neg.neg",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "SubNegMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toNatSMul",
   "SubNegMonoid.zsmul_succ'",
   "Function.Injective",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "Add",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int",
   "SubNegMonoid.zsmul_zero'"],
  "name": "Function.Injective.addGroup",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : AddGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddGroup M₁",
  "constCategory": "Definition"},
 {"references":
  ["CauchySeq",
   "Exists",
   "PartialOrder.toPreorder",
   "Set",
   "GE.ge",
   "Exists.imp",
   "compRel",
   "Exists.intro",
   "le_rfl",
   "Exists.casesOn",
   "Preorder.toLE",
   "Nonempty",
   "SemilatticeSup",
   "Filter.HasBasis",
   "Iff",
   "UniformSpace",
   "Iff.mp",
   "comp_symm_of_uniformity",
   "Iff.trans",
   "Filter",
   "And.casesOn",
   "SemilatticeSup.toPartialOrder",
   "instMembershipSetFilter",
   "Membership.mem",
   "Prod.snd",
   "Filter.HasBasis.mem_of_mem",
   "Filter.HasBasis.cauchySeq_iff",
   "HasSubset.Subset",
   "Prod.fst",
   "Filter.HasBasis.mem_iff",
   "LE.le",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Set.instHasSubsetSet",
   "uniformity",
   "Prod.mk",
   "Prod",
   "And.intro"],
  "name": "Filter.HasBasis.cauchySeq_iff'",
  "constType":
  "∀ {α : Type u} {β : Type v} [uniformSpace : UniformSpace α] {γ : Sort u_1} [inst : Nonempty β] [inst : SemilatticeSup β]\n  {u : β → α} {p : γ → Prop} {s : γ → Set (α × α)},\n  Filter.HasBasis (uniformity α) p s → (CauchySeq u ↔ ∀ (i : γ), p i → ∃ N, ∀ n ≥ N, (u n, u N) ∈ s i)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Finset.card_image₂_singleton_right",
   "DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "IsRightCancelAdd",
   "Singleton.singleton",
   "Nat",
   "Add",
   "Finset.add",
   "Finset.instSingletonFinset",
   "Eq",
   "add_left_injective"],
  "name": "Finset.card_add_singleton",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsRightCancelAdd α] [inst_2 : DecidableEq α] (s : Finset α) (a : α),\n  Finset.card (s + {a}) = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.Nodup",
   "Multiset.Nodup.proof_1",
   "List",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Nodup",
  "constType": "{α : Type u_1} → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "CommRing.toNonUnitalCommRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LE.le.lt_iff_ne",
   "AddCommMonoid.toAddMonoid",
   "ne_comm",
   "Zero.toOfNat0",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "Iff.trans",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "zero_le",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "pos_iff_ne_zero",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, 0 < a ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "CauSeq.Completion.instMulCauchy",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1157",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "OrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "OrderedRing.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : OrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "MulActionWithZero",
   "MonoidWithZero.toZero",
   "MulAction",
   "Eq",
   "MonoidWithZero"],
  "name": "MulActionWithZero.mk",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : MonoidWithZero R] →\n      [inst_1 : Zero M] →\n        [toMulAction : MulAction R M] → (∀ (r : R), r • 0 = 0) → (∀ (m : M), 0 • m = 0) → MulActionWithZero R M",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure.prod_swap",
   "sub_sub",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "MeasureTheory.Measure.instSFiniteMap",
   "SubNegMonoid.toNeg",
   "Real.instSubReal",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "ProbabilityTheory.entropy",
   "MeasureTheory.Measure.prod",
   "Eq",
   "MeasurableSingletonClass",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "rdist",
   "ProbabilityTheory.entropy_neg",
   "HDiv.hDiv",
   "Nat",
   "Eq.trans",
   "instOfNat",
   "measurable_snd",
   "instHSub",
   "instHDiv",
   "add_comm",
   "Prod.snd",
   "Function.comp",
   "Prod.fst",
   "Real.instAddCommSemigroupReal",
   "AddCommMagma.toAdd",
   "Prod.instMeasurableSpace",
   "of_eq_true",
   "instNatAtLeastTwo",
   "AddCommGroup",
   "congrArg",
   "neg_sub",
   "MeasurableSpace",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "Real",
   "measurable_fst",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.IsFiniteMeasure",
   "MeasurableSub₂",
   "True",
   "LinearOrderedField.toDiv",
   "MeasureTheory.Measure",
   "Real.instAddCommGroupReal",
   "outParam",
   "measurable_swap",
   "Eq.rec",
   "MeasureTheory.Measure.map_map",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "rdist_def",
   "eq_self",
   "funext",
   "Pi.instNeg",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "ProbabilityTheory.measureEntropy",
   "AddGroup.toSubNegMonoid",
   "Countable",
   "ProbabilityTheory.entropy_def",
   "Eq.ndrec",
   "Measurable.sub",
   "SubtractionMonoid.toSubNegMonoid",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "Prod.swap",
   "Prod",
   "HSub",
   "NegZeroClass.toNeg"],
  "name": "rdist_symm",
  "constType":
  "∀ {Ω : Type u_1} {Ω' : Type u_2} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : MeasureTheory.Measure Ω'} [hG : MeasurableSpace G]\n  [inst : MeasurableSingletonClass G] [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G]\n  {X : Ω → G} {Y : Ω' → G} [inst_3 : MeasureTheory.IsFiniteMeasure μ] [inst_4 : MeasureTheory.IsFiniteMeasure μ'],\n  d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ]",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "instHSMul",
   "Eq.refl",
   "MeasureTheory.OuterMeasure.trim_smul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Eq.mpr",
   "MeasureTheory.Measure.trimmed",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Algebra.id",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim",
   "id"],
  "name": "MeasureTheory.Measure.instSMul.proof_2",
  "constType":
  "∀ {α : Type u_1} {R : Type u_2} [inst : SMul R ENNReal] [inst_1 : IsScalarTower R ENNReal ENNReal]\n  [inst_2 : MeasurableSpace α] (c : R) (μ : MeasureTheory.Measure α), MeasureTheory.OuterMeasure.trim (c • ↑μ) = c • ↑μ",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionCommMonoid.mk",
   "DivisionMonoid",
   "DivisionMonoid.mul_inv_rev",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.inv_inv",
   "CommGroupWithZero",
   "GroupWithZero.toDivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "CommGroupWithZero.toDivisionCommMonoid.proof_1"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "setOf",
   "instHAdd",
   "Real",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Set",
   "LE.le",
   "Bornology.ofDist.proof_1",
   "Eq",
   "Set.instMembershipSet",
   "Bornology.ofDist.proof_2",
   "Bornology.ofDist.proof_4",
   "Bornology.ofBounded",
   "Bornology.ofDist.proof_3",
   "Bornology"],
  "name": "Bornology.ofDist",
  "constType":
  "{α : Type u_3} →\n  (dist : α → α → ℝ) →\n    (∀ (x y : α), dist x y = dist y x) → (∀ (x y z : α), dist x z ≤ dist x y + dist y z) → Bornology α",
  "constCategory": "Definition"},
 {"references":
  ["Bool.noConfusion",
   "False",
   "Bool.decEq.match_1",
   "Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Decidable",
   "Decidable.isTrue",
   "Bool",
   "rfl",
   "Eq"],
  "name": "Bool.decEq",
  "constType": "(a b : Bool) → Decidable (a = b)",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "SetLike",
   "AddSubgroupClass",
   "SubNegMonoid.toNeg",
   "NegMemClass"],
  "name": "AddSubgroupClass.toNegMemClass",
  "constType":
  "∀ {S : Type u_5} {G : Type u_6} [inst : SubNegMonoid G] [inst_1 : SetLike S G] [self : AddSubgroupClass S G],\n  NegMemClass S G",
  "constCategory": "Definition"},
 {"references": ["Add"],
  "name": "IsRightCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real.instMulReal",
   "Real",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Real.ext_cauchy_iff.match_1",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "letFun",
   "Rat.instNegRat",
   "_private.Mathlib.Data.Real.Basic.0.Real.mul_def",
   "_private.Mathlib.Data.Real.Basic.0.Real.mul",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "CauSeq.Completion.instMulCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "id"],
  "name": "Real.cauchy_mul",
  "constType": "∀ (a b : ℝ), (a * b).cauchy = a.cauchy * b.cauchy",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Trunc.out",
   "Classical.decEq",
   "Fintype",
   "Fintype.truncEquivFin",
   "Fintype.card",
   "Fin"],
  "name": "Fintype.equivFin",
  "constType": "(α : Type u_4) → [inst : Fintype α] → α ≃ Fin (Fintype.card α)",
  "constCategory": "Definition"},
 {"references":
  ["RelIso.instRelHomClassRelIso.proof_2",
   "RelEmbedding",
   "RelIso.toRelEmbedding",
   "RelHomClass",
   "FunLike.mk",
   "RelIso",
   "FunLike.coe",
   "RelHomClass.mk",
   "RelIso.instRelHomClassRelIso.proof_1",
   "RelEmbedding.instRelHomClassRelEmbedding",
   "RelHomClass.toFunLike"],
  "name": "RelIso.instRelHomClassRelIso",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {r : α → α → Prop} → {s : β → β → Prop} → RelHomClass (r ≃r s) r s",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "OrderedAddCommGroup.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommGroup : AddCommGroup α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommGroup α",
  "constCategory": "Other"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "Equiv",
   "MulOneClass.toMul",
   "MulOneClass",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Set",
   "FunLike.coe",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "instHMul",
   "Additive.toMul",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mul_mem'",
   "Submonoid",
   "HMul.hMul",
   "Additive",
   "SetLike.coe"],
  "name": "Submonoid.toAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {a b : Additive M},\n  a ∈ ⇑Additive.toMul ⁻¹' ↑S → b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "lt_of_lt_of_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LT.lt.trans_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro",
   "Subtype.mk",
   "Subtype",
   "Nonempty",
   "Subtype.casesOn",
   "Nonempty.casesOn"],
  "name": "nonempty_subtype.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : Nonempty (Subtype p) → Prop) (x : Nonempty (Subtype p)),\n  (∀ (a : α) (h : p a), motive (_ : Nonempty (Subtype p))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Rat.instLERat",
   "Iff.rfl",
   "Rat.not_le",
   "Eq.refl",
   "Min.mk",
   "Preorder.toLE",
   "ite",
   "Eq",
   "Rat.le_antisymm",
   "inferInstance",
   "Eq.mpr",
   "Rat.le_refl",
   "Iff",
   "Decidable",
   "Eq.symm",
   "Rat.le_trans",
   "id",
   "Rat",
   "and_iff_right_of_imp",
   "LE.le",
   "Preorder.mk",
   "Rat.instLTRat",
   "Or.resolve_left",
   "And",
   "Eq.ndrec",
   "Rat.instDecidableLeRatInstLERat",
   "propext",
   "LT.lt",
   "Not",
   "Rat.le_total"],
  "name": "Rat.linearOrder.proof_2",
  "constType": "∀ (a b : ℚ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure.map",
   "Set.preimage",
   "Set",
   "Real",
   "Eq.refl",
   "MeasureTheory.Measure.map_apply",
   "MeasureTheory.Measure.real",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasurableSet",
   "Measurable",
   "MeasureTheory.measureReal_def",
   "ENNReal.toReal",
   "MeasurableSpace",
   "id"],
  "name": "MeasureTheory.map_measureReal_apply",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {f : α → β}, Measurable f → ∀ {s : Set β}, MeasurableSet s → (MeasureTheory.Measure.map f μ).real s = μ.real (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.mk",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.npow",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "zero_le",
   "OrderedAddCommMonoid.toPartialOrder",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "instOfNatInt",
   "Field",
   "CommRing.toRing",
   "One.toOfNat1",
   "Field.zpow",
   "Ring.toSemiring",
   "Int",
   "Eq"],
  "name": "Field.zpow_zero'",
  "constType": "∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "SemilatticeInf.inf_le_left",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf"],
  "name": "inf_le_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Not", "absurd"],
  "name": "Not.elim",
  "constType": "{a : Prop} → {α : Sort u_1} → ¬a → a → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "SubtractionMonoid",
   "Set.addMonoid",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a : Set α), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne.toSub",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.sub_eq_add_neg",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (a b : R), a - b = a + -b",
  "constCategory": "Definition"},
 {"references": ["Fintype.finite", "Fintype", "Finite"],
  "name": "Finite.of_fintype",
  "constType": "∀ (α : Type u_4) [inst : Fintype α], Finite α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PosMulMono",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toPosMulMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], PosMulMono α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "Field.toSemifield",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Nontrivial",
   "Field.toDivisionRing",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.field.proof_6",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], Nontrivial (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b : G), a + b = b + a) → AddCommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "HMul.hMul",
   "LinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Submonoid.instTopSubmonoid",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Submonoid.instBotSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "MulOneClass",
   "Inf.inf",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "Submonoid.instCompleteLatticeSubmonoid.proof_6",
   "Lattice.mk",
   "LT.mk",
   "Submonoid.instCompleteLatticeSubmonoid.proof_16",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Submonoid.instCompleteLatticeSubmonoid.proof_11",
   "Submonoid.instCompleteLatticeSubmonoid.proof_2",
   "Submonoid.instCompleteLatticeSubmonoid.proof_14",
   "Submonoid.instCompleteLatticeSubmonoid.proof_10",
   "CompleteLattice.toLattice",
   "Inf.mk",
   "Submonoid.instCompleteLatticeSubmonoid.proof_12",
   "SemilatticeSup.toSup",
   "Submonoid.mem_top",
   "Preorder.toLT",
   "Submonoid.instCompleteLatticeSubmonoid.proof_7",
   "Submonoid.instCompleteLatticeSubmonoid.proof_9",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "Submonoid.instCompleteLatticeSubmonoid.proof_3",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Bot.bot",
   "Submonoid.instSetLikeSubmonoid",
   "Top.top",
   "Submonoid.instInfSubmonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_5",
   "Submonoid.instCompleteLatticeSubmonoid.proof_15",
   "SemilatticeSup.mk",
   "completeLatticeOfInf",
   "LE.le",
   "Preorder.mk",
   "Submonoid.instCompleteLatticeSubmonoid.proof_8",
   "InfSet.mk",
   "SetLike.instPartialOrder",
   "Submonoid.instCompleteLatticeSubmonoid.proof_13",
   "CompleteLattice",
   "LT.lt",
   "Bot.mk",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Top.mk",
   "Submonoid.instCompleteLatticeSubmonoid.proof_4"],
  "name": "Submonoid.instCompleteLatticeSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → CompleteLattice (Submonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "Set",
   "AddSubmonoid.add",
   "rfl",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Subtype",
   "Eq",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.toAddZeroClass.proof_3",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) (x x_1 : ↥S), ↑(x + x_1) = ↑(x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "Finset.toSet",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.coe_mem",
   "True",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.7",
  "constType": "∀ {α : Type u_1} {s : Finset α} (x : ↑↑s), (↑x ∈ s) = True",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "LT.lt.le",
   "congr_arg",
   "Eq.le",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Eq",
   "Iff.intro",
   "LE.le.eq_or_lt",
   "forall₂_congr",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Monotone",
   "Or.elim"],
  "name": "monotone_iff_forall_lt",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f ↔ ∀ ⦃a b : α⦄, a < b → f a ≤ f b",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Membership.mem",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Set",
   "Set.instSupSetSet",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_2",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)) (t : Set α), (∀ b ∈ s, b ≤ t) → ∀ a ∈ sSup s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["DiscreteMeasurableSpace", "Set", "MeasurableSet", "MeasurableSpace"],
  "name": "DiscreteMeasurableSpace.mk",
  "constType":
  "∀ {α : Type u_7} [inst : MeasurableSpace α], (∀ (s : Set α), MeasurableSet s) → DiscreteMeasurableSpace α",
  "constCategory": "Other"},
 {"references":
  ["Rat.instLERat",
   "Iff.rfl",
   "Rat.not_le",
   "Rat",
   "Eq.refl",
   "and_iff_right_of_imp",
   "LE.le",
   "Eq",
   "Or.resolve_left",
   "Rat.instLTRat",
   "And",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "Not",
   "Rat.le_total",
   "Eq.symm",
   "id"],
  "name": "Rat.linearOrder.proof_1",
  "constType": "∀ (x x_1 : ℚ), x < x_1 ↔ x ≤ x_1 ∧ ¬x_1 ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.mul_succ",
  "constType": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.add_assoc",
   "Nat.succ_mul",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.add_left_comm",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.zero_mul",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "congrFun",
   "id"],
  "name": "Nat.left_distrib",
  "constType": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "constCategory": "Theorem"},
 {"references":
  ["Bool.not_eq_true",
   "Iff.rfl",
   "Eq.refl",
   "instLTNat",
   "LE.le",
   "Eq",
   "Nat.ble_eq",
   "Eq.mpr",
   "Nat.ble",
   "Iff",
   "instLENat",
   "Eq.ndrec",
   "Bool.false",
   "propext",
   "Bool.true",
   "LT.lt",
   "Not",
   "Nat.not_le",
   "Bool",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Mathlib.Meta.NormNum.ble_eq_false",
  "constType": "∀ {x y : ℕ}, Nat.ble x y = false ↔ y < x",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.Basic._auxLemma.1",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * b + a * c = a * (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "Real.strictOrderedCommSemiring",
   "Real",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring"],
  "name": "Real.strictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Filter",
   "Inter.inter",
   "Set.univ",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mk",
  "constType":
  "{α : Type u_1} →\n  (sets : Set (Set α)) →\n    Set.univ ∈ sets →\n      (∀ {x y : Set α}, x ∈ sets → x ⊆ y → y ∈ sets) → (∀ {x y : Set α}, x ∈ sets → y ∈ sets → x ∩ y ∈ sets) → Filter α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "zpowRec",
   "MulOneClass.toMul",
   "Complex.inv_zero",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "Real.instAddMonoidReal",
   "NonUnitalRingHomClass.toMulHomClass",
   "Complex.instRatCastComplex",
   "Complex.instField.proof_9",
   "Complex.instStarRingComplexToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Semiring.toNonAssocSemiring",
   "DistribSMul.toSMulZeroClass",
   "Semiring.npow",
   "Complex.instField.proof_6",
   "Div.mk",
   "Field",
   "Complex.normSq",
   "HSMul.hSMul",
   "MonoidWithZeroHom",
   "Semigroup.mk",
   "Complex.instNontrivialComplex",
   "Complex.commRing",
   "Rat.distribSMul",
   "Complex.instSMulRealComplex",
   "Field.mk",
   "Complex.instField.proof_11",
   "Complex.instField.proof_10",
   "SMulZeroClass.toSMul",
   "instHMul",
   "Complex.instField.proof_5",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "RingHom",
   "Monoid.mk",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "Real",
   "Complex.mul_inv_cancel",
   "Complex.instField.proof_4",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "Complex.instInvComplex",
   "Complex.instField.proof_8",
   "NonAssocSemiring.toMulZeroOneClass",
   "Complex.instField.proof_1",
   "Inv.mk",
   "RingHomClass.toNonUnitalRingHomClass",
   "Complex.instSemiringComplex",
   "starRingEnd",
   "Complex.ofReal'",
   "Complex.instCommSemiringComplex",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "Complex.instField.proof_7",
   "MonoidHomClass.toMulHomClass",
   "Rat",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Complex.instField.proof_2",
   "NonUnitalNonAssocSemiring.toMul",
   "DivInvMonoid.div'",
   "Ring.toSemiring",
   "Real.instDivisionRingReal",
   "Real.instZeroReal",
   "Semiring.toOne",
   "Real.semiring",
   "HMul.hMul",
   "Complex",
   "Complex.instMulComplex",
   "Complex.instField.proof_3"],
  "name": "Complex.instField",
  "constType": "Field ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.biUnion_eq_iUnion",
   "Subtype.val",
   "Set",
   "Set.Countable.to_subtype",
   "Eq.refl",
   "MeasurableSet.iUnion",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Set.Countable",
   "Countable",
   "Eq.mpr",
   "Set.iUnion",
   "Eq.ndrec",
   "Set.Elem",
   "MeasurableSet",
   "letFun",
   "MeasurableSpace",
   "Subtype",
   "id"],
  "name": "MeasurableSet.biUnion",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {f : β → Set α} {s : Set β},\n  Set.Countable s → (∀ b ∈ s, MeasurableSet (f b)) → MeasurableSet (⋃ b ∈ s, f b)",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "One", "One.mk", "One.toOfNat1"],
  "name": "Pi.instOne",
  "constType":
  "{I : Type u} → {f : I → Type v₁} → [inst : (i : I) → One (f i)] → One ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toDivisionSemiring",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "DivisionRing.toRing",
   "GroupWithZero.toDivisionMonoid",
   "Semiring.toMonoidWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "mul_inv_rev",
   "InvOneClass.toInv",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "inv_pow",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivisionRing.toInv",
   "DivInvMonoid.toInv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "Mathlib.Tactic.Ring.inv_mul",
  "constType":
  "∀ {R : Type u_1} [inst : DivisionRing R] {a₁ : R} {a₂ : ℕ} {a₃ b₁ b₃ c : R},\n  a₁⁻¹ = b₁ → a₃⁻¹ = b₃ → b₃ * (b₁ ^ a₂ * Nat.rawCast 1) = c → (a₁ ^ a₂ * a₃)⁻¹ = c",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "LinearOrderedSemiring.toMin",
   "Eq"],
  "name": "LinearOrderedSemiring.min_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), min a b = if a ≤ b then a else b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "left_distrib",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Nat.le_of_ble_eq_true.match_1",
   "Nat.succ_le_succ",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.zero_le",
   "Nat.succ"],
  "name": "Nat.le_of_ble_eq_true",
  "constType": "∀ {n m : ℕ}, Nat.ble n m = true → n ≤ m",
  "constCategory": "Theorem"},
 {"references": ["Zero", "OfNat.ofNat", "OfNat", "Zero.mk"],
  "name": "Zero.ofOfNat0",
  "constType": "{α : Type u_1} → [inst : OfNat α 0] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Set.instSingletonSet",
   "Set",
   "Zero.mk",
   "Singleton.singleton"],
  "name": "Set.zero",
  "constType": "{α : Type u_2} → [inst : Zero α] → Zero (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "DivisionMonoid",
   "Monoid.toSemigroup",
   "instHMul",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "HMul.hMul",
   "DivInvMonoid.toMonoid",
   "Eq"],
  "name": "DivisionCommMonoid.mk",
  "constType":
  "{G : Type u} → [toDivisionMonoid : DivisionMonoid G] → (∀ (a b : G), a * b = b * a) → DivisionCommMonoid G",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedAddCommMonoid.exists_add_of_le",
  "constType":
  "∀ {α : Type u_1} [self : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b → ∃ c, b = a + c",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Iff",
   "Classical.propDecidable",
   "Not",
   "Decidable.or_iff_not_imp_left"],
  "name": "Classical.or_iff_not_imp_left",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["OrderHom.monotone'",
   "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
   "FunLike.mk",
   "OrderHom",
   "OrderHom.toFun",
   "RelHomClass.mk",
   "Preorder",
   "LE.le",
   "OrderHomClass",
   "Preorder.toLE"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst_1 : Preorder β] → OrderHomClass (α →o β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroClass.zero_mul",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "StrictOrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "mul_lt_mul_of_pos_left",
   "Eq.trans",
   "Or",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Order.Basic._auxLemma.1",
   "Or.casesOn",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "instHMul",
   "Decidable.eq_or_lt_of_le",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "le_refl",
   "congr",
   "HMul.hMul",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DecidableRel"],
  "name": "StrictOrderedSemiring.toOrderedSemiring'.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] (a b c : α),\n  a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Set.Image._auxLemma.20",
   "Set",
   "FiniteRange.mk",
   "Finset.instMembershipFinset",
   "Finset.finite_toSet",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Set.Finite.subset",
   "Eq.ndrec",
   "FiniteRange",
   "Finset.toSet",
   "Finset",
   "Eq.mp"],
  "name": "finiteRange_of_finset",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} (f : Ω → G) (A : Finset G), (∀ (ω : Ω), f ω ∈ A) → FiniteRange f",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5622"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.sup",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Iff",
   "Function.Injective",
   "Function.Injective.eq_iff'",
   "ZeroHomClass.toFunLike",
   "ZeroHomClass",
   "map_zero",
   "FunLike.coe",
   "Eq"],
  "name": "map_eq_zero_iff",
  "constType":
  "∀ {M : Type u_3} {N : Type u_4} {F : Type u_8} [inst : Zero M] [inst_1 : Zero N] [inst_2 : ZeroHomClass F M N] (f : F),\n  Function.Injective ⇑f → ∀ {x : M}, f x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.vaddFinset",
   "Membership.mem",
   "Finset.neg_vadd_mem_iff",
   "AddGroup.toSubtractionMonoid",
   "Finset.instMembershipFinset",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "instHVAdd",
   "AddAction",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "AddGroup",
   "DecidableEq",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "Finset",
   "AddAction.toVAdd",
   "HVAdd.hVAdd",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Combinatorics.Additive.RuzsaCovering._auxAddLemma.2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : DecidableEq β] [inst_1 : AddGroup α] [inst_2 : AddAction α β] {s : Finset β}\n  {a : α} {b : β}, (b ∈ a +ᵥ s) = (-a +ᵥ b ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Nat.zero",
   "Nat.pred",
   "LT.lt",
   "Nat.le_refl",
   "instOfNatNat",
   "Nat.lt_succ_of_le",
   "Nat",
   "Nat.succ",
   "rfl",
   "absurd",
   "instLTNat",
   "Eq",
   "Nat.pred_lt.match_1"],
  "name": "Nat.pred_lt",
  "constType": "∀ {n : ℕ}, n ≠ 0 → Nat.pred n < n",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Classical.decRel",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Ord.mk",
   "Max.mk",
   "Cardinal.partialOrder",
   "Cardinal.instLECardinal.proof_1",
   "Cardinal.partialOrder.proof_2",
   "LT.mk",
   "Min.mk",
   "Preorder.toLE",
   "Nonempty",
   "ite",
   "Cardinal.linearOrder.proof_2",
   "Cardinal.partialOrder.proof_1",
   "Preorder.toLT",
   "Cardinal.linearOrder.proof_3",
   "LinearOrder.mk",
   "Cardinal.partialOrder.proof_4",
   "Function.Embedding",
   "compareOfLessAndEq",
   "Cardinal.linearOrder.proof_4",
   "LinearOrder",
   "Quotient.liftOn₂",
   "decidableEqOfDecidableLE",
   "LE.le",
   "Cardinal.instLECardinal",
   "Preorder.mk",
   "PartialOrder",
   "And",
   "Cardinal.linearOrder.proof_1",
   "Cardinal.partialOrder.proof_3",
   "Cardinal",
   "decidableLTOfDecidableLE",
   "PartialOrder.le_antisymm",
   "Not",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.linearOrder",
  "constType": "LinearOrder Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": ["Field", "Inv"],
  "name": "Field.toInv",
  "constType": "{K : Type u} → [self : Field K] → Inv K",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Ring",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Int.cast_ofNat",
   "Semiring.toOne",
   "instHMul",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "Invertible.mk",
   "mul_one",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isRat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsRat a (Int.ofNat n) 1",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddGroup",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "sub_le_sub_iff_right",
   "LE",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr"],
  "name": "sub_le_sub_right",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  a ≤ b → ∀ (c : α), a - c ≤ b - c",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Eq.refl",
   "Finset.mk.injEq",
   "Preorder.toLE",
   "True",
   "Multiset.instMembershipMultiset",
   "iff_self",
   "Iff.of_eq",
   "Eq",
   "Finset.casesOn",
   "Iff",
   "Multiset",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Mathlib.Data.Multiset.Basic._auxLemma.62",
   "Mathlib.Data.Multiset.Powerset._auxLemma.3",
   "Eq.symm",
   "Finset.powerset.proof_1",
   "Eq.trans",
   "Membership.mem",
   "funext",
   "Multiset.powerset",
   "Finset.powerset",
   "HasSubset.Subset",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Std.Logic._auxLemma.51",
   "LE.le",
   "Std.Logic._auxLemma.38",
   "Multiset.instPartialOrderMultiset",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "Finset.mk",
   "Finset.powerset.proof_2",
   "Mathlib.Data.Finset.Powerset._auxLemma.5",
   "Finset.instHasSubsetFinset",
   "congrArg",
   "Mathlib.Data.Finset.Basic._auxLemma.3",
   "exists_prop_congr'"],
  "name": "Finset.mem_powerset",
  "constType":
  "∀ {α : Type u_1} {s t : Finset α}, s ∈ Finset.powerset t ↔ s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.Prime.two_le",
   "instLTNat"],
  "name": "Nat.Prime.one_lt",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 1 < p",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "dite",
   "lt_of_not_ge",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_or_le",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Monoid",
   "MulOneClass.toMul",
   "Units.instInv",
   "Eq.refl",
   "Monoid.toMulOneClass",
   "Units.inv_mul_cancel_right",
   "Eq",
   "Iff.intro",
   "Units",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Units.val",
   "HMul.hMul",
   "Eq.symm",
   "Units.mul_inv_cancel_right",
   "Inv.inv",
   "id"],
  "name": "Units.eq_mul_inv_iff_mul_eq",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (c : αˣ) {a b : α}, a = b * ↑c⁻¹ ↔ a * ↑c = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toRing",
   "Real.instMulReal",
   "Real",
   "implies_congr",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.5",
   "Rat.instNegRat",
   "Real.ind_mk",
   "CauSeq.instMulCauSeq",
   "Eq.trans",
   "id",
   "Neg.toHasAbs",
   "Real.instLTReal",
   "Rat",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.11",
   "CauSeq.Pos",
   "Real.instZeroReal",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "LT.lt",
   "Real.mk",
   "HMul.hMul",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "CauSeq.mul_pos"],
  "name": "Real.mul_pos",
  "constType": "∀ {a b : ℝ}, 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "mul_neg",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "neg_mul_eq_mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -(a * b) = a * -b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toOrd",
   "Ord.compare",
   "Ordering",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LinearOrder.decidableLT",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "compareOfLessAndEq",
   "Eq"],
  "name": "LinearOrder.compare_eq_compareOfLessAndEq",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), compare a b = compareOfLessAndEq a b",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Function.swap",
   "Covariant",
   "Iff.mp",
   "AddGroup",
   "Contravariant",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covariant_swap_iff_contravariant_swap",
   "AddGroup.toSubNegMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "CovariantClass.elim"],
  "name": "AddGroup.covconv_swap",
  "constType":
  "∀ {N : Type u_2} {r : N → N → Prop} [inst : AddGroup N]\n  [inst_1 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) r],\n  ContravariantClass N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references":
  ["add_assoc",
   "AddOpposite.unop",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddOpposite",
   "Eq.symm",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.toOppositeAddAction.proof_2",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoid α] (x x_1 : αᵃᵒᵖ) (x_2 : α),\n  x_2 + (AddOpposite.unop x_1 + AddOpposite.unop x) = x_2 + AddOpposite.unop x_1 + AddOpposite.unop x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Subtype.val",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "rfl",
   "SetLike.instMembership",
   "Eq",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.subtype.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), ↑0 = ↑0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommGroupWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Zero.mk",
   "Eq.refl",
   "instOfNatNat",
   "nsmulRec",
   "Nat",
   "Eq",
   "Add.mk"],
  "name": "Real.commRing.proof_5",
  "constType": "∀ (n : ℕ) (x : ℝ), nsmulRec (n + 1) x = nsmulRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Add",
   "AddSubsemigroup",
   "Set.instMembershipSet"],
  "name": "AddSubsemigroup.mk",
  "constType":
  "{M : Type u_4} →\n  [inst : Add M] → (carrier : Set M) → (∀ {a b : M}, a ∈ carrier → b ∈ carrier → a + b ∈ carrier) → AddSubsemigroup M",
  "constCategory": "Other"},
 {"references": ["Multiplicative", "rfl", "Eq"],
  "name": "Multiplicative.ofAdd.proof_2",
  "constType":
  "∀ {α : Type u_1} (x : Multiplicative α), (fun x => x) ((fun x => x) x) = (fun x => x) ((fun x => x) x)",
  "constCategory": "Theorem"},
 {"references":
  ["NormedField.toNormedDivisionRing.proof_7",
   "DivisionRing.mk",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "NormedField.toNormedDivisionRing.proof_5",
   "NormedField.norm_mul'",
   "Field.toInv",
   "Field.zpow",
   "NormedField.toNormedDivisionRing.proof_8",
   "NormedField.toNorm",
   "NormedField.toNormedDivisionRing.proof_2",
   "Field.toRatCast",
   "NormedField.toNormedDivisionRing.proof_9",
   "Field.toCommRing",
   "NormedField.toField",
   "NormedField.toNormedDivisionRing.proof_1",
   "NormedField.toNormedDivisionRing.proof_6",
   "NormedField.toNormedDivisionRing.proof_3",
   "CommRing.toRing",
   "Field.toDiv",
   "NormedDivisionRing",
   "Field.qsmul",
   "NormedField.toNormedDivisionRing.proof_4",
   "NormedDivisionRing.mk"],
  "name": "NormedField.toNormedDivisionRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedDivisionRing α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Zero.toOfNat0",
   "Left.neg_neg_iff",
   "AddGroup",
   "Iff",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_lt_zero",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "CommMonoidWithZero.toZero",
   "instHDiv",
   "OfNat.ofNat",
   "Ne.isUnit",
   "CommGroupWithZero.toGroupWithZero",
   "CommGroupWithZero",
   "IsUnit.mul_div_cancel'",
   "CommGroupWithZero.toCommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "CommGroupWithZero.toDiv",
   "HMul.hMul",
   "HDiv.hDiv",
   "CommGroupWithZero.toDivisionCommMonoid"],
  "name": "mul_div_cancel'",
  "constType":
  "∀ {G₀ : Type u_3} [inst : CommGroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → b * (a / b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LinearOrder.toPartialOrder",
   "Nat",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Nat.linearOrderedCommSemiring.proof_4",
  "constType": "∀ (a b : ℕ), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddLeftCancelSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3954",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddLeftCancelMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3915",
   "Eq"],
  "name": "AddLeftCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddLeftCancelSemigroup : AddLeftCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddLeftCancelMonoid M",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid.toContravariantClassLeLeft",
   "OrderedCancelAddCommMonoid",
   "AddZeroClass.toAdd",
   "contravariant_lt_of_contravariant_le",
   "ContravariantClass.elim",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Preorder.toLE",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "ContravariantClass",
   "ContravariantClass.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toContravariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α],\n  ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.mk",
  "constType": "{R : Type u} → (ℤ → R) → IntCast R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "ne_of_lt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mul_nonneg",
   "Rat.instOfNatRat",
   "Rat.isDomain",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "IsDomain.to_noZeroDivisors",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "le_of_lt",
   "Rat.instMulRat",
   "Rat.linearOrder",
   "Rat",
   "mul_ne_zero",
   "Ne.symm",
   "NonUnitalNonAssocSemiring.toMul",
   "Rat.field",
   "Ring.toSemiring",
   "Rat.instPreorderRat",
   "lt_of_le_of_ne",
   "Rat.instPartialOrderRat",
   "instHMul",
   "Rat.divisionRing",
   "LT.lt",
   "CommRing.toRing",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.instLinearOrderedFieldRat.proof_3",
  "constType": "∀ (a b : ℚ), 0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SMul",
   "SMul.mk",
   "instHSMul",
   "Subtype.val",
   "Set",
   "AddSubgroup.zsmul.proof_1",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "HSMul.hSMul",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Int",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.zsmul",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → {H : AddSubgroup G} → SMul ℤ ↥H",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "BiheytingAlgebra"],
  "name": "BiheytingAlgebra.toHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : BiheytingAlgebra α] → HeytingAlgebra α",
  "constCategory": "Definition"},
 {"references": ["HasCompl", "CompleteAtomicBooleanAlgebra"],
  "name": "CompleteAtomicBooleanAlgebra.toHasCompl",
  "constType":
  "{α : Type u} → [self : CompleteAtomicBooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Eq.refl",
   "Rat.instLinearOrderedRingRat",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Real.noConfusionType",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.casesOn",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : ℝ} → v1 = v2 → Real.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "OfNat.ofNat",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Mathlib.Data.Real.CauSeqCompletion._auxLemma.1",
   "CauSeq.LimZero",
   "CauSeq.Completion.inv_mk",
   "CauSeq.Completion.instOneCauchy",
   "CauSeq.inv_mul_cancel",
   "True",
   "Quotient.sound",
   "Eq",
   "Quotient.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Eq.mpr",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.instMulCauchy",
   "not_false_eq_true",
   "CauSeq.Completion.instInvCauchyToRing",
   "CauSeq.instMulCauSeq",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "Ne",
   "DivisionRing",
   "False",
   "One.toOfNat1",
   "CauSeq",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CauSeq.Completion.instZeroCauchy",
   "Semiring.toOne",
   "CauSeq.equiv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "eq_false",
   "CauSeq.inv",
   "of_eq_true",
   "OrderedCommSemiring.toOrderedSemiring",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "Not",
   "CauSeq.Completion.mk",
   "congrArg",
   "Quotient.inductionOn",
   "congrFun",
   "Inv.inv"],
  "name": "CauSeq.Completion.inv_mul_cancel",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {x : CauSeq.Completion.Cauchy abv}, x ≠ 0 → x⁻¹ * x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α] (motive : Mathlib.Meta.NormNum.IsInt a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsInt a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsInt a n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Inf.inf",
   "AddGroup.toSubtractionMonoid",
   "Exists.casesOn",
   "Preorder.toLE",
   "SetLike.instMembership",
   "AddSubgroup.comap",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Set.Elem",
   "AddSubgroup.addSubgroupOf",
   "Std.Classes.Order._auxLemma.3",
   "Set.image",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "And.casesOn",
   "Eq.trans",
   "Subtype",
   "Equiv.symm",
   "setOf",
   "Set.add",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "inf_of_le_left",
   "Std.Logic._auxLemma.32",
   "Set.image_add",
   "Set.instMembershipSet",
   "Nat.card_congr",
   "instHMul",
   "And",
   "eq_true",
   "of_eq_true",
   "Subtype.range_coe_subtype",
   "AddSubgroup.leftTransversals",
   "And.intro",
   "AddSubgroup.subtype",
   "congrArg",
   "AddSubgroup.add",
   "congrFun",
   "SetLike.coe",
   "AddZeroClass.toAdd",
   "Exists",
   "Subtype.val",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "GE.ge",
   "AddSubgroup.zero",
   "Eq.refl",
   "AddSubgroup.exists_left_transversal",
   "AddSubgroup.toAddSubmonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddSubgroup.IsComplement.add_eq",
   "AddSubgroup.toAddGroup",
   "True",
   "iff_self",
   "Equiv.Set.image",
   "Set.range",
   "Zero.toOfNat0",
   "AddGroup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "forall_congr",
   "Mathlib.GroupTheory.Complement._auxAddLemma.16",
   "AddSubgroup",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.image_congr",
   "AddHomClass.toFunLike",
   "instHAdd",
   "AddSubgroup.instInfAddSubgroup",
   "Mathlib.Data.SetLike.Basic._auxLemma.3",
   "ConditionallyCompleteLattice.toLattice",
   "SemilatticeInf.toPartialOrder",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.image_univ",
   "AddSubgroup.IsComplement.card_mul_card",
   "Set.univ",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "AddSubgroup.map",
   "Zero.nonempty",
   "Eq.ndrec",
   "congr_arg₂",
   "AddSubgroup.instCompleteLatticeAddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "AddMonoidHomClass.toAddHomClass",
   "AddSubgroup.subtype_injective",
   "AddMonoidHom.addMonoidHomClass",
   "instMulNat",
   "NegZeroClass.toZero",
   "Nat.card",
   "AddSubgroup.addSubgroupOf_map_subtype",
   "AddMonoidHom"],
  "name": "AddSubgroup.exists_left_transversal_of_le",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H' H : AddSubgroup G},\n  H' ≤ H → ∃ S, S + ↑H' = ↑H ∧ Nat.card ↑S * Nat.card ↥H' = Nat.card ↥H",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "AddSubmonoid.zero_mem",
   "AddSubmonoid",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Iff.mp",
   "AddSubmonoid.mem_bot",
   "Eq.rec",
   "Bot.mk",
   "Eq.symm",
   "AddZeroClass"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_16",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), ∀ x ∈ ⊥, x ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "Measurable",
   "le_sup_right",
   "Prod",
   "Measurable.of_comap_le",
   "Prod.fst",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "Lattice.toSemilatticeSup",
   "MeasurableSpace.comap",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "measurable_snd",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}, Measurable Prod.snd",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "AddGroup",
   "AddSubgroup.instSetLikeAddSubgroup.proof_1",
   "AddSubmonoid.toAddSubsemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instSetLikeAddSubgroup",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → SetLike (AddSubgroup G) G",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "le_iff_exists_add",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHom.toMonoidHom",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → (α →+* β) → α →* β",
  "constCategory": "Definition"},
 {"references": ["CanLift", "Exists", "outParam", "Eq"],
  "name": "CanLift.mk",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {coe : outParam (β → α)} {cond : outParam (α → Prop)},\n  (∀ (x : α), cond x → ∃ y, coe y = x) → CanLift α β coe cond",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddCommSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.27",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "nsmul_eq_mul'",
   "instHSMul",
   "Nat.cast_commute",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "AddMonoid.toNatSMul",
   "instHMul",
   "Eq.mpr",
   "Commute.eq",
   "Eq.ndrec",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HSMul.hSMul",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "id"],
  "name": "nsmul_eq_mul",
  "constType":
  "∀ {R : Type u₁} [inst : NonAssocSemiring R] (n : ℕ) (a : R), n • a = ↑n * a",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid",
   "DivInvMonoid.toMonoid",
   "CommMonoid.mk",
   "DivisionCommMonoid.mul_comm"],
  "name": "DivisionCommMonoid.toCommMonoid",
  "constType": "{G : Type u} → [self : DivisionCommMonoid G] → CommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SMul",
   "SMul.mk",
   "instHSMul",
   "Subtype.val",
   "Set",
   "AddSubgroup.nsmul.proof_1",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "AddMonoid.toNatSMul",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "HSMul.hSMul",
   "SubNegMonoid.toAddMonoid",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "Subtype.mk",
   "SetLike.coe"],
  "name": "AddSubgroup.nsmul",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → {H : AddSubgroup G} → SMul ℕ ↥H",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddMonoid.nsmul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "AddLeftCancelMonoid.mk",
   "Eq.symm",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype",
   "Cardinal.mk_toNat_eq_card",
   "Fintype.card",
   "Nat",
   "Nat.card",
   "Eq"],
  "name": "Nat.card_eq_fintype_card",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α], Nat.card α = Fintype.card α",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.succ_mul",
   "OfNat.ofNat",
   "Or",
   "Or.inr",
   "instAddNat",
   "instHAdd",
   "Nat.eq_zero_of_mul_eq_zero.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "rfl",
   "Eq",
   "Nat.eq_zero_of_add_eq_zero_left",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Or.inl",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.eq_zero_of_mul_eq_zero",
  "constType": "∀ {n m : ℕ}, n * m = 0 → n = 0 ∨ m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "instHasEquiv",
   "CauSeq.lim",
   "CauSeq.IsComplete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.lim_eq_of_equiv_const",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "CauSeq.equiv_lim",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Setoid.trans",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.lim_eq_lim_of_equiv",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] {f g : CauSeq β abv},\n  f ≈ g → CauSeq.lim f = CauSeq.lim g",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "RatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.not_succ_le_zero.match_3",
   "Nat.not_succ_le_zero.match_2",
   "OfNat.ofNat",
   "False",
   "instLENat",
   "Nat.not_succ_le_zero.match_1",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "LE.le"],
  "name": "Nat.not_succ_le_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≤ 0 → False",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid"],
  "name": "AddAction",
  "constType":
  "(G : Type u_10) → Type u_11 → [inst : AddMonoid G] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["Nat.not_prime_one",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "Nat.Prime",
   "False.elim",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "le_add_self",
   "Nat.canonicallyOrderedCommSemiring",
   "instOfNatNat",
   "Nat",
   "Nat.not_prime_zero",
   "LE.le",
   "Nat.Prime.two_le.match_1"],
  "name": "Nat.Prime.two_le",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 2 ≤ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "Semiring.npow",
   "Semiring",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Semiring.npow_zero",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (x : α), Semiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Real.casesOn",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
  "constType":
  "(motive : ℝ → Sort u_1) → (x : ℝ) → ((a : CauSeq.Completion.Cauchy abs) → motive { cauchy := a }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "And",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "DenselyNormedField",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "NormedField",
   "Norm.norm",
   "LE.le",
   "NormedField.toNorm"],
  "name": "DenselyNormedField.mk",
  "constType":
  "{α : Type u_5} →\n  [toNormedField : NormedField α] → (∀ (x y : ℝ), 0 ≤ x → x < y → ∃ a, x < ‖a‖ ∧ ‖a‖ < y) → DenselyNormedField α",
  "constCategory": "Other"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons",
   "And.left"],
  "name": "List.pmap.proof_3",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → p a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "And",
   "Exists",
   "Nat",
   "MeasureTheory.SFinite",
   "MeasureTheory.IsFiniteMeasure",
   "MeasureTheory.Measure.sum",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.SFinite.mk",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α},\n  (∃ m, (∀ (n : ℕ), MeasureTheory.IsFiniteMeasure (m n)) ∧ μ = MeasureTheory.Measure.sum m) → MeasureTheory.SFinite μ",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.refl",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["ExistsUnique.exists.match_1",
   "Exists",
   "Exists.intro",
   "ExistsUnique",
   "Eq"],
  "name": "ExistsUnique.exists",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (∃! x, p x) → ∃ x, p x",
  "constCategory": "Theorem"},
 {"references": ["Inter", "Set", "Inter.mk", "Set.inter"],
  "name": "Set.instInterSet",
  "constType": "{α : Type u_1} → Inter (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Int",
   "Eq"],
  "name": "SubNegMonoid.zsmul_zero'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a : G), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instAddNat",
   "instNatCastInt",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "Int",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Int.instCommRingInt.proof_3",
  "constType": "∀ (x : ℕ), NatCast.natCast (x + 1) = NatCast.natCast (x + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.instMulInt",
   "instHAdd",
   "Int.mul_add",
   "HAdd.hAdd",
   "True",
   "Int.mul_comm",
   "Eq",
   "Int.instAddInt",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "congr",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.add_mul",
  "constType": "∀ (a b c : ℤ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["iInf_subtype",
   "Subtype.property",
   "CompleteLattice",
   "iInf",
   "Subtype.val",
   "CompleteLattice.toInfSet",
   "Eq.symm",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "iInf_subtype'",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {p : ι → Prop} {f : (i : ι) → p i → α},\n  ⨅ i, ⨅ (h : p i), f i h = ⨅ x, f ↑x (_ : p ↑x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "OrderedCommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SeminormedRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["NormedRing.toNorm",
   "NormedCommRing.toSeminormedCommRing.proof_2",
   "NormedCommRing",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "SeminormedCommRing",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toSeminormedCommRing.proof_1",
   "SeminormedRing.mk",
   "NormedRing.toRing",
   "SeminormedCommRing.mk"],
  "name": "NormedCommRing.toSeminormedCommRing",
  "constType": "{α : Type u_1} → [β : NormedCommRing α] → SeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "Eq"],
  "name": "AddCommSemigroup.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommSemigroup G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "Subtype.val",
   "AddSubgroup",
   "Neg.neg",
   "AddSubgroup.neg",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x : ↥H), ↑(-x) = ↑(-x)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Eq",
   "inferInstance",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "Set",
   "InfSet.sInf",
   "completeLatticeOfInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_15",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (s : Set (Submonoid M)) (a : Submonoid M), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "inferInstance",
   "LinearOrderedRing",
   "Real.linearOrderedCommRing",
   "Real"],
  "name": "Real.instLinearOrderedRingReal",
  "constType": "LinearOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references": ["Or", "em", "Or.symm", "Not"],
  "name": "em'",
  "constType": "∀ (p : Prop), ¬p ∨ p",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Nat.strictMono_cast",
   "Nat.linearOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "StrictMono.le_iff_le",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n",
  "constCategory": "Theorem"},
 {"references": ["Int.mul", "Mul", "Int", "Mul.mk"],
  "name": "Int.instMulInt",
  "constType": "Mul ℤ",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.one_smul",
   "Monoid.toMulAction",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "One.toOfNat1",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero.proof_1",
  "constType": "∀ (R : Type u_1) [inst : MonoidWithZero R] (b : R), 1 • b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "instHAdd",
   "HAdd.hAdd",
   "instDistribLattice",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMagma.toAdd",
   "abs_add",
   "LE.le",
   "Preorder.toLE",
   "Abs.abs",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "AddCommMonoid.toAddCommSemigroup",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "AbsoluteValue.abs.proof_3",
  "constType":
  "∀ {S : Type u_1} [inst : LinearOrderedRing S] (a b : S), |a + b| ≤ |a| + |b|",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "DivisionRing.toRing",
   "Subtype.val",
   "Real",
   "Rat",
   "Subtype.ext",
   "Eq.refl",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Rat.instLinearOrderedRingRat",
   "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1334",
   "Real.ofCauchy",
   "rfl",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Subtype.property",
   "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1334",
   "Eq.mpr",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "letFun",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "Rat.instLinearOrderedFieldRat",
   "Subtype",
   "Subtype.mk",
   "Inv.inv",
   "id"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.inv'_def",
  "constType":
  "∀ (x : ℝ),\n  Real.inv' x =\n    match x with\n    | { cauchy := a } => { cauchy := a⁻¹ }",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "AddOpposite.subNegMonoid",
   "AddOpposite",
   "Neg.neg",
   "SubNegMonoid.sub_eq_add_neg",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddOpposite.addGroup.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : AddGroup α] (a b : αᵃᵒᵖ), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.mk",
  "constType":
  "∀ {G : Type u} [inst : Add G] [toIsLeftCancelAdd : IsLeftCancelAdd G] [toIsRightCancelAdd : IsRightCancelAdd G],\n  IsCancelAdd G",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid",
   "NegMemClass.neg_mem",
   "AddSubgroupClass",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddSubmonoidClass.toAddMemClass",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddSubgroupClass.toAddSubmonoidClass",
   "SetLike.instMembership",
   "Eq",
   "SubNegMonoid.toSub",
   "SetLike",
   "Eq.mpr",
   "AddMemClass.add_mem",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroupClass.toNegMemClass",
   "id"],
  "name": "sub_mem",
  "constType":
  "∀ {M : Type u_5} {S : Type u_6} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x - y ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "HAdd.hAdd",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "SubtractionMonoid",
   "Set.addMonoid",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (n : ℕ) (x : Set α), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "refPackage",
   "MeasureTheory.Measure.map",
   "MeasureTheory.isProbabilityMeasure_map",
   "eq_of_heq",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "MeasureTheory.IsProbabilityMeasure",
   "ProbabilityTheory.identDistrib_id_right",
   "MeasureTheory.MeasureSpace.volume",
   "tau_minimizes",
   "LE.le",
   "ProbabilityTheory.IdentDistrib.tau_eq",
   "Eq",
   "MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "HEq.refl",
   "Measurable.aemeasurable",
   "MeasureTheory.MeasureSpace",
   "letFun",
   "LE",
   "Measurable",
   "tau",
   "Eq.casesOn",
   "AddCommGroup",
   "Eq.symm",
   "MeasurableSpace",
   "id"],
  "name": "is_tau_min",
  "constType":
  "∀ {Ω : Type u_7} {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁]\n  [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] {G : Type uG} [inst_2 : AddCommGroup G] [inst_3 : MeasurableSpace G]\n  (p : refPackage Ω₀₁ Ω₀₂ G) {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [inst_4 : MeasureTheory.MeasureSpace Ω]\n  [hΩ₁ : MeasureTheory.MeasureSpace Ω'₁] [hΩ₂ : MeasureTheory.MeasureSpace Ω'₂]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_6 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X₁ X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G},\n  tau_minimizes p X₁ X₂ → Measurable X'₁ → Measurable X'₂ → τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p]",
  "constCategory": "Theorem"},
 {"references":
  ["NoZeroDivisors",
   "Zero.toOfNat0",
   "Zero",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "HMul.hMul",
   "Mul",
   "Eq"],
  "name": "NoZeroDivisors.mk",
  "constType":
  "∀ {M₀ : Type u_4} [inst : Mul M₀] [inst_1 : Zero M₀], (∀ {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0) → NoZeroDivisors M₀",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Real.instOneReal",
   "Eq",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "Real.cauchy_one",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Nat.cast_add",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NatCast.natCast",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "AddMonoidWithOne.toOne",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Rat.instLinearOrderedFieldRat",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Real.cauchy_mul",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_add",
   "One.mk",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_15",
  "constType": "∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Theorem"},
 {"references": ["Nat", "AddMonoid"],
  "name": "AddMonoid.nsmul",
  "constType": "{M : Type u} → [self : AddMonoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrFun",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b c : R} (x : R) (e : ℕ), a + b = c → x ^ e * a + x ^ e * b = x ^ e * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat"],
  "name": "Real.pi.proof_1",
  "constType": "Nat.AtLeastTwo (0 + 2)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Top.top",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddZeroClass.toZero",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instTopAddSubgroup.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G], 0 ∈ ⊤.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred",
   "And",
   "Exists",
   "Subtype.val",
   "LT.lt",
   "Not",
   "Nat.findX",
   "Nat",
   "instLTNat"],
  "name": "Nat.find",
  "constType": "{p : ℕ → Prop} → [inst : DecidablePred p] → (∃ n, p n) → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.zero_le_one",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring.proof_1",
   "OrderedSemiring.mk",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder.le_refl",
   "LE.le",
   "Preorder.toLE"],
  "name": "Real.instDistribLatticeReal.proof_1",
  "constType": "∀ (a : ℝ), a ≤ a",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Commute", "Eq"],
  "name": "Commute.eq",
  "constType":
  "∀ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b → a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Fin.ofNat''",
   "NeZero",
   "Nat.linearOrderedCommMonoidWithZero",
   "Fin.instOneFin",
   "Fin.addCommMonoid",
   "inferInstanceAs",
   "LinearOrderedCommMonoidWithZero.toZero",
   "AddCommMonoid.toAddMonoid",
   "Fin.instAddMonoidWithOne.proof_1",
   "Nat",
   "Fin.instAddMonoidWithOne.proof_2",
   "NatCast.mk",
   "AddMonoidWithOne.mk",
   "Fin",
   "AddCommMonoid"],
  "name": "Fin.instAddMonoidWithOne",
  "constType": "(n : ℕ) → [inst : NeZero n] → AddMonoidWithOne (Fin n)",
  "constCategory": "Definition"},
 {"references": ["CommMonoid", "OrderedCommMonoid"],
  "name": "OrderedCommMonoid.toCommMonoid",
  "constType": "{α : Type u_3} → [self : OrderedCommMonoid α] → CommMonoid α",
  "constCategory": "Definition"},
 {"references": ["refPackage", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.X₀₁",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → Ω₀₁ → G",
  "constCategory": "Definition"},
 {"references":
  ["False", "Decidable", "Not", "Decidable.byContradiction", "absurd"],
  "name": "Decidable.of_not_not",
  "constType": "∀ {p : Prop} [inst : Decidable p], ¬¬p → p",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_6",
  "constType":
  "∀ {α : Type u_1} (x y z : Set α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "Rat.mk'",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.169",
   "autoParam",
   "Inv",
   "CommRing",
   "Semiring.toNatCast",
   "Eq",
   "RatCast",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "Field",
   "Ring.toIntCast",
   "AddMonoid.toZero",
   "Rat.cast",
   "instOfNatNat",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "Rat",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.cast",
   "Int.negSucc",
   "Nat.Coprime",
   "CommRing.toRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "_auto._@.Mathlib.Algebra.Field.Defs._hyg.128",
   "Int.natAbs",
   "Inv.inv"],
  "name": "Field.mk",
  "constType":
  "{K : Type u} →\n  [toCommRing : CommRing K] →\n    [toInv : Inv K] →\n      [toDiv : Div K] →\n        autoParam (∀ (a b : K), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → K → K) →\n            autoParam (∀ (a : K), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : K), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : K), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial K] →\n                    [toRatCast : RatCast K] →\n                      (∀ (a : K), a ≠ 0 → a * a⁻¹ = 1) →\n                        0⁻¹ = 0 →\n                          autoParam\n                              (∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n                                ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹)\n                              _auto✝⁴ →\n                            (qsmul : ℚ → K → K) → autoParam (∀ (a : ℚ) (x : K), qsmul a x = ↑a * x) _auto✝⁵ → Field K",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "Units.exists_iff_ne_zero",
   "IsUnit",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "Iff.mpr"],
  "name": "Ne.isUnit",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → IsUnit a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "Zero.mk",
   "Complex"],
  "name": "Complex.instZeroComplex",
  "constType": "Zero ℂ",
  "constCategory": "Definition"},
 {"references": ["SProd", "Set.prod", "SProd.mk", "Set", "Prod"],
  "name": "Set.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Set α) (Set β) (Set (α × β))",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Nat.decidablePrime1",
   "instOfNatNat",
   "Bool",
   "Nat"],
  "name": "Nat.prime_two",
  "constType": "Nat.Prime 2",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.toAddMonoid",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "inferInstanceAs",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "SetLike.instMembership",
   "Subtype",
   "AddSubmonoid.addAction"],
  "name": "AddSubgroup.instAddAction",
  "constType":
  "{G : Type u_1} →\n  {α : Type u_2} → [inst : AddGroup G] → [inst_1 : AddAction G α] → {S : AddSubgroup G} → AddAction (↥S) α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "uniformity",
   "PartialOrder.toPreorder",
   "UniformSpace",
   "SProd.sprod",
   "Filter.instPartialOrderFilter",
   "Prod",
   "Filter",
   "Filter.instSProd",
   "Filter.NeBot",
   "LE.le",
   "Preorder.toLE"],
  "name": "Cauchy",
  "constType":
  "{α : Type u} → [uniformSpace : UniformSpace α] → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "Set.add_singleton",
   "OfNat.ofNat",
   "AddCommGroup.toAddCommMonoid",
   "MeasureTheory.IsProbabilityMeasure",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Iff",
   "Set.Elem",
   "Mathlib.Tactic.Abel.subst_into_addg",
   "AddOpposite.op",
   "Finset.toSet",
   "HSMul.hSMul",
   "HDiv.hDiv",
   "Set.image",
   "Finset.Subtype.fintype",
   "Subtype",
   "instHSub",
   "instHDiv",
   "Set.add",
   "eq_of_heq",
   "Function.comp",
   "Finset.preimage",
   "MeasureTheory.Measure.real",
   "instHVAdd",
   "AddCommMagma.toAdd",
   "PFR.Main._auxLemma.4",
   "propext",
   "congr",
   "AddCommGroup",
   "Finset.image_add_right",
   "MeasurableSpace",
   "Finite.of_fintype",
   "Int",
   "Finset.add",
   "congrFun",
   "Finset.vaddFinset",
   "AddZeroClass.toAdd",
   "Measurable.add_const",
   "NatCast",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddMonoid.toOppositeAddAction",
   "HEq",
   "instOfNatInt",
   "Set",
   "Real",
   "Eq.refl",
   "HDiv",
   "MeasurableAdd.measurable_add_const",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "iff_self",
   "add_left_injective",
   "MeasureTheory.Measure",
   "Set.ext",
   "zero_add",
   "DiscreteMeasurableSpace.toMeasurableAdd",
   "Eq.rec",
   "Mathlib.Tactic.Abel.unfold_sub",
   "Finset",
   "AddGroup.toAddCancelMonoid",
   "Measurable",
   "HVAdd.hVAdd",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset.coe_add",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Finset.card_add_singleton",
   "Mathlib.Tactic.Abel.term_atomg",
   "Eq.ndrec",
   "letFun",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "ProbabilityTheory.IsUniform.comp",
   "NegZeroClass.toNeg",
   "Finset.instSingletonFinset",
   "Set.instInterSet",
   "instHSMul",
   "Finset.coe_preimage",
   "neg_zero",
   "Real.instMulReal",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Inter.inter",
   "autoParam",
   "Eq",
   "ProbabilityTheory.IndepFun.comp",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Nat.card_eq_fintype_card",
   "Eq.mpr",
   "Fintype",
   "Ring.toNeg",
   "Finset.card_vadd_finset",
   "Fintype.card_coe",
   "Nat",
   "PFR.Main._auxLemma.3",
   "Eq.trans",
   "Finite.to_countable",
   "measurable_id",
   "Classical.propDecidable",
   "Mathlib.Tactic.Abel.termg",
   "Mathlib.Tactic.Abel.term_neg",
   "Finset.instMembershipFinset",
   "AddOpposite.addGroup",
   "SubNegMonoid.SMulInt",
   "Set.instMembershipSet",
   "instHMul",
   "Function.Injective.injOn",
   "of_eq_true",
   "HEq.refl",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "AddAction.toVAdd",
   "Singleton.singleton",
   "sub_eq_zero",
   "Mathlib.Tactic.Abel.term_add_constg",
   "Finset.coe_singleton",
   "add_zero",
   "congrArg",
   "ProbabilityTheory.IndepFun",
   "Finset.card",
   "Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Zero.toOfNat0",
   "outParam",
   "Int.instRingInt",
   "Set.instSingletonSet",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Finset.image",
   "Mathlib.Tactic.Abel.subst_into_negg",
   "AddCommGroup.toAddGroup",
   "Int.instNegInt",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.preimage",
   "ProbabilityTheory.IsUniform.measureReal_preimage_sub_zero",
   "instHAdd",
   "HSub.hSub",
   "Fintype.card",
   "AddGroup.toSubNegMonoid",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "one_zsmul",
   "SubtractionMonoid.toSubNegMonoid",
   "MeasureTheory.MeasureSpace",
   "Set.image_add_right",
   "SubNegMonoid.toAddMonoid",
   "AddOpposite",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat.card",
   "NegZeroClass.toZero",
   "ProbabilityTheory.IsUniform",
   "HMul"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_sub",
  "constType":
  "∀ {G : Type u_1} {Ω : Type u_2} [inst : AddCommGroup G] [inst_1 : Fintype G] [inst_2 : MeasurableSpace G]\n  [inst_3 : MeasurableSingletonClass G] {A B : Finset G} [inst_4 : MeasureTheory.MeasureSpace Ω]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {U V : Ω → G},\n  ProbabilityTheory.IsUniform (↑A) U →\n    Measurable U →\n      ProbabilityTheory.IsUniform (↑B) V →\n        Measurable V →\n          ProbabilityTheory.IndepFun U V →\n            ∀ (x : G),\n              MeasureTheory.volume.real ((U - V) ⁻¹' {x}) =\n                ↑(Nat.card ↑(↑A ∩ (↑B + {x}))) / (↑(Nat.card { x // x ∈ A }) * ↑(Nat.card { x // x ∈ B }))",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid",
   "MeasureTheory.Measure.toOuterMeasure_injective",
   "MeasureTheory.Measure.instSMul",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure.instMulAction.proof_1",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulAction.toSMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Algebra.id",
   "MulAction",
   "Algebra.toSMul",
   "Function.Injective.mulAction",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.instMulAction"],
  "name": "MeasureTheory.Measure.instMulAction",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_6} →\n    [inst : Monoid R] →\n      [inst_1 : MulAction R ENNReal] →\n        [inst_2 : IsScalarTower R ENNReal ENNReal] →\n          [inst_3 : MeasurableSpace α] → MulAction R (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Int",
   "Eq",
   "Int.instHPowIntNat"],
  "name": "Int.instCommRingInt.proof_4",
  "constType": "∀ (x : ℤ), (fun n x => x ^ n) 0 x = (fun n x => x ^ n) 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_2",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x < x_1 → x_1 ≤ x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x < x_1) (x_4 : x_1 ≤ x_2),\n  (∀ (_a _b _c : α) (hab : _a < _b) (hbc : _b ≤ _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references":
  ["le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "And.left",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_of_lt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.div",
  "constType": "{α : Type u} → [self : Div α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["outParam", "AddTorsor", "AddGroup", "Nonempty"],
  "name": "AddTorsor.nonempty",
  "constType":
  "∀ {G : outParam (Type u_1)} {P : Type u_2} [inst : outParam (AddGroup G)] [self : AddTorsor G P], Nonempty P",
  "constCategory": "Definition"},
 {"references": ["Rat", "Nat"],
  "name": "Rat.den",
  "constType": "ℚ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddMonoid"],
  "name": "Nat.addMonoid",
  "constType": "AddMonoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "PartialOrder.toPreorder",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "MulZeroClass.toMul",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring.toOrderedSemiring",
   "StrictOrderedRing",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "OrderedSemiring.toPosMulMono",
   "mul_nonneg"],
  "name": "StrictOrderedRing.toOrderedRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references": ["Set", "Set.instSupSetSet", "iSup"],
  "name": "Set.iUnion",
  "constType": "{β : Type u_2} → {ι : Sort u_4} → (ι → Set β) → Set β",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PProd",
  "constType": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "constCategory": "Other"},
 {"references":
  ["Finset.nodup",
   "Membership.mem",
   "congr_arg",
   "Iff.mp",
   "Iff",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset",
   "Finset.val",
   "Multiset.pmap",
   "Multiset.Nodup",
   "Finset.instMembershipFinset",
   "Subtype.mk",
   "Subtype"],
  "name": "Fintype.subtype.proof_2",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ p x),\n  Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x))",
  "constCategory": "Theorem"},
 {"references": ["Bool.casesOn", "Bool.false", "Bool.true", "Bool", "Eq"],
  "name": "ne_true_of_eq_false.match_1",
  "constType":
  "∀ (motive : (x : Bool) → x = false → Prop) (x : Bool) (x_1 : x = false),\n  (∀ (h : true = false), motive true h) → (∀ (x : false = false), motive false x) → motive x x_1",
  "constCategory": "Definition"},
 {"references": ["Set.range", "SupSet", "SupSet.sSup"],
  "name": "iSup",
  "constType":
  "{α : Type u_1} → [inst : SupSet α] → {ι : Sort u_9} → (ι → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Pi.partialOrder",
   "Set",
   "MeasurableSpace.measurableSet_injective",
   "MeasurableSet",
   "PartialOrder.lift",
   "Preorder.le_trans",
   "Prop.partialOrder",
   "LE.le",
   "MeasurableSpace",
   "Preorder.toLE"],
  "name": "MeasurableSpace.instPartialOrderMeasurableSpace.proof_2",
  "constType":
  "∀ {α : Type u_1} (a b c : MeasurableSpace α), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Submonoid.mk",
   "Subgroup.mk",
   "Subgroup.instBotSubgroup.proof_2",
   "Bot.bot",
   "Submonoid.instBotSubmonoid",
   "Submonoid.toSubsemigroup",
   "Subgroup.instBotSubgroup.proof_1",
   "Submonoid",
   "Subgroup",
   "Bot.mk",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.instBotSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → Bot (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma", "instHAdd", "HAdd.hAdd", "AddCommMagma.toAdd", "Eq"],
  "name": "AddCommMagma.add_comm",
  "constType":
  "∀ {G : Type u} [self : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Definition"},
 {"references": ["Min"],
  "name": "Min.min",
  "constType": "{α : Type u} → [self : Min α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Complex.ofReal'",
   "Complex.instSemiringComplex",
   "Nat.cast",
   "Real.natCast",
   "Real",
   "Complex",
   "Nat",
   "rfl",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Complex.ofReal_nat_cast",
  "constType": "∀ (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "List.cons",
   "List.Perm",
   "of_eq_true",
   "List",
   "Eq.refl",
   "List.nil",
   "List.Perm.rec",
   "List.length",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.succ",
   "True",
   "congrFun",
   "Eq"],
  "name": "List.Perm.length_eq",
  "constType":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.Perm l₁ l₂ → List.length l₁ = List.length l₂",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "MulOneClass.toMul",
   "MonoidHomClass.toMulHomClass",
   "MonoidHom.monoidHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Function.Injective",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "Subtype.coe_injective",
   "Subtype",
   "Subgroup.subtype",
   "Subgroup.instSetLikeSubgroup",
   "Submonoid.toMulOneClass"],
  "name": "Subgroup.subtype_injective",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Function.Injective ⇑(Subgroup.subtype H)",
  "constCategory": "Theorem"},
 {"references": ["PreOpposite"],
  "name": "PreOpposite.op'",
  "constType": "{α : Type u} → α → PreOpposite α",
  "constCategory": "Other"},
 {"references":
  ["starMulOfComm",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "starRingOfComm.proof_2",
   "starRingOfComm.proof_1",
   "StarMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "StarRing.mk",
   "StarMul.toInvolutiveStar",
   "StarMul.mk"],
  "name": "starRingOfComm",
  "constType": "{R : Type u_1} → [inst : CommSemiring R] → StarRing R",
  "constCategory": "Definition"},
 {"references": ["Or", "IsTotal", "IsTotal.total"],
  "name": "total_of",
  "constType":
  "∀ {α : Type u} (r : α → α → Prop) [inst : IsTotal α r] (a b : α), r a b ∨ r b a",
  "constCategory": "Theorem"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Int.negOfNat.match_1",
  "constType":
  "(motive : ℕ → Sort u_1) → (x : ℕ) → (Unit → motive 0) → ((m : ℕ) → motive (Nat.succ m)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "one_nsmul",
   "OfNat.ofNat",
   "instHSMul",
   "HEq",
   "ofNat_zsmul",
   "instOfNatInt",
   "eq_of_heq",
   "Eq.refl",
   "SubNegMonoid.SMulInt",
   "Eq",
   "AddMonoid.toNatSMul",
   "Eq.mpr",
   "Eq.ndrec",
   "HEq.refl",
   "HSMul.hSMul",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Int",
   "id"],
  "name": "one_zsmul",
  "constType": "∀ {G : Type w} [inst : SubNegMonoid G] (a : G), 1 • a = a",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "MeasurableSub₂.measurable_sub",
   "Measurable.prod_mk",
   "Prod.snd",
   "Prod.mk",
   "HSub.hSub",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Measurable.comp",
   "Prod.instMeasurableSpace"],
  "name": "Measurable.sub",
  "constType":
  "∀ {G : Type u_2} {α : Type u_3} [inst : MeasurableSpace G] [inst_1 : Sub G] {m : MeasurableSpace α} {f g : α → G}\n  [inst_2 : MeasurableSub₂ G], Measurable f → Measurable g → Measurable fun a => f a - g a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Eq.mpr",
   "Real.instCommSemigroupReal",
   "Eq.ndrec",
   "CommSemigroup.toCommMagma",
   "Real.instMulReal",
   "Real",
   "Eq.refl",
   "HMul.hMul",
   "CommMagma.toMul",
   "mul_left_comm",
   "id",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.mul_pf_right",
  "constType": "∀ {a b₂ c : ℝ} (b₁ : ℝ), a * b₂ = c → a * (b₁ * b₂) = b₁ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Submonoid.mk",
   "MulOneClass.toMul",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Subsemigroup.mk",
   "Set",
   "Submonoid",
   "Submonoid.copy.proof_1",
   "Submonoid.copy.proof_2",
   "SetLike.coe",
   "Eq"],
  "name": "Submonoid.copy",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → (S : Submonoid M) → (s : Set M) → s = ↑S → Submonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Rat.neg.proof_1",
   "Rat.den_nz",
   "Rat.num",
   "Rat",
   "Rat.den",
   "Int.instNegInt",
   "Neg.neg",
   "Rat.mk'",
   "Int"],
  "name": "Rat.neg",
  "constType": "ℚ → ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "AddGroupWithOne.zsmul",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "AddGroupWithOne.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.zsmul (Int.negSucc n) a = -AddGroupWithOne.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.mk",
  "constType": "{α : Type u} → (α → ℕ → α) → NatPow α",
  "constCategory": "Other"},
 {"references": [],
  "name": "ConditionallyCompleteLattice",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedSemiring",
   "Real.strictOrderedSemiring",
   "Real",
   "Nonneg.strictOrderedSemiring",
   "NNReal"],
  "name": "instNNRealStrictOrderedSemiring",
  "constType": "StrictOrderedSemiring NNReal",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_10",
  "constType": "∀ {α : Type u_1} [β : SeminormedCommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Quotient.liftOn₂",
   "Real",
   "Rat",
   "Real.definition.proof_1._@.Mathlib.Data.Real.Basic._hyg.3933",
   "Rat.instLinearOrderedRingRat",
   "CauSeq",
   "Abs.abs",
   "Rat.instSupRat",
   "CauSeq.equiv",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "LT.lt",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.3933",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Equiv",
   "OfNat.ofNat",
   "One",
   "Zero.mk",
   "One.toOfNat1",
   "Additive.ofMul",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv",
   "Additive"],
  "name": "instZeroAdditive",
  "constType": "{α : Type u} → [inst : One α] → Zero (Additive α)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "inv_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "of_eq_true",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "congr",
   "HDiv.hDiv",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_rev",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Inv.inv",
   "DivInvMonoid.toDiv"],
  "name": "inv_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a b : α), (a / b)⁻¹ = b / a",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "instHDiv",
   "DivisionRing",
   "Nat.cast",
   "DivisionRing.toRing",
   "Int.cast",
   "Ring.toIntCast",
   "HDiv.hDiv",
   "Nat",
   "Int",
   "DivisionRing.toDiv",
   "Semiring.toNatCast"],
  "name": "Rat.rawCast",
  "constType": "{α : Type u_1} → [inst : DivisionRing α] → ℤ → ℕ → α",
  "constCategory": "Definition"},
 {"references": ["Int", "Neg", "Int.neg", "Neg.mk"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "IntCast.intCast",
   "Eq"],
  "name": "AddGroupWithOne.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Ne",
   "OfNat.ofNat",
   "False",
   "Monoid.toOne",
   "Trans.trans",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "instTransEq",
   "HMul.hMul",
   "Not",
   "MonoidWithZero.toZero",
   "not_false_eq_true",
   "congrArg",
   "mul_inv_cancel",
   "inv_ne_zero",
   "Eq.trans",
   "mul_inv_cancel_right₀",
   "congrFun",
   "Inv.inv",
   "GroupWithZero.toInv"],
  "name": "inv_mul_cancel",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a⁻¹ * a = 1",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedAddCommMonoid", "Ord"],
  "name": "LinearOrderedAddCommMonoid.toOrd",
  "constType": "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "Subgroup.instInfSetSubgroup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.neg", "Real", "Neg", "Neg.mk"],
  "name": "Real.instNegReal",
  "constType": "Neg ℝ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Preorder.le_refl",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a : Submonoid M), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Finite",
   "Set.sep_eq_of_subset",
   "HasSubset.Subset",
   "Eq.refl",
   "Set.instMembershipSet",
   "Eq",
   "And",
   "inferInstance",
   "Set.instHasSubsetSet",
   "Eq.mpr",
   "Finite.Set.finite_sep",
   "Eq.ndrec",
   "Set.Elem",
   "Eq.symm",
   "id"],
  "name": "Finite.Set.subset",
  "constType":
  "∀ {α : Type u} (s : Set α) {t : Set α} [inst : Finite ↑s], t ⊆ s → Finite ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "nhds",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "Dist.dist",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Filter.HasBasis",
   "PseudoMetricSpace.toDist",
   "LT.lt",
   "Prod",
   "Metric.ball",
   "nhds_basis_uniformity",
   "Metric.uniformity_basis_dist",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace"],
  "name": "Metric.nhds_basis_ball",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Filter.HasBasis (nhds x) (fun x => 0 < x) (Metric.ball x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "sub_self",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "CauSeq.LimZero",
   "AddGroup.toSubtractionMonoid",
   "Semifield.toCommGroupWithZero",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "Eq",
   "IsAbsoluteValue",
   "Eq.mpr",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "CauSeq.abv_pos_of_not_limZero",
   "not_false_eq_true",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "GroupWithZero.toInv",
   "StrictOrderedRing.toPartialOrder",
   "instHSub",
   "Ne",
   "DivisionRing",
   "DivisionSemiring.toGroupWithZero",
   "CauSeq.instSubCauSeq",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "IsAbsoluteValue.abv_zero",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Std.Classes.Order._auxLemma.4",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun",
   "Inv.inv",
   "Exists",
   "LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "instHasEquiv",
   "DivisionRing.toDivisionSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "Subtype.val",
   "IsCauSeq",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semiring.toMonoidWithZero",
   "Exists.intro",
   "True",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "inv_mul_cancel",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "Ring.toSub",
   "CauSeq.instMulCauSeq",
   "IsAbsoluteValue.abv_pos",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "False",
   "Ring.toAddGroupWithOne",
   "lt_of_lt_of_le",
   "HSub.hSub",
   "One.toOfNat1",
   "CauSeq.instOneCauSeq",
   "CauSeq",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring.toSemiring",
   "LE.le",
   "GroupWithZero.toMonoidWithZero",
   "CauSeq.inv_mul_cancel.match_1",
   "GT.gt",
   "CauSeq.equiv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "eq_false",
   "CauSeq.inv",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "HasEquiv.Equiv",
   "NegZeroClass.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "CauSeq.inv_mul_cancel",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrderedField α] [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {f : CauSeq β abv} (hf : ¬CauSeq.LimZero f), CauSeq.inv f hf * f ≈ 1",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Complex.im",
   "Complex.mk",
   "Real",
   "Neg.neg",
   "Complex",
   "Neg",
   "Neg.mk",
   "Complex.re",
   "Real.instNegReal"],
  "name": "Complex.instNegComplex",
  "constType": "Neg ℂ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Algebra.toRingHom",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HMul.hMul"],
  "name": "Algebra.commutes'",
  "constType":
  "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [self : Algebra R A] (r : R) (x : A),\n  Algebra.toRingHom r * x = x * Algebra.toRingHom r",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "Nat.add_assoc.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.add_assoc",
  "constType": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.arg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "Semiring.toNonAssocSemiring",
   "MulZeroClass.toZero",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Real.normedCommRing",
   "Complex.im",
   "Real.instZeroReal",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "Real.semiring",
   "congr",
   "HMul.hMul",
   "Complex.log",
   "mul_one",
   "Complex",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "add_zero",
   "congrArg",
   "congrFun"],
  "name": "Complex.log_im",
  "constType": "∀ (x : ℂ), (Complex.log x).im = Complex.arg x",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Abs.abs",
   "neg_le_abs_self",
   "le_total",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "Or.elim",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "le_abs_self",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "LinearOrder.toPartialOrder",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), 0 ≤ |a|",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fact",
  "constType": "Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subgroup.mk",
   "Equiv",
   "Subsemigroup.carrier",
   "CompleteSemilatticeInf.toPartialOrder",
   "MulOneClass.toMul",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "Submonoid.toAddSubmonoid",
   "AddSubgroup.casesOn",
   "Iff",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "RelIso",
   "Subgroup",
   "InvOneClass.toInv",
   "Multiplicative.mulOneClass",
   "AddSubmonoid.toAddSubsemigroup",
   "Additive.addZeroClass",
   "AddSubmonoid",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Multiplicative",
   "AddSubgroup.neg_mem'",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid.instCompleteLatticeSubmonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "AddSubsemigroup.carrier",
   "Inv.inv",
   "Group.toDivisionMonoid",
   "AddZeroClass.toAdd",
   "Iff.rfl",
   "Set",
   "Subgroup.inv_mem'",
   "Eq.refl",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "RelIso.instRelHomClassRelIso",
   "AddGroup",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Submonoid.mk",
   "Membership.mem",
   "Submonoid.one_mem'",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toSubmonoid",
   "Neg.neg",
   "Subgroup.casesOn",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Equiv.instFunLikeEquiv",
   "SetLike.instPartialOrder",
   "Eq.ndrec",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "Equiv.mk",
   "Submonoid",
   "Group.toDivInvMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "Subgroup.instSetLikeSubgroup",
   "Additive"],
  "name": "AddSubgroup.toSubgroup.proof_6",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] {a b : AddSubgroup A},\n  {\n          toFun := fun S =>\n            let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n            { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n              inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) },\n          invFun := fun S =>\n            let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n            { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n              neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubgroup A),\n                (fun S =>\n                      let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                      {\n                        toAddSubmonoid :=\n                          { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                        neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                    ((fun S =>\n                        let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                        { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                          inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Subgroup (Multiplicative A)),\n                (fun S =>\n                      let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                      { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                        inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                    ((fun S =>\n                        let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                        {\n                          toAddSubmonoid :=\n                            { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                          neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n            { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n              inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) },\n          invFun := fun S =>\n            let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n            { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n              neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubgroup A),\n                (fun S =>\n                      let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                      {\n                        toAddSubmonoid :=\n                          { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                        neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                    ((fun S =>\n                        let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                        { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                          inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Subgroup (Multiplicative A)),\n                (fun S =>\n                      let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                      { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                        inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                    ((fun S =>\n                        let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                        {\n                          toAddSubmonoid :=\n                            { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                          neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                      x) =\n                  x) }\n        b ↔\n    {\n          toFun := fun S =>\n            let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n            { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n              inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) },\n          invFun := fun S =>\n            let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n            { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n              neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubgroup A),\n                (fun S =>\n                      let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                      {\n                        toAddSubmonoid :=\n                          { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                        neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                    ((fun S =>\n                        let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                        { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                          inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Subgroup (Multiplicative A)),\n                (fun S =>\n                      let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                      { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                        inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                    ((fun S =>\n                        let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                        {\n                          toAddSubmonoid :=\n                            { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                          neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                      x) =\n                  x) }\n        a ≤\n      {\n          toFun := fun S =>\n            let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n            { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n              inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) },\n          invFun := fun S =>\n            let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n            { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n              neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) },\n          left_inv :=\n            (_ :\n              ∀ (x : AddSubgroup A),\n                (fun S =>\n                      let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                      {\n                        toAddSubmonoid :=\n                          { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                        neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                    ((fun S =>\n                        let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                        { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                          inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                      x) =\n                  x),\n          right_inv :=\n            (_ :\n              ∀ (x : Subgroup (Multiplicative A)),\n                (fun S =>\n                      let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n                      { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n                        inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n                    ((fun S =>\n                        let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n                        {\n                          toAddSubmonoid :=\n                            { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n                          neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n                      x) =\n                  x) }\n        b",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Set.image2",
   "Set",
   "HSub.hSub",
   "Set.sub",
   "Sub.sub",
   "Sub",
   "rfl",
   "Eq"],
  "name": "Set.image2_sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s t : Set α}, Set.image2 Sub.sub s t = s - t",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toSemifield",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "LinearOrderedSemifield.toInv",
   "PartialOrder.toPreorder",
   "div_eq_mul_inv",
   "Eq.refl",
   "Semifield.toCommGroupWithZero",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HDiv.hDiv",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "id",
   "DivInvMonoid.toDiv",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LinearOrderedSemifield",
   "DivisionSemiring.toGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "instHMul",
   "LinearOrderedSemifield.toDiv",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "mul_pos",
   "inv_pos",
   "Inv.inv"],
  "name": "div_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → 0 < a / b",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne'",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne'",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≠ a → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Rat.add_le_add_left",
   "Rat.instLERat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Rat",
   "LinearOrder.toPartialOrder",
   "Rat.linearOrder",
   "LE.le",
   "Rat.instAddRat",
   "Iff.mpr",
   "Preorder.toLE"],
  "name": "Rat.instLinearOrderedFieldRat.proof_1",
  "constType": "∀ (a b : ℚ), a ≤ b → ∀ (c : ℚ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "MulOneClass.toMul",
   "Iff.rfl",
   "div_eq_mul_inv",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "Eq.mpr",
   "IsUnit.eq_mul_inv_iff_mul_eq",
   "Eq.ndrec",
   "Iff",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "IsUnit.eq_div_iff",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit c → (a = b / c ↔ a * c = b)",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Quotient", "Quotient.mk"],
  "name": "Quotient.mk'",
  "constType": "{α : Sort u} → [s : Setoid α] → α → Quotient s",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Inv"],
  "name": "DivInvMonoid.toInv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "DivInvMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toDivInvMonoid : DivInvMonoid G] →\n    (∀ (x : G), x⁻¹⁻¹ = x) →\n      (∀ (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹) → (∀ (a b : G), a * b = 1 → a⁻¹ = b) → DivisionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne", "AddMonoidWithOne.toNatCast", "Nat.cast", "Nat"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u_1} → [inst : AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Real.instLTReal",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "Real.partialOrder.proof_4",
   "Real.partialOrder.proof_2",
   "LT.mk",
   "Real.partialOrder.proof_1",
   "LE.le",
   "PartialOrder",
   "Real.partialOrder.proof_3",
   "Preorder.mk"],
  "name": "Real.partialOrder",
  "constType": "PartialOrder ℝ",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "setOf",
  "constType": "{α : Type u} → (α → Prop) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "Prod.snd",
   "Mathlib.Data.Set.Prod._auxLemma.1",
   "Set",
   "Inter.inter",
   "Prod.fst",
   "True",
   "Eq",
   "iff_self",
   "Set.instMembershipSet",
   "Mathlib.Data.Set.Prod._auxLemma.8",
   "Set.ext",
   "And",
   "Iff",
   "Prod.casesOn",
   "of_eq_true",
   "Prod.mk",
   "SProd.sprod",
   "congr",
   "Prod",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Set.Basic._auxLemma.25",
   "Mathlib.Data.Set.Prod._auxLemma.4",
   "Set.instInterSet"],
  "name": "Set.prod_inter_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s₁ s₂ : Set α} {t₁ t₂ : Set β}, s₁ ×ˢ t₁ ∩ s₂ ×ˢ t₂ = (s₁ ∩ s₂) ×ˢ (t₁ ∩ t₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Finset.fold_congr",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Finset",
   "AddCommMagma.to_isCommutative",
   "AddSemigroup.to_isAssociative",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid",
   "id"],
  "name": "Finset.sum_congr",
  "constType":
  "∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],\n  s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → Finset.sum s₁ f = Finset.sum s₂ g",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Exists",
   "Finite",
   "Fin.fintype",
   "Fintype.ofEquiv",
   "Nonempty",
   "Iff.intro",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Iff",
   "finite_iff_nonempty_fintype.match_1",
   "Finite.exists_equiv_fin",
   "Nat",
   "finite_iff_nonempty_fintype.match_2",
   "Finite.of_fintype",
   "Fin",
   "Equiv.symm"],
  "name": "finite_iff_nonempty_fintype",
  "constType": "∀ (α : Type u_4), Finite α ↔ Nonempty (Fintype α)",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.map",
   "Set.preimage",
   "MeasureTheory.Measure.toOuterMeasure",
   "Set",
   "MeasurableSet",
   "MeasurableSet.nullMeasurableSet",
   "MeasureTheory.Measure.map_apply₀",
   "MeasurableSpace",
   "AEMeasurable",
   "Eq"],
  "name": "MeasureTheory.Measure.map_apply_of_aemeasurable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {f : α → β}, AEMeasurable f → ∀ {s : Set β}, MeasurableSet s → ↑↑(MeasureTheory.Measure.map f μ) s = ↑↑μ (f ⁻¹' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Fintype.card_of_finset'",
   "Fintype",
   "Set.Elem",
   "Iff.rfl",
   "Multiset",
   "Finset",
   "Finset.val",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "Nat",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "Eq",
   "id"],
  "name": "Fintype.card_coe",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) [inst : Fintype { x // x ∈ s }], Fintype.card { x // x ∈ s } = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "of_eq_true",
   "Nat.lt_of_succ_lt_succ",
   "LT.lt",
   "Matrix.vecCons",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Fin.mk",
   "Fin",
   "Eq"],
  "name": "Matrix.cons_val_succ'",
  "constType":
  "∀ {α : Type u} {m i : ℕ} (h : Nat.succ i < Nat.succ m) (x : α) (u : Fin m → α),\n  Matrix.vecCons x u { val := Nat.succ i, isLt := h } = u { val := i, isLt := (_ : i < m) }",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "instHAdd",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Eq.refl",
   "Neg.neg",
   "Eq",
   "Real.instNegReal",
   "zsmulRec",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Zero.mk",
   "Nat",
   "Nat.succ",
   "Neg.mk",
   "Add.mk"],
  "name": "Real.commRing.proof_20",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zsmulRec (Int.ofNat (Nat.succ n)) a = zsmulRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["HEq",
   "eq_of_heq",
   "Eq.refl",
   "Neg.neg",
   "Eq",
   "Ring.toNeg",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int",
   "Int.neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α) →\n      (x_1 : α) → (x_2 x_3 : ℤ) → x = Neg.neg → Mathlib.Meta.NormNum.IsInt x_1 x_2 → Int.neg x_2 = x_3 → Prop)\n  (x : α → α) (x_1 : α) (x_2 x_3 : ℤ) (x_4 : x = Neg.neg) (x_5 : Mathlib.Meta.NormNum.IsInt x_1 x_2)\n  (x_6 : Int.neg x_2 = x_3),\n  (∀ (n : ℤ),\n      motive Neg.neg (↑n) n (Int.neg n) (_ : Neg.neg = Neg.neg) (_ : Mathlib.Meta.NormNum.IsInt (↑n) n)\n        (_ : Int.neg n = Int.neg n)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.mk",
   "AddHomClass.toFunLike",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHomClass",
   "AddSubmonoid.map.proof_1",
   "Set.image",
   "AddSubmonoid.map.proof_2",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.map",
  "constType":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_4} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid M → AddSubmonoid N",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.wrapped._@.Mathlib.MeasureTheory.Constructions.Prod.Basic._hyg.2696",
   "Prod",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "MeasureTheory.Measure.prod",
  "constType":
  "{α : Type u_7} →\n  {β : Type u_8} →\n    [inst : MeasurableSpace α] →\n      [inst_1 : MeasurableSpace β] → MeasureTheory.Measure α → MeasureTheory.Measure β → MeasureTheory.Measure (α × β)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HasQuotient",
  "constType": "outParam (Type u) → Type v → Type (max (u + 1) (v + 1))",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat.succ_le_succ",
   "Nat.zero_le",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.zero_lt_succ",
  "constType": "∀ (n : ℕ), 0 < Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4056",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "instHMul",
   "CommSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.mul_comm",
  "constType":
  "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["ENNReal", "WithTop.some", "NNReal"],
  "name": "ENNReal.ofNNReal",
  "constType": "NNReal → ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "OfNat.ofNat",
   "Semiring",
   "Nat.cast_commute",
   "Eq.refl",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Eq.mp",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nat"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] (k : ℕ) (b c : α), ↑k * b * c = 1 → b * (c * ↑k) = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "LinearOrder.toPartialOrder",
   "instOfNatNat",
   "le_rfl",
   "Nat.rel_of_forall_rel_succ_of_le_of_lt",
   "IsTrans",
   "Nat",
   "LE.le",
   "instLTNat"],
  "name": "Nat.rel_of_forall_rel_succ_of_lt",
  "constType":
  "∀ {β : Type v} (r : β → β → Prop) [inst : IsTrans β r] {f : ℕ → β},\n  (∀ (n : ℕ), r (f n) (f (n + 1))) → ∀ ⦃a b : ℕ⦄, a < b → r (f a) (f b)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "StarMul",
   "NonUnitalNonAssocSemiring",
   "Star.star",
   "InvolutiveStar.toStar",
   "instHAdd",
   "HAdd.hAdd",
   "StarRing",
   "NonUnitalNonAssocSemiring.toMul",
   "StarMul.toInvolutiveStar",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "StarRing.mk",
  "constType":
  "{R : Type u} →\n  [inst : NonUnitalNonAssocSemiring R] →\n    [toStarMul : StarMul R] → (∀ (r s : R), star (r + s) = star r + star s) → StarRing R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Ring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.one_mul",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_6",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instHSMul",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "measurable_fst",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.IsProbabilityMeasure",
   "ProbabilityTheory.identDistrib_id_right",
   "MeasureTheory.Measure.prod",
   "CanonicallyOrderedCommSemiring.toOne",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Eq.mpr",
   "one_smul",
   "MeasureTheory.OuterMeasure.measureOf",
   "Measurable.aemeasurable",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "MonoidWithZero.toMulActionWithZero",
   "HSMul.hSMul",
   "MeasureTheory.Measure.instMulAction",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "id",
   "eq_self",
   "IsScalarTower.right",
   "One.toOfNat1",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "instENNRealZero",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "Prod.instMeasurableSpace",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.map_fst_prod",
   "Prod",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "congrFun"],
  "name": "ProbabilityTheory.IdentDistrib.fst_id",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.IsProbabilityMeasure ν],\n  ProbabilityTheory.IdentDistrib Prod.fst id",
  "constCategory": "Theorem"},
 {"references": ["Fact"],
  "name": "Fact.mk",
  "constType": "∀ {p : Prop}, p → Fact p",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.nodup_zero",
   "Multiset.instZeroMultiset",
   "Finset",
   "Multiset",
   "Finset.mk"],
  "name": "Finset.empty",
  "constType": "{α : Type u_1} → Finset α",
  "constCategory": "Definition"},
 {"references": ["Dvd"],
  "name": "Dvd.mk",
  "constType": "{α : Type u_1} → (α → α → Prop) → Dvd α",
  "constCategory": "Other"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "instHSMul",
   "instOfNatInt",
   "HAdd.hAdd",
   "AddCommGroup.toAddCommMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "HSMul.hSMul",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHAdd",
   "Mathlib.Tactic.Abel.termg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "of_eq_true",
   "one_zsmul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "NegZeroClass.toZero",
   "congrArg",
   "add_zero",
   "Int",
   "congrFun"],
  "name": "Mathlib.Tactic.Abel.term_atomg",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (x : α), x = Mathlib.Tactic.Abel.termg 1 x 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "inferInstance",
   "NonUnitalSemiring.mul_assoc",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_6",
  "constType": "∀ (a b c : ℕ), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield",
   "Inv.inv",
   "Eq"],
  "name": "Semifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_4} [self : Semifield α] (n : ℕ) (a : α),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Monoid", "DivInvMonoid"],
  "name": "DivInvMonoid.toMonoid",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.rec",
  "constType":
  "{α : Type u_1} →\n  [inst : AddMonoidWithOne α] →\n    {a : α} →\n      {n : ℕ} →\n        {motive : Mathlib.Meta.NormNum.IsNat a n → Sort u} →\n          ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsNat a n)) →\n            (t : Mathlib.Meta.NormNum.IsNat a n) → motive t",
  "constCategory": "Other"},
 {"references": ["DecidableEq", "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.decidableEq",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd.add_right_cancel",
   "IsRightCancelAdd",
   "Add",
   "Eq"],
  "name": "add_right_cancel",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] {a b c : G}, a + b = c + b → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "AddGroup",
   "instNatCastInt",
   "SubNegMonoid.toNeg",
   "Int.negSucc",
   "SubNegMonoid.zsmul",
   "AddOpposite.subNegMonoid",
   "AddOpposite",
   "Neg.neg",
   "SubNegMonoid.zsmul_neg'",
   "Nat",
   "Nat.succ",
   "Int",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddOpposite.addGroup.proof_4",
  "constType":
  "∀ (α : Type u_1) [inst : AddGroup α] (n : ℕ) (a : αᵃᵒᵖ),\n  SubNegMonoid.zsmul (Int.negSucc n) a = -SubNegMonoid.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Fintype", "Set.Elem", "Finset.toSet", "Finset", "Finset.Subtype.fintype"],
  "name": "FinsetCoe.fintype",
  "constType": "{α : Type u_1} → (s : Finset α) → Fintype ↑↑s",
  "constCategory": "Definition"},
 {"references": ["Not", "mt"],
  "name": "Function.mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Decidable",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "instDecidableLeToLEToPreorderToPartialOrder",
  "constType":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a ≤ b)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.negOfNat",
   "AddGroupWithOne.toIntCast",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "True",
   "Int.cast_ofNat",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast_neg",
   "Int.cast",
   "AddGroupWithOne",
   "Int.instNegInt",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.cast_negOfNat",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑(Int.negOfNat n) = -↑n",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} → [self : InvolutiveNeg A] → Neg A",
  "constCategory": "Definition"},
 {"references": ["outParam", "SetLike", "Function.Injective", "Set"],
  "name": "SetLike.mk",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → (coe : A → Set B) → Function.Injective coe → SetLike A B",
  "constCategory": "Other"},
 {"references":
  ["not_exists",
   "Exists",
   "Or",
   "Eq.mpr",
   "Eq.ndrec",
   "em",
   "propext",
   "Eq.refl",
   "Not",
   "Eq.symm",
   "Eq",
   "id"],
  "name": "exists_or_forall_not",
  "constType": "∀ {α : Sort u_2} (P : α → Prop), (∃ a, P a) ∨ ∀ (a : α), ¬P a",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "StarMul",
  "constType": "(R : Type u) → [inst : Mul R] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Classical.choose_spec",
   "Equiv.Set.imageOfInjOn.match_2",
   "Classical.choose",
   "Subtype.eq",
   "Subtype.val",
   "Set",
   "And.left",
   "Eq",
   "Set.instMembershipSet",
   "Subtype.property",
   "And",
   "And.right",
   "Set.Elem",
   "Set.image",
   "Subtype.mk",
   "Set.mem_image_of_mem"],
  "name": "Equiv.Set.imageOfInjOn.proof_5",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (s : Set α) (x : ↑(f '' s)),\n  (fun p => { val := f ↑p, property := (_ : f ↑p ∈ f '' s) })\n      ((fun p =>\n          { val := Classical.choose (_ : ↑p ∈ f '' s), property := (_ : Classical.choose (_ : ↑p ∈ f '' s) ∈ s) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.toReal",
   "Membership.mem",
   "ENNReal.toNNReal_sum",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "Real",
   "Finset.sum",
   "Eq.refl",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Finset.instMembershipFinset",
   "ENNReal.toNNReal",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "NNReal.coe_sum",
   "Eq",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Eq.mpr",
   "Eq.ndrec",
   "OrderedCommSemiring.toOrderedSemiring",
   "Finset",
   "CompleteLattice.toTop",
   "instNNRealOrderedCommSemiring",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "_private.Mathlib.Data.Real.ENNReal.0.ENNReal.toReal._eq_1",
   "Real.instAddCommMonoidReal",
   "ENNReal.toReal",
   "NNReal",
   "id",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "ENNReal.toReal_sum",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal},\n  (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a).toReal = Finset.sum s fun a => (f a).toReal",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OrderedCancelAddCommMonoid.toContravariantClassLeLeft",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.le",
   "Eq.ge",
   "AddCommMonoid.toAddMonoid",
   "Preorder.toLE",
   "Eq",
   "LE.le.antisymm",
   "le_of_add_le_add_left",
   "AddMonoid.toAddSemigroup",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b c : α), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "neg_eq_zero_sub",
  "constType": "∀ {G : Type u_3} [inst : SubNegMonoid G] (x : G), -x = 0 - x",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instHasEquiv",
   "Set",
   "Function.update",
   "dite",
   "Quotient.out_eq'",
   "Exists.intro",
   "Quotient",
   "QuotientAddGroup.leftRel",
   "QuotientAddGroup.instHasQuotientAddSubgroup",
   "QuotientAddGroup.mk",
   "Eq",
   "Set.range",
   "AddGroup",
   "Quotient.out'",
   "Eq.rec",
   "AddSubgroup",
   "HasQuotient.Quotient",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.symm",
   "Membership.mem",
   "Quotient.decidableEq",
   "congr_arg",
   "Classical.propDecidable",
   "Function.update_noteq",
   "Set.instMembershipSet",
   "And",
   "Quotient.mk''",
   "Function.update_same",
   "AddSubgroup.leftTransversals",
   "Not",
   "And.intro",
   "AddSubgroup.range_mem_leftTransversals",
   "HasEquiv.Equiv",
   "SetLike.coe"],
  "name": "AddSubgroup.exists_left_transversal",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (g : G), ∃ S ∈ AddSubgroup.leftTransversals ↑H, g ∈ S",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "LinearOrderedCommRing"],
  "name": "LinearOrderedField.toLinearOrderedCommRing",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedField α] → LinearOrderedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Function.minimalPeriod",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Nat",
   "AddMonoid",
   "Eq",
   "addOrderOf"],
  "name": "_private.Mathlib.GroupTheory.OrderOfElement.0.addOrderOf._eq_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddMonoid G] (x : G), addOrderOf x = Function.minimalPeriod (fun x_1 => x + x_1) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Submonoid.mk",
   "OfNat.ofNat",
   "Set.instSingletonSet",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Set",
   "Subsemigroup.mk",
   "Submonoid",
   "Bot.mk",
   "One.toOfNat1",
   "Singleton.singleton",
   "Submonoid.instBotSubmonoid.proof_2",
   "Submonoid.instBotSubmonoid.proof_1"],
  "name": "Submonoid.instBotSubmonoid",
  "constType": "{M : Type u_1} → [inst : MulOneClass M] → Bot (Submonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Complex.abs",
   "PartialOrder.toPreorder",
   "AbsoluteValue",
   "Real",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "Norm",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "Norm.mk",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.instNormComplex",
  "constType": "Norm ℂ",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.MeasureSpace.toMeasurableSpace",
   "refPackage",
   "MeasureTheory.MeasureSpace",
   "Measurable",
   "MeasurableSpace",
   "refPackage.X₀₁"],
  "name": "refPackage.hmeas1",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {G : Type uG} [inst_2 : MeasurableSpace G] (self : refPackage Ω₀₁ Ω₀₂ G), Measurable self.X₀₁",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "NonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "NonAssocRing.toNatCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NatCast.natCast",
   "Eq"],
  "name": "NonAssocRing.natCast_zero",
  "constType":
  "∀ {α : Type u_1} [self : NonAssocRing α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["WithTop.instCompleteLinearOrderWithTop.proof_7",
   "LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "WithTop.le",
   "Inf.inf",
   "CompleteLattice.mk",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop.proof_13",
   "OrderBot",
   "Lattice.mk",
   "Sup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_11",
   "Preorder.toLE",
   "WithTop.instCompleteLinearOrderWithTop.proof_2",
   "OrderTop.toTop",
   "Lattice.toInf",
   "Inf.mk",
   "SemilatticeSup.toSup",
   "WithTop.orderBot",
   "ConditionallyCompleteLattice.toSupSet",
   "WithTop",
   "instLinearOrder",
   "WithTop.semilatticeSup",
   "LinearOrder.decidableEq",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrderBot",
   "WithTop.linearOrder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "CompleteLinearOrder.mk",
   "WithTop.instInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_5",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "SemilatticeSup.mk",
   "WithTop.instCompleteLinearOrderWithTop.proof_12",
   "ConditionallyCompleteLattice.toInfSet",
   "WithTop.instCompleteLinearOrderWithTop.proof_8",
   "WithTop.orderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_9",
   "WithTop.instCompleteLinearOrderWithTop.proof_1",
   "WithTop.instCompleteLinearOrderWithTop.proof_6",
   "WithTop.instCompleteLinearOrderWithTop.proof_3",
   "ConditionallyCompleteLinearOrderBot.toOrderBot",
   "WithTop.lattice",
   "LinearOrder.decidableLT",
   "OrderBot.toBot",
   "OrderTop",
   "WithTop.instCompleteLinearOrderWithTop.proof_10",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "WithTop.instCompleteLinearOrderWithTop.proof_4",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "WithTop.instSupSet"],
  "name": "WithTop.instCompleteLinearOrderWithTop",
  "constType":
  "{α : Type u_1} → [inst : ConditionallyCompleteLinearOrderBot α] → CompleteLinearOrder (WithTop α)",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.le_mk_iff_exists_set",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Cardinal.mk_fintype",
   "Cardinal.partialOrder",
   "And.left",
   "Exists.casesOn",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "implies_congr",
   "Nonempty",
   "Preorder.toLE",
   "Eq",
   "Cardinal.lt_lift_iff",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "Iff.mp",
   "Set.Elem",
   "Finset.toSet",
   "Function.Embedding",
   "Fintype.card_coe",
   "Nat",
   "Cardinal.mk",
   "And.casesOn",
   "Cardinal.instCharZeroCardinalToAddMonoidWithOneToAddCommMonoidWithOneToNonAssocSemiringToSemiringToOrderedSemiringToOrderedCommSemiringCanonicallyOrderedCommSemiring",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Set.Infinite.to_subtype",
   "Subtype",
   "Set.instCanLiftSetFinsetToSetFinite",
   "Quotient.liftOn₂",
   "Cardinal.nat_lt_aleph0",
   "Finset.instMembershipFinset",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Iff.intro",
   "And",
   "of_eq_true",
   "LT.lt",
   "Infinite.natEmbedding",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Not",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Contrapose.mtr",
   "congrArg",
   "Cardinal.lift",
   "congrFun",
   "Finset.card",
   "Exists",
   "Std.Logic._auxLemma.36",
   "Set",
   "CanLift.prf",
   "Eq.refl",
   "Cardinal.instLECardinal.proof_1",
   "True",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Cardinal.aleph0",
   "Preorder.toLT",
   "Eq.rec",
   "Finset",
   "Eq.symm",
   "Cardinal.canonicallyOrderedCommSemiring",
   "id",
   "Membership.mem",
   "funext",
   "Cardinal.lt_aleph0.match_1",
   "Fintype.card",
   "Cardinal.linearOrder",
   "LE.le",
   "Set.Finite",
   "Cardinal.instLECardinal",
   "Nonempty.intro",
   "Cardinal.lift_natCast",
   "Eq.ndrec",
   "Cardinal.instNatCastCardinal",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "letFun",
   "Cardinal",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.lt_aleph0",
  "constType": "∀ {c : Cardinal.{u_1}}, c < Cardinal.aleph0 ↔ ∃ n, c = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "mul_left_comm",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₃ c : R} (b₁ : R) (b₂ : ℕ), a * b₃ = c → a * (b₁ ^ b₂ * b₃) = b₁ ^ b₂ * c",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.not_succ_le_self.match_1",
   "LE.le",
   "Nat.not_succ_le_zero",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "Nat.le_of_succ_le_succ",
   "PUnit",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "absurd"],
  "name": "Nat.not_succ_le_self",
  "constType": "∀ (n : ℕ), ¬Nat.succ n ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Neg.toHasAbs",
   "OfNat.ofNat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "CauSeq.Completion.instZeroCauchy",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.577",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Setoid.r",
   "Or",
   "Function.Embedding.total",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Quot.ind",
   "Cardinal",
   "PartialOrder.le_antisymm",
   "Cardinal.partialOrder",
   "Cardinal.isEquivalent",
   "LE.le",
   "Preorder.toLE",
   "Quot.mk"],
  "name": "Cardinal.linearOrder.proof_1",
  "constType": "∀ (a b : Cardinal.{u_1}), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.rfl", "LT.lt", "LT", "GT.gt"],
  "name": "gt_iff_lt",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, x > y ↔ y < x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Abs",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.Completion.instIntCastCauchy",
   "CauSeq.Completion.instAddCauchy",
   "CauSeq.Completion.instNegCauchy",
   "CauSeq.Completion.instNatCastCauchy",
   "CauSeq.Completion.Cauchy.ring.proof_3",
   "CauSeq.Completion.Cauchy.ring.proof_6",
   "CauSeq.Completion.instOneCauchy",
   "CauSeq.Completion.Cauchy.ring.proof_11",
   "CauSeq.Completion.Cauchy.ring.proof_2",
   "AddGroupWithOne.toAddGroup",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.Completion.Cauchy.ring.proof_12",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring.proof_5",
   "CauSeq.Completion.instSMulCauchy",
   "Ring",
   "CauSeq.ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.Cauchy.ring.proof_7",
   "CauSeq.Completion.instMulCauchy",
   "Nat",
   "CauSeq.Completion.instSubCauchy",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "CauSeq.Completion.Cauchy.ring.proof_14",
   "CauSeq.Completion.Cauchy.ring.proof_10",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "CauSeq.Completion.instPowCauchyNat",
   "AddMonoidWithOne.toAddMonoid",
   "CauSeq",
   "CauSeq.Completion.Cauchy.ring.proof_9",
   "CauSeq.Completion.Cauchy.ring.proof_1",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "SubNegMonoid.SMulInt",
   "CauSeq.Completion.Cauchy.ring.proof_8",
   "AddGroup.toSubNegMonoid",
   "CauSeq.Completion.instZeroCauchy",
   "Function.Surjective.ring",
   "AddMonoid.toNatSMul",
   "CauSeq.Completion.Cauchy.ring.proof_13",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.mk",
   "Int",
   "CauSeq.Completion.Cauchy.ring.proof_4"],
  "name": "CauSeq.Completion.Cauchy.ring",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Ring (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real",
   "Set",
   "ENNReal.toReal",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.real",
  "constType":
  "{α : Type u_1} → {x : MeasurableSpace α} → MeasureTheory.Measure α → Set α → ℝ",
  "constCategory": "Definition"},
 {"references": ["Or", "em'", "Set", "Set.Infinite", "Set.Finite"],
  "name": "Set.infinite_or_finite",
  "constType": "∀ {α : Type u} (s : Set α), Set.Infinite s ∨ Set.Finite s",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "propext",
   "SProd.sprod",
   "Set",
   "Set.mem_prod",
   "Prod",
   "Prod.fst",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Prod._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {p : α × β}, (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "eq_true",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "zero_lt_one",
   "One.toOfNat1",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "Semigroup",
   "SemigroupWithZero",
   "Eq"],
  "name": "SemigroupWithZero.mk",
  "constType":
  "{S₀ : Type u} →\n  [toSemigroup : Semigroup S₀] →\n    [toZero : Zero S₀] → (∀ (a : S₀), 0 * a = 0) → (∀ (a : S₀), a * 0 = 0) → SemigroupWithZero S₀",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Prod.snd",
   "HSub.hSub",
   "Prod",
   "Measurable",
   "Prod.fst",
   "Sub",
   "MeasurableSub₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "MeasurableSub₂.measurable_sub",
  "constType":
  "∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : Sub G] [self : MeasurableSub₂ G], Measurable fun p => p.1 - p.2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_8",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Real.ofCauchy_inv",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Real.instInvReal",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.17",
  "constType":
  "∀ {f : CauSeq.Completion.Cauchy abs}, { cauchy := f }⁻¹ = { cauchy := f⁻¹ }",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "Function.Injective",
   "Real",
   "Complex",
   "congrArg",
   "Complex.re"],
  "name": "Complex.ofReal_injective",
  "constType": "Function.Injective Complex.ofReal'",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "MeasureTheory.Measure",
   "prod",
   "instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instSubReal",
   "Real",
   "HSub.hSub",
   "Prod",
   "ProbabilityTheory.entropy",
   "autoParam",
   "MeasurableSpace",
   "_auto._@.PFR.ForMathlib.Entropy.Basic._hyg.16940",
   "Prod.instMeasurableSpace"],
  "name": "ProbabilityTheory.mutualInfo",
  "constType":
  "{Ω : Type uΩ} →\n  {S : Type uS} →\n    {T : Type uT} →\n      [mΩ : MeasurableSpace Ω] →\n        [inst : MeasurableSpace S] →\n          [inst : MeasurableSpace T] → (Ω → S) → (Ω → T) → autoParam (MeasureTheory.Measure Ω) _auto✝ → ℝ",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Zero",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "HMul.hMul",
   "MonoidWithZero",
   "Eq"],
  "name": "MonoidWithZero.mk",
  "constType":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "congrArg",
   "Nat.left_distrib",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Nat.right_distrib",
  "constType": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "constCategory": "Theorem"},
 {"references": ["NatPow", "Nat"],
  "name": "NatPow.pow",
  "constType": "{α : Type u} → [self : NatPow α] → α → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Exists",
   "instLENat",
   "Nat.le.dest",
   "instAddNat",
   "Nat.le.intro",
   "instHAdd",
   "HAdd.hAdd",
   "letFun",
   "Nat.le.dest.match_1",
   "Nat",
   "congrArg",
   "Eq.trans",
   "LE.le",
   "Eq"],
  "name": "Nat.add_le_add_left",
  "constType": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), k + n ≤ k + m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "ZeroLEOneClass.mk",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α], 0 ≤ 1 → ZeroLEOneClass α",
  "constCategory": "Other"},
 {"references":
  ["IsCommutative.comm", "IsSymmOp", "IsSymmOp.mk", "IsCommutative"],
  "name": "isSymmOp_of_isCommutative",
  "constType":
  "∀ (α : Type u) (op : α → α → α) [inst : IsCommutative α op], IsSymmOp α α op",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_succ",
   "Nat.succ_le_of_lt",
   "instLENat",
   "Nat.lt_of_succ_le",
   "instAddNat",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "LT.lt",
   "Nat",
   "LE.le",
   "Nat.succ",
   "instLTNat",
   "Nat.add_le_add_left",
   "Eq"],
  "name": "Nat.add_lt_add_left",
  "constType": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), k + n < k + m",
  "constCategory": "Theorem"},
 {"references": ["NormedField", "DenselyNormedField"],
  "name": "DenselyNormedField.toNormedField",
  "constType": "{α : Type u_5} → [self : DenselyNormedField α] → NormedField α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Finset.sum",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Finset.instMembershipFinset",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ENNReal.instCompleteLinearOrderENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "ENNReal",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "Finset",
   "CompleteLattice.toTop",
   "instNNRealCanonicallyOrderedCommSemiring",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "WithTop.sum_lt_top",
   "instNNRealOrderedCommSemiring",
   "NNReal",
   "OrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "ENNReal.sum_lt_top",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ a ∈ s, f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Fin.ne_of_val_ne",
   "instDecidableEqFin.match_1",
   "DecidableEq",
   "Fin.eq_of_val_eq",
   "Decidable.isFalse",
   "Fin.val",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Nat",
   "decEq",
   "instDecidableEqNat",
   "Fin",
   "Eq"],
  "name": "instDecidableEqFin",
  "constType": "(n : ℕ) → DecidableEq (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "instHDiv",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "propext",
   "GroupWithZero",
   "HMul.hMul",
   "div_eq_iff",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "Mathlib.Algebra.GroupWithZero.Units.Lemmas._auxLemma.1",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (a / b = c) = (a = c * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subsemigroup.carrier",
   "Group.toDivisionMonoid",
   "MulOneClass.toMul",
   "Set",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "DivInvOneMonoid.toInvOneClass",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv"],
  "name": "Subgroup.mk",
  "constType":
  "{G : Type u_5} →\n  [inst : Group G] →\n    (toSubmonoid : Submonoid G) → (∀ {x : G}, x ∈ toSubmonoid.carrier → x⁻¹ ∈ toSubmonoid.carrier) → Subgroup G",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a + b ≤ a + c → b ≤ c",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "id", "Eq"],
  "name": "Function.injective_id",
  "constType": "∀ {α : Sort u₁}, Function.Injective id",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "trivial", "Set", "Set.univ", "Set.instMembershipSet"],
  "name": "Set.mem_univ",
  "constType": "∀ {α : Type u} (x : α), x ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_right",
   "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "Ring.toSemiring",
   "LinearOrderedRing.max_def",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toLinearOrderedSemiring.proof_3",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "LinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.decidableLT",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OrderBot.toBot",
   "CompleteLattice.toBoundedOrder",
   "OrderBot.bot_le",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "LE.le",
   "GaloisInsertion",
   "BoundedOrder.toOrderBot",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_7",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (a : β), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toZero",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "SubtractionMonoid",
   "Set.addMonoid",
   "Eq"],
  "name": "Set.subtractionMonoid.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (x : Set α), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "CommSemigroup.toSemigroup",
   "Eq"],
  "name": "CommSemigroup.mul_comm",
  "constType":
  "∀ {G : Type u} [self : CommSemigroup G] (a b : G), a * b = b * a",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Covariant",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Invertible.invOf",
   "OfNat.ofNat",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "instLTNat",
   "Invertible",
   "StrictOrderedSemiring.toSemiring",
   "Iff.mpr",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "invOf_pos",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Nat",
   "pos_of_invertible_cast",
   "OrderedSemiring.toPartialOrder"],
  "name": "pos_invOf_of_invertible_cast",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedSemiring α] [inst_1 : Nontrivial α] (n : ℕ) [inst_2 : Invertible ↑n], 0 < ⅟↑n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroupWithOne.toIntCast",
   "Nat.cast",
   "instNatCastInt",
   "AddCommGroupWithOne",
   "AddCommGroupWithOne.toNatCast",
   "Nat",
   "Int",
   "IntCast.intCast",
   "Eq"],
  "name": "AddCommGroupWithOne.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references": ["Set.range", "FiniteRange", "Set.Finite"],
  "name": "FiniteRange.mk",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} {X : Ω → G}, Set.Finite (Set.range X) → FiniteRange X",
  "constCategory": "Other"},
 {"references": ["instLENat", "LT.lt", "Nat", "Nat.succ", "LE.le", "instLTNat"],
  "name": "Nat.succ_le_of_lt",
  "constType": "∀ {n m : ℕ}, n < m → Nat.succ n ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ordering",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Nat.lt_succ_of_lt",
   "Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Decidable.isTrue",
   "instLTNat",
   "Nat.decidableBallLT.proof_1",
   "Nat.decidableBallLT.match_3",
   "Nat.decidableBallLT.proof_5",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.decidableBallLT.match_2",
   "Nat.decidableBallLT.match_1",
   "Decidable.isFalse",
   "LT.lt",
   "PUnit",
   "Decidable",
   "Nat.decidableBallLT.proof_2",
   "Not",
   "instOfNatNat",
   "Nat.decidableBallLT.proof_4",
   "Nat",
   "Nat.decidableBallLT.proof_3",
   "Nat.succ"],
  "name": "Nat.decidableBallLT",
  "constType":
  "(n : ℕ) →\n  (P : (k : ℕ) → k < n → Prop) →\n    [inst : (n_1 : ℕ) → (h : n_1 < n) → Decidable (P n_1 h)] → Decidable (∀ (n_1 : ℕ) (h : n_1 < n), P n_1 h)",
  "constCategory": "Definition"},
 {"references":
  ["Not.elim",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.decLt",
   "Nat.prime_def_lt",
   "Nat.instDvdNat",
   "of_decide_eq_true",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "SemigroupWithZero.toZero",
   "instLTNat",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "Nat.Prime",
   "Iff",
   "instLENat",
   "Preorder.toLT",
   "Eq.rec",
   "Bool.true",
   "le_add_self",
   "instOfNatNat",
   "Iff.trans",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "Nat.decLe",
   "Nat.strictOrderedSemiring",
   "not_lt_of_ge",
   "and_congr_right",
   "eq_zero_of_zero_dvd",
   "Nat.canonicallyOrderedCommSemiring",
   "Dvd.dvd",
   "LE.le",
   "forall_prop_decidable",
   "Iff.intro",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Nat.commSemiring",
   "And",
   "Eq.ndrec",
   "Nat.zero",
   "StrictOrderedSemiring.toPartialOrder",
   "LT.lt",
   "Eq.mp",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Not",
   "Bool",
   "Nat.casesOn",
   "forall_congr'"],
  "name": "Nat.prime_def_lt'",
  "constType":
  "∀ {p : ℕ}, Nat.Prime p ↔ 2 ≤ p ∧ ∀ (m : ℕ), 2 ≤ m → m < p → ¬m ∣ p",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Filter.map.proof_2",
   "Set.preimage",
   "Filter.mk",
   "Set",
   "Filter.map.proof_1",
   "Filter",
   "Filter.univ_mem"],
  "name": "Filter.map",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Nat",
   "Nat.succ",
   "AddMonoidWithOne.natCast_succ",
   "Eq"],
  "name": "Nat.cast_succ",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1",
  "constCategory": "Theorem"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references": ["Add", "Mul"],
  "name": "RightDistribClass",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["List.Perm.length_eq",
   "OfNat.ofNat",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "List.length",
   "AddMonoid.toAddZeroClass",
   "rfl",
   "Eq",
   "Quot.liftOn",
   "Zero.toOfNat0",
   "Setoid.r",
   "AddZeroClass.toZero",
   "List",
   "Multiset",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card.proof_1",
  "constType":
  "∀ {α : Type u_1},\n  (fun s => Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n      0 =\n    (fun s =>\n        Quot.liftOn s List.length (_ : ∀ (_l₁ _l₂ : List α), List.Perm _l₁ _l₂ → List.length _l₁ = List.length _l₂))\n      0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Injective.injOn",
   "Equiv.Set.imageOfInjOn",
   "Set.Elem",
   "Function.Injective",
   "Set",
   "Set.image"],
  "name": "Equiv.Set.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (f : α → β) → (s : Set α) → Function.Injective f → ↑s ≃ ↑(f '' s)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "_private.Mathlib.Data.Real.Basic.0.Real.one_def",
   "Rat",
   "One.toOfNat1",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instOneCauchy",
   "_private.Mathlib.Data.Real.Basic.0.Real.one",
   "Real.ofCauchy",
   "Abs.abs",
   "Real.instOneReal",
   "Eq",
   "Rat.instSupRat",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_one",
  "constType": "{ cauchy := 1 } = 1",
  "constCategory": "Theorem"},
 {"references":
  ["refPackage",
   "refPackage.η",
   "instHAdd",
   "Real.instMulReal",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Eq.refl",
   "ProbabilityTheory.IdentDistrib.rdist_eq",
   "ProbabilityTheory.IdentDistrib",
   "MeasureTheory.MeasureSpace.volume",
   "refPackage.X₀₁",
   "Eq",
   "MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "instHMul",
   "refPackage.X₀₂",
   "Eq.mpr",
   "Eq.ndrec",
   "rdist",
   "Measurable.aemeasurable",
   "MeasureTheory.MeasureSpace",
   "HMul.hMul",
   "refPackage.hmeas2",
   "tau",
   "AddCommGroup",
   "ProbabilityTheory.IdentDistrib.refl",
   "MeasurableSpace",
   "refPackage.hmeas1",
   "id"],
  "name": "ProbabilityTheory.IdentDistrib.tau_eq",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  {G : Type uG} [inst_2 : AddCommGroup G] [inst_3 : MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω₁ : Type u_3}\n  {Ω₂ : Type u_4} {Ω'₁ : Type u_5} {Ω'₂ : Type u_6} [inst_4 : MeasurableSpace Ω₁] [inst_5 : MeasurableSpace Ω₂]\n  [inst_6 : MeasurableSpace Ω'₁] [inst_7 : MeasurableSpace Ω'₂] {μ₁ : MeasureTheory.Measure Ω₁}\n  {μ₂ : MeasureTheory.Measure Ω₂} {μ'₁ : MeasureTheory.Measure Ω'₁} {μ'₂ : MeasureTheory.Measure Ω'₂} {X₁ : Ω₁ → G}\n  {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G},\n  ProbabilityTheory.IdentDistrib X₁ X'₁ →\n    ProbabilityTheory.IdentDistrib X₂ X'₂ → τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p]",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PFR.Mathlib.Probability.Independence.Basic._auxLemma.10",
   "CanonicallyOrderedCommSemiring.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "Inter.inter",
   "MeasureTheory.IsProbabilityMeasure",
   "NonAssocSemiring.toMulZeroOneClass",
   "CanonicallyOrderedCommSemiring.toOne",
   "MeasureTheory.Measure.prod",
   "ProbabilityTheory.IndepFun_iff",
   "Exists.casesOn",
   "Set.inter_univ",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "one_mul",
   "MeasureTheory.OuterMeasure.measureOf",
   "SProd.sprod",
   "MeasurableSet",
   "And.casesOn",
   "Eq.trans",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "Set.prod_inter_prod",
   "id",
   "eq_self",
   "Set.instSProd",
   "Prod.snd",
   "Set.preimage",
   "One.toOfNat1",
   "Prod.fst",
   "Set.univ",
   "MeasurableSpace.comap",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "Prod.instMeasurableSpace",
   "instHMul",
   "And",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "propext",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "PFR.Mathlib.Probability.Independence.Basic._auxLemma.9",
   "congr",
   "HMul.hMul",
   "mul_one",
   "Prod",
   "Set.univ_inter",
   "MeasureTheory.Measure.prod_prod",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "ProbabilityTheory.IndepFun",
   "Set.instInterSet"],
  "name": "ProbabilityTheory.indepFun_fst_snd",
  "constType":
  "∀ {Ω : Type u_1} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {Ω' : Type u_10} [inst : MeasurableSpace Ω']\n  {μ' : MeasureTheory.Measure Ω'} [inst_1 : MeasureTheory.IsProbabilityMeasure μ]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure μ'], ProbabilityTheory.IndepFun Prod.fst Prod.snd",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "HasCompl.compl",
   "Sup.sup",
   "BooleanAlgebra.toHasCompl",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.top_le_sup_compl",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_8",
  "constType": "∀ {α : Type u_1} (x : Set α), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Invertible.invOf",
   "One",
   "Invertible.invOf_mul_self",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible",
   "Eq"],
  "name": "invOf_mul_self'",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) {x : Invertible a}, ⅟a * a = 1",
  "constCategory": "Theorem"},
 {"references": ["SeminormedRing", "PseudoMetricSpace"],
  "name": "SeminormedRing.toPseudoMetricSpace",
  "constType":
  "{α : Type u_5} → [self : SeminormedRing α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "Set",
   "Finset",
   "Function.Embedding.subtype",
   "Subtype",
   "Set.instMembershipSet"],
  "name": "Set.toFinset",
  "constType": "{α : Type u_1} → (s : Set α) → [inst : Fintype ↑s] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["GroupWithZero.toDivisionMonoid.proof_1",
   "DivisionMonoid.mk",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "Inv.mk",
   "GroupWithZero.toDiv",
   "DivisionMonoid",
   "GroupWithZero.toDivisionMonoid.proof_2",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero",
   "GroupWithZero.zpow_zero'",
   "_private.Mathlib.Algebra.GroupWithZero.Basic.0.inv_eq_of_mul",
   "Inv.inv",
   "GroupWithZero.toInv",
   "GroupWithZero.zpow",
   "GroupWithZero.zpow_neg'"],
  "name": "GroupWithZero.toDivisionMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : GroupWithZero G₀] → DivisionMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "OfNat.ofNat",
   "Set",
   "Classical.decPred",
   "Not",
   "if_neg",
   "Set.indicator",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.indicator_of_not_mem",
  "constType":
  "∀ {α : Type u_1} {M : Type u_4} [inst : Zero M] {s : Set α} {a : α}, a ∉ s → ∀ (f : α → M), Set.indicator s f a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommRing",
   "StrictOrderedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommRing.mk",
  "constType":
  "{α : Type u_2} → [toStrictOrderedRing : StrictOrderedRing α] → (∀ (a b : α), a * b = b * a) → StrictOrderedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "Iff",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass"],
  "name": "add_lt_add_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},\n  b + a < c + a ↔ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "NonUnitalNonAssocRing.toMul",
   "HEq",
   "DivisionRing.toRing",
   "eq_of_heq",
   "Mathlib.Meta.NormNum.IsRat",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "Int.cast",
   "Ring.toIntCast",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ}\n  (motive : (x x_1 x_2 : α) → Mathlib.Meta.NormNum.IsRat x (Int.ofNat n) d → ↑n = x_1 → ↑d = x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : Mathlib.Meta.NormNum.IsRat x (Int.ofNat n) d) (x_4 : ↑n = x_1) (x_5 : ↑d = x_2),\n  (∀ (inv : Invertible ↑d),\n      motive (↑(Int.ofNat n) * ⅟↑d) ↑n ↑d (_ : Mathlib.Meta.NormNum.IsRat (↑(Int.ofNat n) * ⅟↑d) (Int.ofNat n) d)\n        (_ : ↑n = ↑n) (_ : ↑d = ↑d)) →\n    motive x x_1 x_2 x_3 x_4 x_5",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Set.instSingletonSet",
   "Iff",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "Finset.instSingletonFinset"],
  "name": "Finset.coe_singleton",
  "constType": "∀ {α : Type u_1} (a : α), ↑{a} = {a}",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder", "LE.le", "Preorder.toLE", "Eq", "PartialOrder"],
  "name": "PartialOrder.le_antisymm",
  "constType":
  "∀ {α : Type u} [self : PartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "setOf",
   "Subtype.val",
   "Set",
   "Subtype.range_coe",
   "Subtype",
   "Eq"],
  "name": "Subtype.range_coe_subtype",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop}, Set.range Subtype.val = {x | p x}",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Int"],
  "name": "Int.negSucc",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["add_left_iterate",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHSMul",
   "Function.minimalPeriod",
   "_private.Mathlib.GroupTheory.OrderOfElement.0.addOrderOf._eq_1",
   "Nat.iterate",
   "instHAdd",
   "HAdd.hAdd",
   "Function.isPeriodicPt_minimalPeriod",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Eq",
   "AddMonoid.toNatSMul",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Nat",
   "add_zero",
   "Eq.trans",
   "id",
   "addOrderOf"],
  "name": "addOrderOf_nsmul_eq_zero",
  "constType":
  "∀ {G : Type u_1} [inst : AddMonoid G] (x : G), addOrderOf x • x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OrderedCommRing",
   "OrderedRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "OrderedCommRing.mk",
  "constType":
  "{α : Type u} → [toOrderedRing : OrderedRing α] → (∀ (a b : α), a * b = b * a) → OrderedCommRing α",
  "constCategory": "Other"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Mathlib.Init.Order.LinearOrder._auxLemma.1",
   "dite",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "ite",
   "min_def",
   "if_pos",
   "Eq.mpr",
   "of_eq_true",
   "Decidable",
   "LinearOrder.toMin",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id",
   "congrFun"],
  "name": "min_le_right",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "CovariantClass.elim"],
  "name": "add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {b c : α}, b ≤ c → ∀ (a : α), a + b ≤ a + c",
  "constCategory": "Theorem"},
 {"references":
  ["LeftCommutative",
   "Trans.trans",
   "Associative",
   "Eq.rec",
   "instTransEq",
   "Eq.symm",
   "rfl",
   "Commutative",
   "Eq"],
  "name": "left_comm",
  "constType":
  "∀ {α : Type u} (f : α → α → α), Commutative f → Associative f → LeftCommutative f",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "PartialOrder.le_antisymm",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_4",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "nonempty_subtype.match_2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ a, p a) → Prop) (x : ∃ a, p a),\n  (∀ (a : α) (h : p a), motive (_ : ∃ a, p a)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemifield",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Real.instSubReal",
   "Real",
   "Real.instMulReal",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Real.instAddCommGroupReal",
   "NormedField.toField",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "MulZeroClass.toZero",
   "sub_zero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Real.normedCommRing",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.isROrC.proof_6",
  "constType": "∀ (z w : ℝ), z * w = z * w - 0 * 0",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedField.toField",
   "Real",
   "Field"],
  "name": "Real.field",
  "constType": "Field ℝ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive (_ : a ∧ b)) → motive t",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NegZeroClass",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Cardinal.mk_le_mk_of_subset",
   "Set.instHasSubsetSet",
   "instLENat",
   "Set.Elem",
   "Set",
   "Set.Finite.lt_aleph0",
   "HasSubset.Subset",
   "Nat",
   "Cardinal.mk",
   "Nat.card",
   "Cardinal.toNat_le_of_le_of_lt_aleph0",
   "LE.le",
   "Set.Finite"],
  "name": "Nat.card_mono",
  "constType":
  "∀ {α : Type u_1} {s t : Set α}, Set.Finite t → s ⊆ t → Nat.card ↑s ≤ Nat.card ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedCommSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedCommSemiring α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt",
  "constType": "{α : Type u_1} → [inst : Ring α] → α → ℤ → Prop",
  "constCategory": "Other"},
 {"references":
  ["And.right",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "GT.gt"],
  "name": "not_le_of_gt",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt.le",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "LT.lt",
   "StrictMono",
   "Monotone",
   "Preorder",
   "LT.lt.ne",
   "Eq",
   "PartialOrder"],
  "name": "Monotone.strictMono_of_injective",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : PartialOrder β] {f : α → β},\n  Monotone f → Function.Injective f → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "Pi.instSub",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSubReal",
   "Real.instLEReal",
   "Real",
   "ProbabilityTheory.entropy",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasureTheory.IsProbabilityMeasure",
   "Nonempty",
   "Preorder.toLE",
   "Eq",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "Mathlib.Order.MinMax._auxLemma.4",
   "MeasureTheory.Measure",
   "MeasurableSingletonClass",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "ProbabilityTheory.max_entropy_sub_mutualInfo_le_entropy_sub",
   "Eq.mpr",
   "FiniteRange",
   "AddGroup",
   "ProbabilityTheory.mutualInfo",
   "sub_zero",
   "Measurable",
   "LinearOrderedRing.toMax",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "Real.instLinearOrderedRingReal",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "HSub.hSub",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "ProbabilityTheory.IndepFun.mutualInfo_eq_zero",
   "Real.instZeroReal",
   "DistribLattice.toLattice",
   "Countable",
   "And",
   "Eq.mp",
   "Max.max",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.max_entropy_le_entropy_sub",
  "constType":
  "∀ {Ω : Type uΩ} {G : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable G] [inst : Nonempty G]\n  [inst : MeasurableSpace G] [inst_1 : MeasurableSingletonClass G] [inst_2 : AddGroup G] {X : Ω → G}\n  {μ : MeasureTheory.Measure Ω} [inst_3 : FiniteRange X] [inst_4 : MeasureTheory.IsProbabilityMeasure μ] {Y : Ω → G}\n  [inst_5 : FiniteRange Y],\n  Measurable X → Measurable Y → ProbabilityTheory.IndepFun X Y → max H[X ; μ] H[Y ; μ] ≤ H[X - Y ; μ]",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "NonAssocRing.toAddCommGroupWithOne",
   "NonAssocRing",
   "AddGroupWithOne.toIntCast",
   "Int.cast_commute.match_1",
   "HAdd.hAdd",
   "Nat.cast_commute",
   "Commute",
   "Eq",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "Eq.trans",
   "id",
   "Mathlib.Data.Int.Cast.Lemmas._auxLemma.2",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "instAddNat",
   "instHAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
   "Int.cast_ofNat",
   "NonAssocRing.toIntCast",
   "instNatCastInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Int.cast",
   "Int.negSucc",
   "Eq.mp",
   "NonAssocSemiring.toNatCast",
   "congrArg",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Int",
   "congrFun"],
  "name": "Int.cast_commute",
  "constType":
  "∀ {α : Type u_3} [inst : NonAssocRing α] (m : ℤ) (x : α), Commute (↑m) x",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "LinearOrder.toPartialOrder",
   "Or.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "instDistribLattice.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (b c : α) (motive : b ≤ c ∨ c ≤ b → Prop) (x : b ≤ c ∨ c ≤ b),\n  (∀ (h : b ≤ c), motive (_ : b ≤ c ∨ c ≤ b)) → (∀ (h : c ≤ b), motive (_ : b ≤ c ∨ c ≤ b)) → motive x",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderBot",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references": ["semiOutParam"],
  "name": "IsROrC",
  "constType": "semiOutParam (Type u_1) → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_coe",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.6",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "Submonoid.instSetLikeSubmonoid",
   "Subgroup.toSubmonoid",
   "Set",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (_a _b : Subgroup G) (_x : G),\n  _x ∈ ↑_a.toSubmonoid ∧ _x ∈ ↑_b.toSubmonoid → _x ∈ ↑_b.toSubmonoid",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "instDecidableEqProd.match_2",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} → (motive : α × β → Sort u_3) → (x : α × β) → ((a' : α) → (b' : β) → motive (a', b')) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.cauchy",
  "constType": "ℝ → CauSeq.Completion.Cauchy abs",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1004",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Eq",
   "AddMonoidWithOne",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "HEq.refl",
   "Unit.unit",
   "Eq.casesOn",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_eq.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {n : ℕ}\n  (motive : (x x_1 : α) → Mathlib.Meta.NormNum.IsNat x n → ↑n = x_1 → Prop) (x x_1 : α)\n  (x_2 : Mathlib.Meta.NormNum.IsNat x n) (x_3 : ↑n = x_1),\n  (Unit → motive ↑n ↑n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : ↑n = ↑n)) → motive x x_1 x_2 x_3",
  "constCategory": "Definition"},
 {"references":
  ["Multiplicative.group.proof_2",
   "DivInvMonoid",
   "add_left_neg",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.toInv",
   "DivInvMonoid.zpow",
   "AddGroup",
   "Multiplicative",
   "Multiplicative.group.proof_4",
   "Group.mk",
   "Multiplicative.group.proof_3",
   "Multiplicative.group.proof_1",
   "Group",
   "Multiplicative.divInvMonoid",
   "DivInvMonoid.toDiv"],
  "name": "Multiplicative.group",
  "constType": "{α : Type u} → [inst : AddGroup α] → Group (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.ble",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "OrderedSemiring.toSemiring",
   "Bool",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α]\n  (motive :\n    (x x_1 : α) →\n      (x_2 x_3 : ℕ) →\n        Mathlib.Meta.NormNum.IsNat x x_2 → Mathlib.Meta.NormNum.IsNat x_1 x_3 → Nat.ble x_3 x_2 = false → Prop)\n  (x x_1 : α) (x_2 x_3 : ℕ) (x_4 : Mathlib.Meta.NormNum.IsNat x x_2) (x_5 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_6 : Nat.ble x_3 x_2 = false),\n  (∀ (n n_1 : ℕ) (h : Nat.ble n_1 n = false),\n      motive (↑n) (↑n_1) n n_1 (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1) h) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "Std.Logic._auxLemma.51",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references": ["Inhabited"],
  "name": "Inhabited.mk",
  "constType": "{α : Sort u} → α → Inhabited α",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toNormedCommRing.proof_2",
   "NormedField.toField",
   "Field.toCommRing",
   "NormedCommRing",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "CommRing.toRing",
   "NormedRing.mk",
   "NormedCommRing.mk",
   "NormedField.toNormedCommRing.proof_1",
   "NormedField.toNorm"],
  "name": "NormedField.toNormedCommRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Multiset.card",
   "AddZeroClass.toAdd",
   "congr_arg",
   "instHSMul",
   "AddHomClass.toFunLike",
   "Finset.sum",
   "Multiset.sum",
   "Function.const",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "Multiset.map_const",
   "AddMonoid.toAddZeroClass",
   "Multiset.replicate",
   "Eq",
   "AddMonoid.toNatSMul",
   "Multiset.map",
   "Nat.addMonoid",
   "HSMul.hSMul",
   "Finset",
   "Multiset",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.sum_replicate",
   "Eq.trans",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "AddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.sum_const",
  "constType":
  "∀ {β : Type u} {α : Type v} {s : Finset α} [inst : AddCommMonoid β] (b : β),\n  (Finset.sum s fun _x => b) = Finset.card s • b",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Decidable.decide",
   "OrderedRing.toRing",
   "mul_assoc",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Int.commute_cast",
   "Bool.true",
   "Ring.toIntCast",
   "Int.cast_strictMono",
   "Int.cast_mul",
   "Nat",
   "mul_lt_mul_of_pos_left",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Invertible.invOf",
   "Int.decLt",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.instLTInt",
   "Int.cast_ofNat",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Int.cast",
   "LT.lt",
   "Eq.mp",
   "Mathlib.Meta.NormNum.isRat_lt_true.match_1",
   "congr",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "congrFun",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddGroupWithOne.toIntCast",
   "of_decide_eq_true",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.linearOrderedCommRing",
   "StrictOrderedRing.toOrderedRing",
   "mul_mul_invOf_self_cancel'",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toNatCast",
   "LinearOrderedRing",
   "Preorder.toLT",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Eq.symm",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "Ring.toSemiring",
   "StrictOrderedSemiring.toSemiring",
   "OrderedRing.toPartialOrder",
   "Semiring.toOne",
   "pos_invOf_of_invertible_cast",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "HMul.hMul",
   "mul_lt_mul_of_pos_right",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nontrivial",
   "Bool",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "StrictOrderedSemiring.toPosMulStrictMono"],
  "name": "Mathlib.Meta.NormNum.isRat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Nontrivial α] {a b : α} {na nb : ℤ} {da db : ℕ},\n  Mathlib.Meta.NormNum.IsRat a na da → Mathlib.Meta.NormNum.IsRat b nb db → decide (na * ↑db < nb * ↑da) = true → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Algebra.toRingHom",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "algebraMap",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_right_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "sub_mul",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), (a - b) * c = a * c - b * c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroLEOneClass",
   "lt_add_of_pos_right",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder",
   "AddZeroClass.toZero",
   "NeZero",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "zero_lt_one",
   "AddZeroClass"],
  "name": "lt_add_one",
  "constType":
  "∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1] [inst_5 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α), a < a + 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "DivisionRing",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "DivisionRing.toRatCast",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "Semiring.toNatCast",
   "Eq",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "DivisionRing.ratCast_mk",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Set.Elem",
   "SProd.sprod",
   "Set",
   "Finite",
   "Equiv.Set.prod",
   "Finite.instFiniteProd",
   "Prod",
   "Finite.of_equiv",
   "Equiv.symm"],
  "name": "Finite.Set.finite_prod",
  "constType":
  "∀ {α : Type u} {β : Type v} (s : Set α) (t : Set β) [inst : Finite ↑s] [inst : Finite ↑t], Finite ↑(s ×ˢ t)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "outParam",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "AddMonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] →\n        [inst_1 : AddZeroClass N] → [toAddHomClass : AddHomClass F M N] → (∀ (f : F), f 0 = 0) → AddMonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["NeZero.succ", "OfNat.ofNat", "Fin.instOfNatFin", "Nat", "Nat.succ", "Fin"],
  "name": "Matrix.vecHead",
  "constType": "{α : Type u} → {n : ℕ} → (Fin (Nat.succ n) → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "add_nonpos",
   "ProbabilityTheory.iIndepFun.reindex",
   "Mathlib.Tactic.Ring.pow_zero",
   "Mathlib.Meta.NormNum.IsInt.to_isRat",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Real.instOneReal",
   "Semiring.toNatCast",
   "Real.linearOrder",
   "IsROrC.charZero_isROrC",
   "Pi.instAdd",
   "LinearOrderedField.toLinearOrderedSemifield",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "Fin.mk",
   "Equiv.symm",
   "instHDiv",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "instDistribLattice",
   "AddCommMagma.toAdd",
   "DivisionRing.toInv",
   "Prod.instMeasurableSpace",
   "refPackage.X₀₁",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "List.pmap.proof_4",
   "Prod.instMeasurableSingletonClass",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "Mathlib.Tactic.Ring.atom_pf'",
   "MeasurableSpace",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
   "DivisionRing.toDivisionSemiring",
   "first_estimate",
   "sub_nonpos_of_le",
   "HEq",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "IsCancelAdd.toIsRightCancelAdd",
   "tau_minimizes",
   "Mathlib.Tactic.Ring.sub_pf",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "MeasureTheory.Measure",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedRing.toOrderedSemiring",
   "List.nil",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "List.cons",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Real.instLTReal",
   "sum_dist_diff_le",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Meta.NormNum.isRat_lt_true",
   "List.Mem.tail",
   "Mathlib.Tactic.Ring.mul_add",
   "Field.toSemifield",
   "instTransLeToLE",
   "add_lt_of_le_of_neg",
   "Neg.neg",
   "FunLike.coe",
   "Matrix.vecEmpty",
   "LE.le",
   "sum_uvw_eq_zero",
   "Real.instDivisionRingReal",
   "Mathlib.Meta.NormNum.isNat_mul",
   "OrderedRing.toPartialOrder",
   "CommRing.toCommSemiring",
   "Mathlib.Meta.NormNum.isRat_inv_pos",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "Mathlib.Meta.NormNum.IsRat.of_raw",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "Semifield.toDivisionSemiring",
   "ElementaryAddCommGroup",
   "NegZeroClass.toNeg",
   "AddGroup.toHasOrderedSub",
   "Mathlib.Tactic.Ring.mul_congr",
   "List.pmap.proof_3",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.isROrC",
   "Mathlib.Tactic.Ring.div_pf",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsRat.to_isInt",
   "List.finRange",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "List.Mem.casesOn",
   "Eq.trans",
   "Nat.cast_one",
   "Finite.to_countable",
   "StrictOrderedRing.toPartialOrder",
   "Real.field",
   "neg_neg_of_pos",
   "Lattice.toSemilatticeInf",
   "cond_construct_good",
   "instNontrivial",
   "Fin.fintype",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.438",
   "ProbabilityTheory.IdentDistrib",
   "Real.orderedSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "HEq.refl",
   "of_eq_true",
   "Eq.mp",
   "Fin.instOfNatFin",
   "Real.instAddGroupReal",
   "Mathlib.Tactic.Ring.mul_one",
   "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "Linarith.eq_of_not_lt_of_not_gt",
   "CancelDenoms.mul_subst",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "CancelDenoms.div_subst",
   "MeasureTheory.MeasureSpace.volume",
   "LinearOrderedField.toDiv",
   "Linarith.mul_nonpos",
   "Mathlib.Meta.NormNum.isRat_sub",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "sum_condMutual_le",
   "Mathlib.Tactic.Ring.pow_congr",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "Membership.mem",
   "Fintype.complete",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "refPackage",
   "IsCancelAdd.toIsLeftCancelAdd",
   "SemilatticeInf.toPartialOrder",
   "List.Mem",
   "Mathlib.Meta.NormNum.IsNat.to_isRat",
   "Mathlib.Meta.NormNum.IsNatPowT.bit0",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "MeasurableAdd₂",
   "StrictOrderedSemiring.to_charZero",
   "StrictOrderedSemiring.toPartialOrder",
   "List",
   "MeasureTheory.MeasureSpace",
   "Mathlib.Meta.NormNum.IsNatPowT.run",
   "Bool",
   "Eq.casesOn",
   "Mathlib.Tactic.Ring.one_pow",
   "Equiv",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "Real.orderedRing",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Meta.NormNum.isRat_add",
   "Nat.cast_zero",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Mathlib.Tactic.Ring.neg_congr",
   "le_of_not_gt",
   "Bool.true",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.15",
   "HDiv.hDiv",
   "Mathlib.Tactic.Ring.pow_add",
   "HPow.hPow",
   "instHSub",
   "rdist_nonneg",
   "List.pmap",
   "eq_of_heq",
   "Real.instRingReal",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Meta.NormNum.IsRat.den_nz",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Meta.NormNum.isRat_div",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Field.toDiv",
   "AddCommGroup",
   "Finite.of_fintype",
   "Int",
   "Fin",
   "Inv.inv",
   "Real",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Semiring.toMonoidWithZero",
   "Real.orderedCancelAddCommMonoid",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "Function.dcomp",
   "AddMonoid.toAddZeroClass",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Fintype.elems",
   "Finset",
   "CancelDenoms.add_subst",
   "Mathlib.Tactic.Ring.inv_single",
   "Mathlib.Meta.NormNum.one_natPow",
   "Nat.succ",
   "Mathlib.Meta.NormNum.isRat_mul",
   "neg_nonpos_of_nonneg",
   "Not.intro",
   "List.finRange.proof_1",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Mathlib.Meta.NormNum.isNat_pow",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.44",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "sub_neg_of_lt",
   "Int.mul",
   "Bool.false",
   "Real.instPreorderReal",
   "List.Mem.head",
   "Prod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CancelDenoms.sub_subst",
   "Mathlib.Meta.NormNum.intPow_ofNat",
   "CancelDenoms.pow_subst",
   "Real.instLEReal",
   "Real.instMulReal",
   "Real.instSubReal",
   "Mathlib.Algebra.Order.Sub.Defs._auxLemma.1",
   "Real.commRing",
   "autoParam",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "OrderedRing.toRing",
   "MeasurableSingletonClass",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Fintype",
   "rdist",
   "ProbabilityTheory.condMutualInfo",
   "Nat",
   "Real.instLinearOrderedSemiringReal",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Measurable.add'",
   "Real.partialOrder",
   "Nat.rawCast",
   "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Mathlib.Tactic.Ring.div_congr",
   "DistribLattice.toLattice",
   "instTransEq_1",
   "instHMul",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "refPackage.X₀₂",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "DiscreteMeasurableSpace.toMeasurableSub₂",
   "Matrix.vecCons",
   "congrArg",
   "OrderedAddCommGroup.toAddCommGroup",
   "Real.instLinearOrderedFieldReal",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "refPackage.η",
   "Mathlib.Meta.NormNum.isNat_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "instFiniteRange",
   "Preorder.toLT",
   "instHPow",
   "Ring.toSub",
   "Linarith.mul_neg",
   "Rat.rawCast",
   "Real.strictOrderedRing",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "condRuzsaDist'",
   "DivisionRing.toDiv",
   "NeZero.succ",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.9",
   "funext",
   "Real.instMonoidReal",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Tactic.Ring.single_pow",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Equiv.instFunLikeEquiv",
   "Semiring.toOne",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "LinearOrderedField.toField",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "OrderedSemiring.toSemiring",
   "Equiv.mk",
   "HMul.hMul",
   "ProbabilityTheory.iIndepFun",
   "Mathlib.Meta.NormNum.isRat_pow",
   "List.noConfusion",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "tau_strictly_decreases_aux",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] [hG : MeasurableSpace G]\n  [inst_2 : MeasurableSingletonClass G] [elem : ElementaryAddCommGroup G 2] [inst_3 : MeasurableAdd₂ G] {Ω₀₁ : Type u_2}\n  {Ω₀₂ : Type u_3} [inst_4 : MeasureTheory.MeasureSpace Ω₀₁] [inst_5 : MeasureTheory.MeasureSpace Ω₀₂]\n  [inst_6 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_7 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] (p : refPackage Ω₀₁ Ω₀₂ G) {Ω : Type u_4}\n  [mΩ : MeasureTheory.MeasureSpace Ω] [inst_8 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  (X₁ X₂ X₁' X₂' : Ω → G),\n  Measurable X₁ →\n    Measurable X₂ →\n      Measurable X₁' →\n        Measurable X₂' →\n          ProbabilityTheory.IdentDistrib X₁ X₁' →\n            ProbabilityTheory.IdentDistrib X₂ X₂' →\n              ProbabilityTheory.iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'] →\n                tau_minimizes p X₁ X₂ → p.η = 1 / 9 → d[X₁ # X₂] = 0",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_3",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.mk",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLE",
   "Ring.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_6",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing",
   "Ring.toSub",
   "LinearOrderedAddCommGroup.mk",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_4",
   "AddCommGroup.mk",
   "LinearOrderedAddCommGroup",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_1",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_7",
   "AddGroup.mk",
   "LinearOrderedRing.decidableEq",
   "Ring.toSemiring",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_2",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.min_def",
   "SubNegMonoid.mk",
   "Ring.zsmul",
   "LinearOrderedRing.toLinearOrderedAddCommGroup.proof_5",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [inst : LinearOrderedRing α] → LinearOrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["instLENat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OrderHom",
   "inferInstanceAs",
   "OrderHom.instOrderHomClassOrderHomToLEToLE",
   "Nat",
   "Preorder",
   "Preorder.toLE",
   "OrderHomClass",
   "Nat.strictOrderedSemiring"],
  "name":
  "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
  "constType":
  "{α : Type u} → [inst : Preorder α] → OrderHomClass (OmegaCompletePartialOrder.Chain α) ℕ α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.zero_add",
   "AddZeroClass",
   "Eq"],
  "name": "zero_add",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Distrib",
   "Distrib.toMul",
   "Eq"],
  "name": "Distrib.right_distrib",
  "constType":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "MeasureTheory.Measure.toFiniteSpanningSetsIn",
   "setOf",
   "CanonicallyOrderedCommSemiring.toMul",
   "MeasurableSpace.isPiSystem_measurableSet",
   "Set",
   "MeasureTheory.Measure.prod",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Set.instMembershipSet",
   "Prod.instMeasurableSpace",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "instHMul",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.SigmaFinite",
   "SProd.sprod",
   "MeasurableSet",
   "MeasureTheory.Measure.prod_eq_generateFrom",
   "HMul.hMul",
   "Prod",
   "MeasurableSpace.generateFrom_measurableSet",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.prod_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.SigmaFinite μ] {ν : MeasureTheory.Measure β} [inst_3 : MeasureTheory.SigmaFinite ν]\n  {μν : MeasureTheory.Measure (α × β)},\n  (∀ (s : Set α) (t : Set β), MeasurableSet s → MeasurableSet t → ↑↑μν (s ×ˢ t) = ↑↑μ s * ↑↑ν t) →\n    MeasureTheory.Measure.prod μ ν = μν",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SMul",
   "Function.Injective.subNegMonoid",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Nat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg",
   "id",
   "instHSub",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "add_left_neg",
   "SubNegMonoid.zsmul_neg'",
   "Neg.neg",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "SubNegMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toNatSMul",
   "SubNegMonoid.zsmul_succ'",
   "Eq.ndrec",
   "Function.Injective",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "Add",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int",
   "SubNegMonoid.zsmul_zero'"],
  "name": "Function.Injective.addGroup.proof_1",
  "constType":
  "∀ {M₁ : Type u_1} {M₂ : Type u_2} [inst : Add M₁] [inst_1 : Zero M₁] [inst_2 : SMul ℕ M₁] [inst_3 : Neg M₁]\n  [inst_4 : Sub M₁] [inst_5 : SMul ℤ M₁] [inst_6 : AddGroup M₂] (f : M₁ → M₂) (hf : Function.Injective f)\n  (one : f 0 = 0) (mul : ∀ (x y : M₁), f (x + y) = f x + f y) (inv : ∀ (x : M₁), f (-x) = -f x)\n  (div : ∀ (x y : M₁), f (x - y) = f x - f y) (npow : ∀ (x : M₁) (n : ℕ), f (n • x) = n • f x)\n  (zpow : ∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) (x : M₁), -x + x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "NatCast.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Nat",
   "CauSeq.instNatCast",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instNatCastCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → NatCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "LE",
   "add_le_add_iff_right",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_trans.match_1",
  "constType":
  "∀ {n m : ℕ} (motive : (k : ℕ) → n ≤ m → m ≤ k → Prop) (k : ℕ) (x : n ≤ m) (x_1 : m ≤ k),\n  (∀ (h : n ≤ m), motive m h (_ : Nat.le m m)) →\n    (∀ (h₁ : n ≤ m) (m_1 : ℕ) (h₂ : Nat.le m m_1), motive (Nat.succ m_1) h₁ (_ : Nat.le m (Nat.succ m_1))) →\n      motive k x x_1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Set.ball_image_iff",
   "Set",
   "Function.comp",
   "Set.forall_range_iff",
   "Set.image",
   "Set.mem_range_self",
   "Set.Subset.antisymm",
   "Iff.mpr",
   "Eq",
   "Set.mem_image_of_mem",
   "Set.instMembershipSet"],
  "name": "Set.range_comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} (g : α → β) (f : ι → α), Set.range (g ∘ f) = g '' Set.range f",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instLENat",
   "Bot.mk",
   "instOfNatNat",
   "OrderBot",
   "OrderBot.mk",
   "Nat.zero_le",
   "Nat"],
  "name": "Nat.orderBot",
  "constType": "OrderBot ℕ",
  "constCategory": "Definition"},
 {"references": ["Top"],
  "name": "Top.mk",
  "constType": "{α : Type u} → α → Top α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Complex.cpow_one",
   "True",
   "Real.instOneReal",
   "Eq",
   "Complex.re",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.rpow_one",
  "constType": "∀ (x : ℝ), x ^ 1 = x",
  "constCategory": "Theorem"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.toRatCast",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.ratCast_mk",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} → [self : Field K] → DivisionRing K",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "List.cons",
   "Iff.mp",
   "List.instMembershipList",
   "List",
   "List.forall_mem_cons"],
  "name": "List.pmap.proof_4",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (l : List α), (∀ a_1 ∈ a :: l, p a_1) → ∀ x ∈ l, p x",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "Lattice.toSemilatticeSup",
   "Lattice.le_inf",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_10",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Classical.decRel",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "mul_le_mul_of_nonneg_right",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "HMul.hMul",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "OrderedSemiring.toMulPosMono",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.toOrderedSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] (x x_1 x_2 : α), x ≤ x_1 → 0 ≤ x_2 → x * x_2 ≤ x_1 * x_2",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] → [inst_1 : NonAssocSemiring β] → [self : RingHomClass F α β] → MonoidHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "Classical.choose_spec",
   "instHasEquiv",
   "CauSeq.lim",
   "CauSeq.IsComplete",
   "CauSeq.complete",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.equiv_lim",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] (s : CauSeq β abv),\n  s ≈ CauSeq.const abv (CauSeq.lim s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "DivisionSemiring",
   "One.toOfNat1",
   "DivisionSemiring.zpow",
   "Int",
   "Eq"],
  "name": "DivisionSemiring.zpow_zero'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a : α), DivisionSemiring.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Real.instMulReal",
   "Real",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Real.instOneReal",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "Real.semiring",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.RPowRing.atom_pf",
  "constType": "∀ (a : ℝ), a = a * 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "PFR.Main._auxLemma.4",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "ZeroHom",
  "constType":
  "(M : Type u_9) → (N : Type u_10) → [inst : Zero M] → [inst : Zero N] → Type (max u_10 u_9)",
  "constCategory": "Other"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "CompleteSemilatticeInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "CompleteSemilatticeInf.mk",
  "constType":
  "{α : Type u_9} →\n  [toPartialOrder : PartialOrder α] →\n    [toInfSet : InfSet α] →\n      (∀ (s : Set α), ∀ a ∈ s, sInf s ≤ a) →\n        (∀ (s : Set α) (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s) → CompleteSemilatticeInf α",
  "constCategory": "Other"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1004"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.neg",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "invOf_mul_self'",
   "One.toOfNat1",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "mul_assoc",
   "of_eq_true",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "mul_invOf_mul_self_cancel'",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) {x : Invertible b}, a * ⅟b * b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Int.NonNeg.mk",
   "Int.negSucc",
   "Decidable.isFalse",
   "Int.neg.match_1",
   "Decidable",
   "Decidable.isTrue",
   "Nat",
   "_private.Init.Data.Int.Basic.0.Int.decNonneg.proof_1",
   "Int",
   "Int.NonNeg"],
  "name": "_private.Init.Data.Int.Basic.0.Int.decNonneg",
  "constType": "(m : ℤ) → Decidable (Int.NonNeg m)",
  "constCategory": "Definition"},
 {"references": ["Complex.ofReal'", "Real", "Complex.sin", "Complex.re"],
  "name": "Real.sin",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references": ["Ne", "Or", "em", "Eq"],
  "name": "eq_or_ne",
  "constType": "∀ {α : Sort u_1} (x y : α), x = y ∨ x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "NormedRing",
   "instHMul",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedRing.norm_mul",
  "constType":
  "∀ {α : Type u_5} [self : NormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Pi.addZeroClass.proof_2",
   "Pi.instAdd",
   "Pi.addZeroClass.proof_1",
   "instHAdd",
   "HAdd.hAdd",
   "Zero.mk",
   "AddZeroClass.mk",
   "Pi.instZero",
   "AddZeroClass",
   "Add.mk"],
  "name": "Pi.addZeroClass",
  "constType":
  "{I : Type u} → {f : I → Type v} → [inst : (i : I) → AddZeroClass (f i)] → AddZeroClass ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Rat.commRing",
   "Rat",
   "IsDomain.toNontrivial",
   "Nontrivial",
   "Rat.isDomain"],
  "name": "Rat.nontrivial",
  "constType": "Nontrivial ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "instHAdd",
   "SemiconjBy.add_left",
   "HAdd.hAdd",
   "Distrib",
   "Commute",
   "Distrib.toMul"],
  "name": "Commute.add_left",
  "constType":
  "∀ {R : Type x} [inst : Distrib R] {a b c : R}, Commute a c → Commute b c → Commute (a + b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Trans",
   "Preorder.toLT",
   "lt_of_lt_of_le",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Trans.mk",
   "Preorder.toLE"],
  "name": "instTransLtToLTLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LT.lt LE.le LT.lt",
  "constCategory": "Definition"},
 {"references": ["Real", "Pow.mk", "Pow", "Real.rpow"],
  "name": "Real.instPowReal",
  "constType": "Pow ℝ ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Set.Nonempty",
   "AddCommGroup.toAddCommMonoid",
   "And.left",
   "instLTNat",
   "Iff.mpr",
   "Nonempty",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Eq",
   "mul_pos_iff",
   "Real.linearOrder",
   "And.right",
   "Eq.mpr",
   "Iff.mp",
   "Nat.cast",
   "Set.Elem",
   "or_false",
   "Set.Finite.image2",
   "Nat",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "Set.add",
   "Finite",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMagma.toAdd",
   "Real.orderedSemiring",
   "And",
   "instHMul",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "congr",
   "Not",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "AddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "Set",
   "Real",
   "LT.lt.trans_le",
   "Semiring.toMonoidWithZero",
   "Ring.toNonAssocRing",
   "Set.Nonempty.add",
   "Set.toFinite",
   "True",
   "Zero.toOfNat0",
   "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
   "Set.nonempty_coe_sort",
   "and_false",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Init.Order.Defs._auxLemma.1",
   "instOfNatNat",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "False",
   "Real.instLinearOrderedRingReal",
   "Real.instLTReal",
   "instHAdd",
   "Real.nontrivial",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Set.Finite",
   "Real.instZeroReal",
   "eq_false",
   "Set.finite_coe_iff",
   "Real.instPreorderReal",
   "letFun",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nat.card",
   "OrderedSemiring.toPartialOrder",
   "Mathlib.Data.Nat.Cast.Order._auxLemma.2"],
  "name": "PFR_conjecture_pos_aux'",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {A : Set G} [inst_1 : Finite ↑A] {K : ℝ},\n  Set.Nonempty A → ↑(Nat.card ↑(A + A)) ≤ K * ↑(Nat.card ↑A) → 0 < ↑(Nat.card ↑A) ∧ 0 < ↑(Nat.card ↑(A + A)) ∧ 0 < K",
  "constCategory": "Theorem"},
 {"references": ["Div"],
  "name": "Div.mk",
  "constType": "{α : Type u} → (α → α → α) → Div α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Cardinal.toNat_lift",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHom.zeroHomClass",
   "ZeroHom",
   "FunLike.coe",
   "Cardinal.mk_prod",
   "True",
   "Eq",
   "Cardinal.instMulCardinal",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "instHMul",
   "Cardinal.toNat_mul",
   "of_eq_true",
   "ZeroHomClass.toFunLike",
   "Cardinal",
   "congr",
   "LinearOrderedCommMonoidWithZero.toZero",
   "HMul.hMul",
   "Prod",
   "Nat",
   "Cardinal.mk",
   "instMulNat",
   "Nat.card",
   "congrArg",
   "Eq.trans",
   "Cardinal.lift",
   "congrFun"],
  "name": "Nat.card_prod",
  "constType":
  "∀ (α : Type u_3) (β : Type u_4), Nat.card (α × β) = Nat.card α * Nat.card β",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "Decidable.byCases.match_1",
  "constType":
  "{p : Prop} →\n  (motive : Decidable p → Sort u_1) →\n    (dec : Decidable p) → ((h : p) → motive (isTrue h)) → ((h : ¬p) → motive (isFalse h)) → motive dec",
  "constCategory": "Definition"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "OfNat.ofNat",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_7",
   "AddSemigroup.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Multiset.instZeroMultiset",
   "OrderedAddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_4",
   "nsmulRec",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_8",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_2",
   "Multiset.instAddMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_1",
   "AddMonoid.mk",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_5",
   "AddCommMonoid.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_6",
   "Multiset",
   "OrderedCancelAddCommMonoid.mk",
   "Zero.mk",
   "Add.mk",
   "Multiset.instOrderedCancelAddCommMonoidMultiset.proof_3"],
  "name": "Multiset.instOrderedCancelAddCommMonoidMultiset",
  "constType": "{α : Type u_1} → OrderedCancelAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Rat.instLERat",
   "sub_self",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Int.linearOrderedCommRing",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Rat.le_iff_Nonneg",
   "Rat.Nonneg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "Rat.addGroup",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "HSub.hSub",
   "Rat",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Rat.instSubRat",
   "Eq.ndrec",
   "propext",
   "letFun",
   "le_refl",
   "NegZeroClass.toZero",
   "Int"],
  "name": "Rat.le_refl",
  "constType": "∀ (a : ℚ), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "upperBounds",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddMonoidHom.map_zero",
   "OfNat.ofNat",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "congrArg",
   "Eq.trans",
   "AddMonoidHom",
   "AddMonoidHom.id",
   "congrFun"],
  "name": "Real.isROrC.proof_1",
  "constType": "(AddMonoidHom.id ℝ) 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCancelCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["One", "Real", "One.mk", "_private.Mathlib.Data.Real.Basic.0.Real.one"],
  "name": "Real.instOneReal",
  "constType": "One ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Field.Defs._hyg.169",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "congr_arg",
   "DivisionRing.toRing",
   "Classical.propDecidable",
   "CauSeq.LimZero",
   "Eq.refl",
   "CauSeq.instZeroCauSeq",
   "dite",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Eq",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "Eq.mpr",
   "LinearOrderedField",
   "Eq.ndrec",
   "CauSeq.inv",
   "OrderedCommSemiring.toOrderedSemiring",
   "dif_neg",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Not",
   "CauSeq.Completion.mk",
   "CauSeq.Completion.instInvCauchyToRing",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Inv.inv",
   "id"],
  "name": "CauSeq.Completion.inv_mk",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {f : CauSeq β abv} (hf : ¬CauSeq.LimZero f),\n  (CauSeq.Completion.mk f)⁻¹ = CauSeq.Completion.mk (CauSeq.inv f hf)",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Ne",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "invOf_mul_self",
   "MulZeroClass.mul_zero",
   "One.toOfNat1",
   "NeZero.one",
   "MulZeroOneClass.toZero",
   "Invertible",
   "MulZeroOneClass.toMulZeroClass",
   "True",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "zero_ne_one",
   "of_eq_true",
   "MulZeroClass.toZero",
   "instTransEq",
   "HMul.hMul",
   "Nontrivial",
   "congrArg",
   "Eq.trans"],
  "name": "nonzero_of_invertible",
  "constType":
  "∀ {α : Type u} [inst : MulZeroOneClass α] (a : α) [inst_1 : Nontrivial α] [inst_2 : Invertible a], a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "CompletelyDistribLattice.toCompleteLattice",
   "eq_false",
   "False",
   "Nat.cast",
   "Top.top",
   "CompleteLattice.toTop",
   "ENNReal.nat_ne_top",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "Nat",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Eq"],
  "name": "Mathlib.Data.Real.ENNReal._auxLemma.46",
  "constType": "∀ (n : ℕ), (↑n = ⊤) = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsSymmOp",
  "constType": "(α : Type u) → (β : Type v) → (α → α → β) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "AddCommGroupWithOne.toAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "AddCommGroupWithOne",
   "Nat",
   "AddCommGroupWithOne.toNatCast",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "Eq"],
  "name": "AddCommGroupWithOne.natCast_zero",
  "constType":
  "∀ {R : Type u} [self : AddCommGroupWithOne R], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "HEq",
   "Semiring",
   "eq_of_heq",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.mul",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn"],
  "name": "Mathlib.Meta.NormNum.isNat_mul.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℕ) →\n          x = HMul.hMul →\n            Mathlib.Meta.NormNum.IsNat x_1 x_3 → Mathlib.Meta.NormNum.IsNat x_2 x_4 → Nat.mul x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℕ) (x_6 : x = HMul.hMul) (x_7 : Mathlib.Meta.NormNum.IsNat x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsNat x_2 x_4) (x_9 : Nat.mul x_3 x_4 = x_5),\n  (∀ (n n_1 : ℕ),\n      motive HMul.hMul (↑n) (↑n_1) n n_1 (Nat.mul n n_1) (_ : HMul.hMul = HMul.hMul)\n        (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n_1) n_1)\n        (_ : Nat.mul n n_1 = Nat.mul n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "Submonoid",
  "constType": "(M : Type u_4) → [inst : MulOneClass M] → Type u_4",
  "constCategory": "Other"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or.inr",
   "Set",
   "Insert.insert",
   "Set.instInsertSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.mem_insert_of_mem",
  "constType":
  "∀ {α : Type u} {x : α} {s : Set α} (y : α), x ∈ s → x ∈ insert y s",
  "constCategory": "Theorem"},
 {"references":
  ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1157",
   "DivisionRing.toRing",
   "Subtype.val",
   "Real",
   "Eq.refl",
   "rfl",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Subtype.property",
   "Eq.mpr",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "Rat.instNegRat",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "Subtype",
   "id",
   "Neg.toHasAbs",
   "Rat",
   "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1157",
   "Subtype.ext",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "instHMul",
   "Eq.ndrec",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "letFun",
   "CauSeq.Completion.Cauchy",
   "_private.Mathlib.Data.Real.Basic.0.Real.mul",
   "HMul.hMul",
   "Rat.instLinearOrderedFieldRat",
   "Subtype.mk"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.mul_def",
  "constType":
  "∀ (x x_1 : ℝ),\n  Real.mul x x_1 =\n    match x, x_1 with\n    | { cauchy := a }, { cauchy := b } => { cauchy := a * b }",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "Ne",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "Iff",
   "not_congr",
   "Real",
   "Complex.ofReal_eq_zero",
   "Complex",
   "Eq"],
  "name": "Complex.ofReal_ne_zero",
  "constType": "∀ {z : ℝ}, ↑z ≠ 0 ↔ z ≠ 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsTotal",
  "constType": "(α : Type u) → (α → α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.lift.proof_1",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Function.Injective",
   "Preorder.toLT",
   "Preorder.le_refl",
   "Preorder.le_trans",
   "Preorder.lift",
   "Preorder",
   "Preorder.lt_iff_le_not_le",
   "Preorder.toLE",
   "Preorder.mk",
   "PartialOrder"],
  "name": "PartialOrder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : PartialOrder β] → (f : α → β) → Function.Injective f → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Preorder.le_refl", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_refl",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "eq_of_heq",
   "Ring.toIntCast",
   "Ring",
   "Eq.refl",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℕ) → Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1) → Prop)\n  (x : α) (x_1 : ℕ) (x_2 : Mathlib.Meta.NormNum.IsInt x (Int.ofNat x_1)),\n  (∀ (a : ℕ), motive (↑(Int.ofNat a)) a (_ : Mathlib.Meta.NormNum.IsInt (↑(Int.ofNat a)) (Int.ofNat a))) →\n    motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["Real", "Complex"],
  "name": "Complex.mk",
  "constType": "ℝ → ℝ → ℂ",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instHSMul",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.Measure.prod",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "ProbabilityTheory.IndepFun.comp",
   "inferInstance",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "one_smul",
   "MonoidWithZero.toMonoid",
   "Measurable.aemeasurable",
   "MeasureTheory.Measure.map_snd_prod",
   "MonoidWithZero.toMulActionWithZero",
   "HSMul.hSMul",
   "MeasureTheory.Measure.instMulAction",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "measurable_snd",
   "Prod.snd",
   "IsScalarTower.right",
   "Function.comp",
   "Prod.fst",
   "ProbabilityTheory.IdentDistrib",
   "MeasureTheory.Measure.prod.measureSpace",
   "instENNRealZero",
   "ProbabilityTheory.IdentDistrib.mk",
   "Prod.instMeasurableSpace",
   "And",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.map_fst_prod",
   "And.intro",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun",
   "congrFun",
   "Exists",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "measurable_fst",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.instSFinite",
   "MeasureTheory.Measure.instSMul",
   "ProbabilityTheory.indepFun_fst_snd",
   "Exists.intro",
   "rfl",
   "MeasureTheory.MeasureSpace.volume",
   "True",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "IsScalarTower.left",
   "MeasureTheory.Measure.map_map",
   "Measurable",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "eq_self",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Set.univ",
   "Measurable.comp",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Prod",
   "MeasureTheory.Measure.instIsProbabilityMeasureProdToMeasurableSpaceMeasureSpaceVolume"],
  "name": "ProbabilityTheory.independent_copies_two",
  "constType":
  "∀ {α : Type u_7} {β : Type u_9} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {Ω : Type u} {Ω' : Type v}\n  [inst_2 : MeasureTheory.MeasureSpace Ω] [inst_3 : MeasureTheory.MeasureSpace Ω']\n  [inst_4 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_5 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X : Ω → α} {Y : Ω' → β},\n  Measurable X →\n    Measurable Y →\n      ∃ Ω'' m'' X' Y',\n        MeasureTheory.IsProbabilityMeasure MeasureTheory.volume ∧\n          Measurable X' ∧\n            Measurable Y' ∧\n              ProbabilityTheory.IndepFun X' Y' ∧\n                ProbabilityTheory.IdentDistrib X' X ∧ ProbabilityTheory.IdentDistrib Y' Y",
  "constCategory": "Theorem"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references": ["Finset", "Finset.val", "Multiset.Nodup"],
  "name": "Finset.nodup",
  "constType": "∀ {α : Type u_4} (self : Finset α), Multiset.Nodup self.val",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "max_eq_right",
   "Preorder.toLE",
   "Iff.mpr",
   "Abs.abs",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "SemilatticeSup.toSup",
   "AddMonoid.toAddSemigroup",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "AddSemigroup.toAdd",
   "instHAdd",
   "instDistribLattice",
   "LE.le.trans",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "DistribLattice.toLattice",
   "neg_nonneg",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "abs_of_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, a ≤ 0 → |a| = -a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Prod.snd",
   "Subtype.val",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Prod.fst",
   "AddMonoid.toAddZeroClass",
   "Equiv.ofBijective",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Set.instMembershipSet",
   "instHMul",
   "Nat.card_congr",
   "AddGroup",
   "Set.Elem",
   "Nat.card_prod",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.IsComplement",
   "HMul.hMul",
   "Prod",
   "Nat",
   "instMulNat",
   "Nat.card",
   "Eq.symm",
   "Eq.trans"],
  "name": "AddSubgroup.IsComplement.card_mul_card",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G},\n  AddSubgroup.IsComplement S T → Nat.card ↑S * Nat.card ↑T = Nat.card G",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.34",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.mk",
   "BooleanAlgebra.toHasCompl",
   "Set.Set.completeAtomicBooleanAlgebra.proof_8",
   "BooleanAlgebra.toBot",
   "Set.Set.completeAtomicBooleanAlgebra.proof_12",
   "Preorder.toLE",
   "BooleanAlgebra",
   "CompletelyDistribLattice.mk",
   "CompleteAtomicBooleanAlgebra.mk",
   "BooleanAlgebra.toHImp",
   "CompleteAtomicBooleanAlgebra",
   "Set.Set.completeAtomicBooleanAlgebra.proof_10",
   "Set.Set.completeAtomicBooleanAlgebra.proof_3",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Set.Set.completeAtomicBooleanAlgebra.proof_7",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra.proof_5",
   "Set.Set.completeAtomicBooleanAlgebra.proof_11",
   "Set.Set.completeAtomicBooleanAlgebra.proof_2",
   "LE.le",
   "Set.Set.completeAtomicBooleanAlgebra.proof_6",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Set.instBooleanAlgebraSet",
   "Set.Set.completeAtomicBooleanAlgebra.proof_1",
   "Set.Set.completeAtomicBooleanAlgebra.proof_9",
   "Set.Set.completeAtomicBooleanAlgebra.proof_4",
   "Set.instInfSetSet",
   "BooleanAlgebra.toSDiff"],
  "name": "Set.Set.completeAtomicBooleanAlgebra",
  "constType": "{α : Type u_1} → CompleteAtomicBooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.preimage",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff.intro",
   "And",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "Eq.rec",
   "Set.mem_image",
   "And.intro",
   "Set.image",
   "Eq.symm",
   "And.casesOn",
   "id"],
  "name": "Set.image_congr",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {s : Set α}, (∀ a ∈ s, f a = g a) → f '' s = g '' s",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HSMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "Mathlib.Data.Set.NAry._auxLemma.12",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Int.instSubInt",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Int.instNegInt",
   "Neg.neg",
   "rfl",
   "Int",
   "Int.instAddInt",
   "Eq"],
  "name": "Int.sub_eq_add_neg",
  "constType": "∀ {a b : ℤ}, a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "rfl",
   "Eq"],
  "name": "Nat.add_one",
  "constType": "∀ (n : ℕ), n + 1 = Nat.succ n",
  "constCategory": "Theorem"},
 {"references":
  ["Set.image2",
   "Set.instHasSubsetSet",
   "Set",
   "HasSubset.Subset",
   "Set.image2_subset",
   "Set.Subset.rfl"],
  "name": "Set.image2_subset_left",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t t' : Set β},\n  t ⊆ t' → Set.image2 f s t ⊆ Set.image2 f s t'",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "Real.instStrictOrderedCommRingReal",
   "Real",
   "StrictOrderedRing"],
  "name": "Real.strictOrderedRing",
  "constType": "StrictOrderedRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Classical.decRel",
   "Quotient.liftOn₂",
   "Max.mk",
   "Eq.refl",
   "Cardinal.partialOrder.proof_2",
   "Cardinal.instLECardinal.proof_1",
   "LT.mk",
   "LE.le",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "ite",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "And",
   "Cardinal.partialOrder.proof_1",
   "Cardinal.partialOrder.proof_3",
   "Cardinal",
   "Max.max",
   "Not",
   "Function.Embedding",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.linearOrder.proof_3",
  "constType": "∀ (a b : Cardinal.{u_1}), max a b = max a b",
  "constCategory": "Theorem"},
 {"references":
  ["AddRightCancelMonoid",
   "AddLeftCancelMonoid.toZero",
   "AddRightCancelSemigroup.mk",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddCancelMonoid.add_right_cancel",
   "AddCancelMonoid",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddRightCancelMonoid.mk"],
  "name": "AddCancelMonoid.toAddRightCancelMonoid",
  "constType":
  "{M : Type u} → [self : AddCancelMonoid M] → AddRightCancelMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Semiring.mk",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "npowRec",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Real.instOneReal",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "Nat.cast",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "Real.cauchy_one",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "add_left_neg",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.field",
   "Nat.cast_add",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NatCast.natCast",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "AddMonoidWithOne.toOne",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Zero.mk",
   "mul_one",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Neg.mk",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "CauSeq.Completion.instNegCauchy",
   "Real",
   "Real.ext_cauchy",
   "CauSeq.Completion.instNatCastCauchy",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NatCast.mk",
   "NonUnitalNonAssocSemiring.mk",
   "Abs.abs",
   "True",
   "Real.instNegReal",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoidWithOne.toNatCast",
   "one_mul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Real.cauchy_mul",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "CauSeq.Completion.Cauchy.field",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Real.cauchy_add",
   "Real.cauchy_neg",
   "One.mk",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_22",
  "constType": "∀ (a : ℝ), -a + a = 0",
  "constCategory": "Theorem"},
 {"references": ["Complex.cpow", "Complex", "Pow.mk", "Pow"],
  "name": "Complex.instPowComplex",
  "constType": "Pow ℂ ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Set.fintypeSep",
   "Classical.propDecidable",
   "Finite",
   "Eq.refl",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "Nonempty.intro",
   "inferInstance",
   "Fintype",
   "Set.Elem",
   "Finite.of_fintype",
   "nonempty_fintype"],
  "name": "Finite.Set.finite_sep",
  "constType":
  "∀ {α : Type u} (s : Set α) (p : α → Prop) [inst : Finite ↑s], Finite ↑{a | a ∈ s ∧ p a}",
  "constCategory": "Definition"},
 {"references":
  ["starRingAut",
   "Distrib.toAdd",
   "RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "RingAut",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "StarRing",
   "RingHomClass.toRingHom",
   "NonUnitalNonAssocSemiring.toMul",
   "RingEquivClass.toRingHomClass",
   "RingEquiv.instRingEquivClassRingEquiv",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "starRingEnd",
  "constType":
  "(R : Type u) → [inst : CommSemiring R] → [inst_1 : StarRing R] → R →+* R",
  "constCategory": "Definition"},
 {"references": ["outParam", "AddGroup"],
  "name": "AddTorsor",
  "constType":
  "(G : outParam (Type u_1)) → Type u_2 → [inst : outParam (AddGroup G)] → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instHasSubsetSet",
   "setOf",
   "Filter.mk",
   "Set",
   "Set.subset_inter",
   "HasSubset.Subset",
   "Filter",
   "Set.Subset.trans",
   "Set.subset_univ",
   "Set.instMembershipSet"],
  "name": "Filter.principal",
  "constType": "{α : Type u} → Set α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "OfNat.ofNat",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instBotSubmonoid",
   "Submonoid.mem_bot",
   "MulOneClass.toOne",
   "Submonoid.one_mem",
   "One.toOfNat1",
   "SetLike.instMembership",
   "Eq",
   "Iff.mp",
   "Eq.rec",
   "Submonoid",
   "Bot.mk",
   "Eq.symm"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_16",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), ∀ x ∈ ⊥, x ∈ S",
  "constCategory": "Theorem"},
 {"references": ["One", "AddCommGroupWithOne"],
  "name": "AddCommGroupWithOne.toOne",
  "constType": "{R : Type u} → [self : AddCommGroupWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Multiset.cons",
   "Singleton",
   "Singleton.mk"],
  "name": "Multiset.instSingletonMultiset",
  "constType": "{α : Type u_1} → Singleton α (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Real",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "autoParam",
   "ENNReal.toReal_sum",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal.instTopologicalSpaceENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "BooleanAlgebra.toBiheytingAlgebra",
   "ENNReal",
   "Fintype",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.iUnion",
   "Pairwise",
   "Finset",
   "MeasurableSet",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "_auto._@.PFR.ForMathlib.MeasureReal._hyg.2266",
   "Finite.to_countable",
   "id",
   "Function.onFun",
   "Membership.mem",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "Finset.sum",
   "Disjoint",
   "Finset.instMembershipFinset",
   "tsum",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasureTheory.Measure.real",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Finset.univ",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.measure_iUnion",
   "CompleteLattice.toTop",
   "MeasureTheory.measureReal_def",
   "ENNReal.toReal",
   "Real.instAddCommMonoidReal",
   "Finite.of_fintype",
   "MeasurableSpace",
   "tsum_fintype",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "MeasureTheory.measureReal_iUnion_fintype",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : Fintype β]\n  {f : β → Set α},\n  Pairwise (Disjoint on f) →\n    (∀ (i : β), MeasurableSet (f i)) →\n      autoParam (∀ (i : β), ↑↑μ (f i) ≠ ⊤) _auto✝ → μ.real (⋃ b, f b) = Finset.sum Finset.univ fun p => μ.real (f p)",
  "constCategory": "Theorem"},
 {"references":
  ["Rat.instLTRat",
   "Eq.to_iff",
   "Rat.instLERat",
   "Iff",
   "Bool.not_eq_false",
   "Bool.false",
   "LT.lt",
   "Bool.true",
   "Rat",
   "Rat.blt",
   "Not",
   "Bool",
   "LE.le",
   "Eq"],
  "name": "Rat.not_le",
  "constType": "∀ {a b : ℚ}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "HImp.himp",
   "Iff",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "OrderTop",
   "Lattice",
   "GeneralizedHeytingAlgebra",
   "Lattice.toSemilatticeSup",
   "HImp",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedHeytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toLattice : Lattice α] →\n    [toOrderTop : OrderTop α] → [toHImp : HImp α] → (∀ (a b c : α), a ≤ b ⇨ c ↔ a ⊓ b ≤ c) → GeneralizedHeytingAlgebra α",
  "constCategory": "Other"},
 {"references": ["Int", "IntCast"],
  "name": "IntCast.intCast",
  "constType": "{R : Type u} → [self : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "Eq"],
  "name": "ExistsUnique",
  "constType": "{α : Sort u_1} → (α → Prop) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "DivisionRing.toRatCast",
   "Rat.mk'",
   "Semiring.toNatCast",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "Ring.toIntCast",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Field",
   "Rat.cast",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "DivisionRing.ratCast_mk",
   "Ne",
   "Field.toSemifield",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Int.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "Nat.Coprime",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "CauSeq.Completion.Cauchy.field.proof_9",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "Membership.mem",
   "instHSMul",
   "AddGroup",
   "HSMul.hSMul",
   "AddSubgroup",
   "zsmul_mem",
   "SubNegMonoid.SMulInt",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Int",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership"],
  "name": "AddSubgroup.zsmul_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) {x : G}, x ∈ K → ∀ (n : ℤ), n • x ∈ K",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "instHasEquiv",
   "Setoid",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "HasEquiv.Equiv"],
  "name": "Quotient.decidableEq.match_1",
  "constType":
  "{α : Sort u_1} →\n  {s : Setoid α} →\n    (a₁ a₂ : α) →\n      (motive : Decidable (a₁ ≈ a₂) → Sort u_2) →\n        (x : Decidable (a₁ ≈ a₂)) →\n          ((h₁ : a₁ ≈ a₂) → motive (isTrue h₁)) → ((h₂ : ¬a₁ ≈ a₂) → motive (isFalse h₂)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["And", "Iff", "And.comm"],
  "name": "and_comm",
  "constType": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "constCategory": "Theorem"},
 {"references": ["Add", "Int.add", "Int", "Add.mk"],
  "name": "Int.instAddInt",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "Eq"],
  "name": "SubNegMonoid.sub_eq_add_neg",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "Nat.pred",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "Nat.succ_pred_eq_of_pos.match_1",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Nat.succ",
   "instLTNat",
   "Eq"],
  "name": "Nat.succ_pred_eq_of_pos",
  "constType": "∀ {n : ℕ}, 0 < n → Nat.succ (Nat.pred n) = n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddCancelCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddLeftCancelMonoid : AddLeftCancelMonoid M] → (∀ (a b : M), a + b = b + a) → AddCancelCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["NonAssocRing.toIntCast",
   "Nat.cast",
   "NonAssocRing",
   "instNatCastInt",
   "NonAssocRing.toNatCast",
   "Nat",
   "Int",
   "IntCast.intCast",
   "Eq"],
  "name": "NonAssocRing.intCast_ofNat",
  "constType":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["Complex.ofReal_nat_cast",
   "OfNat.ofNat",
   "Real.natCast",
   "Real",
   "Eq.refl",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Complex.instSemiringComplex",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddMonoid.toZero",
   "Real.strictOrderedSemiring",
   "AddGroup.toAddCancelMonoid",
   "Complex.ofReal_eq_zero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.cast_eq_zero",
   "Complex.ofReal'",
   "AddGroupWithOne.toAddMonoidWithOne",
   "charZero_of_inj_zero",
   "Complex.instZeroComplex",
   "Ring.toAddGroupWithOne",
   "AddRightCancelMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "Real.instRingReal",
   "Real.instZeroReal",
   "Eq.ndrec",
   "StrictOrderedSemiring.to_charZero",
   "CharZero",
   "propext",
   "Eq.mp",
   "Complex"],
  "name": "Complex.charZero",
  "constType": "CharZero ℂ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "Monoid.toOne",
   "mul_invOf_mul_self_cancel'",
   "invOf_mul_self'",
   "One.toOfNat1",
   "Mathlib.Algebra.Invertible.Defs._auxLemma.2",
   "Invertible",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "invertibleMul.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], ⅟b * ⅟a * (a * b) = 1",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "StrictOrderedCommSemiring",
   "StrictOrderedCommRing.toStrictOrderedCommSemiring",
   "Real.instStrictOrderedCommRingReal",
   "Real"],
  "name": "Real.strictOrderedCommSemiring",
  "constType": "StrictOrderedCommSemiring ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "DivInvMonoid.toInv",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "DivInvMonoid.toDiv",
   "id",
   "Inv.inv"],
  "name": "zero_div",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (a : G₀), 0 / a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_private.Mathlib.Data.Real.Basic.0.Real.inv'", "Real", "Inv", "Inv.mk"],
  "name": "Real.instInvReal",
  "constType": "Inv ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "instHSub",
   "OfNat.ofNat",
   "neg_zero",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegZeroMonoid",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "SubNegZeroMonoid.toSubNegMonoid",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "sub_zero",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "congr",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Linarith.eq_of_eq_of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a = 0 → b = 0 → a + b = 0",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedAddCommGroup", "Min"],
  "name": "LinearOrderedAddCommGroup.toMin",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Min α",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "Lattice"],
  "name": "CompleteLattice.toLattice",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3954",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3915",
   "Eq"],
  "name": "AddRightCancelMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddRightCancelSemigroup : AddRightCancelSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddRightCancelMonoid M",
  "constCategory": "Other"},
 {"references": ["Bot", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toBot",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Bot α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "MonoidHomClass",
   "outParam",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "MonoidWithZeroHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "MulZeroOneClass.toZero",
   "Eq",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] →\n          [toMonoidHomClass : MonoidHomClass F M N] → (∀ (f : F), f 0 = 0) → MonoidWithZeroHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "True",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "instHSub",
   "Neg.toHasAbs",
   "eq_self",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_1",
  "constType": "∀ (a : ℝ), |a - a| = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.iUnion",
   "EmptyCollection.emptyCollection",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instEmptyCollectionSet",
   "Nat",
   "MeasurableSpace",
   "CompleteAtomicBooleanAlgebra.toHasCompl"],
  "name": "MeasurableSpace.mk",
  "constType":
  "{α : Type u_7} →\n  (MeasurableSet' : Set α → Prop) →\n    MeasurableSet' ∅ →\n      (∀ (s : Set α), MeasurableSet' s → MeasurableSet' sᶜ) →\n        (∀ (f : ℕ → Set α), (∀ (i : ℕ), MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)) → MeasurableSpace α",
  "constCategory": "Other"},
 {"references": ["Eq.ndrec", "DecidableEq", "Not", "dite", "Eq.symm", "Eq"],
  "name": "Function.update",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → [inst : DecidableEq α] → ((a : α) → β a) → (a' : α) → β a' → (a : α) → β a",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Neg.neg",
   "Sub",
   "Real.instNegReal",
   "Sub.mk"],
  "name": "Real.instSubReal",
  "constType": "Sub ℝ",
  "constCategory": "Definition"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "Set.instBooleanAlgebraSet",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Set",
   "PartialOrder.lift",
   "Preorder.le_refl",
   "SemilatticeInf.toPartialOrder",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe_injective",
   "SetLike.coe",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "SetLike.instPartialOrder.proof_1",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] (a : A), a ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.instDivInvOneMonoidENNReal.proof_1",
   "ENNReal",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivInvMonoid.zpow_succ'",
   "ENNReal.instDivInvMonoidENNReal",
   "DivInvMonoid.zpow_zero'",
   "DivInvMonoid",
   "inferInstanceAs",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.zpow_neg'",
   "DivInvMonoid.zpow",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv"],
  "name": "ENNReal.instDivInvOneMonoidENNReal",
  "constType": "DivInvOneMonoid ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "HAdd.hAdd",
   "Unit",
   "Int.neg_neg.match_1",
   "Int.subNatNat_self",
   "Neg.neg",
   "rfl",
   "True",
   "Eq",
   "Int.instAddInt",
   "of_eq_true",
   "Int.instNegInt",
   "Nat",
   "congrArg",
   "Int",
   "Nat.succ",
   "Eq.trans",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.add_left_neg",
  "constType": "∀ (a : ℤ), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.mul_one",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "constCategory": "Definition"},
 {"references":
  ["SMul.mk",
   "SMul",
   "Monoid",
   "Function.Injective.mulAction.proof_2",
   "MulAction.toSMul",
   "instHSMul",
   "MulAction.mk",
   "Function.Injective",
   "Function.Injective.mulAction.proof_1",
   "HSMul.hSMul",
   "MulAction",
   "Eq"],
  "name": "Function.Injective.mulAction",
  "constType":
  "{M : Type u_1} →\n  {α : Type u_6} →\n    {β : Type u_7} →\n      [inst : Monoid M] →\n        [inst_1 : MulAction M α] →\n          [inst_2 : SMul M β] →\n            (f : β → α) → Function.Injective f → (∀ (c : M) (x : β), f (c • x) = c • f x) → MulAction M β",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "instHasEquiv",
   "DivisionRing.toRing",
   "SubNegMonoid.toNeg",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq.LimZero",
   "Eq.refl",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Or.imp_right",
   "Abs.abs",
   "Eq",
   "Setoid.symm",
   "SubNegMonoid.toSub",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "SemilatticeSup.toSup",
   "Ring.toNeg",
   "CauSeq.ring",
   "Lattice.toSemilatticeSup",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "instHSub",
   "Or",
   "CauSeq.instNegCauSeq",
   "instDistribLattice",
   "CauSeq.instSubCauSeq",
   "HSub.hSub",
   "Neg.neg",
   "CauSeq",
   "CauSeq.Pos",
   "DistribLattice.toLattice",
   "CauSeq.equiv",
   "Eq.ndrec",
   "CauSeq.trichotomy",
   "LinearOrderedField.toField",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "SubtractionMonoid.toSubNegMonoid",
   "LT.lt",
   "Eq.mp",
   "Ring.toAddCommGroup",
   "HasEquiv.Equiv",
   "Field.toDivisionRing",
   "neg_sub",
   "Or.imp"],
  "name": "CauSeq.lt_total",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (f g : CauSeq α abs), f < g ∨ f ≈ g ∨ g < f",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroupWithOne.toIntCast",
   "OfNat.ofNat",
   "instAddNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommGroupWithOne.toAddCommGroup",
   "AddCommGroupWithOne",
   "Neg.neg",
   "AddCommGroupWithOne.toNatCast",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Nat.cast",
   "Int.negSucc",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "IntCast.intCast"],
  "name": "AddCommGroupWithOne.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : AddCommGroupWithOne R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HasEquiv",
  "constType": "Sort u → Sort (max u (v + 1))",
  "constCategory": "Other"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "Ring",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "Eq"],
  "name": "Ring.zsmul_neg'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommRing α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u_1} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.ball_image_of_ball",
   "Set",
   "lowerBounds",
   "Monotone",
   "Set.image",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "Monotone.mem_lowerBounds_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  Monotone f → ∀ {a : α} {s : Set α}, a ∈ lowerBounds s → f a ∈ lowerBounds (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "Semiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Semiring.mul_one",
  "constType": "∀ {α : Type u} [self : Semiring α] (a : α), a * 1 = a",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.mk",
  "constType": "{α : Type u} → α → One α",
  "constCategory": "Other"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemifield", "Int"],
  "name": "LinearOrderedSemifield.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "HAdd.hAdd",
   "AddCommGroup.toAddCommMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddGroup",
   "AddCommMonoid.add_comm",
   "HSMul.hSMul",
   "AddCommGroup.toAddGroup",
   "Nat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg",
   "AddCommGroup.mk",
   "AddCommMonoid",
   "instHSub",
   "instHAdd",
   "AddGroup.mk",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "Function.Injective.addGroup",
   "AddMonoid.toNatSMul",
   "AddGroup.add_left_neg",
   "Function.Injective",
   "SubNegMonoid.toAddMonoid",
   "Function.Injective.addCommMonoid",
   "AddCommGroup",
   "Add",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Function.Injective.addCommGroup",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : AddCommGroup M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → AddCommGroup M₁",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HEq",
   "Semiring",
   "eq_of_heq",
   "Eq.refl",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Invertible",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "Invertible.casesOn",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "Nat.cast",
   "HEq.refl",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Invertible.mk",
   "Eq.casesOn",
   "Nat",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul.match_1",
  "constType":
  "{α : Type u_1} →\n  [inst : Semiring α] →\n    (k : ℕ) →\n      (b : α) →\n        (motive : (x : α) → Invertible x → x = ↑k * b → Sort u_2) →\n          (x : α) →\n            (x_1 : Invertible x) →\n              (x_2 : x = ↑k * b) →\n                ((c : α) →\n                    (hc1 : c * (↑k * b) = 1) →\n                      (hc2 : ↑k * b * c = 1) →\n                        motive (↑k * b) { invOf := c, invOf_mul_self := hc1, mul_invOf_self := hc2 }\n                          (_ : ↑k * b = ↑k * b)) →\n                  motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocRing α] → Mul α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "instHSMul",
   "AddGroup",
   "AddSubgroup.nsmul",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_6",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℕ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references":
  ["Bot",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "AddSubmonoid.instBotAddSubmonoid.proof_2",
   "OfNat.ofNat",
   "Set.instSingletonSet",
   "AddSubsemigroup.mk",
   "Set",
   "Bot.mk",
   "Singleton.singleton",
   "AddSubmonoid.mk",
   "AddSubmonoid.instBotAddSubmonoid.proof_1",
   "AddSubmonoid",
   "AddZeroClass"],
  "name": "AddSubmonoid.instBotAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → Bot (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedAddCommMonoid",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["if_pos.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "rfl",
   "absurd",
   "ite",
   "Eq"],
  "name": "if_neg",
  "constType":
  "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Semiring",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "Nat.cast_mul",
   "Eq",
   "Semiring.toNatCast",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.invertibleOfMul'.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] {a k b : ℕ}, a = k * b → ↑a = ↑k * ↑b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["Equiv", "RelIso"],
  "name": "RelIso.toEquiv",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ≃r s → α ≃ β",
  "constCategory": "Definition"},
 {"references": ["SeminormedAddCommGroup", "AddCommGroup"],
  "name": "SeminormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} → [self : SeminormedAddCommGroup E] → AddCommGroup E",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "And",
   "OfNat.ofNat",
   "Field",
   "Field.toSemifield",
   "And.intro",
   "Semifield.toCommGroupWithZero",
   "And.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq"],
  "name": "Field.toEuclideanDomain.match_1",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (b c : K) (motive : c = 0 ∧ b ≠ 0 → Prop) (x : c = 0 ∧ b ≠ 0),\n  (∀ (left : c = 0) (hnb : b ≠ 0), motive (_ : c = 0 ∧ b ≠ 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Set.preimage",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "autoParam",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
   "MeasurableSpace",
   "ProbabilityTheory.IsUniform"],
  "name": "ProbabilityTheory.IsUniform.measure_preimage_compl",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] {H : Set S} {X : Ω → S}\n  {μ : autoParam (MeasureTheory.Measure Ω) _auto✝}, ProbabilityTheory.IsUniform H X → ↑↑μ (X ⁻¹' Hᶜ) = 0",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "Real",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Inv.mk",
   "Complex.instStarRingComplexToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Inv",
   "RingHomClass.toNonUnitalRingHomClass",
   "Complex.instSemiringComplex",
   "starRingEnd",
   "Semiring.toNonAssocSemiring",
   "Complex.normSq",
   "Real.instInvReal",
   "MonoidWithZeroHom",
   "Complex.ofReal'",
   "Complex.instCommSemiringComplex",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "instHMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Real.semiring",
   "HMul.hMul",
   "Complex",
   "Complex.instMulComplex",
   "Inv.inv"],
  "name": "Complex.instInvComplex",
  "constType": "Inv ℂ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "Ring.toSemiring",
   "Eq",
   "SeminormedCommRing.toSeminormedRing",
   "Ring.toNeg",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "AddLeftCancelSemigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["trivial",
   "Iff.intro",
   "And",
   "And.right",
   "propext",
   "And.intro",
   "True",
   "Eq"],
  "name": "true_and",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references": ["PProd"],
  "name": "PProd.mk",
  "constType": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "propext",
   "Finset",
   "Finset.mem_filter",
   "Finset.filter",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.140",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, (a ∈ Finset.filter p s) = (a ∈ s ∧ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "Nat.succ",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_8",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.ofNat (Nat.succ n)) a = zpowRec (Int.ofNat (Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_4",
  "constType": "∀ (a : ℕ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references": ["setOf", "AddGroup", "Set", "AddSubgroup.IsComplement"],
  "name": "AddSubgroup.leftTransversals",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → Set G → Set (Set G)",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "StrictOrderedRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.add_le_add_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Definition"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Or", "Or.inl", "False", "Or.inr", "False.casesOn", "Or.casesOn"],
  "name": "false_or.match_1",
  "constType":
  "∀ (p : Prop) (motive : False ∨ p → Prop) (x : False ∨ p), (∀ (h : p), motive (_ : False ∨ p)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Countable",
   "Function.Injective",
   "Countable.exists_injective_nat'",
   "Nat"],
  "name": "Countable.exists_injective_nat",
  "constType": "∀ (α : Sort u) [inst : Countable α], ∃ f, Function.Injective f",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedAddCommGroup", "DecidableEq"],
  "name": "LinearOrderedAddCommGroup.decidableEq",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "add_assoc",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Nat.rec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "congr",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "congrArg",
   "Nat.succ",
   "Eq.trans",
   "congrFun"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "InvolutiveNeg.mk"],
  "name": "SubtractionMonoid.toInvolutiveNeg",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → InvolutiveNeg G",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_left",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ a",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toMin",
  "constType": "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Mathlib.Order.Lattice._auxLemma.11",
   "PartialOrder.toPreorder",
   "Mathlib.Order.Basic._auxLemma.1",
   "SemilatticeInf.toInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Eq",
   "And",
   "Iff",
   "of_eq_true",
   "Mathlib.Order.Lattice._auxLemma.13",
   "congr",
   "Iff.trans",
   "congrArg",
   "Eq.trans",
   "SemilatticeInf",
   "le_antisymm_iff",
   "congrFun"],
  "name": "inf_of_le_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references":
  ["NatCast",
   "Or",
   "OfNat.ofNat",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.298",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4056",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "autoParam",
   "NatCast.natCast",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Data.Nat.Cast.Defs._hyg.259",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4095",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.mk",
  "constType":
  "{α : Type u_2} →\n  [toCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) →\n            (∀ (a : α), a * 0 = 0) →\n              (∀ (a b c : α), a * b * c = a * (b * c)) →\n                [toOne : One α] →\n                  (∀ (a : α), 1 * a = a) →\n                    (∀ (a : α), a * 1 = a) →\n                      [toNatCast : NatCast α] →\n                        autoParam (NatCast.natCast 0 = 0) _auto✝ →\n                          autoParam (∀ (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1) _auto✝¹ →\n                            (npow : ℕ → α → α) →\n                              autoParam (∀ (x : α), npow 0 x = 1) _auto✝² →\n                                autoParam (∀ (n : ℕ) (x : α), npow (n + 1) x = x * npow n x) _auto✝³ →\n                                  (∀ (a b : α), a * b = b * a) →\n                                    (∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0) → CanonicallyOrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Prop.booleanAlgebra",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "BooleanAlgebra",
   "Eq"],
  "name": "Set.instBooleanAlgebraSet.proof_16",
  "constType": "∀ {α : Type u_1} (x y : α → Prop), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "completeLatticeOfInf",
   "Subgroup.instInfSetSubgroup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "Subgroup.instCompleteLatticeSubgroup.proof_1",
   "CompleteLattice.toInfSet",
   "Subgroup",
   "Group",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose", "Function.Surjective", "Eq"],
  "name": "Function.surjInv",
  "constType":
  "{α : Sort u} → {β : Sort v} → {f : α → β} → Function.Surjective f → β → α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Eq",
   "Zero.toOfNat0",
   "AddGroup",
   "propext",
   "Left.nonneg_neg_iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Group.Defs._auxLemma.4",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, (0 ≤ -a) = (a ≤ 0)",
  "constCategory": "Theorem"},
 {"references": ["ENNReal", "Set", "MeasureTheory.OuterMeasure"],
  "name": "MeasureTheory.OuterMeasure.measureOf",
  "constType":
  "{α : Type u_1} → MeasureTheory.OuterMeasure α → Set α → ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_3",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_1",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_2",
   "LinearOrderedCommSemiring",
   "LinearOrderedRing.decidableLE",
   "LinearOrderedRing.toOrd",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommRing",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_4"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u} → [d : LinearOrderedCommRing α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "ite",
   "min_def",
   "if_pos",
   "Eq.mpr",
   "Decidable",
   "LinearOrder.toMin",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id"],
  "name": "le_min",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, c ≤ a → c ≤ b → c ≤ min a b",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Elem",
   "Set",
   "Finite",
   "Inter.inter",
   "Set.inter_subset_left",
   "Finite.Set.subset",
   "Set.instInterSet"],
  "name": "Finite.Set.finite_inter_of_left",
  "constType":
  "∀ {α : Type u} (s t : Set α) [inst : Finite ↑s], Finite ↑(s ∩ t)",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Function.Injective",
   "DecidableEq",
   "Finset.image",
   "Finset.toSet",
   "Set",
   "Finset",
   "Finset.card_image_of_injOn",
   "Nat",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Finset.card_image_of_injective",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} [inst : DecidableEq β] (s : Finset α),\n  Function.Injective f → Finset.card (Finset.image f s) = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "MulZeroClass.mul_zero",
   "DenselyNormedField.toNormedField",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "NormedField.toField",
   "Field.toCommRing",
   "AddMonoid.toAddSemigroup",
   "MulZeroClass.toZero",
   "Eq.trans",
   "Real.denselyNormedField",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instZeroAddMonoidHom",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddHomClass.toFunLike",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "FunLike.coe",
   "Ring.toSemiring",
   "Real.normedCommRing",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "of_eq_true",
   "CommRing.toRing",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "add_zero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "congrFun"],
  "name": "Real.isROrC.proof_3",
  "constType": "∀ (z : ℝ), z + 0 z * 0 = z",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "IntCast.intCast",
   "Eq"],
  "name": "AddGroupWithOne.intCast_ofNat",
  "constType":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "PartialOrder.le_antisymm",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_5",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b : AddSubmonoid M), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references": ["Decidable"],
  "name": "Decidable.isTrue",
  "constType": "{p : Prop} → p → Decidable p",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Function.Injective",
   "Subtype.val",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Subtype.coe_injective",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership"],
  "name": "AddSubgroup.toAddCommGroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G), Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.const.proof_1",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "IsCauSeq",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Nat",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Subtype.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.const",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → (abv : β → α) → [inst_2 : IsAbsoluteValue abv] → β → CauSeq β abv",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.PairwiseDisjoint",
   "Set.pairwise_empty",
   "PartialOrder.toPreorder",
   "Set",
   "Disjoint",
   "Set.instEmptyCollectionSet",
   "OrderBot",
   "Preorder.toLE",
   "Function.onFun",
   "PartialOrder"],
  "name": "Set.pairwiseDisjoint_empty",
  "constType":
  "∀ {α : Type u_1} {ι : Type u_4} [inst : PartialOrder α] [inst_1 : OrderBot α] {f : ι → α}, Set.PairwiseDisjoint ∅ f",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Eq.ndrec",
   "HEq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsNat",
   "eq_of_heq",
   "Eq.refl",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_true.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α]\n  (motive : (x x_1 : α) → (x_2 : ℕ) → Mathlib.Meta.NormNum.IsNat x x_2 → Mathlib.Meta.NormNum.IsNat x_1 x_2 → Prop)\n  (x x_1 : α) (x_2 : ℕ) (x_3 : Mathlib.Meta.NormNum.IsNat x x_2) (x_4 : Mathlib.Meta.NormNum.IsNat x_1 x_2),\n  (∀ (n : ℕ), motive (↑n) (↑n) n (_ : Mathlib.Meta.NormNum.IsNat (↑n) n) (_ : Mathlib.Meta.NormNum.IsNat (↑n) n)) →\n    motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["PreOpposite"],
  "name": "AddOpposite",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddGroup",
   "Finite",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.instMembership",
   "Subtype.finite"],
  "name":
  "AddSubgroup.instFiniteSubtypeMemAddSubgroupInstMembershipInstSetLikeAddSubgroup",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) [inst_1 : Finite G], Finite ↥K",
  "constCategory": "Definition"},
 {"references":
  ["Bot.bot",
   "PartialOrder.toPreorder",
   "OrderBot.toBot",
   "Multiset",
   "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
   "inferInstanceAs",
   "OrderBot.bot_le",
   "OrderBot",
   "LE.le",
   "Preorder.toLE",
   "Multiset.instPartialOrderMultiset"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_1",
  "constType": "∀ {α : Type u_1} (a : Multiset α), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toOne",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedRing.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references": ["Exists", "Exists.intro", "Exists.casesOn"],
  "name": "forall_exists_index.match_1",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (motive : (∃ x, p x) → Prop) (x : ∃ x, p x),\n  (∀ (x : α) (hpx : p x), motive (_ : ∃ x, p x)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Set.preimage",
   "Function.comp",
   "Set",
   "MeasurableSet",
   "Measurable",
   "MeasurableSpace"],
  "name": "Measurable.comp",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}\n  {x_2 : MeasurableSpace γ} {g : β → γ} {f : α → β}, Measurable g → Measurable f → Measurable (g ∘ f)",
  "constCategory": "Theorem"},
 {"references": ["Set"],
  "name": "Set.Finite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_left",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "Exists.intro",
   "iSup",
   "BooleanAlgebra.toBot",
   "True",
   "Preorder.toLE",
   "Set.Set.completeAtomicBooleanAlgebra.match_1",
   "iff_self",
   "Lattice.toInf",
   "CompleteLattice.toLattice",
   "CompletelyDistribLattice.mk",
   "Set.ext",
   "Set.iUnion",
   "Iff",
   "forall_congr",
   "Set.instSupSetSet",
   "Lattice.toSemilatticeSup",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "CompleteLattice.toSupSet",
   "Membership.mem",
   "Order.Frame.inf_sSup_le_iSup_inf",
   "BooleanAlgebra.le_top",
   "funext",
   "Mathlib.Data.Set.Lattice._auxLemma.5",
   "SupSet.sSup",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "LE.le",
   "CompletelyDistribLattice.toCompleteDistribLattice",
   "Set.instMembershipSet",
   "CompleteDistribLattice.toFrame",
   "Order.Frame.toCompleteLattice",
   "DistribLattice.toLattice",
   "And",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "iInf",
   "CompleteLattice.toInfSet",
   "congr",
   "Set.iInter",
   "Set.instInfSetSet",
   "And.intro",
   "congrArg",
   "BooleanAlgebra.bot_le"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_11",
  "constType":
  "∀ {α : Type u_1} (a : Set α) (s : Set (Set α)), a ⊓ sSup s ≤ ⨆ b ∈ s, a ⊓ b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Equiv.comp_injective",
   "Equiv.plift",
   "Function.comp",
   "Finite",
   "PLift",
   "Eq.refl",
   "Fintype.ofInjective",
   "FunLike.coe",
   "instFinitePLift",
   "Nonempty",
   "Nonempty.casesOn",
   "Eq",
   "Equiv.instFunLikeEquiv",
   "Nonempty.intro",
   "Fintype",
   "Eq.ndrec",
   "Function.Injective",
   "propext",
   "Equiv.injective_comp",
   "Eq.mp",
   "Eq.symm",
   "Finite.of_equiv",
   "Finite.of_fintype",
   "Equiv.symm",
   "nonempty_fintype"],
  "name": "Finite.of_injective",
  "constType":
  "∀ {α : Sort u_4} {β : Sort u_5} [inst : Finite β] (f : α → β), Function.Injective f → Finite α",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DivInvMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "_private.Mathlib.Data.Real.Basic.0.Real.neg",
   "DivisionRing.toRing",
   "CauSeq.Completion.instNegCauchy",
   "Real",
   "Rat",
   "Eq.refl",
   "_private.Mathlib.Data.Real.Basic.0.Real.neg_def",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Neg.neg",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Real.instNegReal",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.equivCauchy.match_1",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "letFun",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "id"],
  "name": "Real.cauchy_neg",
  "constType": "∀ (a : ℝ), (-a).cauchy = -a.cauchy",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "BooleanAlgebra.le_top",
  "constType": "∀ {α : Type u} [self : BooleanAlgebra α] (a : α), a ≤ ⊤",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCancelAddCommMonoid.toOrd",
   "LinearOrderedCancelAddCommMonoid.toOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.decidableLE",
   "LinearOrderedCancelAddCommMonoid.decidableEq",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.toMin",
   "LinearOrderedAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.min_def",
   "LinearOrderedCancelAddCommMonoid.le_total",
   "LinearOrderedCancelAddCommMonoid.toMax",
   "LinearOrderedAddCommMonoid.mk",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq",
   "LinearOrderedCancelAddCommMonoid.max_def",
   "LinearOrderedCancelAddCommMonoid.decidableLT"],
  "name": "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCancelAddCommMonoid α] → LinearOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "zero_add",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.toAddAction.proof_1",
  "constType": "∀ (M : Type u_1) [inst : AddMonoid M] (a : M), 0 + a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.toCompleteSemilatticeSup",
   "SupSet.sSup",
   "GaloisInsertion.isLUB_of_u_image",
   "GaloisInsertion",
   "CompleteSemilatticeSup.toSupSet",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "CompleteLattice",
   "isLUB_sSup",
   "lowerBounds",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_2",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α],\n  GaloisInsertion l u → ∀ (s : Set β), l (sSup (u '' s)) ∈ lowerBounds (upperBounds s)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "Semiring.mul_one",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_3",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : CauSeq.Completion.Cauchy abv), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["instLENat", "Nat", "LE.le", "Nat.succ", "Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ Nat.succ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SemilatticeSup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "mul_left_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_mul_self",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹ * a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalNonAssocRing.left_distrib",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
  "constType":
  "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.toLattice",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "inf_le_of_right_le",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "inf_le_of_left_le",
   "Lattice.mk",
   "Lattice.le_inf",
   "Lattice.inf_le_left",
   "Lattice.inf_le_right",
   "instDistribLattice.match_1",
   "LE.le",
   "Preorder.toLE",
   "le_total",
   "Lattice.toInf",
   "SemilatticeSup.toSup",
   "le_inf",
   "le_refl",
   "sup_le_sup_left",
   "inferInstanceAs",
   "Sup.sup",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "instDistribLattice.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] (x b c : α), (x ⊔ b) ⊓ (x ⊔ c) ≤ x ⊔ b ⊓ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SMul",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "Nat.le",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Bot",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MeasureTheory.Measure.map",
   "ProbabilityTheory.FiniteSupport.casesOn",
   "NonUnitalCommSemiring.toCommSemigroup",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal",
   "Real.instOneReal",
   "Finset.sum_filter_of_ne",
   "Real.linearOrder",
   "Real.log_zero",
   "And.right",
   "Finset.toSet",
   "HasDistribNeg.toInvolutiveNeg",
   "le_of_lt",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "ENNReal.toReal_ne_zero",
   "And",
   "neg_le",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "congr",
   "And.intro",
   "MeasurableSpace",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NeZero.ne",
   "HEq",
   "Set",
   "GE.ge",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Measurable",
   "MeasureTheory.Measure.measure_univ_pos",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Real.instLTReal",
   "Top.top",
   "Real.toNNReal",
   "Neg.neg",
   "ProbabilityTheory.prob_ge_exp_neg_entropy.match_1",
   "LE.le",
   "ENNReal.toReal_mul",
   "ENNReal.instCompleteLinearOrderENNReal",
   "NormedCommRing.toSeminormedCommRing",
   "Eq.ndrec",
   "letFun",
   "NegZeroClass.toNeg",
   "Finset.eq_empty_or_nonempty",
   "Real.negMulLog",
   "Finset.instEmptyCollectionFinset",
   "MulOneClass.toMul",
   "neg_zero",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "MeasureTheory.Measure.map_apply",
   "MeasureTheory.measure_add_measure_compl",
   "CanonicallyOrderedCommSemiring.toOne",
   "Semiring.toNonAssocSemiring",
   "FiniteRange",
   "Iff.mp",
   "instLinearOrder",
   "zero_le",
   "LinearOrderedAddCommMonoidWithTop.toOrderTop",
   "Eq.trans",
   "ProbabilityTheory.finiteSupport_of_finiteRange",
   "CompletelyDistribLattice.toCompleteLattice",
   "ENNReal.instInvolutiveInvENNReal",
   "Lattice.toSemilatticeInf",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot",
   "Finset.instMembershipFinset",
   "Real.orderedSemiring",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Real.exp_log",
   "of_eq_true",
   "HEq.refl",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.mp",
   "Real.instAddGroupReal",
   "Singleton.singleton",
   "ENNReal.toReal",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "ENNReal.mul_inv_cancel",
   "CanonicallyOrderedCommSemiring.toMul",
   "OmegaCompletePartialOrder.toPartialOrder",
   "instENNRealAddCommMonoidWithOne",
   "le_top",
   "MulZeroClass.zero_mul",
   "ProbabilityTheory.entropy_eq_sum_finset",
   "Classical.arbitrary",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Finset.exists_min_image",
   "Set.instSingletonSet",
   "instDecidableNot",
   "Finset.mul_sum",
   "Finset.sum_le_sum",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "id",
   "Membership.mem",
   "eq_self",
   "AddMonoidWithOne.toAddMonoid",
   "SemilatticeInf.toPartialOrder",
   "NonUnitalNonAssocSemiring.toMul",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "eq_zero_or_neZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Eq.casesOn",
   "OrderedSemiring.toPartialOrder",
   "Distrib.toAdd",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "EmptyCollection.emptyCollection",
   "mul_neg",
   "instDecidableEq",
   "ENNReal.ofReal",
   "ENNReal.sum_lt_top",
   "Real.exp_monotone",
   "MulZeroClass.toMul",
   "Iff.mpr",
   "mul_assoc",
   "MeasureTheory.OuterMeasure.measureOf",
   "LE.le.lt_of_ne",
   "le_of_not_gt",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "InvOneClass.toInv",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Or",
   "eq_of_heq",
   "ENNReal.toReal_nonneg",
   "HasCompl.compl",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "instENNRealZero",
   "CommMagma.toMul",
   "Real.normedCommRing",
   "CanonicallyOrderedCommSemiring.toNoZeroDivisors",
   "LT.lt",
   "OrderedSemiring.toPosMulMono",
   "Inv.inv",
   "Exists",
   "ENNReal.one_toReal",
   "Real",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "LT.lt.ne_top",
   "ENNReal.toReal_sum",
   "True",
   "Real.instAddCommGroupReal",
   "exists_or_forall_not",
   "NeZero",
   "InvolutiveNeg.toNeg",
   "Eq.rec",
   "Finset",
   "Finset.filter",
   "InvolutiveInv.toInv",
   "neg_mul",
   "Function.mt",
   "NonUnitalNonAssocRing.toMul",
   "ne_zero_of_lt",
   "Finset.sum",
   "mul_ne_zero",
   "Finset.sum_measure_singleton",
   "One.toOfNat1",
   "ENNReal.instInvENNReal",
   "Ne.symm",
   "inv_inv",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.univ",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "neg_mul_comm",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "InvOneClass.toOne",
   "ProbabilityTheory.FiniteSupport",
   "MeasureTheory.Measure.instZero",
   "CompleteLattice.toTop",
   "Real.instPreorderReal",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Real.instAddCommMonoidReal",
   "ENNReal.ofNNReal",
   "Real.orderedAddCommGroup",
   "ENNReal.instDivInvOneMonoidENNReal",
   "MulZeroOneClass.toMulOneClass",
   "Real.instLEReal",
   "Real.instMulReal",
   "ENNReal.inv_ne_top",
   "MulZeroClass.mul_zero",
   "inv_one",
   "Exists.casesOn",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "AddZeroClass.toZero",
   "MeasurableSingletonClass",
   "ENNReal",
   "Eq.mpr",
   "OrderedAddCommMonoid.toPartialOrder",
   "AddCommMonoid",
   "Ne",
   "Real.partialOrder",
   "Finset.sum_mul",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Finset.measurableSet",
   "DistribLattice.toLattice",
   "MeasurableSet.univ",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "mul_le_mul_of_nonneg_left",
   "Real.orderedAddCommMonoid",
   "Not",
   "add_zero",
   "congrArg",
   "Finset.Nonempty",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "CommSemiring.toNonUnitalCommSemiring",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "mul_comm",
   "ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal",
   "one_mul",
   "Preorder.toLT",
   "MulZeroClass.toZero",
   "LE",
   "ENNReal.mul_ne_top",
   "Eq.symm",
   "ENNReal.not_lt_zero",
   "funext",
   "Set.preimage",
   "instHAdd",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Real.exp",
   "Real.instZeroReal",
   "Real.log",
   "CommSemigroup.toCommMagma",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "Mathlib.Algebra.Group.Basic._auxLemma.14",
   "HMul.hMul",
   "Finset.mem_filter",
   "ENNReal.ofReal_le_iff_le_toReal",
   "NegZeroClass.toZero",
   "ENNReal.inv_ne_zero"],
  "name": "ProbabilityTheory.prob_ge_exp_neg_entropy",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Nonempty S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] (X : Ω → S) (μ : MeasureTheory.Measure Ω)\n  [inst_2 : MeasureTheory.IsProbabilityMeasure μ],\n  Measurable X →\n    ∀ [hX' : FiniteRange X],\n      ∃ s, ↑↑(MeasureTheory.Measure.map X μ) {s} ≥ ↑↑μ Set.univ * ↑(Real.toNNReal (Real.exp (-H[X ; μ])))",
  "constCategory": "Theorem"},
 {"references": ["NNReal.toReal", "ENNReal", "Real", "ENNReal.toNNReal"],
  "name": "ENNReal.toReal",
  "constType": "ENNReal → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "InfSet.mk",
   "setOf",
   "Set",
   "InfSet",
   "Set.instMembershipSet"],
  "name": "Set.instInfSetSet",
  "constType": "{α : Type u_1} → InfSet (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.mk",
   "CauSeq",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.mk",
  "constType": "CauSeq ℚ abs → ℝ",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "SetLike.instMembership",
   "AddMemClass"],
  "name": "AddMemClass.add_mem",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : Add M] [inst_1 : SetLike S M] [self : AddMemClass S M] {s : S} {a b : M},\n  a ∈ s → b ∈ s → a + b ∈ s",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "SubNegZeroMonoid"],
  "name": "SubNegZeroMonoid.toSubNegMonoid",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Or.resolve_right",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "le_total"],
  "name": "lt_of_not_ge",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["AddOpposite.addGroup.proof_2",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "AddOpposite.addGroup.proof_4",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "AddGroup.mk",
   "AddOpposite.subNegMonoid",
   "AddOpposite.addGroup.proof_5",
   "AddOpposite",
   "AddOpposite.addGroup.proof_3",
   "SubNegMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "AddOpposite.addGroup.proof_1"],
  "name": "AddOpposite.addGroup",
  "constType": "(α : Type u) → [inst : AddGroup α] → AddGroup αᵃᵒᵖ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelMonoid.toZero",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0",
  "constCategory": "Definition"},
 {"references":
  ["Pi.instSub",
   "Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "prod",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "measurable_fst",
   "Real.instSubReal",
   "Real",
   "Eq.refl",
   "ProbabilityTheory.entropy",
   "MeasureTheory.Measure.prod",
   "MeasureTheory.IsFiniteMeasure",
   "MeasurableSub₂",
   "LinearOrderedField.toDiv",
   "Eq",
   "MeasureTheory.Measure",
   "outParam",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff.mp",
   "rdist",
   "Measurable.aemeasurable",
   "Eq.rec",
   "MeasureTheory.Measure.map_map",
   "Measurable",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "measurable_snd",
   "rdist_def",
   "id",
   "ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map",
   "instHSub",
   "instHDiv",
   "Prod.snd",
   "Function.comp",
   "HSub.hSub",
   "Prod.fst",
   "ProbabilityTheory.measureEntropy",
   "AddGroup.toSubNegMonoid",
   "Prod.instMeasurableSpace",
   "ProbabilityTheory.entropy_def",
   "Measurable.prod_mk",
   "Measurable.sub",
   "Eq.ndrec",
   "Prod.mk",
   "letFun",
   "instNatAtLeastTwo",
   "HSub",
   "Prod",
   "AddCommGroup",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.IndepFun.rdist_eq",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [hG : MeasurableSpace G]\n  [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] {X : Ω → G} [inst_2 : MeasureTheory.IsFiniteMeasure μ]\n  {Y : Ω → G},\n  ProbabilityTheory.IndepFun X Y →\n    Measurable X → Measurable Y → d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ] / 2 - H[Y ; μ] / 2",
  "constCategory": "Theorem"},
 {"references":
  ["OmegaCompletePartialOrder.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
   "iSup",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "CompleteLattice",
   "instLENat",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "OmegaCompletePartialOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "(α : Type u) → [inst : CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Iff.mp",
   "Iff",
   "And.symm.match_1",
   "And.intro",
   "Iff.mpr"],
  "name": "and_congr_right",
  "constType": "∀ {a b c : Prop}, (a → (b ↔ c)) → (a ∧ b ↔ a ∧ c)",
  "constCategory": "Theorem"},
 {"references": ["SMul.mk", "SMul", "instHSMul", "HSMul.hSMul"],
  "name": "Pi.instSMul",
  "constType":
  "{I : Type u} → {α : Type u_1} → {f : I → Type v₁} → [inst : (i : I) → SMul α (f i)] → SMul α ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references": ["CompleteLattice", "CompletelyDistribLattice"],
  "name": "CompletelyDistribLattice.toCompleteLattice",
  "constType":
  "{α : Type u} → [self : CompletelyDistribLattice α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["RatCast.mk", "Rat", "RatCast"],
  "name": "instRatCastRat",
  "constType": "RatCast ℚ",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLT",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Complex.ofReal'", "Real", "Complex.cos", "Complex.re"],
  "name": "Real.cos",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "PartialOrder"],
  "name": "SemilatticeSup.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Sub"],
  "name": "Sub.sub",
  "constType": "{α : Type u} → [self : Sub α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "NormedSpace.mk",
   "NormedField",
   "NormedField.toNormedSpace.proof_1",
   "Field.toSemifield",
   "Semifield.toDivisionSemiring",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "NormedField.toNormedCommRing",
   "NormedSpace",
   "Semiring.toModule",
   "NonUnitalSeminormedRing.toSeminormedAddCommGroup"],
  "name": "NormedField.toNormedSpace",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedSpace α α",
  "constCategory": "Definition"},
 {"references":
  ["Function.IsFixedPt.decidable",
   "DecidableEq",
   "Nat.iterate",
   "Decidable",
   "Function.IsPeriodicPt",
   "Nat"],
  "name": "Function.IsPeriodicPt.instDecidableIsPeriodicPt",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → {f : α → α} → {n : ℕ} → {x : α} → Decidable (Function.IsPeriodicPt f n x)",
  "constCategory": "Definition"},
 {"references": ["Nonempty.elim.match_1", "Nonempty"],
  "name": "Nonempty.elim",
  "constType": "∀ {α : Sort u} {p : Prop}, Nonempty α → (α → p) → p",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "SProd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["outParam", "HasQuotient"],
  "name": "HasQuotient.mk",
  "constType":
  "{A : outParam (Type u)} → {B : Type v} → (B → Type (max u v)) → HasQuotient A B",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSet.nullMeasurableSet",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "MeasureTheory.measure_add_measure_compl₀",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasurableSet",
   "OrderedSemiring.toSemiring",
   "MeasurableSpace"],
  "name": "MeasureTheory.measure_add_measure_compl",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α},\n  MeasurableSet s → ↑↑μ s + ↑↑μ sᶜ = ↑↑μ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["ZeroMemClass",
   "Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "OfNat.ofNat",
   "SetLike",
   "SetLike.instMembership"],
  "name": "ZeroMemClass.mk",
  "constType":
  "∀ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M], (∀ (s : S), 0 ∈ s) → ZeroMemClass S M",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Eq.refl",
   "Commute.zero_left",
   "NonAssocSemiring.toMulZeroOneClass",
   "Commute",
   "Nat.cast_zero",
   "Commute.one_left",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "Commute.add_left",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.rec",
   "Nat.zero",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast"],
  "name": "Nat.cast_commute",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (n : ℕ) (x : α), Commute (↑n) x",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Membership.mem",
   "And",
   "Prod.snd",
   "Iff",
   "Iff.rfl",
   "SProd.sprod",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.instMembershipSet"],
  "name": "Set.mem_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {p : α × β}, p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "Set.Elem",
   "Subtype.val",
   "Set",
   "Set.image",
   "Set.instMembershipSet",
   "Set.mem_image_of_mem"],
  "name": "Equiv.Set.imageOfInjOn.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → β) (s : Set α) (p : ↑s), f ↑p ∈ f '' s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Eq.refl",
   "dite",
   "LinearMap.instFunLike",
   "dite_congr",
   "RingHom.id",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "MeasureTheory.Measure.map_def",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.Measure.instModule",
   "LinearMap",
   "Eq.trans",
   "AEMeasurable",
   "Semiring.toModule",
   "MeasureTheory.Measure.definition.proof_1._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.18520",
   "eq_self",
   "False",
   "Classical.propDecidable",
   "Eq.mpr_prop",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure.mapₗ",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "MeasureTheory.Measure.instZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Not",
   "congrArg",
   "MeasurableSpace",
   "AEMeasurable.mk",
   "congrFun"],
  "name": "MeasureTheory.Measure.map_of_not_aemeasurable",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {f : α → β}\n  {μ : MeasureTheory.Measure α}, ¬AEMeasurable f → MeasureTheory.Measure.map f μ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.insert_eq",
   "Set",
   "Union.union",
   "Eq.refl",
   "Inter.inter",
   "Set.Iic",
   "Preorder",
   "Insert.insert",
   "Eq",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Eq.ndrec",
   "lowerBounds_singleton",
   "lowerBounds",
   "lowerBounds_union",
   "Singleton.singleton",
   "Set.instUnionSet",
   "Set.instInsertSet",
   "Set.instInterSet",
   "id"],
  "name": "lowerBounds_insert",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] (a : α) (s : Set α), lowerBounds (insert a s) = Set.Iic a ∩ lowerBounds s",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.empty", "EmptyCollection.mk", "Finset", "EmptyCollection"],
  "name": "Finset.instEmptyCollectionFinset",
  "constType": "{α : Type u_1} → EmptyCollection (Finset α)",
  "constCategory": "Definition"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure.sum.proof_1",
   "MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.toMeasure",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.sum",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.sum",
  "constType":
  "{α : Type u_1} → {ι : Type u_5} → {m0 : MeasurableSpace α} → (ι → MeasureTheory.Measure α) → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "StrictOrderedCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedCommRing.toStrictOrderedCommSemiring.proof_3",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedCommRing α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Sup.sup",
   "le_rfl",
   "sup_le_sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "sup_le_sup_left",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → ∀ (c : α), c ⊔ a ≤ c ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Set.instBooleanAlgebraSet.proof_5",
   "Prop.booleanAlgebra",
   "EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "Set",
   "Inter.inter",
   "Set.instBooleanAlgebraSet.proof_17",
   "Lattice.mk",
   "LT.mk",
   "HasCompl.mk",
   "Sup.mk",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "inferInstance",
   "Inf.mk",
   "BooleanAlgebra.toHImp",
   "SDiff.mk",
   "Set.instBooleanAlgebraSet.proof_9",
   "Set.instBooleanAlgebraSet.proof_1",
   "Set.instBooleanAlgebraSet.proof_8",
   "Set.instBooleanAlgebraSet.proof_13",
   "Set.instBooleanAlgebraSet.proof_6",
   "Membership.mem",
   "Set.instBooleanAlgebraSet.proof_16",
   "setOf",
   "Union.union",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.instBooleanAlgebraSet.proof_4",
   "Set.univ",
   "Set.instLESet",
   "LE.le",
   "Set.instMembershipSet",
   "Preorder.mk",
   "Set.instBooleanAlgebraSet.proof_7",
   "And",
   "Set.instHasSubsetSet",
   "Set.instBooleanAlgebraSet.proof_3",
   "Set.instBooleanAlgebraSet.proof_14",
   "Set.instBooleanAlgebraSet.proof_10",
   "Pi.booleanAlgebra",
   "Bot.mk",
   "Set.instBooleanAlgebraSet.proof_11",
   "Set.instBooleanAlgebraSet.proof_2",
   "Not",
   "Set.instBooleanAlgebraSet.proof_12",
   "Top.mk",
   "Set.instUnionSet",
   "Set.instBooleanAlgebraSet.proof_15",
   "Set.instInterSet"],
  "name": "Set.instBooleanAlgebraSet",
  "constType": "{α : Type u} → BooleanAlgebra (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "CauSeq.equiv.proof_1",
   "CauSeq.instSubCauSeq",
   "Setoid.mk",
   "CauSeq.LimZero",
   "HSub.hSub",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Setoid",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.equiv",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Setoid (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["Real.field",
   "inferInstance",
   "DivisionRing",
   "Real",
   "Field.toDivisionRing"],
  "name": "Real.instDivisionRingReal",
  "constType": "DivisionRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Or",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedRing.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedRing α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.dirac",
   "MeasureTheory.OuterMeasure.toMeasure",
   "MeasureTheory.Measure.dirac.proof_1",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.dirac",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → α → MeasureTheory.Measure α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "Real",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Exists.casesOn",
   "LE.le",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "And",
   "Real.linearOrder",
   "Finset",
   "And.intro",
   "And.casesOn"],
  "name": "ProbabilityTheory.prob_ge_exp_neg_entropy.match_1",
  "constType":
  "∀ {S : Type u_1} (S_nonzero : Finset S) (neg_log_pdf : S → ℝ)\n  (motive : (∃ x ∈ S_nonzero, ∀ x' ∈ S_nonzero, neg_log_pdf x ≤ neg_log_pdf x') → Prop)\n  (x : ∃ x ∈ S_nonzero, ∀ x' ∈ S_nonzero, neg_log_pdf x ≤ neg_log_pdf x'),\n  (∀ (s_max : S) (hs : s_max ∈ S_nonzero) (h_min : ∀ x' ∈ S_nonzero, neg_log_pdf s_max ≤ neg_log_pdf x'),\n      motive (_ : ∃ x ∈ S_nonzero, ∀ x' ∈ S_nonzero, neg_log_pdf x ≤ neg_log_pdf x')) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toPartialOrder : PartialOrder α] → (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) → OrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "congr",
   "congrArg",
   "add_zero",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ c₁ b₂ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.zero_mem",
   "Zero.mk",
   "AddSubmonoid",
   "AddZeroClass",
   "Subtype.mk",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubmonoid.zero",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → Zero ↥S",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_and_left", "Eq"],
  "name": "Std.Logic._auxLemma.39",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) = (b ∧ ∃ x, p x)",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references": ["Monoid", "Semigroup"],
  "name": "Monoid.toSemigroup",
  "constType": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "BoundedOrder",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul_neg'",
   "SubNegMonoid.sub_eq_add_neg",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubNegMonoid.mk",
   "SubNegMonoid.zsmul_zero'",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "eq_true",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "zero_lt_one",
   "One.toOfNat1",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "Mathlib.Algebra.Order.Invertible._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.inv_inv",
   "DivisionMonoid.toDivInvMonoid",
   "InvolutiveInv",
   "DivInvMonoid.toInv",
   "InvolutiveInv.mk"],
  "name": "DivisionMonoid.toInvolutiveInv",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → InvolutiveInv G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.card_eq_zero_of_infinite",
   "Set.Elem",
   "Set",
   "instOfNatNat",
   "Nat",
   "Nat.card",
   "Set.Infinite",
   "Set.Infinite.to_subtype",
   "Eq"],
  "name": "Set.Infinite.card_eq_zero",
  "constType": "∀ {α : Type u_1} {s : Set α}, Set.Infinite s → Nat.card ↑s = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_ne_zero",
  "constType": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "SMul.mk",
   "instHSMul",
   "Set",
   "MeasureTheory.OuterMeasure.instSMul.proof_2",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.OuterMeasure.instSMul.proof_1",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.OuterMeasure.mk",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Algebra.id",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.instSMul.proof_3"],
  "name": "MeasureTheory.OuterMeasure.instSMul",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_3} →\n    [inst : SMul R ENNReal] → [inst : IsScalarTower R ENNReal ENNReal] → SMul R (MeasureTheory.OuterMeasure α)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "SMul",
   "Monoid",
   "Monoid.toOne",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "One.toOfNat1",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mk",
  "constType":
  "{α : Type u_10} →\n  {β : Type u_11} →\n    [inst : Monoid α] →\n      [toSMul : SMul α β] → (∀ (b : β), 1 • b = b) → (∀ (x y : α) (b : β), (x * y) • b = x • y • b) → MulAction α β",
  "constCategory": "Other"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "Set.image",
   "Finite.of_fintype",
   "Finite.Set.finite_image",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.image",
  "constType":
  "∀ {α : Type u} {β : Type v} {s : Set α} (f : α → β), Set.Finite s → Set.Finite (f '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "if_pos.match_1",
  "constType":
  "∀ {c : Prop} (motive : Decidable c → Prop) (h : Decidable c),\n  (∀ (h : c), motive (isTrue h)) → (∀ (hnc : ¬c), motive (isFalse hnc)) → motive h",
  "constCategory": "Definition"},
 {"references": ["Field", "NormedField"],
  "name": "NormedField.toField",
  "constType": "{α : Type u_5} → [self : NormedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "LT.lt",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "PosMulStrictMono",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "mul_lt_mul_of_pos_left",
   "congrArg",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_pos",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],\n  0 < a → 0 < b → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "refPackage",
   "Real.instLEReal",
   "Real",
   "MeasureTheory.MeasureSpace",
   "tau",
   "MeasureTheory.IsProbabilityMeasure",
   "AddCommGroup",
   "MeasureTheory.MeasureSpace.volume",
   "LE.le",
   "MeasurableSpace",
   "id"],
  "name": "tau_minimizes",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} →\n          [inst_2 : AddCommGroup G] →\n            [inst_3 : MeasurableSpace G] →\n              refPackage Ω₀₁ Ω₀₂ G → {Ω : Type u_7} → [inst : MeasureTheory.MeasureSpace Ω] → (Ω → G) → (Ω → G) → Prop",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "MulZeroOneClass.toMulOneClass",
   "MonoidWithZeroHomClass",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass.toMonoidHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] → [self : MonoidWithZeroHomClass F M N] → MonoidHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff.symm",
   "Membership.mem",
   "Set.instHasSubsetSet",
   "Iff",
   "imp_iff_right",
   "Set",
   "HasSubset.Subset",
   "Iff.trans",
   "Set.univ",
   "Set.univ_subset_iff",
   "forall_congr'",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Set.eq_univ_iff_forall",
  "constType": "∀ {α : Type u} {s : Set α}, s = Set.univ ↔ ∀ (x : α), x ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CharP",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toZero",
   "Nat.monoid",
   "CharP.cast_eq_zero_iff",
   "Nat.instDvdNat",
   "AddMonoidWithOne.toAddMonoid",
   "dvd_refl",
   "Dvd.dvd",
   "Nat",
   "Iff.mpr",
   "Eq"],
  "name": "CharP.cast_eq_zero",
  "constType":
  "∀ (R : Type u_1) [inst : AddMonoidWithOne R] (p : ℕ) [inst_1 : CharP R p], ↑p = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "Mathlib.Data.Subtype._auxLemma.2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q { val := a, property := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq.match_1",
   "MulOneClass.toMul",
   "DivisionRing.toDivisionSemiring",
   "Monoid.toOne",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "div_eq_mul_inv",
   "Invertible",
   "True",
   "Ring.toNonAssocRing",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "HDiv.hDiv",
   "Nat",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "DivisionRing.toDiv",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "DivisionRing",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "DivisionSemiring.toGroupWithZero",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "invOf_eq_inv",
   "Int.cast_ofNat",
   "DivInvMonoid.toInv",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {n d : ℕ} {a n' d' : α},\n  Mathlib.Meta.NormNum.IsRat a (Int.ofNat n) d → ↑n = n' → ↑d = d' → a = n' / d'",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} → [inst : AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "Finset.image",
   "Finset",
   "HVAdd.hVAdd",
   "VAdd",
   "instHVAdd",
   "VAdd.mk"],
  "name": "Finset.vaddFinset",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : DecidableEq β] → [inst : VAdd α β] → VAdd α (Finset β)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MeasurableSpace",
  "constType": "Type u_7 → Type u_7",
  "constCategory": "Other"},
 {"references":
  ["Set.neg",
   "InvolutiveNeg",
   "InvolutiveNeg.toNeg",
   "Set",
   "Neg.neg",
   "Set.image",
   "Set.image_neg",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Data.Set.Pointwise.Basic._auxAddLemma.12",
  "constType":
  "∀ {α : Type u_2} [inst : InvolutiveNeg α] {s : Set α}, -s = Neg.neg '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "PartialOrder.toPreorder",
   "LinearOrder.toPartialOrder",
   "Preorder.le_trans",
   "Nat",
   "LE.le",
   "Preorder.toLE"],
  "name": "Nat.linearOrderedCommSemiring.proof_2",
  "constType": "∀ (a b c : ℕ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Iff",
   "Nat.cast_injective",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Nat",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "Nat.cast_inj",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Setoid",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": [],
  "name": "SupSet",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references": ["outParam", "HasQuotient"],
  "name": "HasQuotient.quotient'",
  "constType":
  "{A : outParam (Type u)} → {B : Type v} → [self : HasQuotient A B] → B → Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "LE", "Add", "SubadditiveHomClass"],
  "name": "SubadditiveHomClass.toFunLike",
  "constType":
  "{F : Type u_7} →\n  {α : outParam (Type u_8)} →\n    {β : outParam (Type u_9)} →\n      [inst : Add α] → [inst_1 : Add β] → [inst_2 : LE β] → [self : SubadditiveHomClass F α β] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instEmptyCollectionFinset",
   "eq_false",
   "False",
   "Finset.not_mem_empty",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.instMembershipFinset",
   "Eq"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.20",
  "constType": "∀ {α : Type u_1} (a : α), (a ∈ ∅) = False",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Real",
   "AddCommSemigroup",
   "Real.instAddCommMonoidReal",
   "AddCommMonoid.toAddCommSemigroup"],
  "name": "Real.instAddCommSemigroupReal",
  "constType": "AddCommSemigroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["NNReal.toReal",
   "Real.orderedAddCommGroup",
   "OfNat.ofNat",
   "sub_self",
   "Real.instSubReal",
   "Real.instLEReal",
   "Real",
   "ENNReal.ofReal",
   "AddGroup.toSubtractionMonoid",
   "Real.instSupReal",
   "Abs.abs",
   "True",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "forall_congr",
   "ENNReal.coe_nnreal_eq",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "instNonempty",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "eq_self",
   "instHSub",
   "Neg.toHasAbs",
   "abs_zero",
   "HSub.hSub",
   "Std.Logic._auxLemma.32",
   "abs_sub_le",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.instInhabitedReal",
   "of_eq_true",
   "_private.Mathlib.Topology.MetricSpace.PseudoMetric.0.dist_nonneg'",
   "Real.instAddGroupReal",
   "NegZeroClass.toZero",
   "congrArg",
   "abs_sub_comm",
   "Subtype.mk",
   "ENNReal.ofNNReal",
   "congrFun"],
  "name": "Real.pseudoMetricSpace.proof_3",
  "constType":
  "∀ (x y : ℝ),\n  ↑{ val := |x - y|, property := (_ : 0 ≤ |x - y|) } = ENNReal.ofReal ↑{ val := |x - y|, property := (_ : 0 ≤ |x - y|) }",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "Or",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LinearOrderedAddCommGroup.le_total",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Sup.sup",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "DistribLattice.mk",
  "constType":
  "{α : Type u_1} → [toLattice : Lattice α] → (∀ (x y z : α), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z) → DistribLattice α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "not_congr",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Nat.cast_ne_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subsemigroup.carrier",
   "Bot.bot",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Submonoid.one_mem'",
   "Submonoid.instBotSubmonoid",
   "MulOneClass.toOne",
   "Set",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Subgroup.instBotSubgroup.proof_1",
  "constType": "∀ {G : Type u_1} [inst : Group G], 1 ∈ ⊥.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.iterate.match_1",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.iterate",
  "constType": "{α : Sort u} → (α → α) → ℕ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "NatCast.natCast",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.natCast_succ",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma.add_comm",
   "AddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Inv"],
  "name": "GroupWithZero.toInv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Inv G₀",
  "constCategory": "Definition"},
 {"references":
  ["Set.image2_image_left",
   "Exists",
   "Mathlib.Data.Set.NAry._auxLemma.11",
   "Set",
   "Eq.refl",
   "Set.image2_congr",
   "True",
   "iff_self",
   "Eq",
   "Set.ext",
   "Eq.mpr",
   "Iff",
   "SProd.sprod",
   "Set.image",
   "Eq.symm",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "Eq.trans",
   "Mathlib.Data.Set.NAry._auxLemma.12",
   "id",
   "Set.instSProd",
   "Membership.mem",
   "Set.image2",
   "funext",
   "Prod.snd",
   "Prod.fst",
   "Set.instMembershipSet",
   "Set.image2_image_right",
   "And",
   "Set.image_prod",
   "Eq.ndrec",
   "of_eq_true",
   "Prod.mk",
   "congr",
   "Prod",
   "congrArg"],
  "name": "Set.image2_assoc",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} {ε : Type u_9} {ε' : Type u_10} {s : Set α} {t : Set β}\n  {u : Set γ} {f : δ → γ → ε} {g : α → β → δ} {f' : α → ε' → ε} {g' : β → γ → ε'},\n  (∀ (a : α) (b : β) (c : γ), f (g a b) c = f' a (g' b c)) →\n    Set.image2 f (Set.image2 g s t) u = Set.image2 f' s (Set.image2 g' t u)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivInvOneMonoid.inv_one",
  "constType": "∀ {G : Type u_2} [self : DivInvOneMonoid G], 1⁻¹ = 1",
  "constCategory": "Definition"},
 {"references": ["MeasurableSpace"],
  "name": "DiscreteMeasurableSpace",
  "constType": "(α : Type u_7) → [inst : MeasurableSpace α] → Prop",
  "constCategory": "Other"},
 {"references": ["Function.Embedding"],
  "name": "Function.Embedding.toFun",
  "constType": "{α : Sort u_1} → {β : Sort u_2} → (α ↪ β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "AddCommMonoid.toAddMonoid",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_6",
   "OrderedCommMonoid.mk",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_13",
   "ENNReal",
   "LinearOrderedAddCommMonoid.toOrd",
   "ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal",
   "LinearOrderedAddCommMonoid.decidableLE",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_8",
   "Semiring.npow",
   "AddMonoid.toZero",
   "CommSemiring",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_4",
   "CommMonoid.mk",
   "Semigroup.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedAddCommMonoid.toMax",
   "LinearOrderedAddCommMonoid.decidableLT",
   "LinearOrderedCommMonoidWithZero",
   "LinearOrderedAddCommMonoid.decidableEq",
   "LinearOrderedAddCommMonoid.toMin",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_9",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_1",
   "NonUnitalNonAssocSemiring.toMul",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LinearOrderedAddCommMonoidWithTop",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_5",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_12",
   "LinearOrderedCommMonoidWithZero.mk",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_10",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_11",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_2",
   "LinearOrderedAddCommMonoidWithTop.toLinearOrderedAddCommMonoid",
   "LinearOrderedCommMonoid.mk",
   "inferInstanceAs",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_3",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal.proof_7",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal",
  "constType": "LinearOrderedCommMonoidWithZero ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulPosReflectLT",
   "MulZeroClass.zero_mul",
   "MulZeroClass",
   "Preorder",
   "LE.le",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "LT.lt",
   "Eq.rec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "Eq.symm",
   "lt_of_mul_lt_mul_right"],
  "name": "pos_of_mul_pos_left",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : MulPosReflectLT α],\n  0 < a * b → 0 ≤ b → 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro", "Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.rec",
  "constType":
  "∀ {α : Type u} {s : Set α} {motive : Set.Finite s → Prop},\n  (∀ (a : Fintype ↑s), motive (_ : Set.Finite s)) → ∀ (t : Set.Finite s), motive t",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "instHMul",
   "Additive.toMul",
   "HMul.hMul",
   "Additive.ofMul",
   "FunLike.coe",
   "Add",
   "Mul",
   "Equiv.instFunLikeEquiv",
   "Additive",
   "Add.mk"],
  "name": "Additive.add",
  "constType": "{α : Type u} → [inst : Mul α] → Add (Additive α)",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt.le",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "StrictMono",
   "Monotone",
   "Preorder",
   "monotone_iff_forall_lt",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "PartialOrder"],
  "name": "StrictMono.monotone",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] {f : α → β}, StrictMono f → Monotone f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSProd",
   "Set.Infinite.image2_right",
   "Set.image2",
   "Or",
   "Set",
   "Set.Nonempty",
   "Eq.refl",
   "Or.casesOn",
   "Set.infinite_prod",
   "Exists.casesOn",
   "Set.InjOn",
   "Set.image_uncurry_prod",
   "Eq",
   "Set.instMembershipSet",
   "Iff.intro",
   "And",
   "Iff",
   "Eq.ndrec",
   "Iff.mp",
   "Function.uncurry",
   "SProd.sprod",
   "Eq.mp",
   "Set.Infinite.image2_left",
   "Prod",
   "Set.image",
   "And.casesOn",
   "Eq.symm",
   "Set.Infinite.of_image",
   "Set.Infinite"],
  "name": "Set.infinite_image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} {f : α → β → γ} {s : Set α} {t : Set β},\n  (∀ b ∈ t, Set.InjOn (fun a => f a b) s) →\n    (∀ a ∈ s, Set.InjOn (f a) t) →\n      (Set.Infinite (Set.image2 f s t) ↔ Set.Infinite s ∧ Set.Nonempty t ∨ Set.Infinite t ∧ Set.Nonempty s)",
  "constCategory": "Theorem"},
 {"references": ["Zero", "ZeroHom"],
  "name": "ZeroHom.toFun",
  "constType":
  "{M : Type u_9} → {N : Type u_10} → [inst : Zero M] → [inst_1 : Zero N] → ZeroHom M N → M → N",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "LinearOrderedRing",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing.add_le_add_left",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHSMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "succ_nsmul",
   "Eq",
   "AddMonoid.toNatSMul",
   "zero_nsmul",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "instOfNatNat",
   "Nat",
   "add_zero",
   "id"],
  "name": "one_nsmul",
  "constType": "∀ {A : Type y} [inst : AddMonoid A] (a : A), 1 • a = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "instHAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "HAdd.hAdd",
   "AddSubsemigroup.add_mem'",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.map",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddMonoidHom.addMonoidHomClass",
   "AddSubsemigroup.carrier",
   "AddMonoidHom"],
  "name": "AddSubgroup.map.proof_1",
  "constType":
  "∀ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup G) {a b : N},\n  a ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n    b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n      a + b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "Complex.instNormedFieldComplex.proof_2",
   "Complex.instNormComplex",
   "Complex.instField",
   "NormedField",
   "NormedField.mk",
   "Complex",
   "Complex.instNormedAddCommGroupComplex",
   "Complex.instNormedFieldComplex.proof_1"],
  "name": "Complex.instNormedFieldComplex",
  "constType": "NormedField ℂ",
  "constCategory": "Definition"},
 {"references": ["Nat.commSemiring", "inferInstance", "CommSemiring", "Nat"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv", "Rat", "Eq.refl", "HDiv.hDiv", "Eq", "Rat.instDivRat"],
  "name": "Rat.field.proof_1",
  "constType": "∀ (a b : ℚ), a / b = a / b",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Field.mk",
   "LinearOrderedField.qsmul",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedRing.toNontrivial",
   "LinearOrderedField.inv_zero",
   "CommRing.mk",
   "LinearOrderedField.toDiv",
   "LinearOrderedField.ratCast_mk",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "Field",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedField.toRatCast",
   "LinearOrderedField.qsmul_eq_mul'",
   "LinearOrderedField.toInv",
   "LinearOrderedField.zpow",
   "LinearOrderedField.zpow_neg'"],
  "name": "LinearOrderedField.toField",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Field α",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LE.mk",
   "CauSeq.lt_of_eq_of_lt",
   "instHasEquiv",
   "Or",
   "CauSeq.lt_of_lt_of_eq",
   "Or.inr",
   "DivisionRing.toRing",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "LE.le",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Or.inl",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "Setoid.trans",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.match_1",
   "Field.toDivisionRing",
   "CauSeq.lt_trans"],
  "name":
  "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (x x_1 x_2 : CauSeq α abs), x ≤ x_1 → x_1 ≤ x_2 → x ≤ x_2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "SMul",
   "Set.zero",
   "SMul.mk",
   "Set.add",
   "Set",
   "nsmulRec",
   "Nat",
   "Add"],
  "name": "Set.NSMul",
  "constType":
  "{α : Type u_2} → [inst : Zero α] → [inst : Add α] → SMul ℕ (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Real.instDistribLatticeReal.proof_4",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Inf.inf",
   "Real",
   "Real.instLEReal",
   "DistribLattice.mk",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "Real.instSupReal",
   "Lattice.mk",
   "Real.instDistribLatticeReal.proof_5",
   "Real.instDistribLatticeReal.proof_6",
   "Sup.mk",
   "LE.le",
   "PartialOrder",
   "Preorder.mk",
   "Inf.mk",
   "DistribLattice",
   "Real.instDistribLatticeReal.proof_8",
   "Real.instDistribLatticeReal.proof_2",
   "Real.instDistribLatticeReal.proof_10",
   "Real.instDistribLatticeReal.proof_9",
   "Preorder.toLT",
   "Real.instDistribLatticeReal.proof_1",
   "Real.instDistribLatticeReal.proof_3",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.instDistribLatticeReal.proof_7"],
  "name": "Real.instDistribLatticeReal",
  "constType": "DistribLattice ℝ",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableIff.proof_4",
   "instDecidableIff.proof_2",
   "Iff",
   "Decidable.isFalse",
   "instDecidableIff.proof_1",
   "instDecidableIff.proof_3",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite"],
  "name": "instDecidableIff",
  "constType":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.beq.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) →\n    (Unit → motive Nat.zero Nat.zero) →\n      ((n : ℕ) → motive Nat.zero (Nat.succ n)) →\n        ((n : ℕ) → motive (Nat.succ n) Nat.zero) → ((n m : ℕ) → motive (Nat.succ n) (Nat.succ m)) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "CommRing.toNonUnitalCommRing",
   "AbsoluteValue",
   "Real",
   "IsCauSeq",
   "Semiring.toMonoidWithZero",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "Nat.factorial",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Complex.instField",
   "instHPow",
   "Finset.range",
   "Monoid.toNatPow",
   "HDiv.hDiv",
   "Nat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Complex.abs",
   "instHDiv",
   "Complex.commRing",
   "Finset.sum",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.isCauSeq_exp",
   "Complex.instRingComplex",
   "CauSeq",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toDiv",
   "Subtype.mk",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.exp'",
  "constType": "ℂ → CauSeq ℂ ⇑Complex.abs",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "StrictOrderedRing.toNontrivial",
   "Nontrivial"],
  "name": "LinearOrderedRing.toLinearOrderedSemiring.proof_2",
  "constType": "∀ {α : Type u_1} [inst : LinearOrderedRing α], Nontrivial α",
  "constCategory": "Theorem"},
 {"references":
  ["TopologicalSpace",
   "Filter",
   "wrapped._@.Mathlib.Topology.Basic._hyg.10680"],
  "name": "nhds",
  "constType": "{α : Type u_1} → [inst : TopologicalSpace α] → α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "CommSemigroup",
   "Semigroup",
   "Eq"],
  "name": "CommSemigroup.mk",
  "constType":
  "{G : Type u} → [toSemigroup : Semigroup G] → (∀ (a b : G), a * b = b * a) → CommSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["le_iff_lt_or_eq",
   "Or",
   "Iff",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "Iff.trans",
   "LE.le",
   "or_comm",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_iff_eq_or_lt",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a = b ∨ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ"],
  "name": "Nat.succ_add",
  "constType": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "GroupWithZero.mul_inv_cancel",
   "One.toOfNat1",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Inv.inv",
   "GroupWithZero.toInv"],
  "name": "mul_inv_cancel",
  "constType":
  "∀ {G₀ : Type u} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Fin.mul_zero'",
   "Semiring.mk",
   "Fin.instCommSemigroup",
   "SubNegMonoid.toNeg",
   "Fin.instCommRing.proof_5",
   "Fin.zero_mul'",
   "npowRec",
   "Fin.instCommRing.proof_12",
   "CommSemigroup",
   "Fin.instDistrib",
   "NonUnitalNonAssocSemiring.mk",
   "CommRing",
   "Fin.instCommRing.proof_8",
   "CommRing.mk",
   "Fin.instCommRing.proof_9",
   "Fin.instCommRing.proof_1",
   "SubNegMonoid.toSub",
   "Fin.instCommRing.proof_6",
   "NeZero",
   "Fin.instCommRing.proof_3",
   "AddCommMonoid.mk",
   "AddMonoidWithOne.toNatCast",
   "Int.castDef",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Fin.instCommRing.proof_14",
   "Fin.instCommRing.proof_10",
   "AddCommGroup.toAddGroup",
   "Nat",
   "Fin.instCommRing.proof_4",
   "Distrib",
   "Fin.one_mul'",
   "Fin.instCommRing.proof_7",
   "Fin.addCommGroup",
   "Nat.linearOrderedCommMonoidWithZero",
   "Fin.mul_one'",
   "AddMonoidWithOne.toAddMonoid",
   "Fin.instCommRing.proof_13",
   "AddGroup.toSubNegMonoid",
   "Fin.instCommRing.proof_11",
   "Fin.instCommRing.proof_2",
   "Fin.instCommRing.proof_16",
   "CommSemigroup.toSemigroup",
   "Fin.instCommRing.proof_15",
   "AddMonoidWithOne",
   "Fin.instAddMonoidWithOne",
   "IntCast.mk",
   "AddMonoidWithOne.toOne",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.zsmul",
   "Ring.mk",
   "AddCommGroup",
   "Fin"],
  "name": "Fin.instCommRing",
  "constType": "(n : ℕ) → [inst : NeZero n] → CommRing (Fin n)",
  "constCategory": "Definition"},
 {"references": ["DivisionSemiring", "Int"],
  "name": "DivisionSemiring.zpow",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List.pmap",
   "Multiset.pmap.proof_1",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.recOn'",
   "Multiset.ofList",
   "Multiset.instMembershipMultiset",
   "Quot.mk"],
  "name": "Multiset.pmap",
  "constType":
  "{α : Type u_1} → {β : Type v} → {p : α → Prop} → ((a : α) → p a → β) → (s : Multiset α) → (∀ a ∈ s, p a) → Multiset β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "propext",
   "Set",
   "Set.ext_iff",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.GroupTheory.Complement._auxAddLemma.16",
  "constType":
  "∀ {α : Type u} {s t : Set α}, (s = t) = ∀ (x : α), x ∈ s ↔ x ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.range",
   "Fintype",
   "FiniteRange",
   "Set",
   "FiniteRange.mk",
   "Finite.of_fintype",
   "Subtype.finite",
   "Set.toFinite",
   "Set.instMembershipSet"],
  "name": "instFiniteRange",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} (X : Ω → G) [inst : Fintype G], FiniteRange X",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "ENNReal",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "WithTop",
   "WithTop.linearOrderedAddCommMonoidWithTop",
   "inferInstanceAs",
   "CanonicallyLinearOrderedSemifield.toLinearOrderedSemifield",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "LinearOrderedAddCommMonoidWithTop",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "NNReal"],
  "name": "ENNReal.instLinearOrderedAddCommMonoidWithTopENNReal",
  "constType": "LinearOrderedAddCommMonoidWithTop ENNReal",
  "constCategory": "Definition"},
 {"references": ["Exists", "setOf", "Set", "Eq"],
  "name": "Set.range",
  "constType": "{α : Type u_1} → {ι : Sort u_4} → (ι → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "completeLatticeOfInf",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "CompleteLattice.toInfSet",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_14",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (s : Set (Submonoid M)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "CommSemiring.toSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Real.instAddMonoidReal",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "Real.instOneReal",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Real.linearOrder",
   "SubNegMonoid.toSub",
   "le_of_not_gt",
   "Real.strictOrderedSemiring",
   "Left.add_neg",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Real.instRingReal",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "sub_nonpos_of_le",
   "Real",
   "GE.ge",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Real.instLTReal",
   "lt_of_lt_of_le",
   "lt_mul_iff_one_lt_left",
   "Mathlib.Tactic.Ring.cast_pos",
   "Real.exp_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "sub_add_cancel",
   "sub_neg_of_lt",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "Mathlib.Tactic.Ring.atom_pf",
   "Real.orderedAddCommGroup",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Real.instMulReal",
   "Real.instAddReal",
   "Real.instLEReal",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "StrictMono",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Real.instLinearOrderedSemiringReal",
   "Real.exp_add",
   "Nat.cast_one",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Real.partialOrder",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "lt_of_not_ge",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "AddCancelMonoid.toIsCancelAdd",
   "Real.orderedAddCommMonoid",
   "Eq.mp",
   "Real.instAddGroupReal",
   "LinearOrderedSemiring.toMulPosReflectLT",
   "Int.ofNat",
   "Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "lt_zero_of_zero_gt",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "instHPow",
   "CommSemiring.toCommMonoidWithZero",
   "add_lt_of_neg_of_le",
   "Eq.symm",
   "id",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddSemigroup.toAdd",
   "instHAdd",
   "_private.Mathlib.Data.Complex.Exponential.0.Real.add_one_le_exp_of_nonneg",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Real.exp",
   "GT.gt",
   "Real.instZeroReal",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "NegZeroClass.toZero"],
  "name": "Real.exp_strictMono",
  "constType": "StrictMono Real.exp",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "CommSemiring",
   "HMul.hMul",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "CommSemiring.toCommMonoidWithZero.proof_1",
  "constType": "∀ {α : Type u_1} [inst : CommSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub", "Int.instSubInt", "HSub.hSub", "Int", "Int.NonNeg"],
  "name": "Int.le",
  "constType": "ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Function.Injective",
   "CharZero",
   "Nat"],
  "name": "CharZero.cast_injective",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Nat.zero_lt_succ",
   "LE.le",
   "Zero.toOfNat0",
   "Semiring.toOne",
   "Nat.commSemiring",
   "instLENat",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat.le_of_lt",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.linearOrderedCommSemiring.proof_6",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u_1} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = Int.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Finset.card",
   "AddHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "Multiset.card_map",
   "Multiset.toFinset",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Multiset.map",
   "instLENat",
   "Nat.addMonoid",
   "DecidableEq",
   "Finset.image",
   "Finset",
   "Eq.mp",
   "Multiset",
   "Multiset.toFinset_card_le",
   "Finset.val",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "congrArg",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card_image_le",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {f : α → β} [inst : DecidableEq β],\n  Finset.card (Finset.image f s) ≤ Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.choose_spec",
   "Exists",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Classical.choose",
   "PartialOrder.toPreorder",
   "Eq.refl",
   "dite",
   "Cardinal.partialOrder",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Cardinal.aleph0",
   "Iff.mp",
   "Cardinal.natCast_inj",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Cardinal.canonicallyOrderedCommSemiring",
   "id",
   "Nat.linearOrderedCommMonoidWithZero",
   "dif_pos",
   "AddMonoidWithOne.toAddMonoid",
   "Cardinal.nat_lt_aleph0",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Cardinal.linearOrder",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "Eq.ndrec",
   "propext",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "Cardinal",
   "letFun",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "Not",
   "Cardinal.lt_aleph0"],
  "name": "Cardinal.toNat.proof_2",
  "constType":
  "(fun c => if h : c < Cardinal.aleph0 then Classical.choose (_ : ∃ n, c = ↑n) else 0) 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "flip",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "MulZeroClass.mul_zero",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "lt_of_mul_lt_mul_left",
   "not_false_eq_true",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "GroupWithZero.toInv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "LinearOrderedSemifield",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
   "DivisionSemiring.toGroupWithZero",
   "OrderedSemiring.zeroLEOneClass",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "Iff.intro",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "Not",
   "congrArg",
   "Inv.inv",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "LinearOrderedSemifield.toInv",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "ne_of_gt",
   "Preorder.toLT",
   "Eq.rec",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "InvolutiveInv.toInv",
   "DivisionMonoid.toInvolutiveInv",
   "mul_inv_cancel",
   "CommGroupWithZero.toDivisionCommMonoid",
   "LT.lt.le",
   "False",
   "One.toOfNat1",
   "inv_inv",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "GroupWithZero.toMonoidWithZero",
   "eq_false",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "HMul.hMul",
   "Semifield.toDivisionSemiring"],
  "name": "inv_pos",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 < a⁻¹ ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCommMagma.IsLeftCancelAdd.toIsRightCancelAdd",
   "AddCommMagma.toAdd",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
  "constType":
  "∀ (M : Type u_1) [inst : AddCancelCommMonoid M], IsRightCancelAdd M",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "Eq",
   "Ring.toNeg",
   "Mathlib.Meta.NormNum.isInt_neg.match_1",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Int.cast_neg",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.instNegInt",
   "Eq.symm",
   "Int",
   "Int.neg"],
  "name": "Mathlib.Meta.NormNum.isInt_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α} {a : α} {a' b : ℤ},\n  f = Neg.neg → Mathlib.Meta.NormNum.IsInt a a' → Int.neg a' = b → Mathlib.Meta.NormNum.IsInt (-a) b",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.mk",
  "constType": "{α : Type u} → α → Zero α",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Ne",
   "Unit",
   "Unit.unit",
   "ProbabilityTheory.iIndepFun",
   "MeasureTheory.Measure.dirac",
   "MeasurableSpace",
   "ProbabilityTheory.kernel.iIndepFun.indepFun",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.iIndepFun.indepFun",
  "constType":
  "∀ {Ω : Type u_1} {ι : Type u_2} {_m₀ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {β : ι → Type u_6}\n  {m : (x : ι) → MeasurableSpace (β x)} {f : (i : ι) → Ω → β i},\n  ProbabilityTheory.iIndepFun m f → ∀ {i j : ι}, i ≠ j → ProbabilityTheory.IndepFun (f i) (f j)",
  "constCategory": "Theorem"},
 {"references":
  ["IsDomain.toIsCancelMulZero",
   "Real.instLinearOrderedRingReal",
   "Real.semiring",
   "IsDomain.mk",
   "IsDomain",
   "Real.nontrivial",
   "Real",
   "Real.commRing",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "IsDomain.toNontrivial",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Nontrivial",
   "LinearOrderedRing.isDomain",
   "StrictOrderedSemiring.toSemiring",
   "CommRing"],
  "name": "Real.instIsDomainRealSemiring",
  "constType": "IsDomain ℝ",
  "constCategory": "Definition"},
 {"references": ["SMul", "Monoid", "MulAction"],
  "name": "MulAction.toSMul",
  "constType":
  "{α : Type u_10} → {β : Type u_11} → [inst : Monoid α] → [self : MulAction α β] → SMul α β",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ"],
  "name": "Nat.rec",
  "constType":
  "{motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive (Nat.succ n)) → (t : ℕ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.1",
   "EmptyCollection.emptyCollection",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "Set",
   "MeasurableSet",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "congrArg",
   "Set.univ",
   "MeasurableSet.of_compl",
   "Eq.trans",
   "MeasurableSpace",
   "True"],
  "name": "MeasurableSet.univ",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α}, MeasurableSet Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "instAddNat",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3954",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "autoParam",
   "AddSemigroup",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.3915",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.mk",
  "constType":
  "{M : Type u} →\n  [toAddSemigroup : AddSemigroup M] →\n    [toZero : Zero M] →\n      (∀ (a : M), 0 + a = a) →\n        (∀ (a : M), a + 0 = a) →\n          (nsmul : ℕ → M → M) →\n            autoParam (∀ (x : M), nsmul 0 x = 0) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), nsmul (n + 1) x = x + nsmul n x) _auto✝¹ → AddMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "EmbeddingLike.toFunLike",
   "true_and",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set.toFinset",
   "Set",
   "Eq.refl",
   "True",
   "iff_self",
   "Eq",
   "Iff.of_eq",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset",
   "Function.Embedding",
   "Eq.trans",
   "Subtype",
   "Membership.mem",
   "funext",
   "Mathlib.Data.Finset.Image._auxLemma.1",
   "Finset.instMembershipFinset",
   "Function.Embedding.subtype",
   "FunLike.coe",
   "Std.Logic._auxLemma.51",
   "Std.Logic._auxLemma.38",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.map",
   "Finset.univ",
   "And",
   "Function.instEmbeddingLikeEmbedding",
   "of_eq_true",
   "congrArg",
   "Subtype.mk",
   "congrFun",
   "exists_prop_congr'"],
  "name": "Set.mem_toFinset",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, a ∈ Set.toFinset s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Eq.refl",
   "Eq.symm",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references": ["SMul"],
  "name": "IsScalarTower",
  "constType":
  "(M : Type u_10) → (N : Type u_11) → (α : Type u_12) → [inst : SMul M N] → [inst : SMul N α] → [inst : SMul M α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "add_eq_zero_iff_eq_neg",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "neg_eq_iff_eq_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "Iff",
   "InvolutiveNeg.toNeg",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_eq_zero_iff_neg_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a + b = 0 ↔ -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Filter", "instMembershipSetFilter"],
  "name": "Filter.Eventually",
  "constType": "{α : Type u} → (α → Prop) → Filter α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "Ring.toNeg",
   "instAddNat",
   "instHAdd",
   "Int.negSucc",
   "HAdd.hAdd",
   "Ring.toIntCast",
   "Ring",
   "instOfNatNat",
   "Neg.neg",
   "Nat",
   "Ring.toSemiring",
   "IntCast.intCast",
   "Semiring.toNatCast",
   "Eq"],
  "name": "Ring.intCast_negSucc",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Int.instSubInt",
   "instOfNatInt",
   "_private.Init.Data.Int.Basic.0.Int.decNonneg",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "Decidable",
   "HSub.hSub",
   "Int",
   "Int.instLTInt",
   "Int.instAddInt"],
  "name": "Int.decLt",
  "constType": "(a b : ℤ) → Decidable (a < b)",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "algebraMap",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra.smul_def'",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = (algebraMap R A) r * x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "add_zero",
   "AddMonoid",
   "Eq"],
  "name": "AddMonoid.toOppositeAddAction.proof_1",
  "constType": "∀ (α : Type u_1) [inst : AddMonoid α] (a : α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.zero", "instLENat", "Nat", "Nat.succ", "LE.le", "Nat.casesOn"],
  "name": "Nat.le.dest.match_2",
  "constType":
  "∀ (motive : (x x_1 : ℕ) → x ≤ x_1 → Prop) (x x_1 : ℕ) (x_2 : x ≤ x_1),\n  (∀ (x : Nat.zero ≤ Nat.zero), motive Nat.zero Nat.zero x) →\n    (∀ (n : ℕ) (x : Nat.zero ≤ Nat.succ n), motive Nat.zero (Nat.succ n) x) →\n      (∀ (n : ℕ) (h : Nat.succ n ≤ Nat.zero), motive (Nat.succ n) Nat.zero h) →\n        (∀ (n m : ℕ) (h : Nat.succ n ≤ Nat.succ m), motive (Nat.succ n) (Nat.succ m) h) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "Neg.neg",
   "Eq"],
  "name": "AddGroupWithOne.add_left_neg",
  "constType": "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), -a + a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "InfSet.mk",
   "AddSubmonoid.instInfSetAddSubmonoid.proof_2",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.mk",
   "AddSubmonoid.instInfSetAddSubmonoid.proof_1",
   "Set",
   "InfSet",
   "Set.iInter",
   "AddSubmonoid.mk",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instInfSetAddSubmonoid",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → InfSet (AddSubmonoid M)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "BooleanAlgebra.le_top",
   "PartialOrder.toPreorder",
   "Set.instBooleanAlgebraSet",
   "Top.top",
   "Set",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "BooleanAlgebra.toTop",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_3",
  "constType": "∀ {α : Type u_1} (a : Set α), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Finset.card_image_le",
   "Finset.instSProd",
   "LE.le",
   "instHMul",
   "instLENat",
   "DecidableEq",
   "Function.uncurry",
   "Finset.image",
   "SProd.sprod",
   "Finset.image₂",
   "Finset",
   "HMul.hMul",
   "Prod",
   "Nat",
   "instMulNat",
   "LE.le.trans_eq",
   "Finset.card_product"],
  "name": "Finset.card_image₂_le",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] (f : α → β → γ) (s : Finset α) (t : Finset β),\n  Finset.card (Finset.image₂ f s t) ≤ Finset.card s * Finset.card t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "AddSubgroup.rec",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.casesOn",
  "constType":
  "{G : Type u_5} →\n  [inst : AddGroup G] →\n    {motive : AddSubgroup G → Sort u} →\n      (t : AddSubgroup G) →\n        ((toAddSubmonoid : AddSubmonoid G) →\n            (neg_mem' : ∀ {x : G}, x ∈ toAddSubmonoid.carrier → -x ∈ toAddSubmonoid.carrier) →\n              motive { toAddSubmonoid := toAddSubmonoid, neg_mem' := neg_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.toStrictOrderedRing",
   "PartialOrder.toPreorder",
   "LinearOrderedRing",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedRing.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Subtype.property",
   "Membership.mem",
   "SubNegMonoid.toSub",
   "AddGroup",
   "Subtype.val",
   "Set",
   "HSub.hSub",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "AddSubgroup.sub_mem",
   "SetLike.instMembership",
   "Subtype",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.sub.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (a b : ↥H), ↑a - ↑b ∈ H",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.mk",
  "constType": "{α : Type u} → {x : ℕ} → α → OfNat α x",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegZeroMonoid",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.instMembershipSet"],
  "name": "Set.mem_preimage",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set β} {a : α}, a ∈ f ⁻¹' s ↔ f a ∈ s",
  "constCategory": "Theorem"},
 {"references": ["And", "Or", "not_and_or", "propext", "Not", "Eq"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.35",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (¬a ∨ ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.neg_mem",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "Subtype.property",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toNeg",
   "Subtype",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.coe"],
  "name": "AddSubgroup.neg.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (a : ↥H), -↑a ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["Invertible.invOf",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Mathlib.Meta.NormNum.IsRat.rec",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toOne",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Nat",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.casesOn",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} {motive : Mathlib.Meta.NormNum.IsRat a num denom → Prop}\n  (t : Mathlib.Meta.NormNum.IsRat a num denom),\n  (∀ (inv : Invertible ↑denom) (eq : a = ↑num * ⅟↑denom), motive (_ : Mathlib.Meta.NormNum.IsRat a num denom)) →\n    motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Semiring.natCast_succ",
  "constType":
  "∀ {α : Type u} [self : Semiring α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Eq.refl",
   "DivisionRing.toRatCast",
   "Rat.mk'",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Eq.mpr",
   "CauSeq.Completion.ofRat_mul",
   "Nat.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "instOfNatNat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.ofRat",
   "CauSeq.Completion.instMulCauchy",
   "Nat",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "CauSeq.Completion.ofRat_ratCast",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "Ne",
   "Rat.cast_mk'",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing",
   "RatCast.mk",
   "Rat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "CauSeq.Completion.ofRat_inv",
   "CauSeq.Completion.Cauchy.ring",
   "Eq.ndrec",
   "Int.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.Coprime",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_11",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℤ) (d : ℕ) (hd : d ≠ 0) (hnd : Nat.Coprime (Int.natAbs n) d),\n  ↑(Rat.mk' n d) = ↑n * (↑d)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.le_sup_left",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "SemilatticeInf.toPartialOrder",
   "GaloisInsertion.liftSemilatticeSup",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "GaloisInsertion",
   "PartialOrder",
   "SemilatticeSup",
   "SemilatticeSup.toSup",
   "SemilatticeSup.sup_le",
   "SemilatticeSup.le_sup_right",
   "SemilatticeInf.le_inf",
   "SemilatticeInf.inf_le_right",
   "SemilatticeInf.inf_le_left",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "GaloisInsertion.liftSemilatticeInf",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder"],
  "name": "GaloisInsertion.liftLattice",
  "constType":
  "{α : Type u} →\n  {β : Type v} →\n    {l : α → β} → {u : β → α} → [inst : PartialOrder β] → [inst_1 : Lattice α] → GaloisInsertion l u → Lattice β",
  "constCategory": "Definition"},
 {"references": ["Nontrivial", "EuclideanDomain"],
  "name": "EuclideanDomain.toNontrivial",
  "constType": "∀ {R : Type u} [self : EuclideanDomain R], Nontrivial R",
  "constCategory": "Definition"},
 {"references":
  ["HeytingAlgebra",
   "Bot.bot",
   "HImp.himp",
   "PartialOrder.toPreorder",
   "HasCompl",
   "GeneralizedHeytingAlgebra.toHImp",
   "OrderBot.toBot",
   "HasCompl.compl",
   "GeneralizedHeytingAlgebra.toLattice",
   "OrderBot",
   "Lattice.toSemilatticeSup",
   "GeneralizedHeytingAlgebra",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Eq"],
  "name": "HeytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toGeneralizedHeytingAlgebra : GeneralizedHeytingAlgebra α] →\n    [toOrderBot : OrderBot α] → [toHasCompl : HasCompl α] → (∀ (a : α), a ⇨ ⊥ = aᶜ) → HeytingAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Finset.decidableMem",
   "Disjoint",
   "Finset.partialOrder",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset",
   "Finset.instOrderBotFinsetToLEToPreorderPartialOrder",
   "DecidableEq",
   "instDecidableNot",
   "Finset",
   "Multiset",
   "Decidable",
   "Multiset.decidableDforallMultiset",
   "Finset.val",
   "Not",
   "Finset.decidableDisjoint.proof_1",
   "decidable_of_iff"],
  "name": "Finset.decidableDisjoint",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → (U V : Finset α) → Decidable (Disjoint U V)",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.4598",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.4598",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["Nat.instModNat",
   "Nat.decidable_dvd.proof_1",
   "OfNat.ofNat",
   "instHMod",
   "Nat.instDvdNat",
   "HMod.hMod",
   "Dvd.dvd",
   "instOfNatNat",
   "Nat",
   "instDecidableEqNat",
   "DecidableRel",
   "Eq",
   "decidable_of_decidable_of_iff"],
  "name": "Nat.decidable_dvd",
  "constType": "DecidableRel fun x x_1 => x ∣ x_1",
  "constCategory": "Definition"},
 {"references": ["Function.Injective", "Function.comp", "Eq"],
  "name": "Function.Injective.comp",
  "constType":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},\n  Function.Injective g → Function.Injective f → Function.Injective (g ∘ f)",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toMul",
   "Set.preimage",
   "Set",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "Inter.inter",
   "MeasureTheory.Measure.real",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ENNReal.toReal_mul",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "ProbabilityTheory.IndepFun.measure_inter_preimage_eq_mul",
   "MeasurableSet",
   "HMul.hMul",
   "MeasureTheory.measureReal_def",
   "ENNReal.toReal",
   "MeasurableSpace",
   "id",
   "ProbabilityTheory.IndepFun",
   "Set.instInterSet"],
  "name": "ProbabilityTheory.IndepFun.measureReal_inter_preimage_eq_mul",
  "constType":
  "∀ {Ω : Type u_1} {β : Type u_10} {β' : Type u_11} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {f : Ω → β}\n  {g : Ω → β'} {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'},\n  ProbabilityTheory.IndepFun f g →\n    ∀ {s : Set β} {t : Set β'},\n      MeasurableSet s → MeasurableSet t → μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Neg.toHasAbs",
   "instHSub",
   "Set",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Eq.refl",
   "Bornology.cobounded",
   "Real.instSupReal",
   "abs_sub_le",
   "Real.instLinearOrderedAddCommGroupReal",
   "Abs.abs",
   "Eq",
   "Real.instNegReal",
   "Real.linearOrder",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "abs_sub_comm"],
  "name": "Real.pseudoMetricSpace.proof_5",
  "constType": "(Bornology.cobounded ℝ).sets = (Bornology.cobounded ℝ).sets",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_lt_add_iff_right",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_neg_of_lt",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < b → a - b < 0",
  "constCategory": "Theorem"},
 {"references": ["One", "InvOneClass"],
  "name": "InvOneClass.toOne",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → One G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "true_and",
   "Mathlib.Data.Fintype.Basic._auxLemma.23",
   "setOf",
   "Set.toFinset",
   "Set",
   "Finset.instMembershipFinset",
   "True",
   "Eq",
   "iff_self",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Set.instMembershipSet",
   "DecidablePred",
   "And",
   "Finset.univ",
   "Fintype",
   "Iff",
   "Set.Elem",
   "of_eq_true",
   "Finset.ext",
   "Finset",
   "congr",
   "Finset.filter",
   "congrArg",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "Eq.trans",
   "congrFun"],
  "name": "Set.toFinset_setOf",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (p : α → Prop) [inst_1 : DecidablePred p] [inst_2 : Fintype ↑{x | p x}],\n  Set.toFinset {x | p x} = Finset.filter p Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references":
  ["CharP",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "AddMonoid.toZero",
   "Nat.instDvdNat",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "Nat",
   "Eq"],
  "name": "CharP.mk",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] {p : ℕ}, (∀ (x : ℕ), ↑x = 0 ↔ p ∣ x) → CharP R p",
  "constCategory": "Other"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "NormedField",
   "Semifield.toCommSemiring",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalRingHomClass.toMulHomClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "NormedField.toField",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra.smul_def'",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.id",
   "Algebra.toSMul"],
  "name": "NormedAlgebra.id.proof_2",
  "constType":
  "∀ (𝕜 : Type u_1) [inst : NormedField 𝕜] (r x : 𝕜), r • x = Algebra.toRingHom r * x",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddCommGroup.mk",
  "constType":
  "{G : Type u} → [toAddGroup : AddGroup G] → (∀ (a b : G), a + b = b + a) → AddCommGroup G",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "id"],
  "name": "add_sub_cancel",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "Subtype"],
  "name": "NNReal",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "autoParam",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "MonoidWithZero",
   "Monoid.toSemigroup",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "GroupWithZero",
   "HMul.hMul",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Int",
   "Inv.inv"],
  "name": "GroupWithZero.mk",
  "constType":
  "{G₀ : Type u} →\n  [toMonoidWithZero : MonoidWithZero G₀] →\n    [toInv : Inv G₀] →\n      [toDiv : Div G₀] →\n        autoParam (∀ (a b : G₀), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → G₀ → G₀) →\n            autoParam (∀ (a : G₀), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G₀), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial G₀] → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → GroupWithZero G₀",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "NonUnitalNonAssocRing.toMul",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "of_eq_true",
   "Ring",
   "congr",
   "HMul.hMul",
   "congrArg",
   "left_distrib",
   "Eq.trans",
   "congrFun"],
  "name": "CancelDenoms.add_subst",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {n e1 e2 t1 t2 : α}, n * e1 = t1 → n * e2 = t2 → n * (e1 + e2) = t1 + t2",
  "constCategory": "Theorem"},
 {"references":
  ["measurableSet_discrete",
   "Set.preimage",
   "Set",
   "DiscreteMeasurableSpace",
   "MeasurableSet",
   "Measurable",
   "MeasurableSpace"],
  "name": "measurable_discrete",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : DiscreteMeasurableSpace α] (f : α → β), Measurable f",
  "constCategory": "Theorem"},
 {"references":
  ["measurable_fst",
   "Measurable",
   "Prod.swap",
   "Prod",
   "Measurable.prod",
   "MeasurableSpace",
   "measurable_snd",
   "Prod.instMeasurableSpace"],
  "name": "measurable_swap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β}, Measurable Prod.swap",
  "constCategory": "Theorem"},
 {"references":
  ["MeasurableSpace.GenerateMeasurable",
   "Set",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "CompleteAtomicBooleanAlgebra.toHasCompl"],
  "name": "MeasurableSpace.GenerateMeasurable.compl",
  "constType":
  "∀ {α : Type u_1} {s : Set (Set α)} (t : Set α),\n  MeasurableSpace.GenerateMeasurable s t → MeasurableSpace.GenerateMeasurable s tᶜ",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "propext",
   "Real",
   "Complex.ofReal_eq_zero",
   "Complex",
   "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.1",
  "constType": "∀ {z : ℝ}, (↑z = 0) = (z = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Iic",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Iff",
   "Set.Elem",
   "Set",
   "Finset",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "Nat",
   "Fintype.subtype_card",
   "Fintype.ofFinset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Fintype.card_ofFinset",
  "constType":
  "∀ {α : Type u_1} {p : Set α} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ x ∈ p), Fintype.card ↑p = Finset.card s",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Associative",
  "constType": "{α : Type u} → (α → α → α) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ring.zsmul",
   "Nat.cast",
   "Ring.toNeg",
   "instNatCastInt",
   "Int.negSucc",
   "CommRing.toRing",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "Int",
   "CommRing",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "CommRing.toNonUnitalCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α), Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "ZeroHom.mk",
   "ZeroHom.rec",
   "ZeroHom",
   "Eq"],
  "name": "ZeroHom.casesOn",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : Zero M] →\n      [inst_1 : Zero N] →\n        {motive : ZeroHom M N → Sort u} →\n          (t : ZeroHom M N) →\n            ((toFun : M → N) → (map_zero' : toFun 0 = 0) → motive { toFun := toFun, map_zero' := map_zero' }) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "Preorder.toLE"],
  "name": "StrictOrderedSemiring.zero_le_one",
  "constType": "∀ {α : Type u} [self : StrictOrderedSemiring α], 0 ≤ 1",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "LinearOrder.decidableLE",
   "LinearOrder.max_def",
   "Field.toNontrivial",
   "Field.zpow_neg'",
   "Field.zpow",
   "Field.toRatCast",
   "Rat.instLinearOrderedFieldRat.proof_2",
   "Field.toCommRing",
   "Field.qsmul_eq_mul'",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Field.mul_inv_cancel",
   "Field",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Rat.linearOrder",
   "Field.ratCast_mk",
   "LinearOrder",
   "Semiring",
   "StrictOrderedRing.mk",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Field.toInv",
   "Rat.semiring",
   "Rat.field",
   "Rat.instLinearOrderedFieldRat.proof_1",
   "LinearOrder.toOrd",
   "Rat.instLinearOrderedFieldRat.proof_3",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "Field.inv_zero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Field.toDiv",
   "Field.qsmul",
   "LinearOrderedRing.mk",
   "Rat.instLinearOrderedFieldRat.proof_4",
   "Field.div_eq_mul_inv"],
  "name": "Rat.instLinearOrderedFieldRat",
  "constType": "LinearOrderedField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "StrictOrderedRing.toPartialOrder",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "LinearOrderedRing",
   "DecidableEq",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedRing : StrictOrderedRing α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Real.instOneReal",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "Real.cauchy_one",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "Rat.field",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "congr",
   "CauSeq.Completion.Cauchy",
   "Zero.mk",
   "mul_one",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.mk",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Real.cauchy_mul",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "CauSeq.Completion.Cauchy.field",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "Real.cauchy_add",
   "AddSemigroup.toAdd",
   "One.mk",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_13",
  "constType": "∀ (a : ℝ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1157", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.mul",
  "constType": "ℝ → ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "congr_arg",
   "Subtype.val",
   "Multiset.Nodup.pmap",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Fintype.subtype.match_1",
   "rfl",
   "Multiset.instMembershipMultiset",
   "Iff.mpr",
   "Eq",
   "Finset.nodup",
   "Iff",
   "Iff.mp",
   "Finset",
   "Multiset",
   "Finset.val",
   "Multiset.pmap",
   "Finset.mk",
   "Multiset.mem_pmap",
   "Subtype",
   "Subtype.mk"],
  "name": "Fintype.subtype.proof_3",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ p x) (x : { x // p x }),\n  x ∈\n    { val := Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x),\n      nodup := (_ : Multiset.Nodup (Multiset.pmap Subtype.mk s.val (_ : ∀ x ∈ s, p x))) }",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_succ_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Real.exp_pos",
   "Eq.refl",
   "Real.exp",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Eq.mpr",
   "Real.log",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.rpow_def_of_pos",
   "HMul.hMul",
   "id"],
  "name": "Real.rpow_pos_of_pos",
  "constType": "∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), 0 < x ^ y",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "True",
   "Eq"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subsemigroup.carrier",
   "Submonoid.instTopSubmonoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Submonoid.one_mem'",
   "Top.top",
   "MulOneClass.toOne",
   "Set",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Subgroup.instTopSubgroup.proof_1",
  "constType": "∀ {G : Type u_1} [inst : Group G], 1 ∈ ⊤.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "CompleteLattice.toLattice",
   "SetLike.instPartialOrder",
   "And",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "Preorder.lt_iff_le_not_le",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_4",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b : AddSubmonoid M), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List.instMembershipList",
   "List",
   "List.pmap.proof_1",
   "PUnit",
   "List.pmap.proof_2",
   "List.nil",
   "List.pmap.match_1"],
  "name": "List.pmap",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (l : List α) → (∀ a ∈ l, p a) → List β",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "AbsoluteValue",
   "Real",
   "MulHom.mk",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "Real.orderedSemiring",
   "Real.sqrt",
   "NonAssocSemiring.toMulZeroOneClass",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "_private.Mathlib.Data.Complex.Abs.0.Complex.AbsTheory.abs_add",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AbsoluteValue.mk",
   "Real.semiring",
   "_private.Mathlib.Data.Complex.Abs.0.Complex.AbsTheory.abs_nonneg'",
   "Complex.normSq",
   "OrderedSemiring.toSemiring",
   "Complex",
   "MonoidWithZeroHom",
   "Complex.abs.proof_1",
   "_private.Mathlib.Data.Complex.Abs.0.Complex.AbsTheory.abs_mul"],
  "name": "Complex.abs",
  "constType": "AbsoluteValue ℂ ℝ",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "LinearOrderedAddCommMonoid",
   "DecidableRel"],
  "name": "LinearOrderedAddCommMonoid.decidableLT",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_assoc",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references": ["Set.range", "FiniteRange", "Set.Finite"],
  "name": "FiniteRange.finite",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} {X : Ω → G} [self : FiniteRange X], Set.Finite (Set.range X)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.109",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Real.partialOrder",
   "Real",
   "Preorder.le_trans",
   "LE.le",
   "Preorder.toLE"],
  "name": "Real.instDistribLatticeReal.proof_2",
  "constType": "∀ (a b c : ℝ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.ext_cauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "Rat.instNegRat",
   "Eq.trans",
   "Add.mk",
   "id",
   "Neg.toHasAbs",
   "add_assoc",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "CauSeq.Completion.Cauchy",
   "congr",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "congrFun"],
  "name": "Real.commRing.proof_1",
  "constType": "∀ (a b c : ℝ), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["Field", "RatCast"],
  "name": "Field.toRatCast",
  "constType": "{K : Type u} → [self : Field K] → RatCast K",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.mk",
  "constType":
  "{α : Type u} → [toRing : Ring α] → (∀ (a b : α), a * b = b * a) → CommRing α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "mul_one",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "id"],
  "name": "pow_one",
  "constType": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Fintype.subtype.proof_1",
   "Membership.mem",
   "Iff",
   "Multiset.card_pmap",
   "Finset",
   "Finset.val",
   "Fintype.card",
   "Finset.instMembershipFinset",
   "Nat",
   "Fintype.subtype",
   "Subtype.mk",
   "Subtype",
   "Eq"],
  "name": "Fintype.subtype_card",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ p x), Fintype.card { x // p x } = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "CommGroupWithZero",
   "Semifield.toCommSemiring",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "Semifield.mul_inv_cancel",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semifield",
   "Semifield.toInv",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Semifield.toNontrivial",
   "CommMonoidWithZero.mk",
   "CommMonoid.mk",
   "Semigroup.mk",
   "CommGroupWithZero.mk",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "Semifield.zpow_zero'",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.7",
   "Ne",
   "Exists",
   "funext",
   "Units.mk0",
   "OfNat.ofNat",
   "Eq.refl",
   "Std.Logic._auxLemma.51",
   "GroupWithZero.toMonoidWithZero",
   "True",
   "iff_self",
   "Std.Logic._auxLemma.38",
   "Iff.of_eq",
   "Eq",
   "Zero.toOfNat0",
   "And",
   "Units",
   "Iff",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "Units.val",
   "GroupWithZero",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "Eq.trans",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Units.exists_iff_ne_zero",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {x : G₀}, (∃ u, ↑u = x) ↔ x ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Exists", "Set", "Set.instMembershipSet"],
  "name": "Set.Nonempty",
  "constType": "{α : Type u_1} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "HEq",
   "eq_of_heq",
   "Subsingleton.allEq",
   "Eq.refl",
   "heq_of_eq",
   "Invertible",
   "Monoid.toMulOneClass",
   "Eq",
   "Invertible.subsingleton",
   "Eq.ndrec",
   "One",
   "HEq.refl",
   "Mul"],
  "name": "Invertible.congr",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "LT.lt",
   "Nat.le_trans",
   "Nat",
   "LE.le",
   "instLTNat",
   "Nat.succ"],
  "name": "Nat.lt_of_lt_of_le",
  "constType": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "constCategory": "Theorem"},
 {"references": ["Filter", "Filter.Eventually", "Eq"],
  "name": "Filter.EventuallyEq",
  "constType":
  "{α : Type u} → {β : Type v} → Filter α → (α → β) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "Measurable",
   "Add",
   "MeasurableSpace",
   "MeasurableAdd"],
  "name": "MeasurableAdd.mk",
  "constType":
  "∀ {M : Type u_2} [inst : MeasurableSpace M] [inst_1 : Add M],\n  (∀ (c : M), Measurable fun x => c + x) → (∀ (c : M), Measurable fun x => x + c) → MeasurableAdd M",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{α : Type u} → [inst : NonUnitalNonAssocRing α] → HasDistribNeg α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "CommGroupWithZero.mk",
   "CommMonoidWithZero.toZero",
   "zpowRec",
   "Monoid.toOne",
   "CommGroupWithZero",
   "Rat.commGroupWithZero.proof_6",
   "Rat",
   "Rat.commGroupWithZero.proof_3",
   "Rat.instDivRat",
   "Rat.commGroupWithZero.proof_4",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Rat.commGroupWithZero.proof_8",
   "Rat.commRing",
   "Rat.commGroupWithZero.proof_2",
   "Rat.commGroupWithZero.proof_7",
   "Rat.instInvRat",
   "Rat.mul_inv_cancel",
   "CommMonoidWithZero.mk",
   "Rat.commGroupWithZero.proof_5",
   "CommSemiring.toCommMonoidWithZero",
   "CommMonoid.toMonoid",
   "Rat.commGroupWithZero.proof_1"],
  "name": "Rat.commGroupWithZero",
  "constType": "CommGroupWithZero ℚ",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InvolutiveInv",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Finset", "Multiset", "Multiset.Nodup"],
  "name": "Finset.mk",
  "constType":
  "{α : Type u_4} → (val : Multiset α) → Multiset.Nodup val → Finset α",
  "constCategory": "Other"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "top_inf_eq",
   "Set.instBooleanAlgebraSet",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inter.inter",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.univ",
   "Set.instInterSet",
   "Eq",
   "CoheytingAlgebra.toOrderTop",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra"],
  "name": "Set.univ_inter",
  "constType": "∀ {α : Type u} (a : Set α), Set.univ ∩ a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.log",
   "OfNat.ofNat",
   "Real.instLTReal",
   "Real.instLEReal",
   "LT.lt",
   "Real",
   "Real.instPreorderReal",
   "LT.lt.trans_le",
   "Real.log_le_log_iff",
   "LE.le",
   "Iff.mpr"],
  "name": "Real.log_le_log",
  "constType": "∀ {x y : ℝ}, 0 < x → x ≤ y → Real.log x ≤ Real.log y",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocRing",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "NonAssocRing.toOne",
   "Eq",
   "NatCast.natCast",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "NonAssocRing.toNatCast",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Nat",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.natCast_succ",
  "constType":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), NatCast.natCast (n + 1) = NatCast.natCast n + 1",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_left_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "mul_sub",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), a * (b - c) = a * b - a * c",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Real.natCast",
   "lt_of_lt_of_le",
   "Real",
   "Real.isROrC",
   "Eq.refl",
   "Real.instRingReal",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Real.pi",
   "Real.orderedSemiring",
   "Nat.cast_zero",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "IsROrC.charZero_isROrC",
   "eq_true",
   "Real.two_le_pi",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "Bool.false",
   "Preorder.toLT",
   "LT.lt",
   "Real.instPreorderReal",
   "instNatAtLeastTwo",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "instOfNatNat",
   "Bool",
   "Nat",
   "instOfNat"],
  "name": "Real.pi_pos",
  "constType": "0 < Real.pi",
  "constCategory": "Theorem"},
 {"references":
  ["IsDomain.toIsCancelMulZero",
   "DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "IsDomain.mk",
   "IsDomain",
   "Field",
   "Field.toSemifield",
   "IsDomain.toNontrivial",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "DivisionRing.isDomain"],
  "name": "Field.isDomain",
  "constType": "∀ {K : Type u_3} [inst : Field K], IsDomain K",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr2",
  "constType": "String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["CommSemigroup", "Semigroup"],
  "name": "CommSemigroup.toSemigroup",
  "constType": "{G : Type u} → [self : CommSemigroup G] → Semigroup G",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedAddCommGroup", "Ord"],
  "name": "LinearOrderedAddCommGroup.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedAddCommGroup α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT",
   "lt_of_le_of_lt",
   "LT.lt",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LE.le.trans_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.add.proof_1",
   "Subtype.val",
   "instHAdd",
   "HAdd.hAdd",
   "Add",
   "AddSubmonoid",
   "AddZeroClass",
   "Subtype.mk",
   "SetLike.instMembership",
   "Subtype",
   "Add.mk"],
  "name": "AddSubmonoid.add",
  "constType":
  "{M : Type u_1} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → Add ↥S",
  "constCategory": "Definition"},
 {"references": ["Not"],
  "name": "mt",
  "constType": "∀ {a b : Prop}, (a → b) → ¬b → ¬a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "HMul.hMul",
   "NonUnitalNonAssocCommRing",
   "Eq"],
  "name": "NonUnitalNonAssocCommRing.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommRing α",
  "constCategory": "Other"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.nodup",
   "Iff.symm",
   "Membership.mem",
   "Iff",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Iff.trans",
   "Multiset.Nodup.ext",
   "Finset.val_inj",
   "Eq"],
  "name": "Finset.ext_iff",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, s₁ = s₂ ↔ ∀ (a : α), a ∈ s₁ ↔ a ∈ s₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.out",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = ↑n",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "MulZeroClass.mul_zero",
   "nsmulRec",
   "Real.instOneReal",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "mul_assoc",
   "Eq.mpr",
   "Real.cauchy_zero",
   "AddCommMonoid.mk",
   "Rat.instNegRat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "Real.cauchy_one",
   "add_assoc",
   "add_comm",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "Rat.field",
   "AddMonoid.mk",
   "CauSeq.Completion.instZeroCauchy",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "right_distrib",
   "instHMul",
   "CauSeq.Completion.Cauchy.ring",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "of_eq_true",
   "congr",
   "CauSeq.Completion.Cauchy",
   "Zero.mk",
   "congrArg",
   "add_zero",
   "Rat.instLinearOrderedFieldRat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Mul.mk",
   "congrFun",
   "CauSeq.Completion.instAddCauchy",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Real.ext_cauchy",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "CauSeq.Completion.instOneCauchy",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocSemiring.mk",
   "Abs.abs",
   "True",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "one_mul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Real.cauchy_mul",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "AddCommMonoid.toAddCommSemigroup",
   "CauSeq.Completion.Cauchy.field",
   "id",
   "Neg.toHasAbs",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.mk",
   "instAddNat",
   "instHAdd",
   "Real.cauchy_add",
   "AddSemigroup.toAdd",
   "One.mk",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "Field.toSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib.leftDistribClass",
   "Real.instZeroReal",
   "DivisionSemiring.toSemiring",
   "Rat.divisionRing",
   "NonUnitalSemiring.mk",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "left_distrib",
   "Real.cauchy"],
  "name": "Real.commRing.proof_12",
  "constType": "∀ (a : ℝ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "HEq",
   "eq_of_heq",
   "Eq.refl",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "Eq.ndrec",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α]\n  (motive :\n    (x : α → α → α) →\n      (x_1 x_2 : α) →\n        (x_3 x_4 x_5 : ℤ) →\n          x = HMul.hMul →\n            Mathlib.Meta.NormNum.IsInt x_1 x_3 → Mathlib.Meta.NormNum.IsInt x_2 x_4 → Int.mul x_3 x_4 = x_5 → Prop)\n  (x : α → α → α) (x_1 x_2 : α) (x_3 x_4 x_5 : ℤ) (x_6 : x = HMul.hMul) (x_7 : Mathlib.Meta.NormNum.IsInt x_1 x_3)\n  (x_8 : Mathlib.Meta.NormNum.IsInt x_2 x_4) (x_9 : Int.mul x_3 x_4 = x_5),\n  (∀ (n n_1 : ℤ),\n      motive HMul.hMul (↑n) (↑n_1) n n_1 (Int.mul n n_1) (_ : HMul.hMul = HMul.hMul)\n        (_ : Mathlib.Meta.NormNum.IsInt (↑n) n) (_ : Mathlib.Meta.NormNum.IsInt (↑n_1) n_1)\n        (_ : Int.mul n n_1 = Int.mul n n_1)) →\n    motive x x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "inferInstance",
   "instHMul",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_3",
  "constType": "∀ (a b c : ℕ), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "NormedField",
   "Real.instMulReal",
   "Real",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Eq",
   "Dist.dist",
   "Field.toCommRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Field",
   "Ring.toSub",
   "CommRing.toRing",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedField.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toField : Field α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ = ‖a‖ * ‖b‖) → NormedField α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set.image2",
   "EmptyCollection.emptyCollection",
   "False",
   "false_and",
   "Set",
   "implies_true",
   "Set.instEmptyCollectionSet",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Set.ext",
   "And",
   "Std.Logic._auxLemma.31",
   "Iff",
   "of_eq_true",
   "and_false",
   "Mathlib.Data.Set.Basic._auxLemma.8",
   "forall_congr",
   "congr",
   "Mathlib.Data.Set.NAry._auxLemma.1",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Set.image2_empty_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α}, Set.image2 f s ∅ = ∅",
  "constCategory": "Theorem"},
 {"references": ["CoheytingAlgebra", "GeneralizedCoheytingAlgebra"],
  "name": "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : CoheytingAlgebra α] → GeneralizedCoheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegMonoid",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toSubNegMonoid : SubNegMonoid G] →\n    (∀ (x : G), - -x = x) → (∀ (a b : G), -(a + b) = -b + -a) → (∀ (a b : G), a + b = 0 → -a = b) → SubtractionMonoid G",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Real",
   "Real.instMulReal",
   "HAdd.hAdd",
   "One.mk",
   "Eq.refl",
   "npowRec",
   "One.toOfNat1",
   "Real.instOneReal",
   "Eq",
   "instHMul",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Mul.mk"],
  "name": "Real.commRing.proof_17",
  "constType": "∀ (n : ℕ) (x : ℝ), npowRec (n + 1) x = npowRec (n + 1) x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "Set",
   "Multiplicative.toAdd",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "Membership.mem",
   "Submonoid.mk",
   "Submonoid.instSetLikeSubmonoid",
   "Set.preimage",
   "Submonoid.one_mem'",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "Multiplicative.ofAdd",
   "AddSubmonoid",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "AddSubsemigroup",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "Multiplicative",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Subsemigroup.mul_mem'",
   "Submonoid",
   "AddSubsemigroup.carrier",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid.proof_4",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] (x : AddSubmonoid A),\n  (fun S =>\n        {\n          toAddSubsemigroup :=\n            { carrier := ⇑Multiplicative.ofAdd ⁻¹' ↑S,\n              add_mem' :=\n                (_ :\n                  ∀ {a b : A},\n                    a ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → b ∈ ⇑Multiplicative.ofAdd ⁻¹' ↑S → a * b ∈ S.carrier) },\n          zero_mem' := (_ : 1 ∈ S.carrier) })\n      ((fun S =>\n          {\n            toSubsemigroup :=\n              { carrier := ⇑Multiplicative.toAdd ⁻¹' ↑S,\n                mul_mem' :=\n                  (_ :\n                    ∀ {a b : Multiplicative A},\n                      a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                        b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n                          Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier) },\n            one_mem' := (_ : 0 ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["AddLeftCancelSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddSemigroup",
   "Eq"],
  "name": "AddLeftCancelSemigroup.mk",
  "constType":
  "{G : Type u} → [toAddSemigroup : AddSemigroup G] → (∀ (a b c : G), a + b = a + c → b = c) → AddLeftCancelSemigroup G",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddSubmonoid.toAddZeroClass.proof_2",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Function.Injective.addZeroClass",
   "AddSubmonoid.toAddZeroClass.proof_1",
   "Subtype.val",
   "AddSubmonoid.zero",
   "Set",
   "AddSubmonoid.toAddZeroClass.proof_3",
   "AddSubmonoid.add",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Subtype",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.toAddZeroClass",
  "constType":
  "{M : Type u_5} → [inst : AddZeroClass M] → (S : AddSubmonoid M) → AddZeroClass ↥S",
  "constCategory": "Definition"},
 {"references":
  ["And", "Exists", "DenselyOrdered", "LT.lt", "LT", "DenselyOrdered.dense"],
  "name": "exists_between",
  "constType":
  "∀ {α : Type u} [inst : LT α] [inst_1 : DenselyOrdered α] {a₁ a₂ : α}, a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq"],
  "name": "congrArg₂",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "constCategory": "Theorem"},
 {"references": ["IsTrans"],
  "name": "IsTrans.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b c : α), r a b → r b c → r a c) → IsTrans α r",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0", "Zero", "OfNat.ofNat", "LT.lt", "LT", "GT.gt"],
  "name": "lt_zero_of_zero_gt",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : LT α] {a : α}, 0 > a → a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "CommGroupWithZero.toInv",
   "Int.negSucc",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "CommGroupWithZero.zpow_neg'",
  "constType":
  "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀] (n : ℕ) (a : G₀),\n  CommGroupWithZero.zpow (Int.negSucc n) a = (CommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Neg.neg",
   "SetLike.instMembership",
   "Neg",
   "NegMemClass"],
  "name": "NegMemClass.neg_mem",
  "constType":
  "∀ {S : Type u_5} {G : Type u_6} [inst : Neg G] [inst_1 : SetLike S G] [self : NegMemClass S G] {s : S} {x : G},\n  x ∈ s → -x ∈ s",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "propext", "Eq"],
  "name": "Eq.propIntro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → a = b",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.rec",
  "constType":
  "{motive : ℤ → Sort u} → ((a : ℕ) → motive (Int.ofNat a)) → ((a : ℕ) → motive (Int.negSucc a)) → (t : ℤ) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toZero",
   "HVAdd.hVAdd",
   "VAdd",
   "instHVAdd",
   "AddAction",
   "AddMonoid",
   "Eq"],
  "name": "AddAction.mk",
  "constType":
  "{G : Type u_10} →\n  {P : Type u_11} →\n    [inst : AddMonoid G] →\n      [toVAdd : VAdd G P] →\n        (∀ (p : P), 0 +ᵥ p = p) → (∀ (g₁ g₂ : G) (p : P), g₁ + g₂ +ᵥ p = g₁ +ᵥ (g₂ +ᵥ p)) → AddAction G P",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.zero_lt_succ",
   "instLTNat"],
  "name": "Nat.zero_lt_one",
  "constType": "0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "LinearOrderedCommMonoid",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "OrderedCommMonoid",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "OrderedCommMonoid.toPartialOrder",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedCommMonoid.mk",
  "constType":
  "{α : Type u_3} →\n  [toOrderedCommMonoid : OrderedCommMonoid α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["Set.preimage",
   "Finset.toSet",
   "Finset",
   "Finset.finite_toSet",
   "Set.Finite.preimage",
   "Set.InjOn",
   "Set.Finite"],
  "name": "Finset.preimage.proof_1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (s : Finset β) (f : α → β), Set.InjOn f (f ⁻¹' ↑s) → Set.Finite (f ⁻¹' ↑s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Set.Elem", "Set", "Subtype.mk", "Set.instMembershipSet"],
  "name": "Set.codRestrict",
  "constType":
  "{α : Type u_1} → {ι : Sort u_4} → (f : ι → α) → (s : Set α) → (∀ (x : ι), f x ∈ s) → ι → ↑s",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Eq.ndrec",
   "Decidable.isFalse",
   "Decidable",
   "Eq.refl",
   "Decidable.isTrue",
   "Not",
   "Eq.symm",
   "ite",
   "Eq"],
  "name": "ite_self",
  "constType":
  "∀ {α : Sort u} {c : Prop} {d : Decidable c} (a : α), (if c then a else a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5085",
   "Neg.neg",
   "Sub",
   "autoParam",
   "AddMonoid",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5202",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
   "Nat",
   "Nat.succ",
   "Int",
   "Neg",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124"],
  "name": "SubNegMonoid.mk",
  "constType":
  "{G : Type u} →\n  [toAddMonoid : AddMonoid G] →\n    [toNeg : Neg G] →\n      [toSub : Sub G] →\n        autoParam (∀ (a b : G), a - b = a + -b) _auto✝ →\n          (zsmul : ℤ → G → G) →\n            autoParam (∀ (a : G), zsmul 0 a = 0) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : G), zsmul (Int.ofNat (Nat.succ n)) a = a + zsmul (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : G), zsmul (Int.negSucc n) a = -zsmul (↑(Nat.succ n)) a) _auto✝³ →\n                  SubNegMonoid G",
  "constCategory": "Other"},
 {"references":
  ["instHMul", "Rat", "HMul.hMul", "Eq.refl", "Rat.instMulRat", "Eq"],
  "name": "Rat.field.proof_6",
  "constType":
  "∀ (a x : ℚ), (fun x x_1 => x * x_1) a x = (fun x x_1 => x * x_1) a x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "_auto._@.Mathlib.Probability.Independence.Kernel._hyg.658",
   "ProbabilityTheory.kernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "MeasurableSpace.comap",
   "autoParam",
   "Pi.addZeroClass",
   "AddSubmonoid",
   "MeasurableSpace",
   "ProbabilityTheory.kernel.Indep",
   "SetLike.instMembership",
   "Subtype"],
  "name": "ProbabilityTheory.kernel.IndepFun",
  "constType":
  "{α : Type u_1} →\n  {Ω : Type u_2} →\n    {_mα : MeasurableSpace α} →\n      {β : Type u_4} →\n        {γ : Type u_5} →\n          {_mΩ : MeasurableSpace Ω} →\n            [mβ : MeasurableSpace β] →\n              [mγ : MeasurableSpace γ] →\n                (Ω → β) → (Ω → γ) → ↥(ProbabilityTheory.kernel α Ω) → autoParam (MeasureTheory.Measure α) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "SupSet.mk",
   "Lattice.mk",
   "completeLatticeOfInf.proof_8",
   "Sup.mk",
   "Insert.insert",
   "completeLatticeOfInf.proof_12",
   "Preorder.toLE",
   "Inf.mk",
   "Set.instSingletonSet",
   "upperBounds",
   "completeLatticeOfInf.proof_10",
   "completeLatticeOfInf.proof_3",
   "completeLatticeOfInf.proof_7",
   "IsGLB",
   "completeLatticeOfInf.proof_5",
   "setOf",
   "SemilatticeSup.mk",
   "InfSet",
   "Set.instEmptyCollectionSet",
   "completeLatticeOfInf.proof_11",
   "completeLatticeOfInf.proof_2",
   "Set.univ",
   "LE.le",
   "completeLatticeOfInf.proof_6",
   "PartialOrder",
   "InfSet.mk",
   "And",
   "CompleteLattice",
   "completeLatticeOfInf.proof_1",
   "completeLatticeOfInf.proof_9",
   "Bot.mk",
   "PartialOrder.le_antisymm",
   "completeLatticeOfInf.proof_4",
   "Singleton.singleton",
   "Top.mk",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf",
  "constType":
  "(α : Type u_9) → [H1 : PartialOrder α] → [H2 : InfSet α] → (∀ (s : Set α), IsGLB s (sInf s)) → CompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["AddCommGroupWithOne", "AddCommGroup"],
  "name": "AddCommGroupWithOne.toAddCommGroup",
  "constType": "{R : Type u} → [self : AddCommGroupWithOne R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "instHAdd",
   "HAdd.hAdd",
   "HSMul.hSMul",
   "AddCommGroup.toAddCommMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "SubNegMonoid.SMulInt",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "Int"],
  "name": "Mathlib.Tactic.Abel.termg",
  "constType": "{α : Type u_1} → [inst : AddCommGroup α] → ℤ → α → α → α",
  "constCategory": "Definition"},
 {"references": ["Set", "MeasurableSet", "Measurable", "MeasurableSpace", "id"],
  "name": "measurable_id",
  "constType": "∀ {α : Type u_1} {x : MeasurableSpace α}, Measurable id",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Set.instHasSubsetSet",
   "Set",
   "HSub.hSub",
   "Set.sub",
   "HasSubset.Subset",
   "Set.image2_subset",
   "Sub"],
  "name": "Set.sub_subset_sub",
  "constType":
  "∀ {α : Type u_2} [inst : Sub α] {s₁ s₂ t₁ t₂ : Set α}, s₁ ⊆ t₁ → s₂ ⊆ t₂ → s₁ - s₂ ⊆ t₁ - t₂",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "One.toOfNat1",
   "ENNReal.one_lt_top",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "True",
   "Eq",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "eq_true",
   "Preorder.toLT",
   "LT.lt",
   "OrderedCommSemiring.toOrderedSemiring",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.MeasureTheory.Measure.Typeclasses._auxLemma.3",
  "constType": "(1 < ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Probability.Independence.Basic._hyg.514",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "Ring"],
  "name": "NormedRing.toRing",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Rat.linearOrder.proof_2",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Rat.instLERat",
   "PartialOrder.mk",
   "Max.mk",
   "Iff.rfl",
   "Rat.not_le",
   "Eq.refl",
   "Min.mk",
   "Preorder.toLE",
   "ite",
   "Eq",
   "Rat.le_antisymm",
   "inferInstance",
   "Eq.mpr",
   "Rat.le_refl",
   "Iff",
   "Decidable",
   "LinearOrder.mk",
   "compareOfLessAndEq",
   "Eq.symm",
   "Rat.le_trans",
   "id",
   "LinearOrder",
   "Rat.linearOrder.proof_1",
   "Rat.linearOrder.proof_3",
   "Rat",
   "and_iff_right_of_imp",
   "decidableEqOfDecidableLE",
   "LE.le",
   "Preorder.mk",
   "Rat.instLTRat",
   "Or.resolve_left",
   "Rat.linearOrder.proof_4",
   "And",
   "Rat.instDecidableLeRatInstLERat",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "decidableLTOfDecidableLE",
   "Not",
   "Rat.le_total"],
  "name": "Rat.linearOrder",
  "constType": "LinearOrder ℚ",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_3",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b c : Submonoid M), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["HEq", "HEq.refl"],
  "name": "HEq.rec",
  "constType":
  "{α : Sort u} →\n  {a : α} →\n    {motive : {β : Sort u} → (a_1 : β) → HEq a a_1 → Sort u_1} →\n      motive a (_ : HEq a a) → {β : Sort u} → {a_1 : β} → (t : HEq a a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalNonAssocRing.zero_mul",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
  "constType": "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a : α), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Ordering",
   "Or",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrder.mk",
  "constType":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrder α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name":
  "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α], IsAbsoluteValue abs",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Set.Elem", "Set", "Set.Finite"],
  "name": "Set.Finite.intro",
  "constType": "∀ {α : Type u} {s : Set α}, Fintype ↑s → Set.Finite s",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.mk",
  "constType": "{α : Type u} → (α → α → α) → Inf α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.45",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddGroup.add_left_neg",
   "OfNat.ofNat",
   "Complex.addCommGroup",
   "SubNegMonoid.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddCommGroup.toAddGroup",
   "Complex",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "Complex.Complex.addGroupWithOne.proof_7",
  "constType": "∀ (a : ℂ), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Inhabited",
   "instOfNatNat",
   "Nat",
   "Inhabited.mk",
   "Int"],
  "name": "Int.instInhabitedInt",
  "constType": "Inhabited ℤ",
  "constCategory": "Definition"},
 {"references": ["Nonempty.intro", "Nonempty.rec", "Nonempty"],
  "name": "Nonempty.casesOn",
  "constType":
  "∀ {α : Sort u} {motive : Nonempty α → Prop} (t : Nonempty α), (∀ (val : α), motive (_ : Nonempty α)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "of_decide_eq_true",
   "Rat",
   "Eq.refl",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "Rat.field",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Field.toCommRing",
   "Rat.instDecidableLeRatInstLERat",
   "Bool.true",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "LinearOrder.toPartialOrder",
   "Bool",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Rat.linearOrder",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.instLinearOrderedFieldRat.proof_2",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "eq_neg_add_iff_add_eq",
   "sub_eq_add_neg",
   "sub_eq_iff_eq_add",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.cast",
   "Nat",
   "Eq.trans",
   "instHSub",
   "add_assoc",
   "Nat.cast_add",
   "Int.cast_ofNat",
   "Int.instAddInt",
   "of_eq_true",
   "Int.negSucc",
   "Int.cast",
   "propext",
   "congr",
   "congrArg",
   "Int",
   "Int.subNatNat",
   "Int.cast_subNatNat",
   "AddZeroClass.toAdd",
   "Nat.add_assoc",
   "Nat.add_comm",
   "Int.cast_add.match_1",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "Nat.add_right_comm",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "NegZeroClass.toNeg",
   "neg_add_rev"],
  "name": "Int.cast_add",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.cast",
   "Rat.instIntCastRat",
   "OfNat",
   "Rat",
   "OfNat.mk",
   "Nat",
   "Int"],
  "name": "Rat.instOfNatRat",
  "constType": "{n : ℕ} → OfNat ℚ n",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Iff",
   "Real.instLTReal",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real.mk",
   "Real",
   "LT.lt",
   "Rat.instNegRat",
   "Rat",
   "Real.lt_cauchy",
   "CauSeq",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.mk_lt",
  "constType": "∀ {f g : CauSeq ℚ abs}, Real.mk f < Real.mk g ↔ f < g",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Nonempty.intro",
   "Setoid.r",
   "Quot.ind",
   "Cardinal",
   "Function.Embedding",
   "Function.Embedding.trans",
   "Cardinal.isEquivalent",
   "LE.le",
   "Nonempty.casesOn",
   "Quot.mk",
   "Cardinal.instLECardinal"],
  "name": "Cardinal.partialOrder.proof_2",
  "constType": "∀ (a b c : Cardinal.{u_1}), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.toRing",
   "OrderedCommRing",
   "OrderedCommRing.mk",
   "StrictOrderedCommRing",
   "StrictOrderedCommRing.toStrictOrderedRing",
   "OrderedRing.mul_nonneg",
   "OrderedRing.mk",
   "OrderedRing",
   "StrictOrderedCommRing.toOrderedCommRing.proof_1",
   "StrictOrderedRing.toOrderedRing",
   "StrictOrderedCommRing.mul_comm",
   "StrictOrderedCommRing.toOrderedCommRing.proof_2"],
  "name": "StrictOrderedCommRing.toOrderedCommRing",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommRing α] → OrderedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Multiplicative",
   "SubNegMonoid.toAddMonoid",
   "Monoid.npow_zero",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Monoid.npow",
   "Eq",
   "Multiplicative.monoid"],
  "name": "Multiplicative.divInvMonoid.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : SubNegMonoid α] (x : Multiplicative α), Monoid.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.isROrC.proof_5",
   "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
   "Real.normedField",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "IsROrC",
   "AddMonoid.toAddZeroClass",
   "Real.decidableEq",
   "Field.toCommRing",
   "NormedField.toField",
   "Zero.toOfNat0",
   "Real.isROrC.proof_3",
   "Real.isROrC.proof_1",
   "Real.isROrC.proof_9",
   "Real.isROrC.proof_7",
   "Real.isROrC.proof_12",
   "Real.isROrC.proof_10",
   "Real.isROrC.proof_11",
   "Real.isROrC.proof_2",
   "AddMonoidHom.id",
   "Real.denselyNormedField",
   "instZeroAddMonoidHom",
   "Real.isROrC.proof_6",
   "Real.partialOrder",
   "Ring.toSemiring",
   "Real.instStarRingRealToNonUnitalNonAssocSemiringToNonUnitalNonAssocCommSemiringToNonUnitalNonAssocCommRingToNonUnitalCommRingCommRing",
   "Real.isROrC.proof_4",
   "Real.instZeroReal",
   "Real.isROrC.proof_13",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsROrC.mk",
   "Real.isROrC.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom",
   "NormedAlgebra.id"],
  "name": "Real.isROrC",
  "constType": "IsROrC ℝ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "Prod.snd",
   "Function.bijective_iff_existsUnique",
   "instHAdd",
   "Subtype.val",
   "Set",
   "HAdd.hAdd",
   "Prod.fst",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Set.instMembershipSet",
   "AddGroup",
   "Iff",
   "Set.Elem",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.IsComplement",
   "Prod",
   "ExistsUnique"],
  "name": "AddSubgroup.isComplement_iff_existsUnique",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G}, AddSubgroup.IsComplement S T ↔ ∀ (g : G), ∃! x, ↑x.1 + ↑x.2 = g",
  "constCategory": "Theorem"},
 {"references": ["Real", "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.4598"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.le",
  "constType": "ℝ → ℝ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "NegZeroClass.neg_zero",
   "Eq"],
  "name": "neg_zero",
  "constType": "∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["HSMul", "HSMul.mk", "SMul", "SMul.smul"],
  "name": "instHSMul",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references": ["AddRightCancelSemigroup", "AddSemigroup"],
  "name": "AddRightCancelSemigroup.toAddSemigroup",
  "constType":
  "{G : Type u} → [self : AddRightCancelSemigroup G] → AddSemigroup G",
  "constCategory": "Definition"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references": ["VAdd"],
  "name": "VAdd.mk",
  "constType": "{G : Type u} → {P : Type v} → (G → P → P) → VAdd G P",
  "constCategory": "Other"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Std.Data.Rat.Basic._hyg.4",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.lintegral_indicator",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "MeasureTheory.subset_toMeasurable",
   "EmptyCollection.emptyCollection",
   "MeasureTheory.measure_if",
   "NonUnitalCommSemiring.toCommSemigroup",
   "le_rfl",
   "MeasureTheory.Measure.prod",
   "Preorder.toLE",
   "ENNReal.instLinearOrderedCommMonoidWithZeroENNReal",
   "Eq",
   "ite",
   "MeasureTheory.measurableSet_toMeasurable",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.measure_toMeasurable",
   "Eq.trans",
   "Set.instSProd",
   "CompletelyDistribLattice.toCompleteLattice",
   "setOf",
   "MeasureTheory.toMeasurable",
   "measurable_const",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Classical.propDecidable",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Set.mk_preimage_prod_right_eq_if",
   "instENNRealZero",
   "CommMagma.toMul",
   "ENNReal.measurableSpace",
   "MeasureTheory.Measure.restrict_le_self",
   "Prod.instMeasurableSpace",
   "Set.instMembershipSet",
   "mul_le_mul_right'",
   "instTransEq_1",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "MeasureTheory.set_lintegral_const",
   "le_antisymm",
   "congrArg",
   "Set.mk_mem_prod",
   "MeasurableSpace",
   "MeasureTheory.measure_mono",
   "congrFun",
   "Set.indicator",
   "CanonicallyOrderedCommSemiring.toMul",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Eq.refl",
   "MeasureTheory.Measure.restrict",
   "CommSemiring.toNonUnitalCommSemiring",
   "MeasureTheory.lintegral",
   "True",
   "mul_comm",
   "MeasureTheory.Measure",
   "SProd.sprod",
   "MeasurableSet",
   "Measurable",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.symm",
   "OrderedCommMonoid.toCovariantClassRight",
   "id",
   "eq_self",
   "MeasureTheory.Measure.prod_apply",
   "Membership.mem",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "funext",
   "Set.preimage",
   "Pi.preorder",
   "MeasureTheory.set_lintegral_mono",
   "MeasureTheory.lintegral_const",
   "instTransLeToLE",
   "Set.prod_mono",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.SFinite",
   "Set.univ",
   "LE.le",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Set.instHasSubsetSet",
   "measurable_measure_prod_mk_left",
   "Eq.ndrec",
   "Prod.mk",
   "CommSemigroup.toCommMagma",
   "MeasureTheory.Measure.restrict_apply_univ",
   "MeasurableSet.prod",
   "letFun",
   "HMul.hMul",
   "Prod",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "MeasureTheory.lintegral_mono'"],
  "name": "MeasureTheory.Measure.prod_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] (s : Set α) (t : Set β),\n  ↑↑(MeasureTheory.Measure.prod μ ν) (s ×ˢ t) = ↑↑μ s * ↑↑ν t",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Int.negSucc",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_9",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddHomClass.toFunLike",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "AddGroup",
   "Function.Injective",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Subtype.coe_injective",
   "AddSubgroup.subtype",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "AddMonoidHom"],
  "name": "AddSubgroup.subtype_injective",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), Function.Injective ⇑(AddSubgroup.subtype H)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semifield.zpow_zero'",
   "DivisionSemiring",
   "Semifield.toNontrivial",
   "Semifield.toCommSemiring",
   "DivisionSemiring.mk",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.mul_inv_cancel",
   "Semifield.zpow_neg'",
   "Semifield.zpow",
   "Semifield.toDiv",
   "Semifield.toInv",
   "Semifield",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.map",
   "PartialOrder.toPreorder",
   "Prod.snd",
   "Function.comp",
   "Eq.refl",
   "Measurable.of_le_map",
   "ConditionallyCompleteLattice.toLattice",
   "Prod.fst",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "MeasurableSpace.map_comp",
   "MeasurableSpace.comap",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Prod.instMeasurableSpace",
   "MeasurableSpace.instLEMeasurableSpace",
   "Eq.mpr",
   "Eq.ndrec",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "Prod",
   "Measurable",
   "sup_le",
   "Lattice.toSemilatticeSup",
   "MeasurableSpace",
   "MeasurableSpace.comap_le_iff_le_map",
   "SemilatticeSup.toPartialOrder",
   "id"],
  "name": "Measurable.prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n  {f : α → β × γ}, (Measurable fun a => (f a).1) → (Measurable fun a => (f a).2) → Measurable f",
  "constCategory": "Theorem"},
 {"references":
  ["LT.lt", "Nat.le_trans", "Nat", "Nat.le_step", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_trans",
  "constType": "∀ {n m k : ℕ}, n < m → m < k → n < k",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Or",
   "instHasEquiv",
   "Setoid.refl",
   "DivisionRing.toRing",
   "Or.inr",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LinearOrderedField.toField",
   "LT.lt",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (x : CauSeq α abs), x < x ∨ x ≈ x",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvMonoid",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.zero_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Int.cast_add",
   "Invertible",
   "MulZeroClass.toMul",
   "Iff.mpr",
   "Eq",
   "Semiring.toNatCast",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat",
   "mul_inv_rev",
   "Eq.trans",
   "GroupWithZero.toInv",
   "Ne",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionSemiring.toGroupWithZero",
   "Nat.cast_ne_zero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toMulZeroClass",
   "DivisionRing.toInv",
   "Int.cast_ofNat",
   "DivInvMonoid.toInv",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Inv.inv",
   "Int.ofNat",
   "DivisionRing.toDivisionSemiring",
   "instOfNatInt",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "GroupWithZero.toDivisionMonoid",
   "True",
   "Ring.toNonAssocRing",
   "invertibleOfNonzero",
   "Zero.toOfNat0",
   "Int.instRingInt",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "InvolutiveInv.toInv",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "Nat.succ",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Mathlib.Meta.NormNum.IsRat",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "inv_inv",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "invOf_eq_inv",
   "Semiring.toOne",
   "Eq.ndrec",
   "CharZero",
   "instNatCastInt",
   "letFun",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul"],
  "name": "Mathlib.Meta.NormNum.isRat_inv_pos",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] [inst_1 : CharZero α] {a : α} {n d : ℕ},\n  Mathlib.Meta.NormNum.IsRat a (Int.ofNat (Nat.succ n)) d → Mathlib.Meta.NormNum.IsRat a⁻¹ (Int.ofNat d) (Nat.succ n)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro"],
  "name": "Exists.rec",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop},\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → ∀ (t : Exists p), motive t",
  "constCategory": "Other"},
 {"references":
  ["Nat.eq_zero_of_add_eq_zero",
   "And.right",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.eq_zero_of_add_eq_zero_left",
  "constType": "∀ {n m : ℕ}, n + m = 0 → m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "PUnit.instMeasurableSpace",
   "ProbabilityTheory.kernel.const",
   "ProbabilityTheory.kernel.iIndepFun.indepFun_prod_mk",
   "Unit",
   "ProbabilityTheory.kernel.IndepFun",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.Measure.dirac",
   "ProbabilityTheory.kernel.isMarkovKernel_const",
   "Prod.instMeasurableSpace",
   "MeasureTheory.Measure",
   "ProbabilityTheory.iIndepFun.isProbabilityMeasure",
   "Prod.mk",
   "letFun",
   "Unit.unit",
   "ProbabilityTheory.iIndepFun",
   "Measurable",
   "Prod",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.iIndepFun.indepFun_prod_mk",
  "constType":
  "∀ {Ω : Type u_1} {ι : Type u_2} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {β : ι → Type u_10}\n  {m : (i : ι) → MeasurableSpace (β i)} {f : (i : ι) → Ω → β i},\n  ProbabilityTheory.iIndepFun m f →\n    (∀ (i : ι), Measurable (f i)) →\n      ∀ (i j k : ι), i ≠ k → j ≠ k → ProbabilityTheory.IndepFun (fun a => (f i a, f j a)) (f k)",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "MeasurableSpace.instLEMeasurableSpace",
   "Set.instHasSubsetSet",
   "MeasurableSpace.generateFrom_le_iff",
   "Iff.mp",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "MeasurableSpace"],
  "name": "MeasurableSpace.giGenerateFrom.proof_1",
  "constType":
  "∀ {α : Type u_1} (g : Set (Set α)), {t | MeasurableSet t} ≤ g → {t | MeasurableSet t} = g",
  "constCategory": "Theorem"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "CommSemiring.mk",
   "Field.toSemifield.proof_1",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Ring.toSemiring",
   "Semifield",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Semifield.mk",
   "Field.toDiv",
   "Field.div_eq_mul_inv"],
  "name": "Field.toSemifield",
  "constType": "{K : Type u_3} → [inst : Field K] → Semifield K",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.tail",
  "constType":
  "∀ {α : Type u} {a : α} (b : α) {as : List α}, List.Mem a as → List.Mem a (b :: as)",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubtractionCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["PProd", "Nat.rec", "PUnit", "Nat"],
  "name": "Nat.below",
  "constType": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Cardinal.lift_mk_eq.match_2",
   "Quotient.eq'",
   "Equiv.ulift",
   "Quotient",
   "Cardinal.lift_mk_eq.match_1",
   "ULift",
   "Nonempty",
   "Eq",
   "Quotient.mk'",
   "Iff.intro",
   "Setoid.r",
   "Nonempty.intro",
   "Iff",
   "Cardinal",
   "Iff.trans",
   "Cardinal.mk",
   "Cardinal.isEquivalent",
   "Equiv.trans",
   "Cardinal.lift",
   "Equiv.symm"],
  "name": "Cardinal.lift_mk_eq",
  "constType":
  "∀ {α : Type u} {β : Type v},\n  Cardinal.lift.{max v w, u} (Cardinal.mk α) = Cardinal.lift.{max u w, v} (Cardinal.mk β) ↔ Nonempty (α ≃ β)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.sets",
   "Membership.mem",
   "Set",
   "Filter",
   "Membership.mk",
   "Membership",
   "Set.instMembershipSet"],
  "name": "instMembershipSetFilter",
  "constType": "{α : Type u_1} → Membership (Set α) (Filter α)",
  "constCategory": "Definition"},
 {"references":
  ["Set.add",
   "DecidableEq",
   "instHAdd",
   "Finset.toSet",
   "Set",
   "HAdd.hAdd",
   "Finset.coe_image₂",
   "Finset",
   "Add",
   "Finset.add",
   "Eq"],
  "name": "Finset.coe_add",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] (s t : Finset α), ↑(s + t) = ↑s + ↑t",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHom.toFun",
   "instHAdd",
   "HAdd.hAdd",
   "ZeroHom",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] →\n        (toZeroHom : ZeroHom M N) →\n          (∀ (x y : M), ZeroHom.toFun toZeroHom (x + y) = ZeroHom.toFun toZeroHom x + ZeroHom.toFun toZeroHom y) →\n            M →+ N",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Subtype.val",
   "CovariantClass",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype"],
  "name": "MulPosMono",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DenselyNormedField",
   "Real.normedField",
   "Real",
   "DenselyNormedField.mk",
   "Real.denselyNormedField.proof_1"],
  "name": "Real.denselyNormedField",
  "constType": "DenselyNormedField ℝ",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "Int"],
  "name": "LinearOrderedField.zpow",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "eq_true",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "True",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), (0 ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": ["Complex.ofReal'", "Real", "rfl", "Eq", "Complex.re"],
  "name": "Complex.ofReal_re",
  "constType": "∀ (r : ℝ), (↑r).re = r",
  "constCategory": "Theorem"},
 {"references": ["MeasurableSpace"],
  "name": "MeasureTheory.Measure",
  "constType": "(α : Type u_6) → [inst : MeasurableSpace α] → Type u_6",
  "constCategory": "Other"},
 {"references":
  ["RingHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.mk",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass",
   "RingHomClass.map_add",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_zero",
   "NonAssocSemiring",
   "NonUnitalRingHomClass"],
  "name": "RingHomClass.toNonUnitalRingHomClass",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → NonUnitalRingHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "Function.Injective",
   "Eq.rec",
   "Set",
   "Set.preimage_image_eq.match_1",
   "Set.image",
   "Set.Subset.antisymm",
   "Set.subset_preimage_image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.preimage_image_eq",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} (s : Set α), Function.Injective f → f ⁻¹' (f '' s) = s",
  "constCategory": "Theorem"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.le_total",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_total",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.toAddGroup.proof_1",
   "AddSubgroup.toAddGroup.proof_6",
   "AddSubgroup.toAddGroup.proof_3",
   "Subtype.val",
   "AddSubgroup.zero",
   "AddSubgroup.toAddGroup.proof_4",
   "SetLike.instMembership",
   "Function.Injective.addGroup",
   "AddSubgroup.toAddGroup.proof_7",
   "AddSubgroup.zsmul",
   "AddGroup",
   "AddSubgroup.nsmul",
   "AddSubgroup.toAddGroup.proof_5",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.neg",
   "AddSubgroup.sub",
   "Subtype",
   "AddSubgroup.add",
   "AddSubgroup.toAddGroup.proof_2"],
  "name": "AddSubgroup.toAddGroup",
  "constType":
  "{G : Type u_5} → [inst : AddGroup G] → (H : AddSubgroup G) → AddGroup ↥H",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Rat.instLERat",
   "Rat.nonneg_mul",
   "Rat",
   "Eq.refl",
   "Rat.instOfNatRat",
   "LE.le",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "Rat.nonneg_iff_zero_le",
   "Eq.mp",
   "HMul.hMul",
   "Rat.Nonneg",
   "Rat.instMulRat",
   "Eq.symm",
   "id"],
  "name": "Rat.mul_nonneg",
  "constType": "∀ {a b : ℚ}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Injective.countable",
   "Countable",
   "Equiv.injective",
   "FunLike.coe",
   "Equiv.symm",
   "Equiv.instFunLikeEquiv"],
  "name": "Countable.of_equiv",
  "constType":
  "∀ {β : Sort v} (α : Sort u_1) [inst : Countable α], α ≃ β → Countable β",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Equiv",
   "Multiplicative",
   "Div.mk",
   "Multiplicative.toAdd",
   "HSub.hSub",
   "Div",
   "FunLike.coe",
   "Sub",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv"],
  "name": "Multiplicative.div",
  "constType": "{α : Type u} → [inst : Sub α] → Div (Multiplicative α)",
  "constCategory": "Definition"},
 {"references": ["Field", "Int"],
  "name": "Field.zpow",
  "constType": "{K : Type u} → [self : Field K] → ℤ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff",
   "instLENat",
   "instAddNat",
   "Iff.refl",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "LE.le"],
  "name": "Nat.add_one_le_iff",
  "constType": "∀ {a b : ℕ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.mk",
  "constType": "{α : Type u_9} → (Set α → α) → SupSet α",
  "constCategory": "Other"},
 {"references":
  ["OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Eq.refl",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_2",
   "Eq",
   "MeasureTheory.Measure",
   "BooleanAlgebra.toBiheytingAlgebra",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal.instTopologicalSpaceENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.iUnion",
   "Eq.rec",
   "Pairwise",
   "MeasurableSet",
   "MeasureTheory.Measure.toOuterMeasure_injective.match_1",
   "Nat",
   "Function.onFun",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Disjoint",
   "MeasureTheory.Measure.mk",
   "Set.Set.completeAtomicBooleanAlgebra",
   "tsum",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "Eq.ndrec",
   "Set.instBooleanAlgebraSet",
   "Function.Injective",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "MeasureTheory.Measure.toOuterMeasure_injective",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α], Function.Injective MeasureTheory.Measure.toOuterMeasure",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddSubmonoid.zero_mem",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toZeroHomClass",
   "Eq.refl",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddSubmonoid",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "ZeroHomClass.toFunLike",
   "letFun",
   "map_zero",
   "AddMonoidHomClass.toAddHomClass",
   "AddZeroClass",
   "id"],
  "name": "AddSubmonoid.comap.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (S : AddSubmonoid N), f 0 ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm",
   "Nat.instModNat",
   "OfNat.ofNat",
   "instHMod",
   "Iff",
   "Nat.dvd_iff_mod_eq_zero",
   "Nat.instDvdNat",
   "HMod.hMod",
   "instOfNatNat",
   "Dvd.dvd",
   "Nat",
   "Eq"],
  "name": "Nat.decidable_dvd.proof_1",
  "constType": "∀ (x x_1 : ℕ), x_1 % x = 0 ↔ x ∣ x_1",
  "constCategory": "Theorem"},
 {"references":
  ["Function.LeftInverse",
   "funext",
   "Function.RightInverse",
   "Set.preimage_subset_image_of_inverse",
   "Set.preimage",
   "Set",
   "Set.image_subset_preimage_of_inverse",
   "Set.image",
   "Set.Subset.antisymm",
   "Eq"],
  "name": "Set.image_eq_preimage_of_inverse",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {g : β → α},\n  Function.LeftInverse g f → Function.RightInverse g f → Set.image f = Set.preimage g",
  "constCategory": "Theorem"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.le_sup_left",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_5",
  "constType": "∀ {α : Type u_1} (a b : α → Prop), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "congr_arg",
   "LinearOrder",
   "Trans.trans",
   "SubNegMonoid.toNeg",
   "instDistribLattice",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Abs.abs",
   "Eq",
   "DistribLattice.toLattice",
   "SubNegMonoid.toSub",
   "AddGroup",
   "SemilatticeSup.toSup",
   "SubtractionMonoid.toSubNegMonoid",
   "abs_neg",
   "instTransEq",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_sub",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs_sub_comm",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] (a b : α), |a - b| = |b - a|",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "NatCast",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Nat.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Nat",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "NatCast.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNatCast"],
  "name": "CauSeq.instNatCast",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → NatCast (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "Complex.log_zero",
   "Eq.trans",
   "Complex.instOneComplex",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "eq_self",
   "Ne",
   "Complex.instZeroComplex",
   "False",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.exp_zero",
   "NormedField.toNormedCommRing",
   "instDecidableTrue",
   "ite_congr",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "instDecidableFalse",
   "eq_false",
   "of_eq_true",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Complex.log",
   "Complex",
   "Not",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.zero_cpow",
  "constType": "∀ {x : ℂ}, x ≠ 0 → 0 ^ x = 0",
  "constCategory": "Theorem"},
 {"references": ["GeneralizedCoheytingAlgebra", "Lattice"],
  "name": "GeneralizedCoheytingAlgebra.toLattice",
  "constType":
  "{α : Type u_4} → [self : GeneralizedCoheytingAlgebra α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Pi.booleanAlgebra",
   "DistribLattice.le_sup_inf",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_11",
  "constType":
  "∀ {α : Type u_1} (x y z : α → Prop), (x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ y ⊓ z",
  "constCategory": "Theorem"},
 {"references":
  ["instLENat",
   "instAddNat",
   "Nat.le_add_right",
   "instHAdd",
   "Eq.rec",
   "HAdd.hAdd",
   "Nat",
   "LE.le",
   "Eq"],
  "name": "Nat.le.intro",
  "constType": "∀ {n m k : ℕ}, n + k = m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.noConfusionType", "Eq.ndrec", "Eq.refl", "Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : ℕ} → v1 = v2 → Nat.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Distrib.rightDistribClass",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "right_distrib",
   "instHMul",
   "Eq.ndrec",
   "NonUnitalNonAssocRing.zero_mul",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "InvolutiveNeg.mk",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalNonAssocRing α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set.univ",
   "Eq",
   "Set.instMembershipSet",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "Set.iUnion",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.Measure.FiniteSpanningSetsIn",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "Nat",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.FiniteSpanningSetsIn.mk",
  "constType":
  "{α : Type u_1} →\n  {m0 : MeasurableSpace α} →\n    {μ : MeasureTheory.Measure α} →\n      {C : Set (Set α)} →\n        (set : ℕ → Set α) →\n          (∀ (i : ℕ), set i ∈ C) →\n            (∀ (i : ℕ), ↑↑μ (set i) < ⊤) → ⋃ i, set i = Set.univ → MeasureTheory.Measure.FiniteSpanningSetsIn μ C",
  "constCategory": "Other"},
 {"references":
  ["Set.addMonoid.proof_1",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "Set",
   "Eq.refl",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "Eq",
   "Set.addSemigroup",
   "zsmulRec",
   "AddZeroClass.toZero",
   "SubtractionMonoid.toSubNegMonoid",
   "InvolutiveNeg.toNeg",
   "SubNegMonoid.toAddMonoid",
   "Int",
   "Set.addZeroClass"],
  "name": "Set.subtractionMonoid.proof_7",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a : Set α), zsmulRec 0 a = zsmulRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "propext",
   "zero_eq_mul",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.2",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (0 = a * b) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.neg",
   "InvolutiveNeg",
   "Set.involutiveNeg.proof_1",
   "InvolutiveNeg.toNeg",
   "Set",
   "Neg.neg",
   "InvolutiveNeg.mk",
   "Neg.mk"],
  "name": "Set.involutiveNeg",
  "constType":
  "{α : Type u_2} → [inst : InvolutiveNeg α] → InvolutiveNeg (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Monoid.toMulAction",
   "MulOneClass.toMul",
   "MulAction.toSMul",
   "instHSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction.mul_smul",
   "Monoid.toMulOneClass",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero.proof_2",
  "constType":
  "∀ (R : Type u_1) [inst : MonoidWithZero R] (x y b : R), (x * y) • b = x • y • b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "one_mul",
   "instZeroAdditive",
   "MulOneClass",
   "instHAdd",
   "MulOneClass.toOne",
   "Additive.add",
   "HAdd.hAdd",
   "Zero.mk",
   "mul_one",
   "AddZeroClass.mk",
   "AddZeroClass",
   "Add.mk",
   "Additive"],
  "name": "Additive.addZeroClass",
  "constType":
  "{α : Type u} → [inst : MulOneClass α] → AddZeroClass (Additive α)",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "Commute.eq",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "congrArg",
   "Eq.trans",
   "True",
   "Commute",
   "Semigroup",
   "Eq"],
  "name": "Commute.right_comm",
  "constType":
  "∀ {S : Type u_2} [inst : Semigroup S] {b c : S}, Commute b c → ∀ (a : S), a * b * c = a * c * b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set.preimage",
   "AddHomClass.toFunLike",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "map_add",
   "AddMonoidHomClass",
   "FunLike.coe",
   "AddSubmonoid",
   "SetLike.instMembership",
   "Eq",
   "Set.instMembershipSet",
   "Eq.mpr",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "letFun",
   "AddSubmonoid.add_mem",
   "AddMonoidHomClass.toAddHomClass",
   "AddZeroClass",
   "id",
   "SetLike.coe"],
  "name": "AddSubmonoid.comap.proof_1",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (S : AddSubmonoid N) {a b : M}, a ∈ ⇑f ⁻¹' ↑S → b ∈ ⇑f ⁻¹' ↑S → f (a + b) ∈ S",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype",
   "Finset",
   "HasSubset.Subset",
   "Finset.mem_univ",
   "Finset.instMembershipFinset",
   "Finset.instHasSubsetFinset"],
  "name": "Finset.subset_univ",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (s : Finset α), s ⊆ Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "Real",
   "Complex.ofReal_exp_ofReal_re",
   "Complex",
   "Real.exp",
   "Complex.exp",
   "Eq"],
  "name": "Complex.ofReal_exp",
  "constType": "∀ (x : ℝ), ↑(Real.exp x) = Complex.exp ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nonempty.intro",
   "Exists",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Fin",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "Finite.to_countable.match_1",
  "constType":
  "∀ {α : Sort u_1} (motive : (∃ n, Nonempty (α ≃ Fin n)) → Prop) (x : ∃ n, Nonempty (α ≃ Fin n)),\n  (∀ (w : ℕ) (e : α ≃ Fin w), motive (_ : ∃ n, Nonempty (α ≃ Fin n))) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Inf",
   "Inf.inf",
   "LE.le",
   "SemilatticeInf",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeInf.mk",
  "constType":
  "{α : Type u} →\n  [toInf : Inf α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ⊓ b ≤ a) →\n        (∀ (a b : α), a ⊓ b ≤ b) → (∀ (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c) → SemilatticeInf α",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "instHAdd",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instAddMonoidReal",
   "Complex.instAddComplex",
   "AddMonoid.toAddZeroClass",
   "True",
   "Iff.mpr",
   "Eq",
   "Complex.re",
   "Complex.ext_iff",
   "Complex.im",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "AddZeroClass.toZero",
   "And",
   "of_eq_true",
   "congr",
   "Complex",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "and_self"],
  "name": "Complex.ofReal_add",
  "constType": "∀ (r s : ℝ), ↑(r + s) = ↑r + ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul", "MulOneClass", "Subsemigroup", "Submonoid"],
  "name": "Submonoid.toSubsemigroup",
  "constType":
  "{M : Type u_4} → [inst : MulOneClass M] → Submonoid M → Subsemigroup M",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommRing", "StrictOrderedRing"],
  "name": "StrictOrderedCommRing.toStrictOrderedRing",
  "constType":
  "{α : Type u_2} → [self : StrictOrderedCommRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Nat.le_of_succ_le_succ",
   "LT.lt",
   "HAdd.hAdd",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat"],
  "name": "Nat.lt_of_succ_lt_succ",
  "constType": "∀ {n m : ℕ}, Nat.succ n < Nat.succ m → n < m",
  "constCategory": "Theorem"},
 {"references": ["IsCommutative", "Eq"],
  "name": "IsCommutative.mk",
  "constType":
  "∀ {α : Type u} {op : α → α → α}, (∀ (a b : α), op a b = op b a) → IsCommutative α op",
  "constCategory": "Other"},
 {"references":
  ["IsROrC.toNormedAlgebra",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "NormedAlgebra.toAlgebra",
   "Real",
   "Real.normedField",
   "DenselyNormedField.toNormedField",
   "RingHom.charZero_iff",
   "IsROrC",
   "RingHom.injective",
   "NormedField.toField",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "SeminormedCommRing.toSeminormedRing",
   "Iff.mp",
   "Real.instCommSemiringReal",
   "Real.strictOrderedSemiring",
   "NormedRing.toRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsROrC.toDenselyNormedField",
   "Ring.toAddGroupWithOne",
   "algebraMap",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Real.instDivisionRingReal",
   "DivisionSemiring.toSemiring",
   "NormedCommRing.toSeminormedCommRing",
   "StrictOrderedSemiring.to_charZero",
   "CharZero",
   "Field.toEuclideanDomain",
   "Semifield.toDivisionSemiring",
   "EuclideanDomain.toNontrivial"],
  "name": "IsROrC.charZero_isROrC",
  "constType": "∀ {K : Type u_1} [inst : IsROrC K], CharZero K",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Real.instLTReal",
   "propext",
   "LT.lt",
   "Real.instLEReal",
   "Real",
   "LE.le",
   "_private.Mathlib.Data.Real.Basic.0.Real.le_def'",
   "Eq"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.6",
  "constType": "∀ {x y : ℝ}, (x ≤ y) = (x < y ∨ x = y)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} (motive : Mathlib.Meta.NormNum.IsNat a 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a 0), (∀ (e : a = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat a 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "starMulAut",
   "NonUnitalCommSemiring.toCommSemigroup",
   "MulAut",
   "CommSemiring.toNonUnitalCommSemiring",
   "Semiring.toNonAssocSemiring",
   "starRingAut.proof_3",
   "InvolutiveStar.toStar",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "AddEquiv.toEquiv",
   "StarRing",
   "starRingAut.proof_2",
   "StarRing.toStarMul",
   "starRingAut.proof_1",
   "RingAut",
   "Star.star",
   "AddSemigroup.toAdd",
   "RingEquiv.mk",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddEquiv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "starAddEquiv",
   "StarRing.toStarAddMonoid",
   "Equiv.invFun",
   "starRingAut.proof_4",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Equiv.mk",
   "StarAddMonoid.toInvolutiveStar"],
  "name": "starRingAut",
  "constType":
  "{R : Type u} → [inst : CommSemiring R] → [inst_1 : StarRing R] → RingAut R",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero.toOfNat0",
   "Membership.mem",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddSubsemigroup.carrier",
   "AddSubmonoid",
   "AddZeroClass",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.zero_mem'",
  "constType":
  "∀ {M : Type u_4} [inst : AddZeroClass M] (self : AddSubmonoid M), 0 ∈ self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Set",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "MeasureTheory.IsProbabilityMeasure",
   "NonAssocSemiring.toMulZeroOneClass",
   "CanonicallyOrderedCommSemiring.toOne",
   "MeasureTheory.Measure.prod",
   "Eq",
   "MeasureTheory.IsProbabilityMeasure.mk",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "SProd.sprod",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "id",
   "Set.instSProd",
   "MulOneClass.toOne",
   "Set.univ_prod_univ",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Set.univ",
   "Prod.instMeasurableSpace",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "instHMul",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "mul_one",
   "Prod",
   "MeasureTheory.Measure.prod_prod",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.prod.instIsProbabilityMeasure",
  "constType":
  "∀ {α : Type u_7} {β : Type u_8} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} (μ : MeasureTheory.Measure α)\n  (ν : MeasureTheory.Measure β) [inst : MeasureTheory.IsProbabilityMeasure μ]\n  [inst : MeasureTheory.IsProbabilityMeasure ν], MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.prod μ ν)",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "Eq.refl",
   "MulZeroClass.mul_zero",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "MulZeroClass.toMul",
   "DivInvMonoid.toInv",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "GroupWithZero",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero",
   "GroupWithZero.toInv",
   "DivInvMonoid.toDiv",
   "id",
   "Inv.inv"],
  "name": "div_zero",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (a : G₀), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "List.Perm", "List", "Setoid.mk", "List.Perm.eqv"],
  "name": "List.isSetoid",
  "constType": "(α : Type u_1) → Setoid (List α)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "ProbabilityTheory.entropy_comp_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "add_nonpos",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Trans.trans",
   "PartialOrder.toPreorder",
   "SubNegMonoid.toNeg",
   "Real.instAddMonoidReal",
   "AddCommGroup.toAddCommMonoid",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Real.linearOrder",
   "le_of_not_gt",
   "Mathlib.Tactic.Ring.neg_congr",
   "AddTorsor.nonempty",
   "addGroupIsAddTorsor",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Prod.snd",
   "Prod.mk.injEq",
   "Function.comp",
   "Real.instRingReal",
   "AddCommMagma.toAdd",
   "Prod.instMeasurableSpace",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "instFiniteRangeHSubForAllInstHSubInstSubToSubToSubNegAddMonoid",
   "eq_true",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Prod.instMeasurableSingletonClass",
   "AddCommGroup",
   "Int",
   "MeasurableSpace",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "sub_nonpos_of_le",
   "Real",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "Mathlib.Tactic.Ring.sub_pf",
   "MeasureTheory.Measure",
   "AddMonoid.toAddSemigroup",
   "Eq.rec",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Measurable",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "neg_nonpos_of_nonneg",
   "NonUnitalNonAssocRing.toMul",
   "ProbabilityTheory.entropy_sub_comm",
   "Ring.toAddGroupWithOne",
   "Real.instLTReal",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "add_lt_of_le_of_neg",
   "instTransLeToLE",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "sub_add_cancel",
   "Countable",
   "sub_neg_of_lt",
   "Measurable.prod_mk",
   "Eq.ndrec",
   "ProbabilityTheory.entropy_assoc",
   "Prod.mk",
   "Real.instPreorderReal",
   "letFun",
   "HSub",
   "Measurable.prod",
   "Prod",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.atom_pf",
   "and_self",
   "ProbabilityTheory.mutualInfo_nonneg",
   "Real.orderedAddCommGroup",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "sub_sub_sub_cancel_right",
   "prod",
   "Real.instLEReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "sub_add_sub_cancel",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "FiniteRange",
   "Real.instCommSemiringReal",
   "MonoidWithZero.toMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Eq.trans",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Real.partialOrder",
   "Prod.Nonempty",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Prod.fst",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instTransEq_1",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "Real.orderedAddCommMonoid",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "instFiniteRangeProdProd",
   "Eq.mp",
   "Real.instAddGroupReal",
   "congrArg",
   "neg_sub",
   "ProbabilityTheory.IndepFun",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "ProbabilityTheory.entropy_triple_add_entropy_le",
   "Pi.instSub",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Linarith.lt_irrefl",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "MeasurableSub₂",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "outParam",
   "Preorder.toLT",
   "instHPow",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "ProbabilityTheory.entropy_of_comp_eq_of_comp",
   "HAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "Measurable.sub'",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "funext",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "instCountableProd",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Real.instZeroReal",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Measurable.sub",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "ProbabilityTheory.entropy_pair_eq_add"],
  "name": "ent_of_diff_le",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_5} [mΩ : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [hG : MeasurableSpace G]\n  [inst : MeasurableSingletonClass G] [inst : AddCommGroup G] [inst_1 : MeasurableSub₂ G] [inst_2 : Countable G]\n  (X Y Z : Ω → G),\n  Measurable X →\n    Measurable Y →\n      Measurable Z →\n        ProbabilityTheory.IndepFun (⟨X, Y⟩) Z →\n          ∀ [inst_3 : MeasureTheory.IsProbabilityMeasure μ] [inst_4 : FiniteRange X] [inst_5 : FiniteRange Y]\n            [inst_6 : FiniteRange Z], H[X - Y ; μ] ≤ H[X - Z ; μ] + H[Z - Y ; μ] - H[Z ; μ]",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Additive",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "ENNReal.instInvENNReal",
   "instENNRealZero",
   "True",
   "iff_self",
   "Eq",
   "Mathlib.Data.Real.ENNReal._auxLemma.73",
   "Zero.toOfNat0",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "Iff",
   "of_eq_true",
   "CompleteLattice.toTop",
   "Not",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Inv.inv"],
  "name": "ENNReal.inv_ne_zero",
  "constType": "∀ {a : ENNReal}, a⁻¹ ≠ 0 ↔ a ≠ ⊤",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Dvd",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Inf.inf",
   "AddSubgroup.instInfAddSubgroup",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubgroup.toAddGroup",
   "SetLike.instMembership",
   "Eq",
   "AddSubgroup.map",
   "Subtype.image_preimage_coe",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "SetLike.ext'",
   "AddSubgroup.addSubgroupOf",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.subtype",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.addSubgroupOf_map_subtype",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H K : AddSubgroup G),\n  AddSubgroup.map (AddSubgroup.subtype K) (AddSubgroup.addSubgroupOf H K) = H ⊓ K",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.neg.proof_1",
   "Subtype.val",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toNeg",
   "Neg",
   "Neg.mk",
   "Subtype",
   "Subtype.mk",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.coe"],
  "name": "AddSubgroup.neg",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Neg ↥H",
  "constCategory": "Definition"},
 {"references":
  ["Set.instSProd",
   "Set.prod_univ",
   "Set.preimage",
   "SProd.sprod",
   "Set",
   "Prod",
   "Prod.fst",
   "Set.univ",
   "Eq.symm",
   "Eq"],
  "name": "PFR.Mathlib.Probability.Independence.Basic._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Set α}, Prod.fst ⁻¹' s = s ×ˢ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Set.image_eq_preimage_of_inverse",
   "Set.preimage",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "Eq",
   "add_neg_cancel_right",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Set.image",
   "congrArg",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "congrFun",
   "id"],
  "name": "Set.image_add_right",
  "constType":
  "∀ {α : Type u_2} [inst : AddGroup α] {t : Set α} {b : α}, (fun x => x + b) '' t = (fun x => x + -b) ⁻¹' t",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Eq",
   "Algebra.toRingHom",
   "RingHomClass.toNonUnitalRingHomClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def'",
  "constType":
  "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [self : Algebra R A] (r : R) (x : A),\n  r • x = Algebra.toRingHom r * x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0", "Zero", "Nonempty.intro", "OfNat.ofNat", "Nonempty"],
  "name": "Zero.nonempty",
  "constType": "∀ {α : Type u_2} [inst : Zero α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "False",
   "Nat.noConfusion",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.zero_ne_one",
  "constType": "0 ≠ 1",
  "constCategory": "Theorem"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "OrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "HVAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "IsTotal",
   "SemilatticeInf.toPartialOrder",
   "total_of",
   "Lattice",
   "LE.le",
   "Preorder.toLE"],
  "name": "Lattice.toLinearOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : Lattice α] [inst_1 : IsTotal α fun x x_1 => x ≤ x_1] (a b : α), a ≤ b ∨ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "Preorder.toLT",
   "Subtype.val",
   "LT.lt",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Preorder.toLE",
   "Subtype",
   "ContravariantClass"],
  "name": "PosMulReflectLT",
  "constType":
  "(α : Type u_1) → [inst : Mul α] → [inst : Zero α] → [inst : Preorder α] → Prop",
  "constCategory": "Definition"},
 {"references": ["SupSet", "Set"],
  "name": "SupSet.sSup",
  "constType": "{α : Type u_9} → [self : SupSet α] → Set α → α",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "CompleteSemilatticeInf.toPartialOrder",
   "AddSubmonoid.toSubmonoid.proof_6",
   "PartialOrder.toPreorder",
   "AddSubsemigroup.mk",
   "Multiplicative.toAdd",
   "AddSubmonoid.toSubmonoid.proof_4",
   "Preorder.toLE",
   "AddSubmonoid.zero_mem'",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "AddZeroClass",
   "Multiplicative.mulOneClass",
   "OrderIso",
   "Submonoid.mk",
   "AddSubmonoid.toSubmonoid.proof_5",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "FunLike.coe",
   "LE.le",
   "AddSubmonoid",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv",
   "AddSubmonoid.toSubmonoid.proof_3",
   "AddSubmonoid.toSubmonoid.proof_1",
   "Multiplicative",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Equiv.mk",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "RelIso.mk",
   "AddSubmonoid.toSubmonoid.proof_2",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid",
  "constType":
  "{A : Type u_4} → [inst : AddZeroClass A] → AddSubmonoid A ≃o Submonoid (Multiplicative A)",
  "constCategory": "Definition"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "Std.Logic._auxLemma.22",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "Nat",
   "ElementaryAddCommGroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "addOrderOf"],
  "name": "ElementaryAddCommGroup.orderOf_of_ne",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] {p : outParam ℕ} [self : ElementaryAddCommGroup G p] {x : G},\n  x ≠ 0 → addOrderOf x = p",
  "constCategory": "Definition"},
 {"references": ["Set", "Not", "Set.Finite"],
  "name": "Set.Infinite",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toMulAction",
   "Monoid",
   "MulAction.toSMul",
   "IsScalarTower.mk",
   "MulAction.mul_smul",
   "IsScalarTower",
   "MulAction"],
  "name": "IsScalarTower.left",
  "constType":
  "∀ (M : Type u_1) {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α], IsScalarTower M M α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt.rec",
   "Mathlib.Meta.NormNum.IsInt",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.casesOn",
  "constType":
  "{α : Type u_1} →\n  [inst : Ring α] →\n    {a : α} →\n      {n : ℤ} →\n        {motive : Mathlib.Meta.NormNum.IsInt a n → Sort u} →\n          (t : Mathlib.Meta.NormNum.IsInt a n) →\n            ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsInt a n)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "Iff",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.cast_inj",
   "OrderedSemiring.toSemiring",
   "Cardinal",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Cardinal.instCharZeroCardinalToAddMonoidWithOneToAddCommMonoidWithOneToNonAssocSemiringToSemiringToOrderedSemiringToOrderedCommSemiringCanonicallyOrderedCommSemiring",
   "Cardinal.canonicallyOrderedCommSemiring",
   "Eq"],
  "name": "Cardinal.natCast_inj",
  "constType": "∀ {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr"],
  "name": "Or.rec",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop},\n  (∀ (h : a), motive (_ : a ∨ b)) → (∀ (h : b), motive (_ : a ∨ b)) → ∀ (t : a ∨ b), motive t",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMonoidWithOne",
   "Eq"],
  "name": "AddCommMonoidWithOne.add_comm",
  "constType":
  "∀ {R : Type u_1} [self : AddCommMonoidWithOne R] (a b : R), a + b = b + a",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "CommMonoid",
   "HMul.hMul",
   "CommMonoid.toMonoid",
   "Eq"],
  "name": "CommMonoid.mul_comm",
  "constType": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["add_assoc",
   "Set.image2",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.image2_assoc",
   "AddSemigroup",
   "Eq"],
  "name": "Set.addSemigroup.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddSemigroup α] (x x_1 x_2 : Set α),\n  Set.image2 (fun x x_3 => x + x_3) (Set.image2 (fun x x_3 => x + x_3) x x_1) x_2 =\n    Set.image2 (fun x x_3 => x + x_3) x (Set.image2 (fun x x_3 => x + x_3) x_1 x_2)",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "forall_exists_index.match_1"],
  "name": "Exists.imp",
  "constType":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "SMul.mk",
   "instHSMul",
   "MeasureTheory.Measure.mk",
   "MeasureTheory.Measure.instSMul.proof_1",
   "IsScalarTower",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasureTheory.OuterMeasure.instSMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Algebra.id",
   "Algebra.toSMul",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.Measure.instSMul.proof_2"],
  "name": "MeasureTheory.Measure.instSMul",
  "constType":
  "{α : Type u_1} →\n  {R : Type u_6} →\n    [inst : SMul R ENNReal] →\n      [inst : IsScalarTower R ENNReal ENNReal] → [inst : MeasurableSpace α] → SMul R (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real.instLTReal",
   "Real.instMulReal",
   "Real",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.normedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "instHMul",
   "Real.rpow_pos_of_pos",
   "NormedCommRing.toSeminormedCommRing",
   "instHPow",
   "Real.strictOrderedSemiring",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "mul_pos",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Mathlib.Tactic.RPowRing.pow_pos",
  "constType": "∀ {a b e : ℝ}, 0 < a → 0 < b → 0 < a ^ e * b",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial.exists_pair_ne", "Ne", "Exists", "Nontrivial"],
  "name": "exists_pair_ne",
  "constType": "∀ (α : Type u_3) [inst : Nontrivial α], ∃ x y, x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Set.preimage",
   "One.toOfNat1",
   "MeasureTheory.IsProbabilityMeasure",
   "Set.univ",
   "CanonicallyOrderedCommSemiring.toOne",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "True",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "MeasureTheory.IsProbabilityMeasure.mk",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "eq_true",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "MeasurableSet",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.3",
   "MeasureTheory.Measure.map_apply_of_aemeasurable",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "AEMeasurable",
   "congrFun"],
  "name": "MeasureTheory.isProbabilityMeasure_map",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  [inst_1 : MeasureTheory.IsProbabilityMeasure μ] {f : α → β},\n  AEMeasurable f → MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.map f μ)",
  "constCategory": "Theorem"},
 {"references": ["NonAssocSemiring"],
  "name": "RingHom",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": ["LinearOrderedSemiring", "Max"],
  "name": "LinearOrderedSemiring.toMax",
  "constType": "{α : Type u} → [self : LinearOrderedSemiring α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Set.image2_swap",
   "Set.image2",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.image_image2_distrib",
   "Set",
   "Eq.refl",
   "Set.image",
   "id",
   "Eq"],
  "name": "Set.image_image2_antidistrib",
  "constType":
  "∀ {α : Type u_1} {α' : Type u_2} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ}\n  {s : Set α} {t : Set β} {g : γ → δ} {f' : β' → α' → δ} {g₁ : β → β'} {g₂ : α → α'},\n  (∀ (a : α) (b : β), g (f a b) = f' (g₁ b) (g₂ a)) → g '' Set.image2 f s t = Set.image2 f' (g₁ '' t) (g₂ '' s)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.subtype.proof_2",
   "AddSubgroup.subtype.proof_1",
   "ZeroHom.mk",
   "Subtype.val",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "AddZeroClass.toZero",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.subtype",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → ↥H →+ G",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "Monotone.reflect_lt",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulPosReflectLT",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "monotone_mul_right_of_nonneg",
   "Preorder.toLE",
   "Subtype.property",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "HMul.hMul",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder",
   "ContravariantClass.mk",
   "Subtype"],
  "name": "LinearOrderedSemiring.toMulPosReflectLT",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α], MulPosReflectLT α",
  "constCategory": "Definition"},
 {"references": ["Function.IsFixedPt", "Nat.iterate", "Nat"],
  "name": "Function.IsPeriodicPt",
  "constType": "{α : Type u_1} → (α → α) → ℕ → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Ring.zsmul_succ'",
  "constType":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "Subtype.val",
   "HMul.hMul",
   "Preorder",
   "Mul",
   "LE.le",
   "Subtype.mk",
   "Subtype",
   "Preorder.toLE",
   "CovariantClass.elim"],
  "name": "mul_le_mul_of_nonneg_left",
  "constType":
  "∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],\n  b ≤ c → 0 ≤ a → a * b ≤ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OneHom.toFun",
   "AddZeroClass.toZero",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_zero'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β),\n  OneHom.toFun (↑↑self) 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "Set",
   "AddGroup.toSubtractionMonoid",
   "AddSubgroup.toAddSubmonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "AddSubmonoid.map",
   "AddGroup",
   "AddSubgroup",
   "AddSubmonoid.mk",
   "Set.image",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.add_mem'",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubgroup.neg_mem",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "And",
   "Eq.ndrec",
   "AddMonoidHom.map_neg",
   "SubNegMonoid.toAddMonoid",
   "And.intro",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "AddMonoidHom",
   "SetLike.coe"],
  "name": "AddSubgroup.map.proof_3",
  "constType":
  "∀ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup G) {x : N},\n  x ∈\n      {\n            toAddSubsemigroup :=\n              { carrier := ⇑f '' ↑H,\n                add_mem' :=\n                  (_ :\n                    ∀ {a b : N},\n                      a ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                        b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                          a + b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier) },\n            zero_mem' :=\n              (_ : 0 ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier) }.toAddSubsemigroup.carrier →\n    -x ∈\n      {\n            toAddSubsemigroup :=\n              { carrier := ⇑f '' ↑H,\n                add_mem' :=\n                  (_ :\n                    ∀ {a b : N},\n                      a ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                        b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier →\n                          a + b ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier) },\n            zero_mem' :=\n              (_ : 0 ∈ (AddSubmonoid.map f H.toAddSubmonoid).toAddSubsemigroup.carrier) }.toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.inf_le_right",
  "constType": "∀ {α : Type u} [self : Lattice α] (a b : α), a ⊓ b ≤ b",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "zpowRec",
   "LinearOrder.decidableLE",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int"],
  "name": "Real.instLinearOrderedFieldReal.proof_7",
  "constType": "∀ (a : ℝ), zpowRec 0 a = zpowRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "neg_zsmul",
   "AddCommGroup.toDivisionAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Eq",
   "Eq.mpr",
   "HSMul.hSMul",
   "Int.instNegInt",
   "AddCommGroup.toAddGroup",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "add_comm",
   "instHAdd",
   "Mathlib.Tactic.Abel.termg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "AddCommGroup",
   "NegZeroClass.toNeg",
   "congrArg",
   "Int",
   "neg_add_rev",
   "congrFun"],
  "name": "Mathlib.Tactic.Abel.term_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (n : ℤ) (x a : α) (n' : ℤ) (a' : α),\n  -n = n' → -a = a' → -Mathlib.Tactic.Abel.termg n x a = Mathlib.Tactic.Abel.termg n' x a'",
  "constCategory": "Theorem"},
 {"references":
  ["Ring.zsmul",
   "SeminormedCommRing.toSeminormedRing",
   "Nat.cast",
   "Ring.toNeg",
   "SeminormedRing.toRing",
   "instNatCastInt",
   "Int.negSucc",
   "Neg.neg",
   "Nat",
   "SeminormedCommRing",
   "Nat.succ",
   "Int",
   "Eq",
   "Ring.zsmul_neg'"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_4",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.negSucc n) a = -Ring.zsmul (↑(Nat.succ n)) a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Exists",
   "OfNat.ofNat",
   "Trans.trans",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Real.instAddMonoidReal",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "MeasureTheory.IsProbabilityMeasure",
   "Exists.casesOn",
   "MeasurableSub₂",
   "MeasureTheory.MeasureSpace.volume",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "MeasurableSingletonClass",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Fintype",
   "instFiniteRange",
   "rdist",
   "rdist_triangle",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "Measurable",
   "exists_isUniform_of_rdist_self_eq_zero",
   "And.casesOn",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Finite.to_countable",
   "rdist_nonneg",
   "rdist_symm",
   "Real.partialOrder",
   "instHAdd",
   "AddCommMagma.toAdd",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "MeasurableAdd₂",
   "Real.instZeroReal",
   "instTransEq_1",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "And",
   "Eq.ndrec",
   "MeasureTheory.MeasureSpace",
   "letFun",
   "And.intro",
   "AddCommGroup",
   "le_antisymm",
   "Finite.of_fintype",
   "MeasurableSpace",
   "ProbabilityTheory.IsUniform",
   "SetLike.coe"],
  "name": "exists_isUniform_of_rdist_eq_zero",
  "constType":
  "∀ {Ω : Type u_1} {G : Type u_2} [inst : MeasureTheory.MeasureSpace Ω]\n  [inst_1 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] [inst_2 : AddCommGroup G] [inst_3 : Fintype G]\n  [inst_4 : MeasurableSpace G] [inst_5 : MeasurableAdd₂ G] [inst_6 : MeasurableSub₂ G] {X : Ω → G}\n  [inst_7 : MeasurableSingletonClass G] {Ω' : Type u_3} [inst_8 : MeasureTheory.MeasureSpace Ω']\n  [inst_9 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {X' : Ω' → G},\n  Measurable X →\n    Measurable X' →\n      d[X # X'] = 0 → ∃ H U, Measurable U ∧ ProbabilityTheory.IsUniform (↑H) U ∧ d[X # U] = 0 ∧ d[X' # U] = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
  "constType":
  "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Iff.intro",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "Iff",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mul_eq_zero_of_right",
   "Or.elim",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Subsemigroup.carrier",
   "Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "MulOneClass",
   "Set",
   "Eq.refl",
   "Submonoid.casesOn",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "Additive.toMul",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "Submonoid.mk",
   "Membership.mem",
   "Set.preimage",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.one_mem'",
   "MulOneClass.toOne",
   "AddSubmonoid.toAddSubsemigroup",
   "Subsemigroup",
   "One.toOfNat1",
   "AddSubsemigroup.add_mem'",
   "Additive.ofMul",
   "FunLike.coe",
   "Additive.addZeroClass",
   "AddSubmonoid",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Subsemigroup.mul_mem'",
   "Submonoid",
   "SetLike.coe",
   "Additive"],
  "name": "Submonoid.toAddSubmonoid.proof_4",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x : Submonoid M),\n  (fun S =>\n        {\n          toSubsemigroup :=\n            { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n              mul_mem' :=\n                (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n          one_mem' := (_ : 0 ∈ S.carrier) })\n      ((fun S =>\n          {\n            toAddSubsemigroup :=\n              { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n                add_mem' :=\n                  (_ :\n                    ∀ {a b : Additive M},\n                      a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                        b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n            zero_mem' := (_ : 1 ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Finset.fold_singleton",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Finset",
   "Singleton.singleton",
   "AddCommMagma.to_isCommutative",
   "AddSemigroup.to_isAssociative",
   "add_zero",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "AddCommMonoid",
   "Finset.instSingletonFinset"],
  "name": "Finset.sum_singleton",
  "constType":
  "∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] (f : α → β) (a : α), (Finset.sum {a} fun x => f x) = f a",
  "constCategory": "Theorem"},
 {"references":
  ["IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Set",
   "InfSet.sInf",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Set.instLESet",
   "LE.le",
   "Preorder.toLE",
   "IsGLB.of_image",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "SetLike.instPartialOrder",
   "isGLB_biInf",
   "SetLike.coe_subset_coe",
   "Iff",
   "letFun",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "SetLike.coe"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x : Set (Submonoid M)), IsGLB x (sInf x)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.ext",
   "DecidableEq",
   "Finset.mem_inter",
   "Set",
   "Finset.toSet",
   "Finset",
   "Finset.instInterFinset",
   "Inter.inter",
   "Eq",
   "Set.instInterSet"],
  "name": "Finset.coe_inter",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (s₁ s₂ : Finset α), ↑(s₁ ∩ s₂) = ↑s₁ ∩ ↑s₂",
  "constCategory": "Theorem"},
 {"references":
  ["Real.cos_one_pos",
   "Set.Icc",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Real.natCast",
   "Mathlib.Meta.NormNum.isNat_le_true",
   "Set",
   "Real",
   "Eq.refl",
   "Preorder.toLE",
   "Real.instOneReal",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "OrderTopology.to_orderClosedTopology",
   "AddMonoidWithOne.toNatCast",
   "intermediate_value_Icc'",
   "Real.cos_two_neg",
   "Bool.true",
   "LinearOrderedField.toLinearOrderedSemifield",
   "instOfNatNat",
   "le_of_lt",
   "Set.image",
   "UniformSpace.toTopologicalSpace",
   "Nat",
   "instOfNat",
   "Nat.cast_one",
   "Membership.mem",
   "Real.cos",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "SemilatticeInf.toPartialOrder",
   "ConditionallyCompleteLattice.toLattice",
   "One.toOfNat1",
   "Real.continuousOn_cos",
   "Real.instRingReal",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Real.orderedSemiring",
   "LE.le",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "eq_true",
   "of_eq_true",
   "Real.instPreorderReal",
   "Real.instConditionallyCompleteLinearOrderReal",
   "instNatAtLeastTwo",
   "And.intro",
   "Bool",
   "LinearOrderedSemiField.toDenselyOrdered",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice"],
  "name": "Real.exists_cos_eq_zero",
  "constType": "0 ∈ Real.cos '' Set.Icc 1 2",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_succ'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (n : ℕ) (a : α),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists.fst.match_1",
   "Exists",
   "Iff.mp",
   "Iff",
   "exists_prop_congr.match_1",
   "Exists.intro",
   "Iff.mpr"],
  "name": "exists_prop_congr",
  "constType":
  "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q ↔ ∃ (h : p'), q' (_ : p)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "zpowRec.match_1",
   "Neg.neg",
   "nsmulRec",
   "Nat",
   "Add",
   "Nat.succ",
   "Int",
   "Neg"],
  "name": "zsmulRec",
  "constType":
  "{M : Type u_2} → [inst : Zero M] → [inst : Add M] → [inst : Neg M] → ℤ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Function.comp",
   "Unit",
   "Unit.unit",
   "ProbabilityTheory.kernel.IndepFun.comp",
   "Measurable",
   "MeasureTheory.Measure.dirac",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun"],
  "name": "ProbabilityTheory.IndepFun.comp",
  "constType":
  "∀ {Ω : Type u_1} {β : Type u_6} {β' : Type u_7} {γ : Type u_8} {γ' : Type u_9} {mΩ : MeasurableSpace Ω}\n  {μ : MeasureTheory.Measure Ω} {f : Ω → β} {g : Ω → β'} {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'}\n  {_mγ : MeasurableSpace γ} {_mγ' : MeasurableSpace γ'} {φ : β → γ} {ψ : β' → γ'},\n  ProbabilityTheory.IndepFun f g → Measurable φ → Measurable ψ → ProbabilityTheory.IndepFun (φ ∘ f) (ψ ∘ g)",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder",
   "PartialOrder.toPreorder",
   "dite",
   "LE.le",
   "Preorder.toLE",
   "max_def",
   "Eq",
   "ite",
   "if_pos",
   "Eq.mpr",
   "Decidable",
   "Max.max",
   "LinearOrder.toMax",
   "Not",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "congrArg",
   "Eq.trans",
   "if_neg",
   "id",
   "congrFun"],
  "name": "max_le",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a ≤ c → b ≤ c → max a b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "Exists",
   "OfNat.ofNat",
   "Real.instLinearOrderedFieldReal",
   "Real.normedField",
   "Real.instLEReal",
   "Real",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "Real.instSupReal",
   "Exists.intro",
   "And.left",
   "exists_between",
   "abs_of_nonneg",
   "NormedField.toNorm",
   "Abs.abs",
   "Real.instNegReal",
   "Eq",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Neg.toHasAbs",
   "LT.lt.le",
   "Real.instLTReal",
   "instDistribLattice",
   "LE.le.trans",
   "Real.norm",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "Real.instZeroReal",
   "And",
   "Real.norm_eq_abs",
   "Eq.ndrec",
   "Real.denselyNormedField.match_1",
   "LT.lt",
   "Real.instPreorderReal",
   "Real.instAddGroupReal",
   "Norm.norm",
   "LinearOrderedSemiField.toDenselyOrdered",
   "NegZeroClass.toNeg"],
  "name": "Real.denselyNormedField.proof_1",
  "constType": "∀ (x x_1 : ℝ), 0 ≤ x → x < x_1 → ∃ a, x < ‖a‖ ∧ ‖a‖ < x_1",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "Real.instLEReal",
   "Real",
   "Real.instMulReal",
   "dite",
   "Complex.ofReal_log",
   "True",
   "Real.instOneReal",
   "ite",
   "Eq",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Complex.ofReal_mul",
   "Eq.mpr",
   "instHPow",
   "Real.instPowReal",
   "Eq.symm",
   "Eq.trans",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "Complex.instZeroComplex",
   "False",
   "One.toOfNat1",
   "Real.exp",
   "LE.le",
   "Complex.re",
   "Real.instZeroReal",
   "instHMul",
   "eq_false",
   "if_pos",
   "Real.log",
   "False.elim",
   "of_eq_true",
   "Eq.mp",
   "HMul.hMul",
   "not_true_eq_false",
   "Not",
   "Complex",
   "Complex.log",
   "Mathlib.Data.Complex.Basic._auxLemma.2",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Real.rpow_def_of_nonneg",
  "constType":
  "∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), x ^ y = if x = 0 then if y = 0 then 1 else 0 else Real.exp (Real.log x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instInvCauchyToRing",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Inv.inv",
   "Rat.instSupRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1334",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references": ["Inter"],
  "name": "Inter.inter",
  "constType": "{α : Type u} → [self : Inter α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid.mk",
   "Subgroup.mk",
   "Top",
   "Submonoid.instTopSubmonoid",
   "Submonoid.toSubsemigroup",
   "Top.top",
   "Submonoid",
   "Subgroup",
   "Subgroup.instTopSubgroup.proof_1",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Top.mk",
   "Subgroup.instTopSubgroup.proof_2"],
  "name": "Subgroup.instTopSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → Top (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "OfNat.ofNat",
   "Top.top",
   "ENNReal.instInvENNReal",
   "Mathlib.Data.Real.ENNReal._auxLemma.70",
   "instENNRealZero",
   "True",
   "iff_self",
   "Eq",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Zero.toOfNat0",
   "ENNReal",
   "Iff",
   "of_eq_true",
   "CompleteLattice.toTop",
   "Not",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "Inv.inv"],
  "name": "ENNReal.inv_ne_top",
  "constType": "∀ {a : ENNReal}, a⁻¹ ≠ ⊤ ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "CauSeq.Completion.instNegCauchy",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Neg.neg",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.1004",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1004",
  "constType": "ℝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "DivisionRing.toRing",
   "Rat.divisionRing",
   "Real",
   "Rat.instNegRat",
   "Rat",
   "CauSeq.Completion.Cauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Rat.instLinearOrderedFieldRat",
   "Abs.abs",
   "Rat.instSupRat"],
  "name": "Real.rec",
  "constType":
  "{motive : ℝ → Sort u} → ((cauchy : CauSeq.Completion.Cauchy abs) → motive { cauchy := cauchy }) → (t : ℝ) → motive t",
  "constCategory": "Other"},
 {"references": ["EquivLike", "outParam"],
  "name": "EquivLike.coe",
  "constType":
  "{E : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EquivLike E α β] → E → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "MeasureTheory.Measure.map",
   "MeasureTheory.Measure.map_sum",
   "NonUnitalCommSemiring.toCommSemigroup",
   "MeasureTheory.Measure.map_apply",
   "MeasureTheory.Measure.prod",
   "Equiv.prodComm",
   "ENNReal.instT2SpaceENNRealInstTopologicalSpaceENNReal",
   "Eq",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Measurable.aemeasurable",
   "Nat",
   "Eq.trans",
   "Set.instSProd",
   "Prod.snd",
   "Prod.fst",
   "CommMagma.toMul",
   "Prod.instMeasurableSpace",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "congrArg",
   "MeasurableSpace",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "congrFun",
   "CanonicallyOrderedCommSemiring.toMul",
   "Set",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Equiv.tsum_eq",
   "CommSemiring.toNonUnitalCommSemiring",
   "MeasureTheory.Measure.prod_eq",
   "Set.preimage_swap_prod",
   "True",
   "MeasureTheory.Measure.prod_sum",
   "instCountableNat",
   "mul_comm",
   "MeasureTheory.Measure",
   "ENNReal.instTopologicalSpaceENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "measurable_swap",
   "Eq.rec",
   "SProd.sprod",
   "MeasurableSet",
   "Eq.symm",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "id",
   "eq_self",
   "MeasureTheory.isFiniteMeasure_sFiniteSeq",
   "funext",
   "MeasureTheory.sFiniteSeq",
   "Set.preimage",
   "tsum",
   "FunLike.coe",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.SFinite",
   "Equiv.instFunLikeEquiv",
   "Eq.ndrec",
   "CommSemigroup.toCommMagma",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "MeasurableSet.prod",
   "HMul.hMul",
   "Prod",
   "Prod.swap",
   "MeasureTheory.Measure.sum_apply",
   "MeasureTheory.Measure.prod_prod",
   "MeasureTheory.Measure.sum",
   "MeasureTheory.sum_sFiniteSeq",
   "MeasureTheory.Measure.ext"],
  "name": "MeasureTheory.Measure.prod_swap",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] [inst_3 : MeasureTheory.SFinite μ],\n  MeasureTheory.Measure.map Prod.swap (MeasureTheory.Measure.prod μ ν) = MeasureTheory.Measure.prod ν μ",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.751",
   "OfNat.ofNat",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real",
   "Set",
   "ENNReal.ofReal",
   "Bornology.cobounded",
   "_auto._@.Mathlib.Topology.MetricSpace.PseudoMetric._hyg.712",
   "autoParam",
   "Dist",
   "Dist.dist",
   "Eq",
   "Zero.toOfNat0",
   "ENNReal",
   "Filter.principal",
   "UniformSpace",
   "CompleteLattice.toConditionallyCompleteLattice",
   "Filter",
   "PseudoMetricSpace",
   "Filter.instCompleteLatticeFilter",
   "Membership.mem",
   "Filter.sets",
   "setOf",
   "Prod.snd",
   "Real.instLTReal",
   "instHAdd",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Prod.fst",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "ConditionallyCompleteLattice.toInfSet",
   "Set.instMembershipSet",
   "GT.gt",
   "Real.instZeroReal",
   "uniformity",
   "iInf",
   "LT.lt",
   "Prod",
   "Bornology"],
  "name": "PseudoMetricSpace.mk",
  "constType":
  "{α : Type u} →\n  [toDist : Dist α] →\n    (∀ (x : α), dist x x = 0) →\n      (∀ (x y : α), dist x y = dist y x) →\n        (∀ (x y z : α), dist x z ≤ dist x y + dist y z) →\n          (edist : α → α → ENNReal) →\n            (∀ (x y : α), edist x y = ENNReal.ofReal (dist x y)) →\n              (toUniformSpace : UniformSpace α) →\n                autoParam (uniformity α = ⨅ ε, ⨅ (_ : ε > 0), Filter.principal {p | dist p.1 p.2 < ε}) _auto✝ →\n                  (toBornology : Bornology α) →\n                    autoParam ((Bornology.cobounded α).sets = {s | ∃ C, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C}) _auto✝¹ →\n                      PseudoMetricSpace α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Filter.map",
   "Set",
   "Filter",
   "Filter.mem_map",
   "Eq",
   "instMembershipSetFilter"],
  "name": "Mathlib.Topology.Instances.Real._auxLemma.3",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, (t ∈ Filter.map m f) = (m ⁻¹' t ∈ f)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_succ",
   "OfNat.ofNat",
   "Nat.succ_le_of_lt",
   "instAddNat",
   "instHAdd",
   "Nat.lt_of_lt_of_le",
   "HAdd.hAdd",
   "Nat.add_lt_add_left",
   "LE.le",
   "instLTNat",
   "Eq",
   "GT.gt",
   "instHMul",
   "instLENat",
   "Nat.mul_le_mul_left",
   "LT.lt",
   "Eq.rec",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "instMulNat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.mul_lt_mul_of_pos_left",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → k * n < k * m",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "Bot.bot",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toBot",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "Lattice.toInf",
   "inferInstance",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.inf_compl_le_bot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_12",
  "constType": "∀ {α : Type u_1} (x : α → Prop), x ⊓ xᶜ ≤ ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "NeZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "NeZero.mk",
   "StrictOrderedSemiring.to_charZero",
   "Ring.toAddGroupWithOne",
   "Real.strictOrderedSemiring",
   "Real",
   "one_ne_zero",
   "One.toOfNat1",
   "Real.instRingReal",
   "NeZero.charZero_one",
   "Real.instOneReal"],
  "name": "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
  "constType": "NeZero 1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "inferInstanceAs",
  "constType": "(α : Sort u) → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Real.natCast",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.instAddMonoidReal",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "NatCast.mk",
   "Nat.cast_zero",
   "True",
   "Real.instOneReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "Complex.ext",
   "Nat",
   "AddMonoidWithOne.natCast_succ",
   "Eq.trans",
   "AddMonoidWithOne.mk",
   "Complex.instOneComplex",
   "eq_self",
   "Complex.addCommGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.mk",
   "One.toOfNat1",
   "Real.instRingReal",
   "Real.intCast",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "Complex.re",
   "Complex.im",
   "Real.instZeroReal",
   "IntCast.mk",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "of_eq_true",
   "Int.cast",
   "Complex.mk",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "Complex",
   "add_zero",
   "congrArg",
   "Int",
   "IntCast.intCast",
   "congrFun"],
  "name": "Complex.Complex.addGroupWithOne.proof_8",
  "constType": "∀ (x : ℕ), IntCast.intCast ↑x = ↑x",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod", "instDecidableEqProd.match_2"],
  "name": "Prod.map",
  "constType":
  "{α₁ : Type u₁} → {α₂ : Type u₂} → {β₁ : Type v₁} → {β₂ : Type v₂} → (α₁ → α₂) → (β₁ → β₂) → α₁ × β₁ → α₂ × β₂",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "OfNat.ofNat",
   "MeasureTheory.Measure.instZero.proof_1",
   "MeasureTheory.Measure.mk",
   "Zero.mk",
   "MeasureTheory.OuterMeasure.instZero",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim_zero"],
  "name": "MeasureTheory.Measure.instZero",
  "constType":
  "{α : Type u_1} → [inst : MeasurableSpace α] → Zero (MeasureTheory.Measure α)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddSubsemigroup.mk",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Add",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubsemigroup.rec",
  "constType":
  "{M : Type u_4} →\n  [inst : Add M] →\n    {motive : AddSubsemigroup M → Sort u} →\n      ((carrier : Set M) →\n          (add_mem' : ∀ {a b : M}, a ∈ carrier → b ∈ carrier → a + b ∈ carrier) →\n            motive { carrier := carrier, add_mem' := add_mem' }) →\n        (t : AddSubsemigroup M) → motive t",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real.instMulReal",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "instHMul",
   "Real.ofCauchy_mul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Mathlib.Data.Real.Basic._auxLemma.3",
  "constType":
  "∀ (a b : CauSeq.Completion.Cauchy abs), { cauchy := a } * { cauchy := b } = { cauchy := a * b }",
  "constCategory": "Theorem"},
 {"references":
  ["AddSemigroup.toAdd", "instHAdd", "HAdd.hAdd", "AddSemigroup", "Eq"],
  "name": "AddSemigroup.add_assoc",
  "constType":
  "∀ {G : Type u} [self : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHMul",
   "Int.negOfNat",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Nat.succ",
   "Int",
   "Int.add.match_1"],
  "name": "Int.mul",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Countable",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references": ["Monoid"],
  "name": "Units",
  "constType": "(α : Type u) → [inst : Monoid α] → Type u",
  "constCategory": "Other"},
 {"references": ["Set", "InfSet"],
  "name": "InfSet.mk",
  "constType": "{α : Type u_9} → (Set α → α) → InfSet α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "DivisionRing",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "DivisionRing.mul_inv_cancel",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Finset.range",
   "LT.lt",
   "Finset",
   "Finset.instMembershipFinset",
   "Nat",
   "instLTNat",
   "Multiset.mem_range"],
  "name": "Finset.mem_range",
  "constType": "∀ {n m : ℕ}, m ∈ Finset.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "outParam",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_add",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [self : RingHomClass F α β] (f : F) (x y : α), f (x + y) = f x + f y",
  "constCategory": "Definition"},
 {"references": ["outParam", "AddZeroClass"],
  "name": "AddMonoidHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : AddZeroClass M] → [inst : AddZeroClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["trivial", "eq_true", "True", "Eq"],
  "name": "implies_true",
  "constType": "∀ (α : Sort u), (α → True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subtype.val",
   "AddSubgroup",
   "Neg.neg",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.neg",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x : ↥H), ↑(-x) = ↑(-x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "Int.negSucc",
   "Unit",
   "Int.negOfNat.match_1",
   "Nat",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "Multiplicative",
   "AddGroup",
   "instOfNatInt",
   "DivInvMonoid.zpow_zero'",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Int",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.zpow",
   "Eq",
   "Multiplicative.divInvMonoid"],
  "name": "Multiplicative.group.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] (a : Multiplicative α), DivInvMonoid.zpow 0 a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Complex.mk",
   "Real",
   "Complex"],
  "name": "Complex.ofReal'",
  "constType": "ℝ → ℂ",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Finset.toSet",
   "Set",
   "Finset.sum",
   "Real",
   "Finset",
   "Singleton.singleton",
   "MeasureTheory.Measure.real",
   "Real.instAddCommMonoidReal",
   "MeasureTheory.IsFiniteMeasure",
   "MeasurableSpace",
   "Eq",
   "Finset.sum_toReal_measure_singleton"],
  "name": "MeasureTheory.Finset.sum_realMeasure_singleton",
  "constType":
  "∀ {α : Type u_1} {x : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasurableSingletonClass α]\n  [inst : MeasureTheory.IsFiniteMeasure μ] (s : Finset α), (Finset.sum s fun b => μ.real {b}) = μ.real ↑s",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → γ) → Insert α γ",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Rat.instLERat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "add_left_comm",
   "Rat.instAddRat",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Rat.addCommGroup",
   "Rat.le_iff_Nonneg",
   "Rat.addCommSemigroup",
   "Rat.instNegRat",
   "Mathlib.Data.Rat.Order._auxLemma.12",
   "AddCommGroup.toAddGroup",
   "Rat.nonneg_add",
   "Rat.Nonneg",
   "id",
   "add_neg_cancel_comm_assoc",
   "instHSub",
   "Rat.addGroup",
   "add_comm",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "Neg.neg",
   "AddCommMagma.toAdd",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Rat.instSubRat",
   "Eq.ndrec",
   "propext",
   "Eq.mp",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg"],
  "name": "Rat.le_trans",
  "constType": "∀ {a b c : ℚ}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "Group",
   "mul_left_inv",
   "Group.toDivInvMonoid",
   "Eq.symm",
   "Inv.inv",
   "id"],
  "name": "mul_right_inv",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["le_self_add",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Eq.ndrec",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "id"],
  "name": "le_add_self",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b + a",
  "constCategory": "Theorem"},
 {"references": ["Nontrivial", "Semifield"],
  "name": "Semifield.toNontrivial",
  "constType": "∀ {α : Type u_4} [self : Semifield α], Nontrivial α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Real",
   "Real.instMulReal",
   "One.toOfNat1",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Eq",
   "Real.instOneReal",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "instHPow",
   "Real.semiring",
   "Real.instPowReal",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Real.rpow_one",
   "Eq.trans",
   "congrFun"],
  "name": "Mathlib.Tactic.RPowRing.atom_pow_pf",
  "constType": "∀ (a : ℝ), a = a ^ 1 * 1",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "DivisionRing.toRing",
   "Real.instMulReal",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.definition.match_1._@.Mathlib.Data.Real.Basic._hyg.827",
   "Rat.instNegRat",
   "_private.Mathlib.Data.Real.Basic.0.Real.mul_def",
   "CauSeq.Completion.Cauchy",
   "_private.Mathlib.Data.Real.Basic.0.Real.mul",
   "HMul.hMul",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_mul",
  "constType":
  "∀ (a b : CauSeq.Completion.Cauchy abs), { cauchy := a * b } = { cauchy := a } * { cauchy := b }",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "AddMonoidHom.toZeroHom",
   "ZeroHom.map_zero'",
   "AddZeroClass",
   "AddMonoidHom",
   "Eq"],
  "name": "AddMonoidHom.addMonoidHomClass.proof_2",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), ZeroHom.toFun (↑f) 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet", "Set", "HasSubset.Subset", "Set.Subset.refl"],
  "name": "Set.Subset.rfl",
  "constType": "∀ {α : Type u} {s : Set α}, s ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "eq_neg_of_add_eq_zero_left",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_eq_zero_iff_eq_neg",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a + b = 0 ↔ a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.log_im",
   "Complex.arg",
   "Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AbsoluteValue",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.ofReal_re",
   "Complex.instSemiringComplex",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Complex.log_re",
   "Complex.ext",
   "id",
   "Complex.ofReal'",
   "Complex.abs",
   "Complex.abs_of_nonneg",
   "FunLike.coe",
   "Real.orderedSemiring",
   "LE.le",
   "SubadditiveHomClass.toFunLike",
   "Complex.ofReal_im",
   "Complex.re",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Complex.im",
   "Real.instZeroReal",
   "Real.log",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "Complex.log",
   "Complex.arg_ofReal_of_nonneg",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.ofReal_log",
  "constType": "∀ {x : ℝ}, 0 ≤ x → ↑(Real.log x) = Complex.log ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Eq.ndrec",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "propext",
   "iSup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "iSup_le_iff",
   "LE.le",
   "CompleteLattice.toSupSet",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.OmegaCompletePartialOrder._auxLemma.14",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (iSup f ≤ a) = ∀ (i : ι), f i ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "Measurable",
   "MeasurableAdd.measurable_add_const",
   "Add",
   "MeasurableSpace",
   "Measurable.comp",
   "MeasurableAdd"],
  "name": "Measurable.add_const",
  "constType":
  "∀ {M : Type u_2} {α : Type u_3} [inst : MeasurableSpace M] [inst_1 : Add M] {m : MeasurableSpace α} {f : α → M}\n  [inst_2 : MeasurableAdd M], Measurable f → ∀ (c : M), Measurable fun x => f x + c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Cardinal.map",
   "Cardinal",
   "Equiv.ulift",
   "Equiv.trans",
   "ULift",
   "Equiv.symm"],
  "name": "Cardinal.lift",
  "constType": "Cardinal.{v} → Cardinal.{max v u}",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toNeg",
   "Int.cast_neg",
   "InvolutiveNeg.toNeg",
   "Ring.toIntCast",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "Int.instNegInt",
   "Nat",
   "Eq.symm",
   "neg_mul",
   "Int.neg",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "Int.cast",
   "HMul.hMul",
   "Int",
   "Mathlib.Meta.NormNum.isRat_neg.match_1"],
  "name": "Mathlib.Meta.NormNum.isRat_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α} {a : α} {n n' : ℤ} {d : ℕ},\n  f = Neg.neg → Mathlib.Meta.NormNum.IsRat a n d → Int.neg n = n' → Mathlib.Meta.NormNum.IsRat (-a) n' d",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "DivisionRing",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "DivisionRing.toRing",
   "div_eq_mul_inv",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Ring.toNonAssocRing",
   "DivisionRing.toInv",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "Eq.mpr",
   "HMul.hMul",
   "HDiv.hDiv",
   "Nat",
   "congrArg",
   "DivisionRing.toDivInvMonoid",
   "Int",
   "Mathlib.Meta.NormNum.isRat_div.match_1",
   "DivisionRing.toDiv",
   "DivInvMonoid.toDiv",
   "congrFun",
   "id",
   "Inv.inv"],
  "name": "Mathlib.Meta.NormNum.isRat_div",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {a b : α} {cn : ℤ} {cd : ℕ},\n  Mathlib.Meta.NormNum.IsRat (a * b⁻¹) cn cd → Mathlib.Meta.NormNum.IsRat (a / b) cn cd",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "CommSemiring",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.cast_pos.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ} (motive : Mathlib.Meta.NormNum.IsNat a n → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat a n), (∀ (e : a = ↑n), motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive x",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "OrderedCancelAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedCancelAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["trivial",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "StrictMonoOn.le_iff_le",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "Preorder",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "StrictMono.strictMonoOn"],
  "name": "StrictMono.le_iff_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},\n  StrictMono f → ∀ {a b : α}, f a ≤ f b ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "GeneralizedCoheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "List",
   "Multiset.attach",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Subtype",
   "List.mem_attach"],
  "name": "Multiset.mem_attach",
  "constType":
  "∀ {α : Type u_1} (s : Multiset α) (x : { x // x ∈ s }), x ∈ Multiset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHAdd",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Eq.refl",
   "Neg.neg",
   "Real.instNegReal",
   "Eq",
   "zsmulRec",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Int.negSucc",
   "Zero.mk",
   "Nat",
   "Neg.mk",
   "Add.mk"],
  "name": "Real.commRing.proof_21",
  "constType":
  "∀ (n : ℕ) (a : ℝ), zsmulRec (Int.negSucc n) a = zsmulRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "AddZeroClass.add_zero",
  "constType": "∀ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["true_and",
   "Set",
   "Set.toFinset",
   "Subtype.fintype",
   "Set.decidableSetOf",
   "Set.toFinite",
   "True",
   "Eq",
   "iff_self",
   "DecidablePred",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset.ext",
   "Finset",
   "Finset.filter",
   "Eq.trans",
   "Set.toFinite_toFinset",
   "Membership.mem",
   "setOf",
   "Finset.instMembershipFinset",
   "Set.toFinset_setOf",
   "Set.Finite",
   "Set.instMembershipSet",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.univ",
   "And",
   "of_eq_true",
   "congr",
   "congrArg",
   "Finite.of_fintype",
   "Mathlib.Data.Finset.Basic._auxLemma.140",
   "Set.Finite.toFinset",
   "congrFun"],
  "name": "Set.Finite.toFinset_setOf",
  "constType":
  "∀ {α : Type u} [inst : Fintype α] (p : α → Prop) [inst_1 : DecidablePred p] (h : Set.Finite {x | p x}),\n  Set.Finite.toFinset h = Finset.filter p Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → CommMonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["Complex.im",
   "instHAdd",
   "Complex.mk",
   "Real.instAddReal",
   "Real",
   "HAdd.hAdd",
   "Complex",
   "Add",
   "Complex.re",
   "Add.mk"],
  "name": "Complex.instAddComplex",
  "constType": "Add ℂ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "HMul.hMul",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalSeminormedCommRing.mul_comm",
  "constType":
  "∀ {α : Type u_5} [self : NonUnitalSeminormedCommRing α] (x y : α), x * y = y * x",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSingletonClass",
   "Set.instSingletonSet",
   "Set",
   "MeasurableSet",
   "Singleton.singleton",
   "MeasurableSpace"],
  "name": "MeasurableSingletonClass.measurableSet_singleton",
  "constType":
  "∀ {α : Type u_7} [inst : MeasurableSpace α] [self : MeasurableSingletonClass α] (x : α), MeasurableSet {x}",
  "constCategory": "Definition"},
 {"references": ["Min.min", "Eq.refl", "Nat", "instMinNat", "Eq"],
  "name": "Nat.linearOrder.proof_1",
  "constType": "∀ (a b : ℕ), min a b = min a b",
  "constCategory": "Theorem"},
 {"references": ["Set", "Filter"],
  "name": "Filter.sets",
  "constType": "{α : Type u_1} → Filter α → Set (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "Preorder.toLT",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "add_lt_of_lt_of_neg",
   "AddZeroClass"],
  "name": "Left.add_neg",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < 0 → b < 0 → a + b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Top.top",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "LE.le",
   "BooleanAlgebra",
   "Preorder.toLE",
   "DistribLattice.toLattice",
   "inferInstance",
   "SemilatticeSup.toSup",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.top_le_sup_compl",
   "BooleanAlgebra.toDistribLattice",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop"],
  "name": "Set.instBooleanAlgebraSet.proof_13",
  "constType": "∀ {α : Type u_1} (x : α → Prop), ⊤ ≤ x ⊔ xᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "PartialOrder.toPreorder",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_3",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b c : AddSubmonoid M), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "EmbeddingLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "sub_self",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.instSubReal",
   "Real.instAddMonoidReal",
   "Real.commRing",
   "AddGroup.toSubtractionMonoid",
   "MulZeroClass.mul_zero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "Semiring.toNonAssocSemiring",
   "MulZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Complex.I",
   "eq_self",
   "Complex.ofReal'",
   "instHSub",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "instHAdd",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.instAddComplex",
   "SubNegZeroMonoid.toNegZeroClass",
   "Complex.ext_iff",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.im",
   "And",
   "instHMul",
   "of_eq_true",
   "Real.semiring",
   "Real.instAddGroupReal",
   "congr",
   "HMul.hMul",
   "mul_one",
   "Complex",
   "add_zero",
   "NegZeroClass.toZero",
   "congrArg",
   "Complex.instMulComplex",
   "and_self",
   "congrFun"],
  "name": "Complex.re_add_im",
  "constType": "∀ (z : ℂ), ↑z.re + ↑z.im * Complex.I = z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Field",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.zero", "Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_le.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive Nat.zero) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "mul_lt_mul_of_neg_right",
   "NonUnitalNonAssocRing.toMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "StrictOrderedSemiring.toSemiring",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "StrictOrderedRing",
   "LT.lt",
   "Eq.mp",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "congrFun"],
  "name": "mul_pos_of_neg_of_neg",
  "constType":
  "∀ {α : Type u} [inst : StrictOrderedRing α] {a b : α}, a < 0 → b < 0 → 0 < a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "lt_of_le_of_ne",
   "PartialOrder.toPreorder",
   "Preorder.toLT",
   "LT.lt",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "LE.le.lt_of_ne",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "One", "OneHomClass"],
  "name": "OneHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : One M] → [inst_1 : One N] → [self : OneHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Set",
   "Submonoid",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_10",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x x_1 : Submonoid M) (x_2 : M), x_2 ∈ ↑x ∧ x_2 ∈ ↑x_1 → x_2 ∈ ↑x_1",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.toBiheytingAlgebra",
   "Set.instBooleanAlgebraSet",
   "Lattice.toSemilatticeInf",
   "Set",
   "Inter.inter",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "Set.univ",
   "Set.instInterSet",
   "Eq",
   "CoheytingAlgebra.toOrderTop",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "inf_top_eq"],
  "name": "Set.inter_univ",
  "constType": "∀ {α : Type u} (a : Set α), a ∩ Set.univ = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.le_sup_left",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Submonoid",
   "Sup.sup",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_6",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b : Submonoid M), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Preorder.toLE",
   "Eq",
   "LT.lt.ne",
   "SemilatticeSup.toSup",
   "Iff",
   "not_false_eq_true",
   "Eq.trans",
   "Ne",
   "Or",
   "abs_zero",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "Or.casesOn",
   "DistribLattice.toLattice",
   "Mathlib.Order.Basic._auxLemma.2",
   "eq_true",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "congr",
   "LinearOrder.toPartialOrder",
   "Not",
   "congrArg",
   "AddZeroClass.toAdd",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.10",
   "AddMonoid.toAddZeroClass",
   "Abs.abs",
   "True",
   "iff_self",
   "Zero.toOfNat0",
   "AddGroup",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Lattice.toSemilatticeSup",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg.toHasAbs",
   "eq_self",
   "LinearOrder",
   "IsCancelAdd.toIsLeftCancelAdd",
   "False",
   "instHAdd",
   "AddSemigroup.toAdd",
   "abs_of_neg",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "eq_false",
   "Eq.ndrec",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "not_true_eq_false",
   "abs_of_pos",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "lt_trichotomy"],
  "name": "abs_pos",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 < |a| ↔ a ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "instHDiv",
   "div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "True",
   "CommMonoid.toCommSemigroup",
   "DivInvMonoid.toInv",
   "Eq",
   "mul_comm",
   "instHMul",
   "of_eq_true",
   "DivisionCommMonoid.toDivisionMonoid",
   "CommSemigroup.toCommMagma",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "DivisionCommMonoid.toCommMonoid",
   "congr",
   "DivisionCommMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "congrArg",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "Eq.trans",
   "DivInvMonoid.toDiv",
   "Inv.inv"],
  "name": "div_eq_inv_mul",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b : α), a / b = b⁻¹ * a",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.toLattice",
   "Membership.mem",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Set",
   "SupSet.sSup",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "Set.instMembershipSet"],
  "name": "CompleteLattice.le_sSup",
  "constType":
  "∀ {α : Type u_9} [self : CompleteLattice α] (s : Set α), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Complex.instNegComplex",
   "Real.instSubReal",
   "Real.instAddReal",
   "Real.instLEReal",
   "Real",
   "AbsoluteValue",
   "HAdd.hAdd",
   "Real.pi",
   "Real.decidableLE",
   "LinearOrderedField.toDiv",
   "Preorder.toLE",
   "ite",
   "Zero.toOfNat0",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "HDiv.hDiv",
   "instHSub",
   "Real.arcsin",
   "Complex.abs",
   "instHDiv",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "FunLike.coe",
   "Real.orderedSemiring",
   "LE.le",
   "SubadditiveHomClass.toFunLike",
   "Complex.re",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Complex.im",
   "Real.instZeroReal",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "Complex",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.arg",
  "constType": "ℂ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "RingHomClass.toMonoidHomClass"],
  "name": "RingHomClass.map_zero",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [self : RingHomClass F α β] (f : F), f 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Init.Order.Defs._hyg.12",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "implies_congr",
   "LE.le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "Rat.instNegRat",
   "le_trans",
   "Real.ind_mk",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_2",
  "constType": "∀ (a b c : ℝ), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.zsmul",
   "AddMonoid.toAddSemigroup",
   "Ring.zsmul_succ'",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.succ",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_3",
  "constType":
  "∀ {α : Type u_1} [s : CommRing α] (n : ℕ) (a : α),\n  Ring.zsmul (Int.ofNat (Nat.succ n)) a = a + Ring.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mk",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["decidableLTOfDecidableLE.proof_1",
   "lt_of_le_not_le",
   "not_le_of_gt",
   "Decidable.isFalse",
   "Preorder.toLT",
   "LT.lt",
   "Decidable",
   "decidableLTOfDecidableLE.match_1",
   "Decidable.isTrue",
   "Not",
   "dite",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "decidableLTOfDecidableLE",
  "constType":
  "{α : Type u} → [inst : Preorder α] → [inst_1 : DecidableRel fun x x_1 => x ≤ x_1] → DecidableRel fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Exists",
   "Iff.mp",
   "Finite",
   "Nat",
   "finite_iff_exists_equiv_fin",
   "Fin",
   "Nonempty"],
  "name": "Finite.exists_equiv_fin",
  "constType": "∀ (α : Sort u_3) [h : Finite α], ∃ n, Nonempty (α ≃ Fin n)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedSemifield", "Div"],
  "name": "LinearOrderedSemifield.toDiv",
  "constType": "{α : Type u_2} → [self : LinearOrderedSemifield α] → Div α",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Real",
   "Real.instSupReal",
   "Norm.norm",
   "Real.norm",
   "rfl",
   "Abs.abs",
   "Real.instNegReal",
   "Eq"],
  "name": "Real.norm_eq_abs",
  "constType": "∀ (r : ℝ), ‖r‖ = |r|",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Complex.abs",
   "Real.instLinearOrderedFieldReal",
   "PartialOrder.toPreorder",
   "Real",
   "AbsoluteValue",
   "Complex.instRingComplex",
   "FunLike.coe",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "AbsoluteValue.isAbsoluteValue",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Complex",
   "OrderedSemiring.toPartialOrder",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "Complex.exp.proof_1",
  "constType": "IsAbsoluteValue ⇑Complex.abs",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "one_div",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Real.instOneReal",
   "measurableSet_discrete",
   "Real.log_zero",
   "MeasureTheory.OuterMeasure.measureOf",
   "Nat.cast",
   "Finset.toSet",
   "HasDistribNeg.toInvolutiveNeg",
   "HDiv.hDiv",
   "Subtype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Finset.decidableMem",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "eq_of_heq",
   "HasCompl.compl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MeasureTheory.Measure.real",
   "instENNRealZero",
   "Real.normedCommRing",
   "MeasurableSet.singleton",
   "MeasureTheory.Measure.toOuterMeasure",
   "congr",
   "ProbabilityTheory.IsUniform.measureReal_preimage_of_mem'",
   "MeasurableSpace",
   "Inv.inv",
   "congrFun",
   "AddCommGroup.toDivisionAddCommMonoid",
   "MeasureTheory.map_measureReal_apply",
   "HEq",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Set",
   "Eq.refl",
   "neg_neg",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "True",
   "ProbabilityTheory.IsUniform.measure_preimage_compl",
   "MeasureTheory.Measure",
   "Real.instAddCommGroupReal",
   "InvolutiveNeg.toNeg",
   "MeasurableSet",
   "Finset",
   "Measurable",
   "neg_mul",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "MeasureTheory.Finset.sum_realMeasure_singleton",
   "ProbabilityTheory.IsUniform.measureReal_preimage_of_nmem",
   "NonUnitalNonAssocRing.toMul",
   "Finset.sum",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Set.univ",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "Real.instDivisionRingReal",
   "Countable",
   "NormedCommRing.toSeminormedCommRing",
   "Eq.ndrec",
   "letFun",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Real.instAddCommMonoidReal",
   "Real.negMulLog",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "neg_zero",
   "Real.instMulReal",
   "dite",
   "MeasureTheory.Measure.map_apply",
   "MulZeroClass.mul_zero",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "MeasurableSingletonClass",
   "ENNReal",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Finset.sum_congr",
   "Eq.trans",
   "DivisionRing.toDivInvMonoid",
   "Finset.sum_mul",
   "Classical.propDecidable",
   "Finset.instMembershipFinset",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "DivInvMonoid.toInv",
   "instHMul",
   "of_eq_true",
   "HEq.refl",
   "_private.PFR.ForMathlib.Entropy.Basic.0.MeasureTheory.Measure.real._eq_1",
   "Eq.mp",
   "Singleton.singleton",
   "Not",
   "ENNReal.toReal",
   "congrArg",
   "Real.instLinearOrderedFieldReal",
   "Real.natCast",
   "MulZeroClass.zero_mul",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "ProbabilityTheory.IsUniform.full_measure",
   "Real.instNegReal",
   "Real.log_inv",
   "Zero.toOfNat0",
   "outParam",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Set.instSingletonSet",
   "one_mul",
   "Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.2",
   "MulZeroClass.toZero",
   "neg_mul_eq_mul_neg",
   "Eq.symm",
   "id",
   "Membership.mem",
   "eq_self",
   "Set.preimage",
   "ProbabilityTheory.entropy_eq_sum_finset'",
   "Set.Set.completeAtomicBooleanAlgebra",
   "NonUnitalNonAssocSemiring.toMul",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Real.instZeroReal",
   "Real.log",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "Real.semiring",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Eq.casesOn",
   "Nat.card",
   "NegZeroClass.toZero",
   "ProbabilityTheory.IsUniform",
   "HMul"],
  "name": "ProbabilityTheory.IsUniform.entropy_eq",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] (H : Finset S) (X : Ω → S) {μ : MeasureTheory.Measure Ω}\n  [inst_2 : MeasureTheory.IsProbabilityMeasure μ],\n  ProbabilityTheory.IsUniform (↑H) X → Measurable X → H[X ; μ] = Real.log ↑(Nat.card { x // x ∈ H })",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "instHSub",
   "OfNat.ofNat",
   "Dist.mk",
   "Real.instLEReal",
   "Real",
   "Real.instSubReal",
   "HSub.hSub",
   "Real.instSupReal",
   "Real.pseudoMetricSpace.proof_1",
   "UniformSpace.ofDist",
   "abs_sub_le",
   "Real.pseudoMetricSpace.proof_3",
   "Real.instLinearOrderedAddCommGroupReal",
   "Real.pseudoMetricSpace.proof_4",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.linearOrder",
   "Real.pseudoMetricSpace.proof_5",
   "Real.instAddGroupReal",
   "Bornology.ofDist",
   "PseudoMetricSpace",
   "Subtype.mk",
   "PseudoMetricSpace.mk",
   "abs_sub_comm",
   "Real.pseudoMetricSpace.proof_2",
   "ENNReal.ofNNReal"],
  "name": "Real.pseudoMetricSpace",
  "constType": "PseudoMetricSpace ℝ",
  "constCategory": "Definition"},
 {"references": ["subset_trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "HasSubset.Subset.trans",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocRing",
   "instAddNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "NonAssocRing.toIntCast",
   "Nat.cast",
   "Int.negSucc",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "NonAssocRing.toNatCast",
   "Nat",
   "IntCast.intCast",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.intCast_negSucc",
  "constType":
  "∀ {α : Type u_1} [self : NonAssocRing α] (n : ℕ), IntCast.intCast (Int.negSucc n) = -↑(n + 1)",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedCommMonoid", "OrderedCommMonoid"],
  "name": "LinearOrderedCommMonoid.toOrderedCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCommMonoid α] → OrderedCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Semiring.one_mul",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_2",
  "constType": "∀ (a : ℝ), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Real.linearOrder",
   "OrderTopology.to_orderClosedTopology",
   "Real.partialOrder",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "Real.pseudoMetricSpace",
   "T0Space",
   "T1Space.t0Space",
   "T2Space.t1Space",
   "UniformSpace.toTopologicalSpace",
   "instOrderTopologyRealToTopologicalSpaceToUniformSpacePseudoMetricSpaceInstPreorderReal",
   "OrderClosedTopology.to_t2Space"],
  "name": "Real.metricSpace.proof_1",
  "constType": "T0Space ℝ",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedCommRing",
   "HMul.hMul",
   "NonUnitalSeminormedRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "Eq"],
  "name": "NonUnitalSeminormedCommRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNonUnitalSeminormedRing : NonUnitalSeminormedRing α] → (∀ (x y : α), x * y = y * x) → NonUnitalSeminormedCommRing α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_le_add_iff_left",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "add_right_neg",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "AddMonoid.toZero",
   "LE",
   "Eq.symm",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "congr",
   "add_zero",
   "congrArg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrFun"],
  "name": "Left.nonneg_neg_iff",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.SetTheory.Cardinal.Basic._auxLemma.44",
   "Equiv",
   "Exists",
   "funext",
   "PartialOrder.toPreorder",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.42",
   "Finite",
   "Cardinal.partialOrder",
   "Nonempty",
   "True",
   "iff_self",
   "Eq",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "Iff",
   "Cardinal.aleph0",
   "of_eq_true",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "congr",
   "Mathlib.SetTheory.Cardinal.Basic._auxLemma.43",
   "Cardinal.mk",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Fin"],
  "name": "Cardinal.lt_aleph0_iff_finite",
  "constType": "∀ {α : Type u}, Cardinal.mk α < Cardinal.aleph0 ↔ Finite α",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedRing",
   "GE.ge",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "OrderedRing.toRing",
   "Ring.toNeg",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.4",
   "Preorder.toLT",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "OrderedRing.toOrderedSemiring",
   "Std.Classes.Order._auxLemma.3",
   "le_of_lt",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "neg_neg_of_pos",
   "OrderedRing.toOrderedAddCommGroup",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "mul_nonneg_of_nonpos_of_nonpos",
   "OrderedRing.toPartialOrder",
   "instHMul",
   "LT.lt",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Eq.mp",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Linarith.mul_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedRing α] {a b : α}, a ≤ 0 → 0 < b → b * a ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["Set.Elem", "Set", "Encodable", "Nonempty"],
  "name": "Set.Countable",
  "constType": "{α : Type u} → Set α → Prop",
  "constCategory": "Definition"},
 {"references": ["Sub"],
  "name": "Sub.mk",
  "constType": "{α : Type u} → (α → α → α) → Sub α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "zero_vadd",
   "OfNat.ofNat",
   "instHSMul",
   "Function.iterate_succ'",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddAction",
   "succ_nsmul",
   "Eq",
   "Zero.toOfNat0",
   "zero_nsmul",
   "Function.comp_apply",
   "Eq.mpr",
   "Nat.recOn",
   "Function.iterate_zero",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddAction.add_vadd",
   "instOfNatNat",
   "HVAdd.hVAdd",
   "Nat",
   "Nat.succ",
   "id",
   "funext",
   "instAddNat",
   "Nat.iterate",
   "instHAdd",
   "Function.comp",
   "id.def",
   "instHVAdd",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "Eq.ndrec",
   "Nat.zero",
   "AddAction.toVAdd"],
  "name": "vadd_iterate",
  "constType":
  "∀ {G : Type u_3} {H : Type u_4} [inst : AddMonoid G] (a : G) (n : ℕ) [inst_1 : AddAction G H],\n  (fun x => a +ᵥ x)^[n] = fun x => n • a +ᵥ x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Decidable", "Set.instMembershipSet"],
  "name": "Set.decidableSetOf",
  "constType":
  "{α : Type u} → (a : α) → (p : α → Prop) → [inst : Decidable (p a)] → Decidable (a ∈ {a | p a})",
  "constCategory": "Definition"},
 {"references": ["Sup"],
  "name": "Sup.mk",
  "constType": "{α : Type u} → (α → α → α) → Sup α",
  "constCategory": "Other"},
 {"references": ["Membership.mem", "Set", "Eq", "Set.instMembershipSet"],
  "name": "Set.InjOn",
  "constType": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.577",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.577",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Decidable",
   "Finset",
   "Finset.val",
   "Multiset.decidableDforallMultiset",
   "Finset.instMembershipFinset",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.decidableDforallFinset",
  "constType":
  "{α : Type u_1} →\n  {s : Finset α} →\n    {p : (a : α) → a ∈ s → Prop} →\n      [_hp : (a : α) → (h : a ∈ s) → Decidable (p a h)] → Decidable (∀ (a : α) (h : a ∈ s), p a h)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Equiv.toFun", "Equiv.invFun", "Function.RightInverse"],
  "name": "Equiv.right_inv",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} (self : α ≃ β), Function.RightInverse self.invFun self.toFun",
  "constCategory": "Definition"},
 {"references": ["Prod.exists", "Exists", "Prod.mk", "propext", "Prod", "Eq"],
  "name": "Mathlib.Data.Set.NAry._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) = ∃ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references": ["And", "eq_false", "False", "And.left", "Eq"],
  "name": "false_and",
  "constType": "∀ (p : Prop), (False ∧ p) = False",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HVAdd"],
  "name": "HVAdd.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HVAdd α β γ",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "NonUnitalRing",
   "HMul.hMul",
   "Eq"],
  "name": "NonUnitalRing.mk",
  "constType":
  "{α : Type u_1} →\n  [toNonUnitalNonAssocRing : NonUnitalNonAssocRing α] → (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalRing α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Subgroup.subtype.proof_2",
   "MulOneClass.toOne",
   "Subtype.val",
   "Set",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Set.instMembershipSet",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "OneHom.mk",
   "Subgroup.subtype.proof_1",
   "MonoidHom.mk",
   "Group.toDivInvMonoid",
   "Subtype",
   "SetLike.coe",
   "Subgroup.instSetLikeSubgroup",
   "Submonoid.toMulOneClass"],
  "name": "Subgroup.subtype",
  "constType": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → ↥H →* G",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "DecidablePred",
   "instLENat",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "Decidable",
   "HSub.hSub",
   "decidable_of_iff",
   "Nat",
   "instLTNat",
   "LE.le",
   "Nat.decidableBallLT",
   "Nat.decidableLoHi.proof_1"],
  "name": "Nat.decidableLoHi",
  "constType":
  "(lo hi : ℕ) → (P : ℕ → Prop) → [H : DecidablePred P] → Decidable (∀ (x : ℕ), lo ≤ x → x < hi → P x)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "Set.instSingletonSet",
   "Set.image2",
   "OfNat.ofNat",
   "instHAdd",
   "Set.image2_right_identity",
   "Set",
   "HAdd.hAdd",
   "Singleton.singleton",
   "add_zero",
   "AddZeroClass",
   "Eq"],
  "name": "Set.addZeroClass.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] (s : Set α), Set.image2 (fun x x_1 => x + x_1) s {0} = s",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass"],
  "name": "add_lt_add_iff_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α}, a + b < a + c ↔ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.attach.proof_1",
   "Multiset",
   "Multiset.pmap",
   "Subtype.mk",
   "Multiset.instMembershipMultiset",
   "Subtype"],
  "name": "Multiset.attach",
  "constType": "{α : Type u_1} → (s : Multiset α) → Multiset { x // x ∈ s }",
  "constCategory": "Definition"},
 {"references":
  ["MetricSpace",
   "Real",
   "Real.metricSpace.proof_1",
   "Real.pseudoMetricSpace",
   "MetricSpace.ofT0PseudoMetricSpace"],
  "name": "Real.metricSpace",
  "constType": "MetricSpace ℝ",
  "constCategory": "Definition"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {R : Type u_1} {a c b : R}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "WithTop",
   "Zero.mk",
   "WithTop.some"],
  "name": "WithTop.zero",
  "constType": "{α : Type u} → [inst : Zero α] → Zero (WithTop α)",
  "constCategory": "Definition"},
 {"references": ["False", "Preorder.toLT", "LT.lt", "lt_irrefl", "Preorder"],
  "name": "LT.lt.false",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x : α}, x < x → False",
  "constCategory": "Theorem"},
 {"references": ["instHMul", "HMul.hMul", "Mul", "Eq.symm", "Commute"],
  "name": "Commute.symm",
  "constType":
  "∀ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b → Commute b a",
  "constCategory": "Theorem"},
 {"references":
  ["Invertible.casesOn",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "Invertible.mk",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Invertible",
   "Eq"],
  "name": "Invertible.subsingleton.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] (a : α) (motive : Invertible a → Prop) (x : Invertible a),\n  (∀ (c : α) (invOf_mul_self : c * a = 1) (hac : a * c = 1),\n      motive { invOf := c, invOf_mul_self := invOf_mul_self, mul_invOf_self := hac }) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "HasDistribNeg.toInvolutiveNeg",
   "Ring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "AddCommMagma.mk",
  "constType":
  "{G : Type u} → [toAdd : Add G] → (∀ (a b : G), a + b = b + a) → AddCommMagma G",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid.zsmul_succ'",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddOpposite.subNegMonoid",
   "AddOpposite",
   "Nat",
   "Nat.succ",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddOpposite.addGroup.proof_3",
  "constType":
  "∀ (α : Type u_1) [inst : AddGroup α] (n : ℕ) (a : αᵃᵒᵖ),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Filter.HasBasis",
   "Set.instHasSubsetSet",
   "Iff",
   "Set",
   "Filter.HasBasis.mem_iff'",
   "HasSubset.Subset",
   "Filter",
   "instMembershipSetFilter"],
  "name": "Filter.HasBasis.mem_iff",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {t : Set α},\n  Filter.HasBasis l p s → (t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t)",
  "constCategory": "Theorem"},
 {"references":
  ["Set.coe_toFinset",
   "Finset.toSet",
   "Set",
   "Set.Finite.fintype",
   "Set.Finite.toFinset",
   "Set.Finite",
   "Eq"],
  "name": "Set.Finite.coe_toFinset",
  "constType":
  "∀ {α : Type u} {s : Set α} (hs : Set.Finite s), ↑(Set.Finite.toFinset hs) = s",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.83",
   "_auto._@.Mathlib.Probability.IdentDistrib._hyg.56",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IdentDistrib",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      [inst : MeasurableSpace α] →\n        [inst_1 : MeasurableSpace β] →\n          [inst_2 : MeasurableSpace γ] →\n            (α → γ) →\n              (β → γ) → autoParam (MeasureTheory.Measure α) _auto✝ → autoParam (MeasureTheory.Measure β) _auto✝¹ → Prop",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "instOfNatInt",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Int",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_zero'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Set.Elem",
   "propext",
   "Set.toFinset",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.mem_toFinset",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Fintype.Basic._auxLemma.23",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ Set.toFinset s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "OfNat.ofNat",
   "instHasEquiv",
   "Quotient.exact",
   "Equiv.isEmpty",
   "Cardinal.mk_eq_zero_iff.match_1",
   "Cardinal.mk_eq_zero",
   "IsEmpty",
   "ULift",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "Cardinal.instZeroCardinal",
   "ULift.instIsEmptyULift",
   "Iff",
   "Fin.isEmpty'",
   "Cardinal",
   "instOfNatNat",
   "Cardinal.mk",
   "HasEquiv.Equiv",
   "Nat",
   "Cardinal.isEquivalent",
   "Fin"],
  "name": "Cardinal.mk_eq_zero_iff",
  "constType": "∀ {α : Type u}, Cardinal.mk α = 0 ↔ IsEmpty α",
  "constCategory": "Theorem"},
 {"references": ["Top", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toTop",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "RatCast.mk",
   "DivisionRing.toRing",
   "Rat",
   "qsmulRec",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "CauSeq.Completion.Cauchy.ring",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Rat.cast",
   "CauSeq.Completion.Cauchy",
   "CauSeq.Completion.ofRat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_12",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : ℚ) (x : CauSeq.Completion.Cauchy abv),\n  (qsmulRec Rat.cast) a x = (qsmulRec Rat.cast) a x",
  "constCategory": "Theorem"},
 {"references": ["Pow"],
  "name": "Pow.mk",
  "constType": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "constCategory": "Other"},
 {"references":
  ["AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "Eq"],
  "name": "AddCancelMonoid.add_right_cancel",
  "constType":
  "∀ {M : Type u} [self : AddCancelMonoid M] (a b c : M), a + b = c + b → a = c",
  "constCategory": "Definition"},
 {"references":
  ["disjointed",
   "MeasureTheory.spanningSets",
   "Set",
   "MeasureTheory.iUnion_spanningSets",
   "Eq.refl",
   "MeasureTheory.Measure.restrict",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "disjoint_disjointed",
   "MeasureTheory.Measure.restrict_iUnion",
   "Set.univ",
   "instCountableNat",
   "Eq",
   "MeasureTheory.measurable_spanningSets",
   "MeasureTheory.Measure",
   "Eq.mpr",
   "iUnion_disjointed",
   "Set.instBooleanAlgebraSet",
   "Set.iUnion",
   "Eq.ndrec",
   "MeasureTheory.SigmaFinite",
   "Nat",
   "MeasurableSet.disjointed",
   "Eq.symm",
   "MeasurableSpace",
   "MeasureTheory.Measure.sum",
   "MeasureTheory.Measure.restrict_univ",
   "id"],
  "name": "MeasureTheory.sum_restrict_disjointed_spanningSets",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.SigmaFinite μ],\n  (MeasureTheory.Measure.sum fun n => MeasureTheory.Measure.restrict μ (disjointed (MeasureTheory.spanningSets μ) n)) =\n    μ",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_6",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Equiv", "Finite", "Nat", "Fin"],
  "name": "Finite.intro",
  "constType": "∀ {α : Sort u_1} {n : ℕ}, α ≃ Fin n → Finite α",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "Multiplicative",
   "AddGroup",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "AddGroup.toSubNegMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.zpow",
   "Eq",
   "Multiplicative.divInvMonoid",
   "DivInvMonoid.zpow_neg'"],
  "name": "Multiplicative.group.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : AddGroup α] (n : ℕ) (a : Multiplicative α),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Theorem"},
 {"references": ["Zero", "SMulWithZero", "SMulZeroClass"],
  "name": "SMulWithZero.toSMulZeroClass",
  "constType":
  "{R : Type u_1} → {M : Type u_3} → [inst : Zero R] → [inst_1 : Zero M] → [self : SMulWithZero R M] → SMulZeroClass R M",
  "constCategory": "Definition"},
 {"references":
  ["PFR.ForMathlib.Uniform._auxLemma.2",
   "Mathlib.Data.Real.ENNReal._auxLemma.46",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "Subtype.instMeasurableSingletonClass",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.IsProbabilityMeasure.mk",
   "MeasureTheory.OuterMeasure.measureOf",
   "Nat.cast",
   "Pi.instOne",
   "Finset.toSet",
   "Mathlib.Data.Set.Basic._auxLemma.80",
   "HSMul.hSMul",
   "measurable_subtype_coe",
   "Finset.Subtype.fintype",
   "Subtype",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsScalarTower.right",
   "MeasureTheory.Measure.coe_finset_sum",
   "HasCompl.compl",
   "instENNRealZero",
   "Mathlib.Data.Finset.Basic._auxLemma.7",
   "And",
   "MeasureTheory.Measure.toOuterMeasure",
   "PFR.ForMathlib.Uniform._auxLemma.1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "And.intro",
   "Finset.card_attach",
   "MeasurableSpace",
   "congrFun",
   "Inv.inv",
   "Set.indicator",
   "ENNReal.instCharZeroENNRealToAddMonoidWithOneInstENNRealAddCommMonoidWithOne",
   "Exists",
   "Subtype.val",
   "Set",
   "Eq.refl",
   "ProbabilityTheory.IsUniform.mk",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Subtype.property",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "AddMonoidWithOne.toNatCast",
   "Finset",
   "MeasurableSet",
   "Measurable",
   "Finset.Nonempty.ne_empty",
   "Subtype.mk.injEq",
   "Subtype.instMeasurableSpace",
   "Top.top",
   "Finset.sum",
   "implies_true",
   "One.toOfNat1",
   "ENNReal.instInvENNReal",
   "Finset.sum_const",
   "Set.univ",
   "MeasureTheory.Measure.dirac",
   "Mathlib.Logic.IsEmpty._auxLemma.1",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "CompleteLattice.toTop",
   "not_true_eq_false",
   "Subtype.mk",
   "Finset.instEmptyCollectionFinset",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "Set.indicator_of_mem",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "MulZeroClass.mul_zero",
   "Finset.sum_const_zero",
   "BooleanAlgebra.toHasCompl",
   "CanonicallyOrderedCommSemiring.toOne",
   "implies_congr",
   "Eq",
   "Mathlib.Data.Subtype._auxLemma.1",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "MeasurableSingletonClass",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "FiniteRange",
   "instIsEmptyFalse",
   "nsmul_eq_mul",
   "Mathlib.Data.Set.Image._auxLemma.1",
   "Nat",
   "Algebra.toSMul",
   "Finset.sum_congr",
   "not_false_eq_true",
   "Eq.trans",
   "Ne",
   "CompletelyDistribLattice.toCompleteLattice",
   "Pi.instSMul",
   "Finset.instMembershipFinset",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Set.instMembershipSet",
   "instHMul",
   "Finset.univ",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "of_eq_true",
   "Eq.mp",
   "Finset.sum_apply",
   "mul_one",
   "Not",
   "Singleton.singleton",
   "MeasureTheory.Measure.dirac_apply",
   "Algebra.id",
   "congrArg",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Subtype.casesOn",
   "Finset.card",
   "Finset.Nonempty",
   "CanonicallyOrderedCommSemiring.toMul",
   "Set.indicator_of_not_mem",
   "instENNRealAddCommMonoidWithOne",
   "Mathlib.Data.Finset.Card._auxLemma.1",
   "MeasureTheory.Measure.instSMul",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "MeasureTheory.Measure.dirac_apply'",
   "Zero.toOfNat0",
   "Pi.addCommMonoid",
   "Set.instSingletonSet",
   "forall_congr",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "NeZero.charZero_one",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "id",
   "eq_self",
   "Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.133",
   "False",
   "Set.preimage",
   "Finset.sum_eq_single",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddMonoid.toNatSMul",
   "eq_false",
   "ENNReal.inv_mul_cancel",
   "OrderedCommSemiring.toOrderedSemiring",
   "Finset.attach",
   "OrderedSemiring.toSemiring",
   "finiteRange_of_finset",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "MeasureTheory.Measure.instAddCommMonoid",
   "ProbabilityTheory.IsUniform",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3"],
  "name": "ProbabilityTheory.exists_isUniform",
  "constType":
  "∀ {S : Type uS} [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] (H : Finset S),\n  Finset.Nonempty H →\n    ∃ Ω mΩ X μ,\n      MeasureTheory.IsProbabilityMeasure μ ∧\n        Measurable X ∧ ProbabilityTheory.IsUniform (↑H) X ∧ (∀ (ω : Ω), X ω ∈ H) ∧ FiniteRange X",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Iff.refl", "Eq.rec", "Eq"],
  "name": "Iff.of_eq",
  "constType": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd",
   "HAdd.hAdd",
   "Complex.sin",
   "Eq.refl",
   "Complex.instAddComplex",
   "Complex.cos",
   "Complex.exp_mul_I",
   "Complex.exp_add",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "Complex",
   "Complex.instMulComplex",
   "Complex.exp",
   "Complex.I",
   "id"],
  "name": "Complex.exp_add_mul_I",
  "constType":
  "∀ (x y : ℂ), Complex.exp (x + y * Complex.I) = Complex.exp x * (Complex.cos y + Complex.sin y * Complex.I)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.swap",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "CovariantClass.elim"],
  "name": "add_lt_add_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α},\n  b < c → ∀ (a : α), b + a < c + a",
  "constCategory": "Theorem"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Complex.ofReal'",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Complex.instNegComplex",
   "neg_zero",
   "Real",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "True",
   "Iff.mpr",
   "Eq",
   "Real.instNegReal",
   "Complex.re",
   "Complex.ext_iff",
   "Real.instAddCommGroupReal",
   "Complex.im",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "of_eq_true",
   "congr",
   "Complex",
   "congrArg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Eq.trans",
   "and_self",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Complex.ofReal_neg",
  "constType": "∀ (r : ℝ), ↑(-r) = -↑r",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHasEquiv",
   "Or",
   "DivisionRing.toRing",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "Abs.abs",
   "CauSeq.equiv",
   "DistribLattice.toLattice",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toField",
   "LT.lt",
   "LE",
   "HasEquiv.Equiv",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LE (CauSeq α abs)",
  "constCategory": "Definition"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingletonFinset",
  "constType": "{α : Type u_1} → Singleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "SetLike",
   "MulOneClass.toMul",
   "SetLike.mk",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Subgroup.instSetLikeSubgroup.proof_1",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.instSetLikeSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → SetLike (Subgroup G) G",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "Nat.add",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Nat.mul.match_1"],
  "name": "Nat.mul",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Submonoid.one_mem'",
   "MulOneClass.toOne",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "Set",
   "AddSubmonoid.toSubmonoid",
   "One.toOfNat1",
   "AddSubgroup.toAddSubmonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "RelIso.instRelHomClassRelIso",
   "AddGroup",
   "Multiplicative",
   "Submonoid.toSubsemigroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "RelIso",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Submonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Multiplicative.mulOneClass"],
  "name": "AddSubgroup.toSubgroup.proof_1",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] (S : AddSubgroup A), 1 ∈ (AddSubmonoid.toSubmonoid S.toAddSubmonoid).carrier",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Nat.add_comm",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_assoc.match_1",
   "Eq.refl",
   "Int.add_comm",
   "Nat.add_left_comm",
   "True",
   "Eq",
   "Int.instAddInt",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "Int.add_assoc.aux1",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "Int",
   "Int.add_assoc.aux2",
   "congrFun",
   "id"],
  "name": "Int.add_assoc",
  "constType": "∀ (a b c : ℤ), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references": ["Prod.snd", "Prod", "Prod.fst"],
  "name": "Function.uncurry",
  "constType":
  "{α : Type u₁} → {β : Type u₂} → {φ : Type u₃} → (α → β → φ) → α × β → φ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Equiv",
   "AddZeroClass.toAdd",
   "Set.preimage",
   "instHAdd",
   "Set",
   "Multiplicative.toAdd",
   "AddSubmonoid.toAddSubsemigroup",
   "HAdd.hAdd",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "Equiv.instFunLikeEquiv",
   "Multiplicative",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.carrier",
   "AddZeroClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.toSubmonoid.proof_1",
  "constType":
  "∀ {A : Type u_1} [inst : AddZeroClass A] (S : AddSubmonoid A) {a b : Multiplicative A},\n  a ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S →\n    b ∈ ⇑Multiplicative.toAdd ⁻¹' ↑S → Multiplicative.toAdd a + Multiplicative.toAdd b ∈ S.carrier",
  "constCategory": "Theorem"},
 {"references": ["Ord", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toOrd",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["PProd",
   "PProd.fst",
   "List.cons",
   "List.rec",
   "List.below",
   "List.brecOn",
   "List",
   "Unit",
   "PUnit",
   "List.erase.match_1",
   "List.nil",
   "Bool",
   "List.isEmpty.match_1"],
  "name": "List.filter",
  "constType": "{α : Type u} → (α → Bool) → List α → List α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "instHAdd",
   "Real",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Eq.refl",
   "Neg.neg",
   "Real.instNegReal",
   "Eq",
   "zsmulRec",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Zero.mk",
   "Int",
   "Neg.mk",
   "Add.mk"],
  "name": "Real.commRing.proof_19",
  "constType": "∀ (a : ℝ), zsmulRec 0 a = zsmulRec 0 a",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "of_decide_eq_true.match_1",
  "constType":
  "∀ {p : Prop} (motive : Decidable p → Prop) (inst : Decidable p),\n  (∀ (h₁ : p), motive (isTrue h₁)) → (∀ (h₁ : ¬p), motive (isFalse h₁)) → motive inst",
  "constCategory": "Definition"},
 {"references":
  ["Function.uncurry",
   "DecidableEq",
   "Finset.instSProd",
   "SProd.sprod",
   "Finset.image",
   "Finset",
   "Prod"],
  "name": "Finset.image₂",
  "constType":
  "{α : Type u_1} → {β : Type u_3} → {γ : Type u_5} → [inst : DecidableEq γ] → (α → β → γ) → Finset α → Finset β → Finset γ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Top.top",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "Set.univ",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "AddSubmonoid.instTopAddSubmonoid",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubmonoid.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "Set.mem_univ",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.instTopAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {x : G},\n  x ∈ { toAddSubsemigroup := ⊤.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ ⊤.carrier) }.toAddSubsemigroup.carrier →\n    -x ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHMul",
   "Subsemigroup",
   "Set",
   "HMul.hMul",
   "Mul",
   "Set.instMembershipSet"],
  "name": "Subsemigroup.mk",
  "constType":
  "{M : Type u_4} →\n  [inst : Mul M] → (carrier : Set M) → (∀ {a b : M}, a ∈ carrier → b ∈ carrier → a * b ∈ carrier) → Subsemigroup M",
  "constCategory": "Other"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Real.instLEReal",
   "Inf.inf",
   "Real.instSupReal",
   "implies_congr",
   "Preorder.toLE",
   "Eq",
   "Inf.mk",
   "Eq.mpr",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "Rat.instNegRat",
   "CauSeq.inf_le_left",
   "CauSeq.inf_le_right",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "congr_arg",
   "Real.partialOrder",
   "instDistribLattice",
   "Preorder.le_refl",
   "Real.instInfReal",
   "CauSeq.instInfCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Preorder.mk",
   "DistribLattice.toLattice",
   "CauSeq.le_sup_right",
   "CauSeq.sup_le",
   "propext",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "congr",
   "Real.mk_sup",
   "Field.toDivisionRing",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le",
   "congrFun",
   "LE.mk",
   "DivisionRing.toRing",
   "Real",
   "Eq.le",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Eq.refl",
   "Preorder.le_trans",
   "Lattice.mk",
   "Sup.mk",
   "CauSeq.sup_inf_distrib_left",
   "Abs.abs",
   "Rat.instSupRat",
   "Lattice.toInf",
   "LinearOrderedRing.toLinearOrder",
   "Mathlib.Data.Real.Basic._auxLemma.16",
   "Real.mk_inf",
   "Preorder.toLT",
   "Real.ind_mk",
   "Lattice.toSemilatticeSup",
   "CauSeq.le_inf",
   "Eq.symm",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "Real.mk_le",
   "Rat",
   "SemilatticeSup.mk",
   "CauSeq",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.15",
   "Eq.ndrec",
   "CauSeq.le_sup_left",
   "LinearOrderedField.toField",
   "Rat.divisionRing",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Real.instPreorderReal",
   "Sup.sup"],
  "name": "Real.instDistribLatticeReal.proof_10",
  "constType": "∀ (a b c : ℝ), (a ⊔ b) ⊓ (a ⊔ c) ≤ a ⊔ b ⊓ c",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "RingHom.instRingHomClass",
   "RingHom",
   "LinearOrderedSemifield.toSemifield",
   "instHDiv",
   "Real.instLinearOrderedFieldReal",
   "DivisionSemiring.toGroupWithZero",
   "Real",
   "Field.toSemifield",
   "LinearOrderedField.toDiv",
   "map_div₀",
   "Eq",
   "Complex.instSemiringComplex",
   "Semiring.toNonAssocSemiring",
   "Complex.instField",
   "Real.semiring",
   "RingHomClass.toMonoidWithZeroHomClass",
   "Complex",
   "Semifield.toDivisionSemiring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Field.toDiv",
   "HDiv.hDiv",
   "Complex.ofReal"],
  "name": "Complex.ofReal_div",
  "constType": "∀ (r s : ℝ), ↑(r / s) = ↑r / ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Real",
   "Real.instAddMonoidReal",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Real.instAddCommGroupReal",
   "AddZeroClass.toZero",
   "of_eq_true",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Real.isROrC.proof_9",
  "constType": "ℝ → 0 = -0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Set.instSingletonSet",
   "OfNat.ofNat",
   "Set.mem_singleton",
   "Set",
   "Singleton.singleton",
   "AddZeroClass",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instBotAddSubmonoid.proof_2",
  "constType": "∀ {M : Type u_1} [inst : AddZeroClass M], 0 ∈ {0}",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Trans",
  "constType":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      (α → β → Sort u) →\n        (β → γ → Sort v) → outParam (α → γ → Sort w) → Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "RingHom",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "MonoidHom.monoidHomClass",
   "MulHomClass.toFunLike",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "Eq",
   "OneHom.toFun",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.ndrec",
   "MonoidHom.toOneHom",
   "Eq.rec",
   "RingHom.toMonoidHom",
   "Eq.symm",
   "FunLike.coe_injective'"],
  "name": "RingHom.instRingHomClass.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f g : α →+* β),\n  (fun f => f.toFun) f = (fun f => f.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references": ["Max.mk", "LE", "Max", "LE.le", "ite", "DecidableRel"],
  "name": "maxOfLe",
  "constType":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq.trans",
   "eq_self",
   "mul_add",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instAddNat",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_add",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Nat.rec",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "congr",
   "mul_one",
   "instMulNat",
   "congrArg",
   "congrFun",
   "Nat.semiring"],
  "name": "Nat.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "Membership.mem",
   "SubNegMonoid.toSub",
   "AddGroup",
   "HSub.hSub",
   "AddSubgroup",
   "sub_mem",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership"],
  "name": "AddSubgroup.sub_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x y : G}, x ∈ H → y ∈ H → x - y ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Rat.commGroupWithZero",
   "GroupWithZero.toCancelMonoidWithZero",
   "Rat.commRing",
   "CommGroupWithZero.toGroupWithZero",
   "IsDomain",
   "Rat",
   "CommRing.toRing",
   "NoZeroDivisors.to_isDomain",
   "CommGroupWithZero.toNontrivial",
   "CancelMonoidWithZero.to_noZeroDivisors"],
  "name": "Rat.isDomain",
  "constType": "IsDomain ℚ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Invertible.invOf",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "invOf_mul_self",
   "left_inv_eq_right_inv",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Invertible",
   "Eq"],
  "name": "invOf_eq_right_inv",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible a], a * b = 1 → ⅟a = b",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred",
   "Finset.univ",
   "Fintype",
   "Subtype.fintype.proof_1",
   "Finset.filter",
   "Fintype.subtype",
   "Subtype"],
  "name": "Subtype.fintype",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → [inst : Fintype α] → Fintype { x // p x }",
  "constCategory": "Definition"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "RelIso.toEquiv",
   "Iff",
   "RelIso",
   "FunLike.coe",
   "Equiv.instFunLikeEquiv"],
  "name": "RelIso.map_rel_iff'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} {r : α → α → Prop} {s : β → β → Prop} (self : r ≃r s) {a b : α},\n  s (self.toEquiv a) (self.toEquiv b) ↔ r a b",
  "constCategory": "Definition"},
 {"references": ["Set"],
  "name": "MeasurableSpace.GenerateMeasurable",
  "constType": "{α : Type u_1} → Set (Set α) → Set α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": ["Subtype.property", "Subtype.val", "Subtype"],
  "name": "Subtype.prop",
  "constType": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHSMul",
   "instOfNatInt",
   "SubNegMonoid.toNeg",
   "neg_zero",
   "HAdd.hAdd",
   "Eq.refl",
   "neg_neg",
   "SubtractionMonoid",
   "True",
   "zero_zsmul",
   "Eq",
   "Zero.toOfNat0",
   "Nat.add",
   "Eq.mpr",
   "Nat.cast",
   "InvolutiveNeg.toNeg",
   "negSucc_zsmul",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "instOfNatNat",
   "Int.instNegInt",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "ofNat_zsmul",
   "instAddNat",
   "instHAdd",
   "Unit",
   "SubNegMonoid.zsmul_neg'",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddMonoid.toNatSMul",
   "Eq.ndrec",
   "instNatCastInt",
   "of_eq_true",
   "Int.negSucc",
   "SubtractionMonoid.toSubNegMonoid",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrArg",
   "Int",
   "zpow_neg.match_1"],
  "name": "neg_zsmul",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a : α) (n : ℤ), -n • a = -(n • a)",
  "constCategory": "Theorem"},
 {"references":
  ["Min.min",
   "LinearOrder",
   "SemilatticeSup.mk",
   "Lattice.mk",
   "Sup.mk",
   "min_le_right",
   "max_le",
   "Inf.mk",
   "le_min",
   "le_max_left",
   "Max.max",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "LinearOrder.toPartialOrder",
   "Lattice",
   "min_le_left",
   "le_max_right"],
  "name": "LinearOrder.toLattice",
  "constType": "{α : Type u} → [o : LinearOrder α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["AddSemigroup.add_assoc",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toAddSemigroup",
   "HAdd.hAdd",
   "Set",
   "AddMonoid",
   "Eq",
   "Set.addSemigroup"],
  "name": "Set.addMonoid.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoid α] (a b c : Set α), a + b + c = a + (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.mk",
   "Monoid.toOne",
   "Multiplicative.divInvMonoid.proof_2",
   "SubNegMonoid.toNeg",
   "Multiplicative.divInvMonoid.proof_4",
   "DivInvMonoid",
   "Multiplicative.divInvMonoid.proof_3",
   "SubNegMonoid.zsmul_neg'",
   "sub_eq_add_neg",
   "Multiplicative.div",
   "DivInvMonoid.mk",
   "Inv.mk",
   "Inv",
   "Multiplicative.monoid",
   "SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "Multiplicative",
   "Div.mk",
   "Multiplicative.inv",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "Div.div",
   "Div",
   "Multiplicative.divInvMonoid.proof_1",
   "SubNegMonoid.zsmul_zero'",
   "Inv.inv",
   "Monoid.npow"],
  "name": "Multiplicative.divInvMonoid",
  "constType":
  "{α : Type u} → [inst : SubNegMonoid α] → DivInvMonoid (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "instHSub",
   "instSubNat",
   "Int.negSucc",
   "Unit",
   "HSub.hSub",
   "Int.negOfNat.match_1",
   "Nat",
   "Int"],
  "name": "Int.subNatNat",
  "constType": "ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing.toDivisionSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionRing.toRing",
   "Eq.refl",
   "Semiring.npow_succ",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Semiring.npow",
   "Div.mk",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "CauSeq.Completion.instInvCauchyToRing",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Semigroup.mk",
   "instHDiv",
   "DivisionRing",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "DivInvMonoid.div'",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "CauSeq.Completion.Cauchy.ring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_6",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a b : CauSeq.Completion.Cauchy abv), a / b = a / b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Function.Injective.addCommGroup",
   "AddSubgroup.toAddCommGroup.proof_1",
   "Subtype.val",
   "AddSubgroup.toAddCommGroup.proof_3",
   "AddSubgroup.zero",
   "AddSubgroup.toAddCommGroup.proof_4",
   "AddSubgroup.toAddCommGroup.proof_7",
   "SetLike.instMembership",
   "AddSubgroup.zsmul",
   "AddSubgroup.toAddCommGroup.proof_5",
   "AddSubgroup.nsmul",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddSubgroup.toAddCommGroup.proof_2",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroup.neg",
   "AddSubgroup.toAddCommGroup.proof_6",
   "AddSubgroup.sub",
   "Subtype",
   "AddSubgroup.add"],
  "name": "AddSubgroup.toAddCommGroup",
  "constType":
  "{G : Type u_5} → [inst : AddCommGroup G] → (H : AddSubgroup G) → AddCommGroup ↥H",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Ordering", "LT.lt", "Ordering.Compares.match_1", "LT", "GT.gt", "Eq"],
  "name": "Ordering.Compares",
  "constType": "{α : Type u_1} → [inst : LT α] → Ordering → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Exists", "eq_false", "False", "exists_false", "Eq"],
  "name": "Std.Logic._auxLemma.31",
  "constType": "∀ {α : Sort u_1}, (∃ _a, False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "MulOneClass.toMul",
   "instHDiv",
   "div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "True",
   "CommMonoid.toCommSemigroup",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "of_eq_true",
   "CommSemigroup.toCommMagma",
   "DivisionCommMonoid.toDivisionMonoid",
   "DivisionCommMonoid.toCommMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "congr",
   "DivisionCommMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "congrArg",
   "Eq.trans",
   "mul_left_comm",
   "DivInvMonoid.toDiv",
   "Inv.inv"],
  "name": "mul_div_left_comm",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b c : α), a * (b / c) = b * (a / c)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "SubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "SubNegMonoid.zsmul_succ'",
  "constType":
  "∀ {G : Type u} [self : SubNegMonoid G] (n : ℕ) (a : G),\n  SubNegMonoid.zsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.zsmul (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Nonempty.intro",
   "Fintype",
   "Set.Elem",
   "Set",
   "Nonempty",
   "Nonempty.casesOn"],
  "name": "Set.finite_def.match_2",
  "constType":
  "∀ {α : Type u_1} {s : Set α} (motive : Nonempty (Fintype ↑s) → Prop) (x : Nonempty (Fintype ↑s)),\n  (∀ (h : Fintype ↑s), motive (_ : Nonempty (Fintype ↑s))) → motive x",
  "constCategory": "Definition"},
 {"references": ["DivisionRing", "Inv"],
  "name": "DivisionRing.toInv",
  "constType": "{K : Type u} → [self : DivisionRing K] → Inv K",
  "constCategory": "Definition"},
 {"references":
  ["IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "Set.Set.completeAtomicBooleanAlgebra",
   "IsGLB.of_image",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "SetLike.instPartialOrder",
   "AddSubgroup.instInfSetAddSubgroup",
   "isGLB_biInf",
   "AddGroup",
   "SetLike.coe_subset_coe",
   "AddSubgroup",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SetLike.coe"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_s : Set (AddSubgroup G)), IsGLB _s (sInf _s)",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "Function.Injective",
   "EquivLike.inv",
   "EquivLike.left_inv",
   "Function.LeftInverse.injective"],
  "name": "EquivLike.toEmbeddingLike.proof_2",
  "constType":
  "∀ {E : Sort u_3} {α : Sort u_1} {β : Sort u_2} [iE : EquivLike E α β] (e : E), Function.Injective (EquivLike.coe e)",
  "constCategory": "Theorem"},
 {"references": ["Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.702", "Real"],
  "name": "_private.Mathlib.Data.Real.Basic.0.Real.one",
  "constType": "ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "StrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mul_lt_mul_of_pos_left",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "HasSubset.Subset",
   "Finset.image₂_subset_right",
   "Add",
   "Finset.instHasSubsetFinset",
   "Finset.add"],
  "name": "Finset.add_subset_add_right",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] {s₁ s₂ t : Finset α}, s₁ ⊆ s₂ → s₁ + t ⊆ s₂ + t",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Iff.mp",
   "Preorder.toLT",
   "LT.lt",
   "le_not_le_of_lt.match_1",
   "Not",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE"],
  "name": "le_not_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image2",
  "constType":
  "{α : Type u_1} → {β : Type u_3} → {γ : Type u_5} → (α → β → γ) → Set α → Set β → Set γ",
  "constCategory": "Definition"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5124",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["One"],
  "name": "One.one",
  "constType": "{α : Type u} → [self : One α] → α",
  "constCategory": "Definition"},
 {"references":
  ["DecidablePred",
   "Eq.ndrec",
   "Eq.rec",
   "Decidable",
   "Finset",
   "Eq.refl",
   "Finset.filter",
   "instSubsingletonDecidable",
   "instSubsingletonForAll",
   "Subsingleton.elim",
   "Eq"],
  "name": "Finset.filter_congr_decidable",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) (p : α → Prop) (h : DecidablePred p) [inst : DecidablePred p],\n  Finset.filter p s = Finset.filter p s",
  "constCategory": "Theorem"},
 {"references": ["Max", "LinearOrderedAddCommMonoid"],
  "name": "LinearOrderedAddCommMonoid.toMax",
  "constType": "{α : Type u_3} → [self : LinearOrderedAddCommMonoid α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.rec",
  "constType":
  "{G : Type u_5} →\n  [inst : AddGroup G] →\n    {motive : AddSubgroup G → Sort u} →\n      ((toAddSubmonoid : AddSubmonoid G) →\n          (neg_mem' : ∀ {x : G}, x ∈ toAddSubmonoid.carrier → -x ∈ toAddSubmonoid.carrier) →\n            motive { toAddSubmonoid := toAddSubmonoid, neg_mem' := neg_mem' }) →\n        (t : AddSubgroup G) → motive t",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "HasSubset.Subset",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "Set.Set.completeAtomicBooleanAlgebra",
   "le_rfl",
   "MeasurableSpace.mkOfClosure_sets",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "MeasurableSpace.instLEMeasurableSpace",
   "Set.instHasSubsetSet",
   "MeasurableSpace.generateFrom_le_iff",
   "Iff.mp",
   "MeasurableSpace.mkOfClosure",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "CompleteLattice.toCompleteSemilatticeInf",
   "le_antisymm",
   "MeasurableSpace"],
  "name": "MeasurableSpace.giGenerateFrom.proof_3",
  "constType":
  "∀ {α : Type u_1} (x : Set (Set α)) (x_1 : {t | MeasurableSet t} ≤ x),\n  MeasurableSpace.mkOfClosure x (_ : {t | MeasurableSet t} = x) = MeasurableSpace.generateFrom x",
  "constCategory": "Theorem"},
 {"references": ["Or", "IsTotal"],
  "name": "IsTotal.mk",
  "constType":
  "∀ {α : Type u} {r : α → α → Prop}, (∀ (a b : α), r a b ∨ r b a) → IsTotal α r",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemiring.toMax",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedSemiring.decidableLE",
   "Max.max",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedSemiring.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedSemiring α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Quot.liftOn",
   "DecidablePred",
   "Setoid.r",
   "List.filter",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.filter.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Iff", "Classical.propDecidable", "Decidable.not_iff_not", "Not"],
  "name": "not_iff_not",
  "constType": "∀ {a b : Prop}, (¬a ↔ ¬b) ↔ (a ↔ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "StrictOrderedSemiring",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "LT.lt",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toSemiring : Semiring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        (∀ (a b c : α), a + b ≤ a + c → b ≤ c) →\n          [toNontrivial : Nontrivial α] →\n            0 ≤ 1 →\n              (∀ (a b c : α), a < b → 0 < c → c * a < c * b) →\n                (∀ (a b c : α), a < b → 0 < c → a * c < b * c) → StrictOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Neg.toHasAbs",
   "DistribLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "le_max_right",
   "Abs.abs",
   "Preorder.toLE",
   "Neg"],
  "name": "neg_le_abs_self",
  "constType":
  "∀ {α : Type u_1} [inst : Neg α] [inst_1 : LinearOrder α] (a : α), -a ≤ |a|",
  "constCategory": "Theorem"},
 {"references": ["Mul"],
  "name": "HasDistribNeg",
  "constType": "(α : Type u_1) → [inst : Mul α] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "MulOneClass.toOne",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Mathlib.Meta.NormNum.IsInt.to_isRat.match_1",
   "Semiring.toOne",
   "instHMul",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "mul_one",
   "Invertible.mk",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isRat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, Mathlib.Meta.NormNum.IsInt a n → Mathlib.Meta.NormNum.IsRat a n 1",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "CommSemigroup.mk",
   "NonUnitalCommSemiring.mul_comm",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommSemigroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "NonUnitalCommSemiring.toCommSemigroup",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → CommSemigroup α",
  "constCategory": "Definition"},
 {"references": ["Subsingleton", "Eq"],
  "name": "Subsingleton.intro",
  "constType": "∀ {α : Sort u}, (∀ (a b : α), a = b) → Subsingleton α",
  "constCategory": "Other"},
 {"references": ["LinearOrderedAddCommGroup", "OrderedAddCommGroup"],
  "name": "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "Preorder",
   "LE.le",
   "AddZeroClass",
   "Preorder.toLE",
   "Left.add_nonpos"],
  "name": "add_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "One.toOfNat1",
   "Int.cast_ofNat",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Eq.ndrec",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "Int",
   "Nat.cast_one",
   "id"],
  "name": "Int.cast_one",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.commSemiring",
   "CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Nat"],
  "name": "Nat.semiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "MeasureTheory.IsFiniteMeasure",
   "Set.univ",
   "MeasureTheory.IsFiniteMeasure.measure_univ_lt_top",
   "LE.le.trans_lt",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "MeasurableSpace",
   "Set.subset_univ",
   "MeasureTheory.measure_mono"],
  "name": "MeasureTheory.measure_lt_top",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ]\n  (s : Set α), ↑↑μ s < ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure.prod.instIsProbabilityMeasure",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace",
   "Prod",
   "MeasureTheory.Measure.prod.measureSpace",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.MeasureSpace.volume"],
  "name":
  "MeasureTheory.Measure.instIsProbabilityMeasureProdToMeasurableSpaceMeasureSpaceVolume",
  "constType":
  "∀ {α : Type u_7} {β : Type u_8} [inst : MeasureTheory.MeasureSpace α] [inst_1 : MeasureTheory.MeasureSpace β]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume],\n  MeasureTheory.IsProbabilityMeasure MeasureTheory.volume",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "Complex.arg",
   "Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Complex.sin_arg",
   "HAdd.hAdd",
   "AbsoluteValue",
   "Complex.sin",
   "Semifield.toCommGroupWithZero",
   "Complex.cos",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Complex.exp_add_mul_I",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Complex.instField",
   "CommGroupWithZero.toDiv",
   "Complex.ofReal_cos",
   "Complex.re_add_im",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Real.cos",
   "Complex.abs",
   "Ne",
   "Complex.instZeroComplex",
   "instHDiv",
   "Complex.ofReal_exp",
   "Real.sin",
   "AbsoluteValue.pos",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.instAddComplex",
   "Real.orderedSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "SubadditiveHomClass.toFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Complex.im",
   "Real.exp_log",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Complex.log",
   "Field.toDiv",
   "mul_div_cancel'",
   "Complex.exp",
   "Complex.ofReal_sin",
   "Real.instLinearOrderedFieldReal",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Real",
   "Eq.refl",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "AbsoluteValue.subadditiveHomClass",
   "Zero.toOfNat0",
   "Complex.instSemiringComplex",
   "Complex.ofReal_div",
   "Eq.symm",
   "Complex.I",
   "id",
   "Complex.ofReal'",
   "CommGroupWithZero.toGroupWithZero",
   "mul_add",
   "instHAdd",
   "Field.toSemifield",
   "FunLike.coe",
   "NormedField.toNormedCommRing",
   "GroupWithZero.toMonoidWithZero",
   "Real.exp",
   "_private.Mathlib.Analysis.SpecialFunctions.Complex.Log.0.Complex.log._eq_1",
   "Complex.re",
   "Real.instZeroReal",
   "Distrib.leftDistribClass",
   "NormedCommRing.toSeminormedCommRing",
   "Real.log",
   "Eq.ndrec",
   "AbsoluteValue.ne_zero",
   "Complex.cos_arg",
   "OrderedSemiring.toSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Complex.ofReal_ne_zero",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Complex",
   "Complex.instMulComplex",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.exp_log",
  "constType": "∀ {x : ℂ}, x ≠ 0 → Complex.exp (Complex.log x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddCommMonoid.toAddMonoid",
   "autoParam",
   "Semifield",
   "Inv",
   "Eq",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4838",
   "Zero.toOfNat0",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4799",
   "Nat.cast",
   "CommSemiring",
   "AddMonoid.toZero",
   "Div",
   "HDiv.hDiv",
   "Nat",
   "Nat.succ",
   "Ne",
   "instHDiv",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.toOne",
   "instHMul",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4877",
   "instNatCastInt",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4916",
   "Int.negSucc",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Semifield.mk",
  "constType":
  "{α : Type u_4} →\n  [toCommSemiring : CommSemiring α] →\n    [toInv : Inv α] →\n      [toDiv : Div α] →\n        autoParam (∀ (a b : α), a / b = a * b⁻¹) _auto✝ →\n          (zpow : ℤ → α → α) →\n            autoParam (∀ (a : α), zpow 0 a = 1) _auto✝¹ →\n              autoParam (∀ (n : ℕ) (a : α), zpow (Int.ofNat (Nat.succ n)) a = a * zpow (Int.ofNat n) a) _auto✝² →\n                autoParam (∀ (n : ℕ) (a : α), zpow (Int.negSucc n) a = (zpow (↑(Nat.succ n)) a)⁻¹) _auto✝³ →\n                  [toNontrivial : Nontrivial α] → 0⁻¹ = 0 → (∀ (a : α), a ≠ 0 → a * a⁻¹ = 1) → Semifield α",
  "constCategory": "Other"},
 {"references":
  ["MeasureTheory.Measure",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "ProbabilityTheory.kernel.iIndepFun",
   "Unit",
   "Unit.unit",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.438",
   "MeasureTheory.Measure.dirac",
   "autoParam",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.iIndepFun",
  "constType":
  "{Ω : Type u_1} →\n  {ι : Type u_2} →\n    [inst : MeasurableSpace Ω] →\n      {β : ι → Type u_6} →\n        ((x : ι) → MeasurableSpace (β x)) → ((x : ι) → Ω → β x) → autoParam (MeasureTheory.Measure Ω) _auto✝ → Prop",
  "constCategory": "Definition"},
 {"references": ["OrderHom", "Preorder"],
  "name": "OrderHom.toFun",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → [inst : Preorder α] → [inst_1 : Preorder β] → (α →o β) → α → β",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.image2",
   "Set.mem_image2_of_mem",
   "Set",
   "Set.Nonempty",
   "Set.Nonempty.image2.match_1",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Nonempty.image2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β},\n  Set.Nonempty s → Set.Nonempty t → Set.Nonempty (Set.image2 f s t)",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "AddSubmonoid.add_mem",
   "Inter.inter",
   "And.intro",
   "AddSubmonoid.instInfAddSubmonoid.match_1",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instInfAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S₁ S₂ : AddSubmonoid M) {a b : M},\n  a ∈ ↑S₁ ∩ ↑S₂ → b ∈ ↑S₁ ∩ ↑S₂ → a + b ∈ ↑S₁ ∩ ↑S₂",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.Le",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Multiset.instPartialOrderMultiset.proof_2",
   "Multiset.instPartialOrderMultiset.proof_4",
   "Multiset",
   "Multiset.instPartialOrderMultiset.proof_3",
   "Not",
   "Multiset.instPartialOrderMultiset.proof_1",
   "LT.mk",
   "PartialOrder",
   "Preorder.mk"],
  "name": "Multiset.instPartialOrderMultiset",
  "constType": "{α : Type u_1} → PartialOrder (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Multiset",
   "Finset.mk",
   "Multiset.toFinset.proof_1",
   "Multiset.dedup"],
  "name": "Multiset.toFinset",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "SemiconjBy",
   "MulZeroClass",
   "MulZeroClass.zero_mul",
   "MulZeroClass.mul_zero",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "of_eq_true",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "SemiconjBy.zero_left",
  "constType":
  "∀ {G₀ : Type u_3} [inst : MulZeroClass G₀] (x y : G₀), SemiconjBy 0 x y",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue"],
  "name": "instDecidableAnd.match_1",
  "constType":
  "{q : Prop} →\n  (motive : Decidable q → Sort u_1) →\n    (dq : Decidable q) → ((hq : q) → motive (isTrue hq)) → ((hq : ¬q) → motive (isFalse hq)) → motive dq",
  "constCategory": "Definition"},
 {"references":
  ["Set.ext",
   "Fintype",
   "Set.Elem",
   "Set.toFinset",
   "Finset.toSet",
   "Set",
   "Set.mem_toFinset",
   "Eq"],
  "name": "Set.coe_toFinset",
  "constType":
  "∀ {α : Type u_1} (s : Set α) [inst : Fintype ↑s], ↑(Set.toFinset s) = s",
  "constCategory": "Theorem"},
 {"references": ["And", "Function.Surjective", "Function.Injective"],
  "name": "Function.Bijective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "Eq.refl",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "Rat",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_13",
  "constType":
  "∀ (a : ℚ) (x : ℝ), (qsmulRec Rat.cast) a x = (qsmulRec Rat.cast) a x",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Preorder.le_trans",
   "Real.instSupReal",
   "Sup.mk",
   "Preorder.toLE",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "Eq.mpr",
   "Preorder.toLT",
   "Rat.instNegRat",
   "Real.ind_mk",
   "Eq.symm",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Real.mk_le",
   "Preorder.le_refl",
   "Rat",
   "CauSeq",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Preorder.mk",
   "CauSeq.le_sup_left",
   "Eq.ndrec",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.mk_sup",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le"],
  "name": "Real.instDistribLatticeReal.proof_4",
  "constType": "∀ (a b : ℝ), a ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "setOf",
   "MeasureTheory.Measure.ae.proof_2",
   "MeasureTheory.Measure.ae.proof_1",
   "Set",
   "MeasureTheory.Measure.ae.proof_3",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Filter.mk",
   "Filter",
   "MeasurableSpace"],
  "name": "MeasureTheory.Measure.ae",
  "constType":
  "{α : Type u_6} → {m : MeasurableSpace α} → MeasureTheory.Measure α → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Or",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Neg.neg",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "rfl",
   "Eq",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Field.toCommRing",
   "NormedField.toField",
   "instHMul",
   "Or.intro_left",
   "Ring.toNeg",
   "AddMonoid.toZero",
   "HMul.hMul",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_2",
  "constType": "0 = 0 ∨ 0 * 0 = -1",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "AddCommMonoid"],
  "name": "Module",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst : AddCommMonoid M] → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toRing",
   "AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "Mathlib.Algebra.Order.Group.Defs._auxLemma.10",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Ring.toNeg",
   "mul_pos_of_neg_of_neg",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "StrictOrderedRing",
   "HasDistribNeg.toInvolutiveNeg",
   "AddGroup.toAddCancelMonoid",
   "neg_mul",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "StrictOrderedRing.toPartialOrder",
   "NonUnitalNonAssocRing.toMul",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "neg_neg_of_pos",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "StrictOrderedSemiring.toSemiring",
   "GT.gt",
   "instHMul",
   "Std.Classes.Order._auxLemma.4",
   "AddCancelMonoid.toIsCancelAdd",
   "neg_of_neg_pos",
   "LT.lt",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrFun"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "RelHomClass",
  "constType":
  "Type u_5 →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} → outParam (α → α → Prop) → outParam (β → β → Prop) → Type (max (max u_5 u_6) u_7)",
  "constCategory": "Other"},
 {"references": ["AddGroup"],
  "name": "AddSubgroup",
  "constType": "(G : Type u_5) → [inst : AddGroup G] → Type u_5",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "PosMulMono",
   "mul_le_mul_of_nonneg_left",
   "Eq.mp",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "congrArg",
   "LE.le",
   "Preorder.toLE",
   "MulZeroClass.toMul",
   "congrFun"],
  "name": "Left.mul_nonneg",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],\n  0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "MulOneClass",
   "Submonoid.instSetLikeSubmonoid",
   "Submonoid.instInfSetSubmonoid",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_12",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (s : Set (Submonoid M)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Nat.card_pos_iff",
   "OfNat.ofNat",
   "LT.lt",
   "Finite",
   "instOfNatNat",
   "And.intro",
   "Nat",
   "Nat.card",
   "instLTNat",
   "Iff.mpr",
   "Nonempty"],
  "name": "Nat.card_pos",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α] [inst : Finite α], 0 < Nat.card α",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "true_or_iff", "True", "Eq"],
  "name": "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "List.isSetoid",
   "List.Sublist",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Setoid.r",
   "instHAppend",
   "List.instAppendList",
   "List.Perm",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "HAppend.hAppend",
   "Multiset.le_iff_exists_add.match_1",
   "AddMonoid.toAddSemigroup",
   "List",
   "Multiset",
   "Multiset.leInductionOn",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.ofList",
   "List.Sublist.exists_perm_append",
   "OrderedAddCommMonoid.toPartialOrder",
   "Quot.sound",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_2",
  "constType": "∀ {α : Type u_1} {a b : Multiset α}, a ≤ b → ∃ c, b = a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "False.elim",
   "False",
   "Preorder.toLT",
   "LT.lt",
   "lt_irrefl",
   "Preorder"],
  "name": "lt_self_iff_false",
  "constType": "∀ {α : Type u} [inst : Preorder α] (x : α), x < x ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.property",
   "Membership.mem",
   "AddSubgroup.nsmul_mem",
   "instHSMul",
   "AddGroup",
   "Subtype.val",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "AddSubgroup",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Subtype",
   "AddMonoid.toNatSMul"],
  "name": "AddSubgroup.nsmul.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} (n : ℕ) (a : ↥H), n • ↑a ∈ H",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedField.inv_zero",
  "constType": "∀ {α : Type u_2} [self : LinearOrderedField α], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references": ["Subtype.val", "rfl", "Subtype.mk", "Eq"],
  "name": "Subtype.coe_mk",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (a : α) (h : p a), ↑{ val := a, property := h } = a",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Function.Bijective.surjective",
   "Function.Bijective",
   "Function.surjInv",
   "Function.leftInverse_surjInv",
   "Equiv.mk",
   "Equiv.ofBijective.proof_1"],
  "name": "Equiv.ofBijective",
  "constType":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → Function.Bijective f → α ≃ β",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "IntCast.mk",
   "Int.cast",
   "Ring.toIntCast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Int",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "IntCast"],
  "name": "CauSeq.instIntCast",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → IntCast (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.nsmul",
   "HAdd.hAdd",
   "Set",
   "Eq.refl",
   "sub_eq_add_neg",
   "SubtractionMonoid",
   "Set.addMonoid",
   "AddMonoid.add_zero",
   "Sub.mk",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Set.image_image2_distrib_right",
   "Set.image_id",
   "AddMonoid.toAddSemigroup",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toZero",
   "Set.sub",
   "Sub.sub",
   "Set.image",
   "Eq.symm",
   "id",
   "instHSub",
   "Set.neg",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "Set.image_neg",
   "Set.involutiveNeg",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddMonoid.mk",
   "AddMonoid.nsmul_zero",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "AddMonoid.zero_add"],
  "name": "Set.subtractionMonoid.proof_5",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (s t : Set α), s - t = s + -t",
  "constCategory": "Theorem"},
 {"references":
  ["Complex.ofReal'",
   "Real.sin",
   "Complex.ofReal_sin_ofReal_re",
   "Real",
   "Complex.sin",
   "Complex",
   "Eq"],
  "name": "Complex.ofReal_sin",
  "constType": "∀ (x : ℝ), ↑(Real.sin x) = Complex.sin ↑x",
  "constCategory": "Theorem"},
 {"references": ["Neg"],
  "name": "Neg.mk",
  "constType": "{α : Type u} → (α → α) → Neg α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instOfNatInt",
   "One.toOfNat1",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Int",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (a : α), LinearOrderedSemifield.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "AddSubsemigroup.mk",
   "MulOneClass",
   "Set",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "AddSubmonoid.zero_mem'",
   "AddZeroClass.toZero",
   "Additive.toMul",
   "Submonoid.toSubsemigroup",
   "Subsemigroup.mk",
   "AddSubmonoid.mk",
   "Eq.symm",
   "Membership.mem",
   "Submonoid.mk",
   "Submonoid.instSetLikeSubmonoid",
   "Set.preimage",
   "Submonoid.one_mem'",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubsemigroup.add_mem'",
   "FunLike.coe",
   "Additive.ofMul",
   "Additive.addZeroClass",
   "AddSubmonoid",
   "Equiv.instFunLikeEquiv",
   "Set.instMembershipSet",
   "AddSubsemigroup",
   "AddSubmonoid.casesOn",
   "Eq.ndrec",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Subsemigroup.mul_mem'",
   "Submonoid",
   "AddSubsemigroup.carrier",
   "SetLike.coe",
   "Additive"],
  "name": "Submonoid.toAddSubmonoid.proof_5",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x : AddSubmonoid (Additive M)),\n  (fun S =>\n        {\n          toAddSubsemigroup :=\n            { carrier := ⇑Additive.toMul ⁻¹' ↑S,\n              add_mem' :=\n                (_ :\n                  ∀ {a b : Additive M},\n                    a ∈ ⇑Additive.toMul ⁻¹' ↑S →\n                      b ∈ ⇑Additive.toMul ⁻¹' ↑S → Additive.toMul a * Additive.toMul b ∈ S.carrier) },\n          zero_mem' := (_ : 1 ∈ S.carrier) })\n      ((fun S =>\n          {\n            toSubsemigroup :=\n              { carrier := ⇑Additive.ofMul ⁻¹' ↑S,\n                mul_mem' :=\n                  (_ : ∀ {a b : M}, a ∈ ⇑Additive.ofMul ⁻¹' ↑S → b ∈ ⇑Additive.ofMul ⁻¹' ↑S → a + b ∈ S.carrier) },\n            one_mem' := (_ : 0 ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Ring.toAddGroupWithOne",
   "AddGroup",
   "CommRing.toRing",
   "Int",
   "Int.instCommRingInt",
   "AddGroupWithOne.toAddGroup"],
  "name": "Int.instAddGroupInt",
  "constType": "AddGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.sup_le",
   "Pi.booleanAlgebra",
   "Sup.sup",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_7",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.left_distrib",
   "Eq",
   "instHMul",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedRing.toRing",
   "AddMonoid.toAddSemigroup",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_7",
  "constType":
  "∀ {α : Type u_1} [β : SeminormedCommRing α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["Zero"],
  "name": "Zero.zero",
  "constType": "{α : Type u} → [self : Zero α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "Abs.abs",
   "Rat.instSupRat",
   "IntCast.mk",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "IntCast"],
  "name": "Real.intCast",
  "constType": "IntCast ℝ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Matrix.vecTail",
   "funext",
   "Matrix.cons_val_succ",
   "of_eq_true",
   "Matrix.vecCons",
   "Nat",
   "congrArg",
   "Fin.succ",
   "Eq.trans",
   "True",
   "Fin",
   "congrFun",
   "Eq"],
  "name": "Matrix.tail_cons",
  "constType":
  "∀ {α : Type u} {m : ℕ} (x : α) (u : Fin m → α), Matrix.vecTail (Matrix.vecCons x u) = u",
  "constCategory": "Theorem"},
 {"references": ["Classical.choose_spec", "Exists", "Exists.choose"],
  "name": "Exists.choose_spec",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p (Exists.choose P)",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg",
   "Iff",
   "InvolutiveNeg.toNeg",
   "neg_injective",
   "Neg.neg",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "neg_inj",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OrderedCancelAddCommMonoid",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddMonoid.toZero",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "instOfNatNat",
   "AddCommMonoid.toAddMonoid",
   "Nat",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedCancelAddCommMonoid.toCancelAddCommMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] (x : α), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddMonoid.nsmul_zero",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_4",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (x : G), AddMonoid.nsmul 0 x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "LinearOrderedSemiring.toPosMulReflectLT",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "pos_of_mul_pos_left",
   "Invertible",
   "Preorder.toLE",
   "True",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "mul_invOf_self",
   "Iff",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "Mathlib.Algebra.Order.Invertible._auxLemma.1",
   "Eq.trans",
   "Invertible.invOf",
   "LT.lt.le",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "OrderedSemiring.zeroLEOneClass",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "pos_of_mul_pos_right",
   "Iff.intro",
   "Semiring.toOne",
   "instHMul",
   "StrictOrderedSemiring.toPartialOrder",
   "of_eq_true",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "LinearOrderedSemiring.toMulPosReflectLT",
   "congrArg"],
  "name": "invOf_nonneg",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedSemiring α] {a : α} [inst_1 : Invertible a], 0 ≤ ⅟a ↔ 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "Real.instLEReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "dite",
   "Complex.ofReal_log",
   "Real.rpow_def_of_nonneg",
   "True",
   "ite",
   "Eq",
   "Real.instOneReal",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.1",
   "Real.decidableEq",
   "Zero.toOfNat0",
   "Complex.ofReal_mul",
   "Eq.mpr",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Eq.trans",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "Complex.ofReal_exp",
   "Complex.instZeroComplex",
   "One.toOfNat1",
   "LE.le",
   "Real.exp",
   "ite_congr",
   "Real.instZeroReal",
   "instHMul",
   "if_pos",
   "Real.log",
   "of_eq_true",
   "HMul.hMul",
   "congr",
   "Not",
   "Complex",
   "Complex.log",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.ofReal_cpow",
  "constType": "∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), ↑(x ^ y) = ↑x ^ ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instNatCastInt",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "Int",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Int.instCommRingInt.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid",
   "AddCommMonoid",
   "Eq"],
  "name": "AddCommMonoid.mk",
  "constType":
  "{M : Type u} → [toAddMonoid : AddMonoid M] → (∀ (a b : M), a + b = b + a) → AddCommMonoid M",
  "constCategory": "Other"},
 {"references":
  ["Exists",
   "Countable",
   "Function.Injective",
   "Function.comp",
   "Function.Injective.countable.match_1",
   "Function.Injective.comp",
   "Exists.intro",
   "Nat",
   "Countable.mk",
   "Countable.exists_injective_nat"],
  "name": "Function.Injective.countable",
  "constType":
  "∀ {α : Sort u} {β : Sort v} [inst : Countable β] {f : α → β}, Function.Injective f → Countable α",
  "constCategory": "Theorem"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references": ["MeasurableSpace"],
  "name": "MeasurableSingletonClass",
  "constType": "(α : Type u_7) → [inst : MeasurableSpace α] → Prop",
  "constCategory": "Other"},
 {"references": ["outParam"],
  "name": "EquivLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["AddMonoid.nsmul",
   "Monoid",
   "Monoid.mk",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "Multiplicative.semigroup",
   "Multiplicative.monoid.proof_1",
   "AddMonoid.toAddZeroClass",
   "AddMonoid",
   "Multiplicative",
   "AddMonoid.nsmul_zero",
   "Multiplicative.monoid.proof_2",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.nsmul_succ",
   "Multiplicative.monoid.proof_3",
   "Multiplicative.mulOneClass",
   "Semigroup",
   "Semigroup.mk"],
  "name": "Multiplicative.monoid",
  "constType": "{α : Type u} → [h : AddMonoid α] → Monoid (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "One",
   "MulOneClass",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Eq"],
  "name": "MulOneClass.mk",
  "constType":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "constCategory": "Other"},
 {"references": ["HasCompl", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHasCompl",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HasCompl α",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Exists",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "Semifield.toCommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "GT.gt",
   "Zero.toOfNat0",
   "LinearOrderedField",
   "instLENat",
   "Preorder.toLT",
   "LT.lt",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat"],
  "name": "CauSeq.LimZero",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} → [inst : LinearOrderedField α] → [inst_1 : Ring β] → {abv : β → α} → CauSeq β abv → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Complex.arg",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "mul_neg",
   "SubNegMonoid.toNeg",
   "Real.instAddMonoidReal",
   "Semifield.toCommGroupWithZero",
   "Real.pi",
   "Real.decidableLE",
   "And.left",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Real.sin_pi",
   "Real.instOneReal",
   "ite",
   "Real.sin_neg",
   "And.right",
   "SemilatticeSup.toSup",
   "Real.cos_pi",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "HasDistribNeg.toInvolutiveNeg",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "Complex.abs",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real.sin",
   "MulOneClass.toOne",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Real.normedCommRing",
   "SubadditiveHomClass.toFunLike",
   "Complex.im",
   "And",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Real",
   "neg_neg",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "Abs.abs",
   "Real.instAddCommGroupReal",
   "AbsoluteValue.subadditiveHomClass",
   "Real.arcsin_neg",
   "Complex.instSemiringComplex",
   "InvolutiveNeg.toNeg",
   "Lattice.toSemilatticeSup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "if_neg",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Real.arcsin",
   "Neg.toHasAbs",
   "Complex.abs_im_div_abs_le_one",
   "Real.cos_neg",
   "NonUnitalNonAssocRing.toMul",
   "One.toOfNat1",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Real.instLinearOrderedAddCommGroupReal",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "Monoid.toMulOneClass",
   "NormedCommRing.toSeminormedCommRing",
   "DivisionMonoid.toDivInvMonoid",
   "NegZeroClass.toNeg",
   "MulOneClass.toMul",
   "OrderedAddCommGroup.toPartialOrder",
   "MulZeroOneClass.toMulOneClass",
   "neg_zero",
   "Real.instSubReal",
   "Real.instAddReal",
   "HAdd.hAdd",
   "AbsoluteValue",
   "Real.instLEReal",
   "Real.instMulReal",
   "sub_eq_add_neg",
   "dite",
   "MulZeroClass.mul_zero",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "DivisionCommMonoid.toDivisionMonoid",
   "Eq.trans",
   "neg_div",
   "Real.cos",
   "Real.sin_arcsin",
   "Real.orderedSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "DistribLattice.toLattice",
   "instHMul",
   "of_eq_true",
   "Real.instAddGroupReal",
   "Not",
   "mul_one",
   "congrArg",
   "add_zero",
   "OrderedAddCommGroup.toAddCommGroup",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "Complex.instNegComplex",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "LinearOrderedField.toDiv",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "MulZeroClass.toZero",
   "id",
   "eq_self",
   "instHAdd",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Complex.re",
   "abs_le",
   "Real.instZeroReal",
   "if_pos",
   "Real.semiring",
   "SubNegMonoid.toAddMonoid",
   "OrderedSemiring.toSemiring",
   "Real.sin_add",
   "HMul.hMul",
   "Complex",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "NegZeroClass.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.sin_arg",
  "constType": "∀ (x : ℂ), Real.sin (Complex.arg x) = x.im / Complex.abs x",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalSeminormedCommRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedCommRing α] → NonUnitalSeminormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "Real.instMulReal",
   "DivisionRing.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Ring.toIntCast",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Rat.cast",
   "Rat.instNegRat",
   "CauSeq.Completion.instRatCastCauchyToRing",
   "Real.instInvReal",
   "Nat",
   "Ne",
   "Rat.cast_mk'",
   "Real.ofCauchy_natCast",
   "Rat.instLinearOrderedRingRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.intCast",
   "Real.ofCauchy",
   "DivisionRing.toInv",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Int.cast",
   "Real.ofCauchy_inv",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv",
   "StrictOrderedRing.toRing",
   "CauSeq.Completion.instIntCastCauchy",
   "DivisionRing.toDivisionSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "DivisionRing.toRing",
   "Real",
   "Real.ofCauchy_ratCast",
   "CauSeq.Completion.instNatCastCauchy",
   "Eq.refl",
   "Rat.mk'",
   "Real.ofCauchy_intCast",
   "Inv.mk",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Rat.instSupRat",
   "Real.ofCauchy_mul",
   "instOfNatNat",
   "CauSeq.Completion.instMulCauchy",
   "Eq.symm",
   "CauSeq.Completion.instInvCauchyToRing",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "RatCast.mk",
   "Rat",
   "Real.ratCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivisionSemiring.toSemiring",
   "Eq.ndrec",
   "LinearOrderedCommRing.mk",
   "Rat.divisionRing",
   "Real.linearOrderedCommRing",
   "Nat.Coprime",
   "HMul.hMul",
   "Int.natAbs"],
  "name": "Real.instLinearOrderedFieldReal.proof_12",
  "constType":
  "∀ (n : ℤ) (d : ℕ) (hd : d ≠ 0) (h2 : Nat.Coprime (Int.natAbs n) d), ↑(Rat.mk' n d) = ↑n * (↑d)⁻¹",
  "constCategory": "Theorem"},
 {"references": ["Set", "Subsemigroup", "Mul"],
  "name": "Subsemigroup.carrier",
  "constType": "{M : Type u_4} → [inst : Mul M] → Subsemigroup M → Set M",
  "constCategory": "Definition"},
 {"references":
  ["Field.toCommRing",
   "Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "instHMul",
   "Field",
   "CommRing.toRing",
   "HMul.hMul",
   "Field.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "Field.zpow_succ'",
  "constType":
  "∀ {K : Type u} [self : Field K] (n : ℕ) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["Decidable"],
  "name": "DecidableRel",
  "constType": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["ZeroHomClass.mk",
   "outParam",
   "MulOneClass.toMul",
   "MonoidWithZeroHomClass.map_zero",
   "MulZeroOneClass.toMulOneClass",
   "ZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "MonoidWithZeroHomClass",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "MulHomClass.toFunLike",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHomClass.toZeroHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulZeroOneClass M] →\n        [inst_1 : MulZeroOneClass N] → [self : MonoidWithZeroHomClass F M N] → ZeroHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["StarMul",
   "instHMul",
   "Star.star",
   "InvolutiveStar.toStar",
   "HMul.hMul",
   "InvolutiveStar",
   "Mul",
   "Eq"],
  "name": "StarMul.mk",
  "constType":
  "{R : Type u} →\n  [inst : Mul R] → [toInvolutiveStar : InvolutiveStar R] → (∀ (r s : R), star (r * s) = star s * star r) → StarMul R",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "pow_one",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "mul_one",
   "add_zero",
   "congrArg",
   "Nat.semiring",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Quotient.mk''",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.mk",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → CauSeq β abv → CauSeq.Completion.Cauchy abv",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.const",
   "OfNat.ofNat",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Mathlib.Data.Real.CauSeqCompletion._auxLemma.1",
   "CauSeq.LimZero",
   "CauSeq.Completion.inv_mk",
   "CauSeq.Completion.instOneCauchy",
   "True",
   "Quotient.sound",
   "Eq",
   "Quotient.mk",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Eq.mpr",
   "CauSeq.mul_inv_cancel",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.instMulCauchy",
   "not_false_eq_true",
   "CauSeq.Completion.instInvCauchyToRing",
   "CauSeq.instMulCauSeq",
   "Eq.trans",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "id",
   "Ne",
   "DivisionRing",
   "False",
   "One.toOfNat1",
   "CauSeq",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CauSeq.Completion.instZeroCauchy",
   "Semiring.toOne",
   "CauSeq.equiv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "eq_false",
   "CauSeq.inv",
   "of_eq_true",
   "OrderedCommSemiring.toOrderedSemiring",
   "Eq.mp",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "Not",
   "CauSeq.Completion.mk",
   "congrArg",
   "Quotient.inductionOn",
   "congrFun",
   "Inv.inv"],
  "name": "CauSeq.Completion.mul_inv_cancel",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] {x : CauSeq.Completion.Cauchy abv}, x ≠ 0 → x * x⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "Int"],
  "name": "SubNegMonoid.zsmul",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → ℤ → G → G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrder.decidableLE",
   "LinearOrder",
   "LinearOrder.max_def",
   "Real",
   "Real.nontrivial",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.commRing",
   "CommRing.mul_comm",
   "StrictOrderedRing.toNontrivial",
   "StrictOrderedRing.mul_pos",
   "CommRing",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "Nontrivial",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.linearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℝ",
  "constCategory": "Definition"},
 {"references": ["HeytingAlgebra", "GeneralizedHeytingAlgebra"],
  "name": "HeytingAlgebra.toGeneralizedHeytingAlgebra",
  "constType":
  "{α : Type u_4} → [self : HeytingAlgebra α] → GeneralizedHeytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["not_or",
   "And",
   "Or",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "Iff.rfl",
   "propext",
   "Decidable",
   "Eq.refl",
   "Not",
   "instDecidableOr",
   "Decidable.not_not",
   "Eq.symm",
   "Eq",
   "id"],
  "name": "Decidable.or_iff_not_and_not",
  "constType":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "constCategory": "Theorem"},
 {"references": ["Set", "MeasurableSpace"],
  "name": "MeasurableSpace.MeasurableSet'",
  "constType": "{α : Type u_7} → MeasurableSpace α → Set α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm", "Iff", "Decidable", "decidable_of_decidable_of_iff"],
  "name": "decidable_of_iff'",
  "constType":
  "{a : Prop} → (b : Prop) → (a ↔ b) → [inst : Decidable b] → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveInv.toInv",
   "InvolutiveInv.inv_inv",
   "InvolutiveInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_inv",
  "constType": "∀ {G : Type u_1} [inst : InvolutiveInv G] (a : G), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup",
   "PartialOrder.toPreorder",
   "Sup",
   "Sup.sup",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "SemilatticeSup.mk",
  "constType":
  "{α : Type u} →\n  [toSup : Sup α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ a ⊔ b) →\n        (∀ (a b : α), b ≤ a ⊔ b) → (∀ (a b c : α), a ≤ c → b ≤ c → a ⊔ b ≤ c) → SemilatticeSup α",
  "constCategory": "Other"},
 {"references":
  ["Real.orderedAddCommGroup",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real.commRing",
   "AddGroup.toSubtractionMonoid",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Preorder.toLE",
   "Iff.mpr",
   "Real.instOneReal",
   "Eq",
   "Real.linearOrder",
   "Eq.mpr",
   "HasDistribNeg.toInvolutiveNeg",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Real.instInvReal",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Real.one_le_exp",
   "Real.partialOrder",
   "OrderedSemiring.zeroLEOneClass",
   "Function.comp",
   "Real.orderedSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "LT.lt",
   "Real.instAddGroupReal",
   "LinearOrder.toPartialOrder",
   "inv_pos",
   "Inv.inv",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedSemifield.toInv",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "Eq.refl",
   "neg_neg",
   "le_total",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "InvolutiveNeg.toNeg",
   "Preorder.toLT",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "zero_lt_one",
   "Real.exp_neg",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "Or.elim",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Real.instLTReal",
   "lt_of_lt_of_le",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Real.exp",
   "Real.instZeroReal",
   "neg_nonneg",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "Real.instPreorderReal",
   "Complex.instNeZeroRealInstZeroRealOfNatToOfNat1InstOneReal",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero"],
  "name": "Real.exp_pos",
  "constType": "∀ (x : ℝ), 0 < Real.exp x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = Nat.rawCast n + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Analysis.Normed.Group.Basic._hyg.1612",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "Function.Injective", "FunLike.coe"],
  "name": "FunLike.coe_injective'",
  "constType":
  "∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\n  Function.Injective FunLike.coe",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.image",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α) (y : β), y ∈ f '' s ↔ ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset"],
  "name": "Fintype.elems",
  "constType": "{α : Type u_4} → [self : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toOne",
   "OfNat.ofNat",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "instOfNatInt",
   "LinearOrderedField.toLinearOrderedCommRing",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "LinearOrderedField.zpow",
   "Eq"],
  "name": "LinearOrderedField.zpow_zero'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a : α), LinearOrderedField.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MonoidHomClass.toMulHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MulHomClass.toFunLike",
   "AddMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_add",
   "NonAssocSemiring",
   "outParam",
   "AddHomClass.mk",
   "RingHomClass.toMonoidHomClass",
   "AddMonoidHomClass.mk",
   "RingHomClass.map_zero"],
  "name": "RingHomClass.toAddMonoidHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] →\n        [inst_1 : NonAssocSemiring β] → [self : RingHomClass F α β] → AddMonoidHomClass F α β",
  "constCategory": "Definition"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} → [self : Field K] → CommRing K",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.imp", "id"],
  "name": "Or.imp_right",
  "constType": "∀ {b c a : Prop}, (b → c) → a ∨ b → a ∨ c",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.casesOn",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (motive : Mathlib.Meta.NormNum.IsNat (a + b) 0 → Prop)\n  (x : Mathlib.Meta.NormNum.IsNat (a + b) 0),\n  (∀ (h : a + b = ↑0), motive (_ : Mathlib.Meta.NormNum.IsNat (a + b) 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.univ",
   "Set.mem_univ",
   "AddZeroClass",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instTopAddSubmonoid.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {a b : M}, a ∈ Set.univ → b ∈ Set.univ → a + b ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Zero", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toZero",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Zero S₀",
  "constCategory": "Definition"},
 {"references":
  ["Prop.partialOrder.proof_2",
   "LE.mk",
   "And",
   "PartialOrder.mk",
   "Function.comp",
   "LE",
   "Not",
   "LT.mk",
   "Prop.le",
   "LE.le",
   "Prop.partialOrder.proof_1",
   "PartialOrder",
   "id",
   "Preorder.mk"],
  "name": "Prop.partialOrder",
  "constType": "PartialOrder Prop",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "SemilatticeSup.sup_le",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "Sup.sup",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "LE.le",
   "AddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_8",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (a b c : AddSubmonoid M), a ≤ c → b ≤ c → a ⊔ b ≤ c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "HasCompl",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "Trans.trans",
   "Eq.refl",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "invOf_mul_self_assoc'",
   "Commute",
   "True",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "Commute.eq",
   "Eq.ndrec",
   "of_eq_true",
   "instTransEq",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Commute.invOf_left",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible b], Commute b a → Commute (⅟b) a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "Eq",
   "Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_2",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : CauSeq.Completion.Cauchy abv), 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "add_neg_cancel_right",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_neg_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a + -b = c ↔ a = c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "instHMul",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.mul_le_mul_of_nonneg_right",
  "constType":
  "∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "PartialOrder.le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "le_antisymm",
  "constType":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Or",
   "Nat.below",
   "Or.inr",
   "Unit",
   "GE.ge",
   "instLTNat",
   "Eq",
   "PProd",
   "Nat.lt_or_ge.match_2",
   "Nat.le_succ_of_le",
   "PProd.fst",
   "Nat.rec",
   "Or.inl",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "Eq.rec",
   "LT.lt",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.zero_le",
   "Nat.succ",
   "Nat.eq_or_lt_of_le",
   "Nat.lt_or_ge.match_1"],
  "name": "Nat.lt_or_ge",
  "constType": "∀ (n m : ℕ), n < m ∨ n ≥ m",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "NeZero.ne",
   "One",
   "One.toOfNat1"],
  "name": "one_ne_zero",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 1 ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["nonzero_of_invertible",
   "Ne",
   "Invertible.invOf",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing.toRing",
   "DivisionRing.toNontrivial",
   "Mathlib.Meta.NormNum.IsRat",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.IsRat.den_nz.match_1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "HMul.hMul",
   "Nat",
   "MonoidWithZero.toZero",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.den_nz",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionRing α] {a : α} {n : ℤ} {d : ℕ}, Mathlib.Meta.NormNum.IsRat a n d → ↑d ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "upperBounds",
   "And.right",
   "IsGLB",
   "setOf",
   "PartialOrder.toPreorder",
   "Set",
   "lowerBounds",
   "InfSet.sInf",
   "InfSet",
   "And.left",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "PartialOrder"],
  "name": "completeLatticeOfInf.proof_1",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α],\n  (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a b : α), a ≤ sInf {x | a ≤ x ∧ b ≤ x}",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Finite.intro",
   "Fintype",
   "Set.instHasSubsetSet",
   "Set.Elem",
   "Set",
   "Eq.refl",
   "HasSubset.Subset",
   "Finite.of_fintype",
   "Finite.Set.subset",
   "Set.toFinite",
   "Set.Finite",
   "Eq",
   "Set.Finite.casesOn"],
  "name": "Set.Finite.subset",
  "constType":
  "∀ {α : Type u} {s : Set α}, Set.Finite s → ∀ {t : Set α}, t ⊆ s → Set.Finite t",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Rat.commGroupWithZero",
   "zpowRec",
   "Rat.field.proof_4",
   "instRatCastRat",
   "CommGroupWithZero.mul_inv_cancel",
   "RatCast.mk",
   "Field.mk",
   "CommGroupWithZero.inv_zero",
   "Rat",
   "Rat.field.proof_5",
   "NonUnitalNonAssocSemiring.toMul",
   "Rat.field.proof_6",
   "Ring.toSemiring",
   "Rat.instDivRat",
   "Semiring.toOne",
   "instHMul",
   "Rat.commRing",
   "Rat.field.proof_2",
   "Rat.field.proof_1",
   "Field",
   "Rat.instInvRat",
   "Rat.cast",
   "Rat.field.proof_3",
   "HMul.hMul",
   "CommRing.toRing",
   "Rat.instMulRat",
   "Rat.nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Rat.field",
  "constType": "Field ℚ",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "Top.top",
   "OrderTop.le_top",
   "CompleteLattice.toBoundedOrder",
   "GaloisInsertion.liftBoundedOrder",
   "CompleteLattice.toCompleteSemilatticeInf",
   "BoundedOrder.toOrderTop",
   "LE.le",
   "GaloisInsertion",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "GaloisInsertion.liftCompleteLattice.proof_6",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {l : α → β} {u : β → α} [inst : PartialOrder β] [inst_1 : CompleteLattice α]\n  (gi : GaloisInsertion l u) (a : β), a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "Real.natCast",
   "DivisionRing.toRing",
   "Real",
   "Rat",
   "CauSeq.Completion.instNatCastCauchy",
   "Rat.instLinearOrderedRingRat",
   "Real.ofCauchy",
   "rfl",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Nat.cast",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Rat.instNegRat",
   "CauSeq.Completion.Cauchy",
   "Nat",
   "Rat.instLinearOrderedFieldRat"],
  "name": "Real.ofCauchy_natCast",
  "constType": "∀ (n : ℕ), { cauchy := ↑n } = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "DivisionRing.ratCast_mk",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "DivisionRing.toRing",
   "DivisionRing.toRatCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Rat.mk'",
   "DivisionRing.toInv",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Rat.cast",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "Inv.inv",
   "Int.natAbs"],
  "name": "Rat.cast_mk'",
  "constType":
  "∀ {K : Type u_3} [inst : DivisionRing K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Set",
   "Eq.refl",
   "Preorder",
   "LE.le",
   "lt_iff_le_not_le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "And",
   "StrictMonoOn",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "StrictMonoOn.le_iff_le",
   "LinearOrder.toPartialOrder",
   "Not",
   "id"],
  "name": "StrictMonoOn.lt_iff_lt",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → ∀ {a b : α}, a ∈ s → b ∈ s → (f a < f b ↔ a < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Setoid",
   "Decidable",
   "Subsingleton",
   "Quotient",
   "instSubsingletonDecidable",
   "Quotient.mk",
   "Eq"],
  "name": "Quotient.decidableEq.proof_1",
  "constType":
  "∀ {α : Sort u_1} {s : Setoid α} (a b : α), Subsingleton (Decidable (⟦a⟧ = ⟦b⟧))",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.recOnSubsingleton",
   "Setoid.r",
   "Setoid",
   "Subsingleton",
   "Quotient",
   "Quotient.recOnSubsingleton₂.proof_1",
   "Quot.mk",
   "Quotient.mk"],
  "name": "Quotient.recOnSubsingleton₂",
  "constType":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {motive : Quotient s₁ → Quotient s₂ → Sort uC} →\n          [s : ∀ (a : α) (b : β), Subsingleton (motive ⟦a⟧ ⟦b⟧)] →\n            (q₁ : Quotient s₁) → (q₂ : Quotient s₂) → ((a : α) → (b : β) → motive ⟦a⟧ ⟦b⟧) → motive q₁ q₂",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "MulOneClass.toMul",
   "Invertible.invOf",
   "Monoid.toOne",
   "Trans.trans",
   "Eq.refl",
   "One.toOfNat1",
   "mul_invOf_self'",
   "Invertible",
   "Monoid.toMulOneClass",
   "invOf_mul_self_assoc'",
   "Commute",
   "True",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "Commute.eq",
   "Eq.ndrec",
   "of_eq_true",
   "instTransEq",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Eq.trans",
   "congrFun",
   "id"],
  "name": "Commute.invOf_right",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible b], Commute a b → Commute a ⅟b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instBooleanAlgebraSet",
   "propext",
   "Set",
   "Set.mem_compl_iff",
   "HasCompl.compl",
   "Not",
   "BooleanAlgebra.toHasCompl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.80",
  "constType": "∀ {α : Type u} (s : Set α) (x : α), (x ∈ sᶜ) = (x ∉ s)",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Rat"],
  "name": "DivisionRing.qsmul",
  "constType": "{K : Type u} → [self : DivisionRing K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.cast_commute",
   "Commute.symm",
   "NonAssocRing.toIntCast",
   "NonUnitalNonAssocRing.toMul",
   "NonAssocRing",
   "Int.cast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int",
   "Commute"],
  "name": "Int.commute_cast",
  "constType":
  "∀ {α : Type u_3} [inst : NonAssocRing α] (x : α) (m : ℤ), Commute x ↑m",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "CanonicallyOrderedCommSemiring.toMul",
   "instHSMul",
   "MeasureTheory.Measure.map",
   "Set",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.Measure.map_apply",
   "MeasureTheory.Measure.prod",
   "True",
   "Eq",
   "Mathlib.MeasureTheory.Constructions.Prod.Basic._auxLemma.6",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "SProd.sprod",
   "HSMul.hSMul",
   "MeasurableSet",
   "Algebra.toSMul",
   "Eq.trans",
   "measurable_snd",
   "eq_self",
   "Set.instSProd",
   "Prod.snd",
   "IsScalarTower.right",
   "Set.preimage",
   "NonUnitalNonAssocSemiring.toMul",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.SFinite",
   "Set.univ",
   "Prod.instMeasurableSpace",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Prod",
   "Algebra.id",
   "MeasureTheory.Measure.prod_prod",
   "congrArg",
   "MeasurableSpace",
   "MeasureTheory.Measure.ext",
   "congrFun"],
  "name": "MeasureTheory.Measure.map_snd_prod",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν],\n  MeasureTheory.Measure.map Prod.snd (MeasureTheory.Measure.prod μ ν) = ↑↑μ Set.univ • ν",
  "constCategory": "Theorem"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.mk"],
  "name": "Quotient.mk",
  "constType": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "ENNReal",
   "OfNat.ofNat",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "One.toOfNat1",
   "MeasureTheory.IsProbabilityMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "Set.univ",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasureTheory.IsProbabilityMeasure.mk",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α},\n  ↑↑μ Set.univ = 1 → MeasureTheory.IsProbabilityMeasure μ",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.mul_zero",
  "constType": "∀ (n : ℕ), n * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.le_of_lt_succ",
   "div_eq_mul_inv",
   "NonUnitalCommSemiring.toCommSemigroup",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Iff.mpr",
   "add_pow",
   "Semiring.toNatCast",
   "Complex.Complex.addGroupWithOne",
   "mul_assoc",
   "Nat.cast",
   "Complex.instField",
   "Finset.range",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "InvOneClass.toInv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Subtype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "GroupWithZero.toInv",
   "instHSub",
   "HPow.hPow",
   "Complex.abs",
   "instHDiv",
   "Complex.instZeroComplex",
   "cauchy_product",
   "MulOneClass.toOne",
   "Nat.cast_ne_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.isCauSeq_exp",
   "Complex.instAddComplex",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommMagma.toMul",
   "SubadditiveHomClass.toFunLike",
   "MonoidWithZero.toMulZeroOneClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CauSeq.lim_mul_lim",
   "LT.lt",
   "congr",
   "Complex.isCauSeq_abs_exp",
   "Field.toDiv",
   "Field.toDivisionRing",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv",
   "congrFun",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "IsCauSeq",
   "Real",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Complex.instInvComplex",
   "NonAssocSemiring.toMulZeroOneClass",
   "Nat.choose_pos",
   "rfl",
   "True",
   "Nat.cast_mul",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "AbsoluteValue.subadditiveHomClass",
   "Complex.instSemiringComplex",
   "AddMonoidWithOne.toNatCast",
   "Eq.rec",
   "Finset",
   "Monoid.toNatPow",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat.succ",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "NonUnitalNonAssocRing.toMul",
   "Complex.instCommSemiringComplex",
   "CauSeq.lim",
   "Finset.sum",
   "pos_iff_ne_zero",
   "Field.toSemifield",
   "Complex.instRingComplex",
   "One.toOfNat1",
   "CauSeq",
   "FunLike.coe",
   "DivInvMonoid.toMonoid",
   "mul_inv",
   "Monoid.toMulOneClass",
   "GroupWithZero.toMonoidWithZero",
   "Finset.mem_range",
   "CauSeq.equiv",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Eq.ndrec",
   "letFun",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HasEquiv.Equiv",
   "Subtype.mk",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "AbsoluteValue",
   "HAdd.hAdd",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "CauSeq.lim_eq_lim_of_equiv",
   "Nat.factorial",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff.mp",
   "Nat.choose",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "AbsoluteValue.isAbsoluteValue",
   "Nat",
   "Finset.sum_congr",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "mul_left_comm",
   "Ne",
   "Complex.commRing",
   "DivisionSemiring.toGroupWithZero",
   "Finset.sum_mul",
   "Complex.charZero",
   "Finset.instMembershipFinset",
   "Nat.canonicallyOrderedCommSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "MulZeroOneClass.toMulZeroClass",
   "DivInvMonoid.toInv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "of_eq_true",
   "DivInvOneMonoid.toInvOneClass",
   "mul_one",
   "congrArg",
   "Complex.exp",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "instHasEquiv",
   "Real.instLinearOrderedFieldReal",
   "instSubNat",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "mul_comm",
   "inv_mul_cancel",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "instOfNatNat",
   "CauSeq.instMulCauSeq",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "Nat.choose_mul_factorial_mul_factorial",
   "instHAdd",
   "Complex.exp'",
   "Complex.instIsComplete",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Complex.exp.proof_1",
   "CommSemigroup.toCommMagma",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Complex",
   "instMulNat",
   "Complex.instMulComplex",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.exp_add",
  "constType":
  "∀ (x y : ℂ), Complex.exp (x + y) = Complex.exp x * Complex.exp y",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.toAdd",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_add",
   "Ring.toNonAssocRing",
   "Int.instAddInt",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.add",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → Int.add a' b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references": ["Setoid", "Equivalence"],
  "name": "Setoid.mk",
  "constType": "{α : Sort u} → (r : α → α → Prop) → Equivalence r → Setoid α",
  "constCategory": "Other"},
 {"references": ["Inf"],
  "name": "Inf.inf",
  "constType": "{α : Type u} → [self : Inf α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "DivInvMonoid.div_eq_mul_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "DivInvMonoid.toDiv",
   "Eq"],
  "name": "div_eq_mul_inv",
  "constType":
  "∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "Real.instLTReal",
   "nhds",
   "Set",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Filter.HasBasis.mem_iff",
   "Metric.nhds_basis_ball",
   "GT.gt",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "And",
   "Set.instHasSubsetSet",
   "Iff",
   "LT.lt",
   "Filter",
   "Metric.ball",
   "UniformSpace.toTopologicalSpace",
   "PseudoMetricSpace",
   "instMembershipSetFilter"],
  "name": "Metric.mem_nhds_iff",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {s : Set α}, s ∈ nhds x ↔ ∃ ε > 0, Metric.ball x ε ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["instSubsingletonPUnit",
   "CanonicallyOrderedCommSemiring.toMul",
   "Set",
   "Mathlib.Probability.Independence.Basic._auxLemma.1",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Inter.inter",
   "Subsingleton.measurableSingletonClass",
   "AddMonoid.toAddZeroClass",
   "Pure.pure",
   "implies_congr",
   "SetLike.instMembership",
   "True",
   "iff_self",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "Filter.instPureFilter",
   "MeasureTheory.OuterMeasure.measureOf",
   "Iff",
   "forall_congr",
   "MeasurableSet",
   "Unit.unit",
   "Filter",
   "MeasureTheory.Measure.ae",
   "Pi.addZeroClass",
   "MeasureTheory.ae_dirac_eq",
   "Eq.trans",
   "Subtype",
   "Membership.mem",
   "ProbabilityTheory.kernel.const",
   "PUnit.instMeasurableSpace",
   "Set.preimage",
   "Unit",
   "ProbabilityTheory.kernel.IndepFun",
   "Filter.Eventually",
   "FunLike.coe",
   "MeasureTheory.Measure.dirac",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "AddSubmonoid",
   "instHMul",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "Mathlib.Probability.Independence.Basic._auxLemma.12",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "ProbabilityTheory.instFunLikeSubtypeForAllMeasureMemAddSubmonoidAddZeroClassToAddZeroClassToAddMonoidInstAddCommMonoidInstMembershipInstSetLikeAddSubmonoidKernel",
   "ProbabilityTheory.kernel",
   "MeasureTheory.Measure.instAddCommMonoid",
   "HMul.hMul",
   "congrArg",
   "MeasurableSpace",
   "ProbabilityTheory.IndepFun",
   "Set.instInterSet",
   "congrFun"],
  "name": "ProbabilityTheory.indepFun_iff_measure_inter_preimage_eq_mul",
  "constType":
  "∀ {Ω : Type u_1} {β : Type u_6} {β' : Type u_7} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {f : Ω → β}\n  {g : Ω → β'} {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'},\n  ProbabilityTheory.IndepFun f g ↔\n    ∀ (s : Set β) (t : Set β'),\n      MeasurableSet s → MeasurableSet t → ↑↑μ (f ⁻¹' s ∩ g ⁻¹' t) = ↑↑μ (f ⁻¹' s) * ↑↑μ (g ⁻¹' t)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.le.step",
   "Unit",
   "Nat.le.refl",
   "LE.le",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.zero",
   "Nat.zero_le.match_1",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.zero_le",
  "constType": "∀ (n : ℕ), 0 ≤ n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Monoid.npow",
   "Eq"],
  "name": "Monoid.npow_zero",
  "constType": "∀ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["List.nodup_singleton",
   "Multiset",
   "Multiset.instSingletonMultiset",
   "Singleton.singleton",
   "Multiset.Nodup"],
  "name": "Multiset.nodup_singleton",
  "constType": "∀ {α : Type u_1} (a : α), Multiset.Nodup {a}",
  "constCategory": "Theorem"},
 {"references":
  ["norm_mul_le",
   "NonUnitalSeminormedRing.toNorm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Real.instMulReal",
   "NormedField.toNormedCommRing",
   "NonUnitalSeminormedRing.toNonUnitalRing",
   "LE.le",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Norm.norm"],
  "name": "NormedField.toNormedSpace.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : NormedField α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [self : OrderedCommSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "Int.neg.match_1",
  "constType":
  "(motive : ℤ → Sort u_1) → (n : ℤ) → ((n : ℕ) → motive (Int.ofNat n)) → ((n : ℕ) → motive (Int.negSucc n)) → motive n",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.ble",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.ble_succ_eq_true.match_1",
   "rfl",
   "Nat.succ",
   "Eq"],
  "name": "Nat.ble_succ_eq_true",
  "constType":
  "∀ {n m : ℕ}, Nat.ble n m = true → Nat.ble n (Nat.succ m) = true",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid.toCovariantClassRight",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "abs_le'",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Abs.abs",
   "Preorder.toLE",
   "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
   "Eq",
   "Eq.mpr",
   "SemilatticeSup.toSup",
   "Iff",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "AddCommGroup.toAddGroup",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCancelAddCommMonoid.toLinearOrderedAddCommMonoid",
   "id",
   "Neg.toHasAbs",
   "LinearOrderedAddCommGroup",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "SemilatticeInf.toPartialOrder",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "DistribLattice.toLattice",
   "neg_le",
   "And",
   "and_comm",
   "Eq.ndrec",
   "propext",
   "NegZeroClass.toNeg",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "abs_le",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, |a| ≤ b ↔ -b ≤ a ∧ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Equiv",
   "Zero",
   "OfNat.ofNat",
   "One",
   "Multiplicative",
   "One.mk",
   "FunLike.coe",
   "Multiplicative.ofAdd",
   "Equiv.instFunLikeEquiv"],
  "name": "instOneMultiplicative",
  "constType": "{α : Type u} → [inst : Zero α] → One (Multiplicative α)",
  "constCategory": "Definition"},
 {"references":
  ["instLENat", "Nat.le_succ", "Nat.le_trans", "Nat", "Nat.succ", "LE.le"],
  "name": "Nat.le_of_succ_le",
  "constType": "∀ {n m : ℕ}, Nat.succ n ≤ m → n ≤ m",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal",
   "NNReal.instCanonicallyLinearOrderedSemifieldNNReal",
   "CanonicallyLinearOrderedSemifield.toNontrivial",
   "instDecidableEq",
   "WithTop",
   "instLinearOrder",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "ConditionallyCompleteLinearOrderBot.toConditionallyCompleteLinearOrder",
   "inferInstanceAs",
   "instNNRealCanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop",
   "CanonicallyOrderedCommSemiring",
   "NNReal"],
  "name": "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
  "constType": "CanonicallyOrderedCommSemiring ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "mul_one",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "invertibleOne.proof_1",
  "constType": "∀ {α : Type u_1} [inst : Monoid α], 1 * 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_8",
  "constType": "∀ {α : Type u_1} [inst : Ring α], NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Subgroup.mk",
   "Membership.mem",
   "Subsemigroup.carrier",
   "Group.toDivisionMonoid",
   "MulOneClass.toMul",
   "Set",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "DivInvOneMonoid.toInvOneClass",
   "Subgroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.rec",
   "Inv.inv"],
  "name": "Subgroup.casesOn",
  "constType":
  "{G : Type u_5} →\n  [inst : Group G] →\n    {motive : Subgroup G → Sort u} →\n      (t : Subgroup G) →\n        ((toSubmonoid : Submonoid G) →\n            (inv_mem' : ∀ {x : G}, x ∈ toSubmonoid.carrier → x⁻¹ ∈ toSubmonoid.carrier) →\n              motive { toSubmonoid := toSubmonoid, inv_mem' := inv_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references":
  ["CauchySeq",
   "Exists",
   "EMetric.complete_of_cauchySeq_tendsto",
   "CompleteSpace",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "nhds",
   "PseudoMetricSpace.toUniformSpace",
   "Filter.Tendsto",
   "UniformSpace.toTopologicalSpace",
   "Nat",
   "Filter.atTop",
   "PseudoMetricSpace",
   "Nat.strictOrderedSemiring",
   "PseudoMetricSpace.toPseudoEMetricSpace"],
  "name": "Metric.complete_of_cauchySeq_tendsto",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α],\n  (∀ (u : ℕ → α), CauchySeq u → ∃ a, Filter.Tendsto u Filter.atTop (nhds a)) → CompleteSpace α",
  "constCategory": "Theorem"},
 {"references":
  ["CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Disjoint",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "tsum",
   "Set.Set.completeAtomicBooleanAlgebra",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "HeytingAlgebra.toOrderBot",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Eq",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "MeasureTheory.Measure",
   "ENNReal.instTopologicalSpaceENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "BooleanAlgebra.toBiheytingAlgebra",
   "Set.iUnion",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.instBooleanAlgebraSet",
   "OrderedCommSemiring.toOrderedSemiring",
   "Pairwise",
   "MeasurableSet",
   "Nat",
   "MeasureTheory.OuterMeasure",
   "MeasurableSpace",
   "MeasureTheory.OuterMeasure.trim",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Function.onFun"],
  "name": "MeasureTheory.Measure.mk",
  "constType":
  "{α : Type u_6} →\n  [inst : MeasurableSpace α] →\n    (toOuterMeasure : MeasureTheory.OuterMeasure α) →\n      (∀ ⦃f : ℕ → Set α⦄,\n          (∀ (i : ℕ), MeasurableSet (f i)) →\n            Pairwise (Disjoint on f) → ↑toOuterMeasure (⋃ i, f i) = ∑' (i : ℕ), ↑toOuterMeasure (f i)) →\n        MeasureTheory.OuterMeasure.trim toOuterMeasure = toOuterMeasure → MeasureTheory.Measure α",
  "constCategory": "Other"},
 {"references": [],
  "name": "NormedField",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Submonoid.mk",
   "Submonoid.instInfSubmonoid.proof_2",
   "Inf.mk",
   "MulOneClass.toMul",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Inf",
   "Set",
   "Subsemigroup.mk",
   "Submonoid.instInfSubmonoid.proof_1",
   "Submonoid",
   "Inter.inter",
   "SetLike.coe",
   "Set.instInterSet"],
  "name": "Submonoid.instInfSubmonoid",
  "constType": "{M : Type u_1} → [inst : MulOneClass M] → Inf (Submonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Rat.commRing",
   "CommSemiring",
   "Rat"],
  "name": "Rat.commSemiring",
  "constType": "CommSemiring ℚ",
  "constCategory": "Definition"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Set",
   "Set.iInter",
   "Mathlib.Data.Set.Lattice._auxLemma.4",
   "congrArg",
   "Eq.trans",
   "True",
   "iff_self",
   "congrFun",
   "Set.instMembershipSet"],
  "name": "Set.mem_iInter₂",
  "constType":
  "∀ {γ : Type u_3} {ι : Sort u_4} {κ : ι → Sort u_7} {x : γ} {s : (i : ι) → κ i → Set γ},\n  x ∈ ⋂ i, ⋂ j, s i j ↔ ∀ (i : ι) (j : κ i), x ∈ s i j",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "AddMonoid.toAddZeroClass",
   "Set.addZeroClass",
   "AddMonoid",
   "Eq"],
  "name": "Set.addMonoid.proof_3",
  "constType": "∀ {α : Type u_1} [inst : AddMonoid α] (a : Set α), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Iff.intro",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero_of_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "ContravariantClass.elim",
   "LT.lt.le",
   "Subtype.val",
   "Preorder",
   "PosMulReflectLT",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Mul",
   "ContravariantClass",
   "ContravariantClass.mk",
   "Subtype",
   "Subtype.mk"],
  "name": "PosMulReflectLT.to_contravariantClass_pos_mul_lt",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulReflectLT α],\n  ContravariantClass { x // 0 < x } α (fun x y => ↑x * y) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.instMeasurableSpace",
   "measurable_const",
   "Measurable",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.kernel.const.proof_1",
  "constType":
  "∀ (α : Type u_2) {β : Type u_1} [inst : MeasurableSpace α] {x : MeasurableSpace β} (μβ : MeasureTheory.Measure β),\n  Measurable fun x => μβ",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.linearOrder",
   "Nat.rel_of_forall_rel_succ_of_le",
   "instIsTransLeToLE",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Monotone",
   "LinearOrder.toPartialOrder",
   "instOfNatNat",
   "instIsReflLeToLE",
   "Nat",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "monotone_nat_of_le_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n ≤ f (n + 1)) → Monotone f",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Ne",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "One.toOfNat1",
   "Nontrivial.mk",
   "Exists.intro",
   "CauSeq.Completion.instOneCauchy",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CauSeq.Completion.zero_ne_one",
   "CauSeq.Completion.instZeroCauchy",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nontrivial",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_10",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv], Nontrivial (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "completeLatticeOfInf",
   "SupSet.sSup",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)), ∀ a ∈ s, a ≤ sSup s",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedField",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "GroupWithZero",
   "HMul.hMul",
   "IsUnit.mul_div_cancel",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "mul_div_cancel",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → a * b / b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "starMulOfComm",
   "MulOneClass.toMul",
   "Star.star",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "rfl",
   "Monoid.toMulOneClass",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "InvolutiveStar.toStar",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "StarMul.toInvolutiveStar",
   "StarMul.star_mul",
   "StarMul.mk"],
  "name": "starRingOfComm.proof_2",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (x x_1 : R), star (x + x_1) = star (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "AbsoluteValue.abs.proof_3",
   "LinearOrderedRing.toStrictOrderedRing",
   "AbsoluteValue",
   "instDistribLattice",
   "MulHom.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "LinearOrderedRing.toLinearOrder",
   "Semiring.toNonAssocSemiring",
   "AbsoluteValue.abs.proof_1",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "AbsoluteValue.abs.proof_2",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "abs_mul",
   "AbsoluteValue.mk",
   "OrderedSemiring.toSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name": "AbsoluteValue.abs",
  "constType":
  "{S : Type u_2} → [inst : LinearOrderedRing S] → AbsoluteValue S S",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Zero",
   "AddGroup",
   "AddSubmonoid.zero",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubgroup.zero",
  "constType":
  "{G : Type u_1} → [inst : AddGroup G] → (H : AddSubgroup G) → Zero ↥H",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "DivInvMonoid",
   "HMul.hMul",
   "Nat",
   "DivInvMonoid.toMonoid",
   "Nat.succ",
   "DivInvMonoid.zpow",
   "Eq"],
  "name": "DivInvMonoid.zpow_succ'",
  "constType":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "EmbeddingLike"],
  "name": "EmbeddingLike.toFunLike",
  "constType":
  "{F : Sort u_1} →\n  {α : outParam (Sort u_2)} → {β : outParam (Sort u_3)} → [self : EmbeddingLike F α β] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["Int.mul_zero",
   "instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "instOfNatInt",
   "Eq.rec",
   "HMul.hMul",
   "Int",
   "Int.mul_comm",
   "Eq"],
  "name": "Int.zero_mul",
  "constType": "∀ (a : ℤ), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "OfNat.ofNat",
   "SMulWithZero.toSMulZeroClass",
   "instHSMul",
   "HSMul.hSMul",
   "MulZeroClass.toSMulWithZero",
   "MulZeroClass.toZero",
   "SMulZeroClass.smul_zero",
   "MulZeroOneClass.toMulZeroClass",
   "SMulZeroClass.toSMul",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero.proof_3",
  "constType": "∀ (R : Type u_1) [inst : MonoidWithZero R] (a : R), a • 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NNReal.toReal",
   "Iff",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "GaloisInsertion.gc",
   "Real.instLEReal",
   "Real",
   "Real.toNNReal",
   "instNNRealStrictOrderedSemiring",
   "Real.instPreorderReal",
   "LE.le",
   "NNReal.gi",
   "NNReal",
   "Preorder.toLE"],
  "name": "Real.toNNReal_le_iff_le_coe",
  "constType": "∀ {r : ℝ} {p : NNReal}, Real.toNNReal r ≤ p ↔ r ≤ ↑p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "StrictOrderedCommSemiring",
   "HMul.hMul",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "StrictOrderedCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : StrictOrderedCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "IsAbsoluteValue.mk",
  "constType":
  "∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S},\n  (∀ (x : R), 0 ≤ f x) →\n    (∀ {x : R}, f x = 0 ↔ x = 0) →\n      (∀ (x y : R), f (x + y) ≤ f x + f y) → (∀ (x y : R), f (x * y) = f x * f y) → IsAbsoluteValue f",
  "constCategory": "Other"},
 {"references":
  ["Filter.principal",
   "CompleteLattice.toConditionallyCompleteLattice",
   "iInf",
   "Filter",
   "Set.Ici",
   "Preorder",
   "ConditionallyCompleteLattice.toInfSet",
   "Filter.instCompleteLatticeFilter"],
  "name": "Filter.atTop",
  "constType": "{α : Type u_3} → [inst : Preorder α] → Filter α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Ne",
   "Iff",
   "congr_arg",
   "Function.Injective",
   "Function.Injective.ne",
   "mt",
   "Eq"],
  "name": "Function.Injective.ne_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {x y : α}, f x ≠ f y ↔ x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.coe_le_coe",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "propext",
   "OrderedCommSemiring.toOrderedSemiring",
   "instNNRealStrictOrderedSemiring",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "LE.le",
   "NNReal",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "ENNReal.ofNNReal"],
  "name": "Mathlib.Data.Real.ENNReal._auxLemma.19",
  "constType": "∀ {r q : NNReal}, (↑r ≤ ↑q) = (r ≤ q)",
  "constCategory": "Theorem"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "zpowRec",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Eq.refl",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Semiring.toOne",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "CauSeq.Completion.Cauchy.ring",
   "LinearOrderedField",
   "Int.negSucc",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "CauSeq.Completion.instInvCauchyToRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_9",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℕ) (a : CauSeq.Completion.Cauchy abv),\n  zpowRec (Int.negSucc n) a = zpowRec (Int.negSucc n) a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Real",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.real",
   "ENNReal.toReal",
   "MeasurableSpace",
   "Eq"],
  "name":
  "_private.PFR.ForMathlib.Entropy.Basic.0.MeasureTheory.Measure.real._eq_1",
  "constType":
  "∀ {α : Type u_1} {x : MeasurableSpace α} (μ : MeasureTheory.Measure α) (s : Set α), μ.real s = (↑↑μ s).toReal",
  "constCategory": "Theorem"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [inst : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instModNat",
  "constType": "Mod ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Nat.cast_zero",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "AddGroupWithOne.intCast_ofNat",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "NegZeroClass.toZero",
   "Eq.trans",
   "Int",
   "IntCast.intCast",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Int.cast_zero",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "LE.le",
   "Eq",
   "Int.instAddInt",
   "Int.le_trans.match_1",
   "Int.le.dest",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.add_assoc",
   "Nat",
   "Int.le.intro",
   "Int",
   "Int.instLEInt",
   "id"],
  "name": "Int.add_le_add_left",
  "constType": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), c + a ≤ c + b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalSeminormedRing", "PseudoMetricSpace"],
  "name": "NonUnitalSeminormedRing.toPseudoMetricSpace",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → PseudoMetricSpace α",
  "constCategory": "Definition"},
 {"references": ["NatPow.pow", "NatPow", "Pow.mk", "Nat", "Pow"],
  "name": "instPowNat",
  "constType": "{α : Type u_1} → [inst : NatPow α] → Pow α ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "instHPow",
   "Monoid.toNatPow",
   "Monoid.npow_zero",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "pow_zero",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "lowerBounds_empty",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "Set.instEmptyCollectionSet",
   "Set.univ",
   "LE.le",
   "Preorder.toLE",
   "True",
   "PartialOrder",
   "Set.instMembershipSet",
   "And.right",
   "upperBounds",
   "Mathlib.Data.Set.Basic._auxLemma.14",
   "of_eq_true",
   "lowerBounds",
   "congrArg",
   "Eq.trans"],
  "name": "completeLatticeOfInf.proof_11",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α], (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a : α), a ≤ sInf ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le",
   "Nat.le.step",
   "HEq",
   "Unit",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "LE.le",
   "Eq",
   "instLENat",
   "Eq.ndrec",
   "HEq.refl",
   "Unit.unit",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → Prop) (m : ℕ) (h : n ≤ m),\n  (Unit → motive n (_ : Nat.le n n)) →\n    (∀ (m : ℕ) (h : Nat.le n m), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m))) → motive m h",
  "constCategory": "Definition"},
 {"references": ["Nat.linearOrder", "LinearOrder.toLattice", "Lattice", "Nat"],
  "name": "Nat.instLatticeNat",
  "constType": "Lattice ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "exists_prop.match_2",
   "And",
   "Exists",
   "Iff",
   "Exists.intro",
   "And.intro",
   "exists_prop.match_1"],
  "name": "exists_prop",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) ↔ a ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le.dest.match_1",
  "constType":
  "∀ (n m : ℕ) (motive : (∃ k, n + k = m) → Prop) (this : ∃ k, n + k = m),\n  (∀ (k : ℕ) (h : n + k = m), motive (_ : ∃ k, n + k = m)) → motive this",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toRing",
   "instOfNatInt",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Int",
   "DivisionRing.zpow",
   "Eq"],
  "name": "DivisionRing.zpow_zero'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1",
  "constCategory": "Definition"},
 {"references":
  ["NormedField.toField",
   "Field.toCommRing",
   "instHSub",
   "PseudoMetricSpace.toDist",
   "NormedField.toMetricSpace",
   "Real",
   "NormedField",
   "Ring.toSub",
   "HSub.hSub",
   "CommRing.toRing",
   "MetricSpace.toPseudoMetricSpace",
   "Norm.norm",
   "NormedField.toNorm",
   "Dist.dist",
   "Eq"],
  "name": "NormedField.dist_eq",
  "constType":
  "∀ {α : Type u_5} [self : NormedField α] (x y : α), dist x y = ‖x - y‖",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonUnitalSeminormedCommRing",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Top.top",
   "CompleteLattice.toTop",
   "PUnit",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "MeasurableSpace"],
  "name": "PUnit.instMeasurableSpace",
  "constType": "MeasurableSpace PUnit.{u_6 + 1}",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Set.add",
   "Set.image2_empty_right",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Set.instEmptyCollectionSet",
   "Add",
   "Eq"],
  "name": "Set.add_empty",
  "constType": "∀ {α : Type u_2} [inst : Add α] {s : Set α}, s + ∅ = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real.instLEReal",
   "Real.instMulReal",
   "dite",
   "Real.rpow_def_of_nonneg",
   "MulZeroClass.toMul",
   "Nat.cast_zero",
   "Real.instOneReal",
   "Eq",
   "ite",
   "Real.decidableEq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Real.strictOrderedSemiring",
   "Real.instPowReal",
   "true_or",
   "le_trans",
   "not_false_eq_true",
   "LinearOrderedRing.noZeroDivisors",
   "Real.exp_add",
   "Eq.trans",
   "false_or",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Real.partialOrder",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.5",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.instRingReal",
   "Real.normedCommRing",
   "Real.orderedSemiring",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.2",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "LE.le.lt_of_ne'",
   "eq_true",
   "False.elim",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "Eq.mp",
   "congr",
   "mul_one",
   "Not",
   "OrderedSemiring.toPosMulMono",
   "congrArg",
   "mul_nonneg",
   "congrFun",
   "Real",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "Real.log_mul",
   "instHPow",
   "Real.rpow_def_of_pos",
   "MulZeroClass.toZero",
   "if_neg",
   "id",
   "eq_self",
   "Real.rpow_zero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Real.instLinearOrderedRingReal",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "One.toOfNat1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "StrictOrderedSemiring.toSemiring",
   "Real.exp",
   "LE.le",
   "Real.instZeroReal",
   "NormedCommRing.toSeminormedCommRing",
   "eq_false",
   "Real.log",
   "if_pos",
   "Eq.ndrec",
   "Real.semiring",
   "HMul.hMul",
   "not_true_eq_false",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1"],
  "name": "Real.mul_rpow",
  "constType": "∀ {x y z : ℝ}, 0 ≤ x → 0 ≤ y → (x * y) ^ z = x ^ z * y ^ z",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "VSub",
  "constType": "outParam (Type u_1) → Type u_2 → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Set",
   "Set.mem_preimage",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set β} {a : α}, (a ∈ f ⁻¹' s) = (f a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.mul_comm",
   "instHMul",
   "OfNat.ofNat",
   "Eq.rec",
   "LT.lt",
   "HMul.hMul",
   "instOfNatNat",
   "instMulNat",
   "Nat",
   "Nat.mul_lt_mul_of_pos_left",
   "instLTNat",
   "Eq",
   "GT.gt"],
  "name": "Nat.mul_lt_mul_of_pos_right",
  "constType": "∀ {n m k : ℕ}, n < m → k > 0 → n * k < m * k",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "MulOneClass.one_mul",
  "constType": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["Function.LeftInverse",
   "And.right",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective",
   "Function.surjInv",
   "And.left",
   "Function.rightInverse_of_injective_of_leftInverse",
   "Function.rightInverse_surjInv"],
  "name": "Function.leftInverse_surjInv",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (hf : Function.Bijective f),\n  Function.LeftInverse (Function.surjInv (_ : Function.Surjective f)) f",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PUnit",
   "Nat.choose.match_1",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.choose",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Set",
   "AddSubmonoid.toAddSubsemigroup",
   "Inf.inf",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddSubgroup.toAddSubmonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddSubgroup.neg_mem",
   "AddSubgroup.instInfAddSubgroup.match_1",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "Set.instMembershipSet",
   "AddSubmonoid.zero_mem'",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubmonoid.mk",
   "And.intro",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "AddSubmonoid.instInfAddSubmonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "SetLike.coe"],
  "name": "AddSubgroup.instInfAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G) {x : G},\n  x ∈\n      { toAddSubsemigroup := (H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid).toAddSubsemigroup,\n            zero_mem' := (_ : 0 ∈ (H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid).carrier) }.toAddSubsemigroup.carrier →\n    -x ∈\n      { toAddSubsemigroup := (H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid).toAddSubsemigroup,\n            zero_mem' := (_ : 0 ∈ (H₁.toAddSubmonoid ⊓ H₂.toAddSubmonoid).carrier) }.toAddSubsemigroup.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SubNegZeroMonoid.toSubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "Neg.neg",
   "Eq"],
  "name": "SubNegZeroMonoid.neg_zero",
  "constType": "∀ {G : Type u_2} [self : SubNegZeroMonoid G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["Real.linearOrder",
   "Function.Injective",
   "Real",
   "Real.instPreorderReal",
   "StrictMono.injective",
   "Real.exp",
   "Real.exp_strictMono"],
  "name": "Real.exp_injective",
  "constType": "Function.Injective Real.exp",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Inv",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["One", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toOne",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "one_mul",
   "HMul.hMul",
   "mul_one",
   "Eq.symm",
   "id"],
  "name": "left_inv_eq_right_inv",
  "constType":
  "∀ {M : Type u} [inst : Monoid M] {a b c : M}, b * a = 1 → a * c = 1 → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing.toRing",
   "Rat",
   "Field.toSemifield",
   "DivisionRing.toRatCast",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.qsmul_eq_mul'",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Rat.cast",
   "DivisionRing.qsmul",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.field.proof_10",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : ℚ) (x : CauSeq.Completion.Cauchy abv), DivisionRing.qsmul a x = ↑a * x",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "Inv"],
  "name": "LinearOrderedField.toInv",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Contravariant",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "add_neg_cancel_right",
   "Function.swap",
   "Covariant",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.ndrec",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.covariant_swap_iff_contravariant_swap",
  "constType":
  "∀ {N : Type u_2} {r : N → N → Prop} [inst : AddGroup N],\n  Covariant N N (Function.swap fun x x_1 => x + x_1) r ↔ Contravariant N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Theorem"},
 {"references": ["Field", "Rat"],
  "name": "Field.qsmul",
  "constType": "{K : Type u} → [self : Field K] → ℚ → K → K",
  "constCategory": "Definition"},
 {"references":
  ["Nat.linearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instAddNat",
   "instHAdd",
   "Preorder.toLT",
   "HAdd.hAdd",
   "LT.lt",
   "StrictMono",
   "LinearOrder.toPartialOrder",
   "instIsTransLtToLT",
   "instOfNatNat",
   "Nat",
   "Preorder",
   "Nat.rel_of_forall_rel_succ_of_lt"],
  "name": "strictMono_nat_of_lt_succ",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {f : ℕ → α}, (∀ (n : ℕ), f n < f (n + 1)) → StrictMono f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_attach",
   "Finset.attach",
   "Finset",
   "Finset.val",
   "Finset.instMembershipFinset",
   "Subtype"],
  "name": "Finset.mem_attach",
  "constType":
  "∀ {α : Type u_1} (s : Finset α) (x : { x // x ∈ s }), x ∈ Finset.attach s",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "NatCast.natCast",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "inferInstance",
   "AddMonoid.toZero",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "Nat.linearOrderedSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_9",
  "constType": "NatCast.natCast 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["le_trans", "IsTrans", "IsTrans.mk", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "instIsTransLeToLE",
  "constType":
  "∀ {α : Type u} [inst : Preorder α], IsTrans α fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Nat.add_assoc",
   "Semiring.mk",
   "Nat.add_comm",
   "Nat.pow_succ'",
   "Nat.pow_zero",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Nat.mul_zero",
   "Nat.right_distrib",
   "Nat.add",
   "AddCommMonoid.mk",
   "instHPow",
   "CommSemiring",
   "instNatPowNat",
   "Nat.mul_one",
   "Nat",
   "Nat.add_zero",
   "Nat.left_distrib",
   "Nat.succ",
   "Nat.commSemiring.proof_3",
   "Add.mk",
   "HPow.hPow",
   "Nat.commSemiring.proof_2",
   "AddSemigroup.mk",
   "CommSemiring.mk",
   "One.mk",
   "Nat.commSemiring.proof_1",
   "instPowNat",
   "AddMonoid.mk",
   "Nat.mul_comm",
   "instHMul",
   "Nat.zero_add",
   "Nat.mul_assoc",
   "Nat.zero",
   "Nat.one_mul",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "HMul.hMul",
   "Zero.mk",
   "instMulNat",
   "Nat.mul",
   "Mul.mk"],
  "name": "Nat.commSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references": ["Int", "Semifield"],
  "name": "Semifield.zpow",
  "constType": "{α : Type u_4} → [self : Semifield α] → ℤ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Real",
   "Set",
   "Real.exp_pos",
   "StrictMono.codRestrict",
   "Real.exp",
   "_private.Mathlib.Data.Real.Basic.0.Real.lt",
   "Real.exp_strictMono",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Set.codRestrict",
   "Set.Elem",
   "Real.instPreorderReal",
   "StrictMono",
   "Subtype.preorder"],
  "name": "Real.expOrderIso.proof_1",
  "constType": "StrictMono (Set.codRestrict Real.exp (Real.lt 0) Real.exp_pos)",
  "constCategory": "Theorem"},
 {"references":
  ["InvolutiveNeg",
   "neg_involutive",
   "Function.Injective",
   "InvolutiveNeg.toNeg",
   "Neg.neg",
   "Function.Involutive.injective"],
  "name": "neg_injective",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G], Function.Injective Neg.neg",
  "constCategory": "Theorem"},
 {"references": ["MulHom", "instHMul", "HMul.hMul", "Mul", "Eq"],
  "name": "MulHom.mk",
  "constType":
  "{M : Type u_9} →\n  {N : Type u_10} →\n    [inst : Mul M] → [inst_1 : Mul N] → (toFun : M → N) → (∀ (x y : M), toFun (x * y) = toFun x * toFun y) → M →ₙ* N",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "Classical.propDecidable",
   "left_inv_eq_right_inv",
   "dite",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "True",
   "Inv.mk",
   "Eq",
   "DivInvMonoid.toInv",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "inv_mul_cancel",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "GroupWithZero",
   "GroupWithZero.zpow_zero'",
   "congr",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "inv_ne_zero",
   "Eq.trans",
   "Inv.inv",
   "GroupWithZero.toInv",
   "GroupWithZero.zpow",
   "GroupWithZero.zpow_neg'"],
  "name": "GroupWithZero.toDivisionMonoid.proof_1",
  "constType":
  "∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a⁻¹⁻¹ = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "StrictOrderedRing",
   "LT.lt",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.mk",
  "constType":
  "{α : Type u} →\n  [toRing : Ring α] →\n    [toPartialOrder : PartialOrder α] →\n      (∀ (a b : α), a ≤ b → ∀ (c : α), c + a ≤ c + b) →\n        [toNontrivial : Nontrivial α] → 0 ≤ 1 → (∀ (a b : α), 0 < a → 0 < b → 0 < a * b) → StrictOrderedRing α",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "LinearOrderedField",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "HMul.hMul",
   "LinearOrderedCommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "LinearOrderedField.toLinearOrderedSemifield.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] (a b : α), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "SubNegMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Multiplicative",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.mul_one",
   "Eq",
   "Multiplicative.monoid"],
  "name": "Multiplicative.divInvMonoid.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : SubNegMonoid α] (a : Multiplicative α), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Eq"],
  "name": "Function.Surjective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Set",
   "Disjoint",
   "OrderBot",
   "Preorder.toLE",
   "Function.onFun",
   "Set.Pairwise",
   "PartialOrder"],
  "name": "Set.PairwiseDisjoint",
  "constType":
  "{α : Type u_1} → {ι : Type u_4} → [inst : PartialOrder α] → [inst : OrderBot α] → Set ι → (ι → α) → Prop",
  "constCategory": "Definition"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.mul_succ",
   "Nat.add_succ",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "instHMul",
   "Nat.rec",
   "Eq.mpr",
   "Nat.zero",
   "Eq.ndrec",
   "Nat.add_right_comm",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Nat.succ",
   "id"],
  "name": "Nat.succ_mul",
  "constType": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Finset.val",
   "Multiset.ndinsert",
   "Finset.mk",
   "Finset.instInsertFinset.proof_1",
   "Insert",
   "Insert.mk"],
  "name": "Finset.instInsertFinset",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Insert α (Finset α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Neg",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "Field.toInv",
   "Rat.mk'",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Field.toRatCast",
   "Semiring.toNatCast",
   "Eq",
   "Field.toCommRing",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Field",
   "Rat.cast",
   "CommRing.toRing",
   "Nat.Coprime",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Int",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Int.natAbs"],
  "name": "Field.ratCast_mk",
  "constType":
  "∀ {K : Type u} [self : Field K] (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑a * (↑b)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Real.instMulReal",
   "Real",
   "One.mk",
   "HMul.hMul",
   "Eq.refl",
   "instOfNatNat",
   "One.toOfNat1",
   "npowRec",
   "Nat",
   "Eq",
   "Mul.mk",
   "Real.instOneReal"],
  "name": "Real.commRing.proof_16",
  "constType": "∀ (x : ℝ), npowRec 0 x = npowRec 0 x",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Distrib",
   "Distrib.toMul",
   "Eq"],
  "name": "Distrib.left_distrib",
  "constType":
  "∀ {R : Type u_1} [self : Distrib R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OneHom.toFun",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "instHAdd",
   "MulOneClass.toOne",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "RingHom.toMonoidHom",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.map_add'",
  "constType":
  "∀ {α : Type u_5} {β : Type u_6} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (self : α →+* β) (x y : α),\n  OneHom.toFun (↑↑self) (x + y) = OneHom.toFun (↑↑self) x + OneHom.toFun (↑↑self) y",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → (α : outParam (Sort u_2)) → outParam (α → Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Function.comp",
   "Set",
   "Set.instMembershipSet",
   "Eq",
   "Set.range",
   "Eq.mpr",
   "CompleteLattice",
   "Set.Elem",
   "iInf_subtype'",
   "iInf",
   "CompleteLattice.toInfSet",
   "Subtype.range_coe",
   "Eq.mp",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "isGLB_iInf",
   "Set.range_comp",
   "Subtype",
   "congrFun",
   "id"],
  "name": "isGLB_biInf",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {s : Set β} {f : β → α}, IsGLB (f '' s) (⨅ x ∈ s, f x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "Finite",
   "instOfNatNat",
   "Nat",
   "Nat.card",
   "instLTNat",
   "True",
   "Nonempty",
   "Eq",
   "Nat.card_pos"],
  "name": "Mathlib.SetTheory.Cardinal.Finite._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : Nonempty α] [inst : Finite α], (0 < Nat.card α) = True",
  "constCategory": "Theorem"},
 {"references": ["Inv"],
  "name": "Inv.mk",
  "constType": "{α : Type u} → (α → α) → Inv α",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "SeminormedRing",
   "SeminormedRing.toRing",
   "SeminormedRing.toNorm",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le"],
  "name": "SeminormedRing.norm_mul",
  "constType":
  "∀ {α : Type u_5} [self : SeminormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instHSMul",
   "Real.instLEReal",
   "MulZeroClass.mul_zero",
   "dite",
   "ProbabilityTheory.measureEntropy_of_not_isFiniteMeasure",
   "Eq",
   "MeasurableSingletonClass",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.card_eq_fintype_card",
   "Nat.cast",
   "MeasureTheory.OuterMeasure.measureOf",
   "Finset.toSet",
   "HSMul.hSMul",
   "Fintype.card_coe",
   "Std.Classes.Order._auxLemma.3",
   "Nat",
   "Real.log_nat_cast_nonneg",
   "Algebra.toSMul",
   "Eq.trans",
   "Finset.Subtype.fintype",
   "Subtype",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsScalarTower.right",
   "eq_of_heq",
   "Classical.propDecidable",
   "HasCompl.compl",
   "Finset.instMembershipFinset",
   "Or.casesOn",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "HEq.refl",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "Not",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "congrFun",
   "Inv.inv",
   "Finset.card",
   "NatCast",
   "HEq",
   "Real.natCast",
   "ProbabilityTheory.measureEntropy_le_card_aux",
   "Real",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.IsFiniteMeasure",
   "True",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "NeZero",
   "Finset",
   "LE",
   "MulZeroClass.toZero",
   "ProbabilityTheory.measureEntropy_univ_smul",
   "Eq.symm",
   "id",
   "eq_self",
   "Membership.mem",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Fintype.card",
   "ENNReal.instInvENNReal",
   "Set.univ",
   "ProbabilityTheory.measureEntropy_zero",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "ProbabilityTheory.measureEntropy",
   "LE.le",
   "Real.instZeroReal",
   "Real.log",
   "eq_zero_or_neZero",
   "Eq.ndrec",
   "MeasureTheory.Measure.instZero",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "MeasureTheory.isProbabilityMeasureSMul",
   "Eq.casesOn",
   "Nat.card"],
  "name": "ProbabilityTheory.measureEntropy_le_log_card_of_mem",
  "constType":
  "∀ {S : Type u_2} [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] {A : Finset S}\n  (μ : MeasureTheory.Measure S), ↑↑μ (↑A)ᶜ = 0 → ProbabilityTheory.measureEntropy ≤ Real.log ↑(Nat.card { x // x ∈ A })",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CompleteLinearOrder",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "Real.instSemigroupReal",
   "Real.instMulReal",
   "Real",
   "Eq.refl",
   "HMul.hMul",
   "id",
   "Eq"],
  "name": "Mathlib.Tactic.RPowRing.mul_pf_left",
  "constType": "∀ {a₂ b c : ℝ} (a₁ : ℝ), a₂ * b = c → a₁ * a₂ * b = a₁ * c",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "CompletelyDistribLattice.toCompleteLattice",
   "Mathlib.MeasureTheory.Measure.Typeclasses._auxLemma.3",
   "PartialOrder.toPreorder",
   "MeasureTheory.IsFiniteMeasure.mk",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "One.toOfNat1",
   "MeasureTheory.IsProbabilityMeasure",
   "MeasureTheory.IsFiniteMeasure",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "CanonicallyOrderedCommSemiring.toOne",
   "Set.univ",
   "True",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "MeasureTheory.Measure",
   "ENNReal.instCompleteLinearOrderENNReal",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "LT.lt",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "congrArg",
   "Eq.trans",
   "MeasurableSpace",
   "congrFun"],
  "name": "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsProbabilityMeasure μ],\n  MeasureTheory.IsFiniteMeasure μ",
  "constCategory": "Definition"},
 {"references":
  ["AddRightCancelMonoid",
   "AddRightCancelSemigroup.toAddSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "instOfNatNat",
   "AddRightCancelMonoid.nsmul",
   "Nat",
   "Eq"],
  "name": "AddRightCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (n : ℕ) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Semiring.toNonUnitalSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "Ring.toNonAssocRing.proof_5",
  "constType": "∀ {α : Type u_1} [inst : Ring α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["SDiff", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toSDiff",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → SDiff α",
  "constCategory": "Definition"},
 {"references":
  ["Complex.arg",
   "Complex.ofReal'",
   "Distrib.toAdd",
   "Complex.abs",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AbsoluteValue",
   "Real",
   "Complex.instAddComplex",
   "FunLike.coe",
   "Real.orderedSemiring",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "instHMul",
   "Complex.instSemiringComplex",
   "Real.log",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "Complex",
   "Complex.instMulComplex",
   "OrderedSemiring.toPartialOrder",
   "Complex.I"],
  "name": "Complex.log",
  "constType": "ℂ → ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Ord.mk",
   "Nat.decLt",
   "Nat",
   "compareOfLessAndEq",
   "instLTNat",
   "instDecidableEqNat",
   "Ord"],
  "name": "instOrdNat",
  "constType": "Ord ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Algebra.Group.Defs._hyg.5163",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "GroupWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "OrderDual.instLEOrderDual",
   "Function.swap",
   "AddGroup",
   "Iff",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "OrderIso.neg",
   "LE",
   "OrderDual",
   "OrderIso.symm_apply_le",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_le",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, -a ≤ b ↔ -b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalCommRing.toNonUnitalRing",
   "Eq"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
  "constType": "∀ {α : Type u_1} [s : NonUnitalCommRing α] (a : α), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv.prodCongr", "Cardinal", "Prod", "Mul", "Cardinal.map₂", "Mul.mk"],
  "name": "Cardinal.instMulCardinal",
  "constType": "Mul Cardinal.{u}",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["MeasurableSpace.prod", "Prod", "MeasurableSpace"],
  "name": "Prod.instMeasurableSpace",
  "constType":
  "{α : Type u_6} → {β : Type u_7} → [m₁ : MeasurableSpace α] → [m₂ : MeasurableSpace β] → MeasurableSpace (α × β)",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "instHSMul",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Semiring.toMonoidWithZero",
   "MeasureTheory.instSFinite",
   "Eq.refl",
   "MeasureTheory.Measure.instSMul",
   "MeasureTheory.IsProbabilityMeasure",
   "ProbabilityTheory.identDistrib_id_right",
   "MeasureTheory.Measure.prod",
   "CanonicallyOrderedCommSemiring.toOne",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "ENNReal",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Eq.mpr",
   "one_smul",
   "MeasureTheory.OuterMeasure.measureOf",
   "Measurable.aemeasurable",
   "MonoidWithZero.toMonoid",
   "IsScalarTower.left",
   "MeasureTheory.Measure.map_snd_prod",
   "MonoidWithZero.toMulActionWithZero",
   "HSMul.hSMul",
   "MeasureTheory.Measure.instMulAction",
   "Algebra.toSMul",
   "Eq.trans",
   "measurable_snd",
   "MulActionWithZero.toMulAction",
   "MeasureTheory.IsFiniteMeasure.toSigmaFinite",
   "id",
   "eq_self",
   "Prod.snd",
   "IsScalarTower.right",
   "One.toOfNat1",
   "ProbabilityTheory.IdentDistrib",
   "instENNRealZero",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "Prod.instMeasurableSpace",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "of_eq_true",
   "OrderedCommSemiring.toOrderedSemiring",
   "letFun",
   "OrderedSemiring.toSemiring",
   "Prod",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "congrFun"],
  "name": "ProbabilityTheory.IdentDistrib.snd_id",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.IsProbabilityMeasure μ]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure ν], ProbabilityTheory.IdentDistrib Prod.snd id",
  "constCategory": "Theorem"},
 {"references":
  ["decidableEqOfDecidableLE.proof_1",
   "PartialOrder.toPreorder",
   "DecidableEq",
   "decidableEqOfDecidableLE.proof_2",
   "Decidable.isFalse",
   "Decidable",
   "decidableLTOfDecidableLE.match_1",
   "Not",
   "Decidable.isTrue",
   "dite",
   "le_antisymm",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "DecidableRel",
   "PartialOrder"],
  "name": "decidableEqOfDecidableLE",
  "constType":
  "{α : Type u} → [inst : PartialOrder α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → DecidableEq α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semiring.mk",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.npow",
   "AddCommMonoid.toAddMonoid",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.toOne",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Zero.toOfNat0",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "AddMonoid.toZero",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedCommMonoid.toCovariantClassRight",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "LE.le",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "mul_le_mul_right'",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "NonUnitalSemiring.mk",
   "HMul.hMul",
   "CanonicallyOrderedCommSemiring.toOrderedCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedCommSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNat",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "constCategory": "Definition"},
 {"references":
  ["sub_add_cancel",
   "SubNegMonoid.toSub",
   "AddTorsor",
   "AddTorsor.mk",
   "AddGroup",
   "VSub.mk",
   "SubNegMonoid.toAddMonoid",
   "Sub.sub",
   "AddMonoid.toAddAction",
   "add_sub_cancel",
   "AddGroup.toSubNegMonoid",
   "addGroupIsAddTorsor.proof_1"],
  "name": "addGroupIsAddTorsor",
  "constType": "(G : Type u_1) → [inst : AddGroup G] → AddTorsor G G",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "Std.Classes.Order._auxLemma.3",
  "constType": "∀ {α : Type u_1} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Cardinal.mk_fintype",
   "Nat.linearOrderedCommMonoidWithZero",
   "ZeroHom.zeroHomClass",
   "ZeroHom",
   "Fintype.card",
   "FunLike.coe",
   "True",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.toNat",
   "Fintype",
   "Cardinal.instNatCastCardinal",
   "Nat.cast",
   "of_eq_true",
   "ZeroHomClass.toFunLike",
   "Cardinal.toNat_cast",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Cardinal.mk",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Cardinal.mk_toNat_eq_card",
  "constType":
  "∀ {α : Type u} [inst : Fintype α], Cardinal.toNat (Cardinal.mk α) = Fintype.card α",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "RingHomClass.toMonoidHomClass",
   "RingHomClass",
   "MonoidWithZeroHomClass",
   "MonoidWithZeroHomClass.mk",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.map_zero",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidWithZeroHomClass",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonAssocSemiring α] →\n        [inst_1 : NonAssocSemiring β] → [self : RingHomClass F α β] → MonoidWithZeroHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "NonUnitalNonAssocRing.toMul",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Abs.abs",
   "Ring.toNonAssocRing",
   "Eq",
   "DistribLattice.toLattice",
   "instHMul",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedRing",
   "abs_mul",
   "HMul.hMul",
   "Lattice.toSemilatticeSup",
   "Eq.symm"],
  "name": "Mathlib.Data.IsROrC.Basic._auxLemma.26",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), |a| * |b| = |a * b|",
  "constCategory": "Theorem"},
 {"references":
  ["ENNReal.instCompleteLinearOrderENNReal",
   "CanLift",
   "Ne",
   "ENNReal",
   "WithTop.canLift",
   "CompletelyDistribLattice.toCompleteLattice",
   "Top.top",
   "CompleteLattice.toTop",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "NNReal",
   "ENNReal.ofNNReal"],
  "name": "ENNReal.canLift",
  "constType": "CanLift ENNReal NNReal ENNReal.ofNNReal fun x => x ≠ ⊤",
  "constCategory": "Definition"},
 {"references":
  ["Neg.toHasAbs",
   "Membership.mem",
   "OfNat.ofNat",
   "Set",
   "dif_pos",
   "Real",
   "Real.instLEReal",
   "Real.instSupReal",
   "FunLike.coe",
   "Real.log.proof_1",
   "Subtype.le",
   "Set.Ioi",
   "rfl",
   "LE.le",
   "Abs.abs",
   "Real.instNegReal",
   "Real.expOrderIso",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.decidableEq",
   "RelIso.instRelHomClassRelIso",
   "Real.log",
   "Set.Elem",
   "RelIso",
   "Real.instPreorderReal",
   "Not",
   "Subtype.mk",
   "OrderIso.symm"],
  "name": "Real.log_zero",
  "constType": "Real.log 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "Iff.mp", "False", "Iff", "propext", "Not", "Eq"],
  "name": "iff_false",
  "constType": "∀ (p : Prop), (p ↔ False) = ¬p",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "constCategory": "Definition"},
 {"references": ["setOf", "Preorder.toLT", "Set", "LT.lt", "Preorder"],
  "name": "Set.Ioi",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Real.pi_pos",
   "OfNat.ofNat",
   "eq_true",
   "Real.instLTReal",
   "Real",
   "LT.lt",
   "Real.pi",
   "True",
   "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.9",
  "constType": "(0 < Real.pi) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHDiv",
   "inv_eq_one_div",
   "Monoid.toOne",
   "DivInvMonoid",
   "One.toOfNat1",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Eq",
   "DivInvMonoid.toDiv",
   "DivInvMonoid.toInv",
   "Inv.inv"],
  "name": "one_div",
  "constType": "∀ {G : Type u_3} [inst : DivInvMonoid G] (a : G), 1 / a = a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Real",
   "Real.instConditionallyCompleteLinearOrderReal",
   "Nonneg.conditionallyCompleteLinearOrderBot",
   "NNReal",
   "ConditionallyCompleteLinearOrderBot"],
  "name": "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
  "constType": "ConditionallyCompleteLinearOrderBot NNReal",
  "constCategory": "Definition"},
 {"references": ["WellFounded", "Acc"],
  "name": "WellFounded.intro",
  "constType":
  "∀ {α : Sort u} {r : α → α → Prop}, (∀ (a : α), Acc r a) → WellFounded r",
  "constCategory": "Other"},
 {"references":
  ["Set.instSingletonSet",
   "Set.add",
   "Set.image2_singleton_right",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Singleton.singleton",
   "Set.image",
   "Add",
   "Eq"],
  "name": "Set.add_singleton",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s : Set α} {b : α}, s + {b} = (fun x => x + b) '' s",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Function.Injective.ne_iff",
   "Add",
   "IsLeftCancelAdd"],
  "name": "add_ne_add_right",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b ≠ a + c ↔ b ≠ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Nat.cast_zero",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "Zero.toOfNat0",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Nat.mono_cast",
   "AddMonoidWithOne.toOne",
   "Eq.rec",
   "AddMonoid.toZero",
   "CovariantClass",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_nonneg'",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedSemiring.toNoMaxOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "dist_triangle",
   "dist_comm",
   "Real",
   "NoMaxOrder.exists_gt",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Dist.dist",
   "Eq",
   "Zero.toOfNat0",
   "Filter.HasBasis",
   "Eq.mpr",
   "UniformSpace",
   "Metric.toUniformSpace_eq",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Real.strictOrderedSemiring",
   "UniformSpace.hasBasis_ofFun",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "Real.instLinearOrderedSemiringReal",
   "OrderedAddCommMonoid.toPartialOrder",
   "PseudoMetricSpace",
   "id",
   "Prod.snd",
   "setOf",
   "Real.instLTReal",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "UniformSpace.ofDist",
   "Real.instZeroReal",
   "PseudoMetricSpace.toDist",
   "UniformSpace.ofDist.proof_1",
   "uniformity",
   "Eq.ndrec",
   "LT.lt",
   "dist_self",
   "Prod",
   "LinearOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Metric.uniformity_basis_dist",
  "constType":
  "∀ {α : Type u} [inst : PseudoMetricSpace α],\n  Filter.HasBasis (uniformity α) (fun ε => 0 < ε) fun ε => {p | dist p.1 p.2 < ε}",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "neg_inj",
   "InvolutiveNeg.toNeg",
   "propext",
   "Neg.neg",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Basic._auxLemma.14",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["CompleteLattice", "CompleteLinearOrder"],
  "name": "CompleteLinearOrder.toCompleteLattice",
  "constType":
  "{α : Type u_9} → [self : CompleteLinearOrder α] → CompleteLattice α",
  "constCategory": "Definition"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "RelEmbedding",
   "Eq.refl",
   "RelEmbedding.toEmbedding",
   "FunLike.coe",
   "RelEmbedding.mk",
   "RelEmbedding.casesOn",
   "Eq",
   "Iff",
   "Function.instEmbeddingLikeEmbedding",
   "Eq.ndrec",
   "Function.Embedding.toFun",
   "Function.Embedding.casesOn",
   "Function.Injective",
   "Function.Embedding.mk",
   "Eq.rec",
   "Function.Embedding"],
  "name": "RelEmbedding.instRelHomClassRelEmbedding.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {r : α → α → Prop} {s : β → β → Prop} (f g : r ↪r s),\n  (fun x => x.toFun) f = (fun x => x.toFun) g → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Complex.addCommGroup",
   "instOfNatInt",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddCommGroup.toAddGroup",
   "Complex",
   "Int",
   "AddGroup.toSubNegMonoid",
   "SubNegMonoid.zsmul_zero'",
   "Eq"],
  "name": "Complex.Complex.addGroupWithOne.proof_4",
  "constType": "∀ (a : ℂ), SubNegMonoid.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Field.toSemifield",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "And",
   "instHMul",
   "Field",
   "HMul.hMul",
   "CommRing.toRing",
   "And.intro",
   "And.casesOn",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.match_2",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K) (motive : a * b = 0 ∧ a ≠ 0 → Prop) (x : a * b = 0 ∧ a ≠ 0),\n  (∀ (hab : a * b = 0) (hna : a ≠ 0), motive (_ : a * b = 0 ∧ a ≠ 0)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["ContravariantClass.elim",
   "instHAdd",
   "HAdd.hAdd",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "le_of_add_le_add_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Group.toDivisionMonoid",
   "Bot.bot",
   "OfNat.ofNat",
   "Subgroup.mem_bot",
   "Subgroup.one_mem",
   "Subgroup.instBotSubgroup",
   "One.toOfNat1",
   "SetLike.instMembership",
   "Eq",
   "InvOneClass.toOne",
   "Iff.mp",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.rec",
   "Subgroup",
   "Bot.mk",
   "Group",
   "Eq.symm",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.instSetLikeSubgroup"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_9",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (S : Subgroup G), ∀ _x ∈ ⊥, _x ∈ S",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Std.Logic._auxLemma.4",
   "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.2",
   "OfNat.ofNat",
   "AddSubsemigroup.instSetLikeSubsemigroup",
   "Set",
   "Mathlib.GroupTheory.Submonoid.Basic._auxLemma.9",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "implies_congr",
   "True",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "forall_congr",
   "Mathlib.Algebra.Group.Basic._auxLemma.16",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "AddSubmonoid.instBotAddSubmonoid",
   "Bot.bot",
   "AddSubmonoid.toAddSubsemigroup",
   "Std.Logic._auxLemma.32",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "AddSubsemigroup",
   "Zero.nonempty",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.GroupTheory.Subsemigroup.Basic._auxLemma.2",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "AddSubsemigroup.carrier"],
  "name": "AddSubgroup.instBotAddSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G], ∀ a ∈ ⊥.carrier, -a ∈ ⊥.carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Zero", "Real", "Zero.mk", "_private.Mathlib.Data.Real.Basic.0.Real.zero"],
  "name": "Real.instZeroReal",
  "constType": "Zero ℝ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instHSMul",
   "Monoid.toOne",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq",
   "smul_one_smul",
   "BooleanAlgebra.toBiheytingAlgebra",
   "ENNReal",
   "Eq.mpr",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.iUnion",
   "MonoidWithZero.toMonoid",
   "ENNReal.tsum_mul_left",
   "HSMul.hSMul",
   "MonoidWithZero.toMulActionWithZero",
   "Nat",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "CompletelyDistribLattice.toCompleteLattice",
   "IsScalarTower.right",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "IsScalarTower",
   "instENNRealZero",
   "BiheytingAlgebra.toHeytingAlgebra",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "instHMul",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MulAction.toSMul",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "Algebra.id",
   "congrArg",
   "MeasurableSpace",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "congrFun",
   "SMul",
   "CanonicallyOrderedCommSemiring.toMul",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "MeasureTheory.OuterMeasure.instIsScalarTower",
   "True",
   "instCountableNat",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal.instTopologicalSpaceENNReal",
   "MeasureTheory.OuterMeasure.instSMul",
   "Pairwise",
   "Eq.rec",
   "MeasurableSet",
   "instOfNatNat",
   "Eq.symm",
   "Function.onFun",
   "id",
   "eq_self",
   "Disjoint",
   "Set.Set.completeAtomicBooleanAlgebra",
   "tsum",
   "One.toOfNat1",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "HeytingAlgebra.toOrderBot",
   "Set.instBooleanAlgebraSet",
   "Eq.ndrec",
   "OrderedCommSemiring.toOrderedSemiring",
   "MeasureTheory.measure_iUnion",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "MeasureTheory.OuterMeasure",
   "MeasureTheory.OuterMeasure.instMulAction"],
  "name": "MeasureTheory.Measure.instSMul.proof_1",
  "constType":
  "∀ {α : Type u_1} {R : Type u_2} [inst : SMul R ENNReal] [inst_1 : IsScalarTower R ENNReal ENNReal]\n  [inst_2 : MeasurableSpace α] (c : R) (μ : MeasureTheory.Measure α) (s : ℕ → Set α),\n  (∀ (i : ℕ), MeasurableSet (s i)) → Pairwise (Disjoint on s) → ↑(c • ↑μ) (⋃ i, s i) = ∑' (i : ℕ), ↑(c • ↑μ) (s i)",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidHomClass",
   "MulHomClass",
   "outParam",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "Eq"],
  "name": "MonoidHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulOneClass M] →\n        [inst_1 : MulOneClass N] → [toMulHomClass : MulHomClass F M N] → (∀ (f : F), f 1 = 1) → MonoidHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "Preorder",
   "add_lt_add_right",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "instTransEq_1",
   "Function.swap",
   "AddZeroClass.toZero",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "instTransLtToLTLeToLE",
   "AddZeroClass"],
  "name": "add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "VAdd",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["AddOpposite.subNegMonoid.proof_3",
   "AddMonoid.nsmul",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "AddOpposite.subNegMonoid.proof_12",
   "AddMonoid.toAddZeroClass",
   "AddOpposite.subNegMonoid.proof_8",
   "Sub.mk",
   "AddOpposite.addSemigroup",
   "AddZeroClass.toZero",
   "AddOpposite.unop",
   "AddOpposite.subNegMonoid.proof_6",
   "AddMonoid.toAddSemigroup",
   "AddOpposite.op",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "AddOpposite.addZeroClass",
   "Nat",
   "AddOpposite.subNegMonoid.proof_4",
   "Neg",
   "AddOpposite.neg",
   "SubNegMonoid",
   "AddOpposite.subNegMonoid.proof_9",
   "AddOpposite.subNegMonoid.proof_1",
   "AddOpposite.subNegMonoid.proof_7",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "AddOpposite.subNegMonoid.proof_13",
   "Neg.neg",
   "AddOpposite.subNegMonoid.proof_10",
   "AddOpposite.subNegMonoid.proof_11",
   "SubNegMonoid.SMulInt",
   "AddOpposite.subNegMonoid.proof_2",
   "SubNegMonoid.mk",
   "AddMonoid.mk",
   "AddMonoid",
   "AddMonoid.toNatSMul",
   "AddOpposite.addMonoid",
   "AddOpposite.subNegMonoid.proof_5",
   "SubNegMonoid.sub'",
   "SubNegMonoid.toAddMonoid",
   "AddOpposite",
   "Int",
   "Neg.mk"],
  "name": "AddOpposite.subNegMonoid",
  "constType": "(α : Type u) → [inst : SubNegMonoid α] → SubNegMonoid αᵃᵒᵖ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "setOf",
   "Set",
   "InfSet.sInf",
   "InfSet",
   "And.left",
   "LE.le",
   "True",
   "Preorder.toLE",
   "PartialOrder",
   "Set.instMembershipSet",
   "And",
   "eq_true",
   "upperBounds",
   "of_eq_true",
   "lowerBounds",
   "congr",
   "PartialOrder.le_antisymm",
   "congrArg",
   "Eq.trans",
   "and_self"],
  "name": "completeLatticeOfInf.proof_3",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α],\n  (∀ (s : Set α), IsGLB s (sInf s)) → ∀ (a b c : α), a ≤ c → b ≤ c → sInf {x | a ≤ x ∧ b ≤ x} ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Set.mem_insert",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Set.mem_singleton",
   "lowerBounds_insert",
   "Set",
   "InfSet.sInf",
   "Inter.inter",
   "Set.Iic",
   "Lattice.mk",
   "Sup.mk",
   "And.left",
   "Insert.insert",
   "Preorder.toLE",
   "True",
   "Inf.mk",
   "Set.instSingletonSet",
   "And.right",
   "upperBounds",
   "lowerBounds_singleton",
   "Lattice.toSemilatticeSup",
   "Eq.trans",
   "Mathlib.Data.Set.Basic._auxLemma.25",
   "SemilatticeSup.toPartialOrder",
   "Membership.mem",
   "IsGLB",
   "setOf",
   "SemilatticeSup.mk",
   "InfSet",
   "LE.le",
   "Set.instMembershipSet",
   "PartialOrder",
   "And",
   "eq_true",
   "of_eq_true",
   "Mathlib.Data.Set.Intervals.Basic._auxLemma.5",
   "lowerBounds",
   "Set.mem_insert_of_mem",
   "PartialOrder.le_antisymm",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "and_self",
   "Set.instInterSet",
   "Set.instInsertSet"],
  "name": "completeLatticeOfInf.proof_10",
  "constType":
  "∀ (α : Type u_1) [H1 : PartialOrder α] [H2 : InfSet α] (isGLB_sInf : ∀ (s : Set α), IsGLB s (sInf s)) (s : Set α)\n  (a : α), (∀ b ∈ s, a ≤ b) → a ≤ sInf s",
  "constCategory": "Theorem"},
 {"references": ["Zero", "outParam", "FunLike", "ZeroHomClass"],
  "name": "ZeroHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] → [inst_1 : Zero N] → [self : ZeroHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references": ["HImp", "BooleanAlgebra"],
  "name": "BooleanAlgebra.toHImp",
  "constType": "{α : Type u} → [self : BooleanAlgebra α] → HImp α",
  "constCategory": "Definition"},
 {"references":
  ["Ord.compare", "Ordering", "Eq.refl", "instOrdNat", "Nat", "Eq"],
  "name": "Nat.linearOrder.proof_3",
  "constType": "∀ (a b : ℕ), compare a b = compare a b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Invertible.invOf",
   "One",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible.mul_invOf_self",
   "Invertible",
   "Eq"],
  "name": "mul_invOf_self",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) [inst_2 : Invertible a], a * ⅟a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Neg.neg",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "NegZeroClass",
   "Eq"],
  "name": "NegZeroClass.neg_zero",
  "constType": "∀ {G : Type u_2} [self : NegZeroClass G], -0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.casesOn",
   "Int.ofNat",
   "Int.instMulInt",
   "Int.negOfNat",
   "Eq.refl",
   "True",
   "Eq",
   "Nat.mul_comm",
   "instHMul",
   "Eq.ndrec",
   "Nat.cast",
   "of_eq_true",
   "instNatCastInt",
   "Int.negSucc",
   "HMul.hMul",
   "Nat",
   "instMulNat",
   "Eq.symm",
   "congrArg",
   "Nat.succ",
   "Int",
   "Eq.trans",
   "congrFun"],
  "name": "Int.mul_comm",
  "constType": "∀ (a b : ℤ), a * b = b * a",
  "constCategory": "Theorem"},
 {"references": ["setOf", "Set", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "Set.Ici",
  "constType": "{α : Type u_1} → [inst : Preorder α] → α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Set",
   "Set.toFinset",
   "Eq.refl",
   "Set.Finite",
   "Eq",
   "Subsingleton.elim",
   "_private.Mathlib.Data.Set.Finite.0.Set.Finite.toFinset._eq_1",
   "Fintype",
   "Eq.mpr",
   "Eq.ndrec",
   "Set.Elem",
   "letFun",
   "Finset",
   "Set.Finite.fintype",
   "Fintype.subsingleton",
   "Set.Finite.toFinset",
   "id"],
  "name": "Set.Finite.toFinset_eq_toFinset",
  "constType":
  "∀ {α : Type u} {s : Set α} [inst : Fintype ↑s] (h : Set.Finite s), Set.Finite.toFinset h = Set.toFinset s",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Finset.instEmptyCollectionFinset",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "propext",
   "Finset",
   "Finset.card_eq_zero",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Mathlib.Data.Finset.Card._auxLemma.1",
  "constType": "∀ {α : Type u_1} {s : Finset α}, (Finset.card s = 0) = (s = ∅)",
  "constCategory": "Theorem"},
 {"references":
  ["CauSeq.const",
   "CauchySeq",
   "Metric.mem_nhds_iff",
   "CompleteSpace",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Real.instSupReal",
   "Mathlib.Topology.Instances.Real._auxLemma.4",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Dist.dist",
   "Eq.mpr",
   "Iff.mp",
   "Filter.Tendsto",
   "Filter",
   "Metric.ball",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "SemilatticeSup.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "StrictOrderedRing.toPartialOrder",
   "CauSeq.instSubCauSeq",
   "PseudoMetricSpace.toUniformSpace",
   "HasSubset.Subset",
   "Nat.instLatticeNat",
   "Real.instRingReal",
   "Set.instMembershipSet",
   "And",
   "CauSeq.equiv_lim",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "LT.lt",
   "instInhabitedNat",
   "Filter.atTop",
   "Exists",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "Subtype.val",
   "IsCauSeq",
   "Real",
   "Set",
   "GE.ge",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Exists.imp",
   "Exists.intro",
   "Abs.abs",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Metric.cauchySeq_iff'",
   "instLENat",
   "Preorder.toLT",
   "Filter.map",
   "Lattice.toSemilatticeSup",
   "UniformSpace.toTopologicalSpace",
   "instNonempty",
   "id",
   "instMembershipSetFilter",
   "Neg.toHasAbs",
   "Membership.mem",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "CauSeq.lim",
   "Real.instLinearOrderedRingReal",
   "Set.preimage",
   "Real.instLTReal",
   "nhds",
   "HSub.hSub",
   "Metric.complete_of_cauchySeq_tendsto",
   "Real.pseudoMetricSpace",
   "CauSeq",
   "GT.gt",
   "Real.instZeroReal",
   "Real.instIsCompleteRealInstLinearOrderedFieldRealInstRingRealAbsToHasAbsInstNegRealInstSupRealAbs_isAbsoluteValueInstLinearOrderedRingReal",
   "PseudoMetricSpace.toDist",
   "Set.instHasSubsetSet",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun",
   "Mathlib.Topology.Instances.Real._auxLemma.3",
   "Subtype.mk"],
  "name": "instCompleteSpaceRealToUniformSpacePseudoMetricSpace",
  "constType": "CompleteSpace ℝ",
  "constCategory": "Definition"},
 {"references": ["Min", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toMin",
  "constType": "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → Min α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "DecidableEq",
   "instHAdd",
   "HAdd.hAdd",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.mem_image₂",
   "Add",
   "Finset.add",
   "Eq"],
  "name": "Finset.mem_add",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Add α] {s t : Finset α} {x : α},\n  x ∈ s + t ↔ ∃ y z, y ∈ s ∧ z ∈ t ∧ y + z = x",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instSubNat",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "Nat.lt_of_sub_eq_succ",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddGroupWithOne.toAddGroup",
   "True",
   "Eq",
   "Nat.linearOrder",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instLENat",
   "AddGroupWithOne",
   "instOfNatNat",
   "le_of_lt",
   "Int.cast_negSucc",
   "Nat",
   "Eq.symm",
   "Nat.le_of_sub_eq_zero",
   "Nat.succ",
   "Eq.trans",
   "Nat.add_one",
   "id",
   "eq_self",
   "instHSub",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "LE.le",
   "Int.cast_ofNat",
   "eq_true",
   "Nat.zero",
   "Eq.ndrec",
   "of_eq_true",
   "instNatCastInt",
   "Nat.cast_sub",
   "SubtractionMonoid.toSubNegMonoid",
   "Int.cast",
   "Int.negSucc",
   "Int.negOfNat.match_1",
   "LinearOrder.toPartialOrder",
   "congrArg",
   "neg_sub",
   "Int",
   "Nat.casesOn",
   "Int.subNatNat",
   "congrFun"],
  "name": "Int.cast_subNatNat",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℕ), ↑(Int.subNatNat m n) = ↑m - ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["BooleanAlgebra.himp_eq",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Inf.inf",
   "Eq.refl",
   "HNot.hnot",
   "BooleanAlgebra.toHasCompl",
   "BoundedOrder.toOrderTop",
   "BooleanAlgebra.sdiff_eq",
   "isCompl_compl",
   "Preorder.toLE",
   "BooleanAlgebra",
   "Eq",
   "HNot.mk",
   "OrderTop.toTop",
   "Lattice.toInf",
   "top_inf_eq",
   "Eq.mpr",
   "HImp.himp",
   "Iff",
   "SemilatticeSup.toSup",
   "BooleanAlgebra.toHImp",
   "GeneralizedHeytingAlgebra.toLattice",
   "IsCompl.le_sup_right_iff_inf_left_le",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "Eq.trans",
   "BoundedOrder.toOrderBot",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "id",
   "OrderTop.mk",
   "BooleanAlgebra.le_top",
   "Bot.bot",
   "SemilatticeInf.toInf",
   "Lattice.toSemilatticeInf",
   "Top.top",
   "himp_eq",
   "SemilatticeInf.toPartialOrder",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "LE.le",
   "DistribLattice.toLattice",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Eq.ndrec",
   "bot_sup_eq",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "propext",
   "OrderBot.toBot",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "HeytingAlgebra.mk",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BooleanAlgebra.toBoundedOrder",
   "Sup.sup",
   "BooleanAlgebra.toSDiff",
   "GeneralizedCoheytingAlgebra.toOrderBot",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : BooleanAlgebra α] (a : α), ⊤ \\ a = ￢a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "instHSMul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Mathlib.Tactic.Abel.termg",
   "HAdd.hAdd",
   "AddCommGroup.toAddCommMonoid",
   "SubNegMonoid.SMulInt",
   "AddCommMagma.toAdd",
   "AddGroup.toSubNegMonoid",
   "True",
   "Eq",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "HSMul.hSMul",
   "congr",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "Eq.symm",
   "congrArg",
   "Eq.trans",
   "Int",
   "AddCommMonoid.toAddCommSemigroup"],
  "name": "Mathlib.Tactic.Abel.term_add_constg",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommGroup α] (n : ℤ) (x a k a' : α),\n  a + k = a' → Mathlib.Tactic.Abel.termg n x a + k = Mathlib.Tactic.Abel.termg n x a'",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.nodup",
   "DecidablePred",
   "Finset",
   "Multiset.filter",
   "Finset.val",
   "Multiset.Nodup",
   "Multiset.Nodup.filter"],
  "name": "Finset.filter.proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (s : Finset α), Multiset.Nodup (Multiset.filter p s.val)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype.complete",
   "Fintype",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Finset.mem_univ",
  "constType": "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.OuterMeasure.dirac",
   "MeasurableSpace.instLEMeasurableSpace",
   "MeasureTheory.OuterMeasure.dirac_caratheodory",
   "of_eq_true",
   "Top.top",
   "Mathlib.Order.BoundedOrder._auxLemma.1",
   "CompleteLattice.toTop",
   "CompleteLattice.toBoundedOrder",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "BoundedOrder.toOrderTop",
   "congrArg",
   "Eq.trans",
   "LE.le",
   "MeasurableSpace",
   "True",
   "MeasureTheory.OuterMeasure.caratheodory"],
  "name": "MeasureTheory.Measure.dirac.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] (a : α),\n  inst ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.OuterMeasure.dirac a)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "sub_add_eq_sub_sub_swap",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b c : α), a - (b + c) = a - c - b",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "Lattice.toInf",
   "Set.instBooleanAlgebraSet",
   "Inf.inf",
   "Set",
   "HasCompl.compl",
   "SDiff.sdiff",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toSDiff",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.sdiff_eq",
   "Eq"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_9",
  "constType": "∀ {α : Type u_1} (x y : Set α), x \\ y = x ⊓ yᶜ",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem", "Or", "setOf", "Set", "Set.instMembershipSet", "Eq"],
  "name": "Set.insert",
  "constType": "{α : Type u_1} → α → Set α → Set α",
  "constCategory": "Definition"},
 {"references": ["refPackage", "MeasureTheory.MeasureSpace", "MeasurableSpace"],
  "name": "refPackage.X₀₂",
  "constType":
  "{Ω₀₁ : Type u_1} →\n  {Ω₀₂ : Type u_2} →\n    [inst : MeasureTheory.MeasureSpace Ω₀₁] →\n      [inst_1 : MeasureTheory.MeasureSpace Ω₀₂] →\n        {G : Type uG} → [inst_2 : MeasurableSpace G] → refPackage Ω₀₁ Ω₀₂ G → Ω₀₂ → G",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid", "SMul", "SMul.mk", "SubNegMonoid.zsmul", "Int"],
  "name": "SubNegMonoid.SMulInt",
  "constType": "{M : Type u_2} → [inst : SubNegMonoid M] → SMul ℤ M",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonAssocRing",
   "HMul.hMul",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.toOne",
   "Eq"],
  "name": "NonAssocRing.one_mul",
  "constType": "∀ {α : Type u_1} [self : NonAssocRing α] (a : α), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "mul_neg",
   "OrderedRing",
   "Semiring.toMonoidWithZero",
   "AddGroup.toSubtractionMonoid",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Iff.mpr",
   "Ring.toNonAssocRing",
   "Preorder.toLE",
   "AddGroupWithOne.toAddGroup",
   "Zero.toOfNat0",
   "OrderedRing.toRing",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "OrderedRing.toOrderedSemiring",
   "Eq.trans",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.3",
   "Ring.toAddGroupWithOne",
   "OrderedRing.toOrderedAddCommGroup",
   "Neg.neg",
   "mul_le_mul_of_nonneg_right",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "OrderedRing.toPartialOrder",
   "instHMul",
   "neg_nonneg",
   "Eq.mp",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "congr",
   "OrderedSemiring.toMulPosMono",
   "MonoidWithZero.toZero",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "congrArg"],
  "name": "mul_le_mul_of_nonpos_right",
  "constType":
  "∀ {α : Type u} [inst : OrderedRing α] {a b c : α}, b ≤ a → c ≤ 0 → a * c ≤ b * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "Multiset.instZeroMultiset",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Multiset.instAddMultiset",
   "add_le_add_left",
   "Preorder.toLE",
   "Eq",
   "Multiset.instPartialOrderMultiset",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Multiset.instCovariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Eq.mp",
   "Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.15",
   "Multiset",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "Multiset.instContravariantClassMultisetHAddInstHAddInstAddMultisetLeToLEToPreorderInstPartialOrderMultiset",
   "Multiset.zero_le",
   "congrFun",
   "id",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.le_add_right",
  "constType": "∀ {α : Type u_1} (s t : Multiset α), s ≤ s + t",
  "constCategory": "Theorem"},
 {"references":
  ["PseudoEMetricSpace.mk",
   "EDist.mk",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_2",
   "PseudoMetricSpace.edist",
   "Metric.uniformity_edist",
   "PseudoMetricSpace.toUniformSpace",
   "PseudoEMetricSpace",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_3",
   "PseudoMetricSpace.toPseudoEMetricSpace.proof_1",
   "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toPseudoEMetricSpace",
  "constType":
  "{α : Type u} → [inst : PseudoMetricSpace α] → PseudoEMetricSpace α",
  "constCategory": "Definition"},
 {"references": ["instHAdd", "HAdd.hAdd", "VAdd", "Add", "VAdd.mk"],
  "name": "Add.toVAdd",
  "constType": "(α : Type u_10) → [inst : Add α] → VAdd α α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubmonoid.comap.proof_2",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubsemigroup.mk",
   "Set.preimage",
   "AddSubmonoid.comap.proof_1",
   "AddHomClass.toFunLike",
   "AddSubmonoid.mk",
   "AddMonoidHomClass.toAddHomClass",
   "FunLike.coe",
   "AddMonoidHomClass",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe"],
  "name": "AddSubmonoid.comap",
  "constType":
  "{M : Type u_1} →\n  {N : Type u_2} →\n    [inst : AddZeroClass M] →\n      [inst_1 : AddZeroClass N] → {F : Type u_4} → [mc : AddMonoidHomClass F M N] → F → AddSubmonoid N → AddSubmonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set",
   "implies_true",
   "Finset.instMembershipFinset",
   "Mathlib.Data.Finset.Image._auxLemma.4",
   "True",
   "iff_self",
   "Eq",
   "Set.instMembershipSet",
   "Set.ext",
   "And",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "forall_congr",
   "Finset.toSet",
   "Finset.image",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Image._auxLemma.5",
   "Mathlib.Data.Finset.Image._auxLemma.24",
   "Set.image",
   "congrArg",
   "Eq.trans",
   "congrFun"],
  "name": "Finset.coe_image",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {s : Finset α} {f : α → β}, ↑(Finset.image f s) = f '' ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["Function.swap",
   "Iff",
   "instHAdd",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LE",
   "Add",
   "LE.le",
   "ContravariantClass"],
  "name": "add_le_add_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b c : α},\n  b + a ≤ c + a ↔ b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "instHMul",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedCommSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "OrderedCommSemiring.mk",
  "constType":
  "{α : Type u} → [toOrderedSemiring : OrderedSemiring α] → (∀ (a b : α), a * b = b * a) → OrderedCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["VSub.vsub",
   "outParam",
   "AddTorsor",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "AddAction.toVAdd",
   "VSub",
   "HVAdd.hVAdd",
   "instHVAdd",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "Nonempty",
   "Eq"],
  "name": "AddTorsor.mk",
  "constType":
  "{G : outParam (Type u_1)} →\n  {P : Type u_2} →\n    [inst : outParam (AddGroup G)] →\n      [toAddAction : AddAction G P] →\n        [toVSub : VSub G P] →\n          [nonempty : Nonempty P] →\n            (∀ (p1 p2 : P), p1 -ᵥ p2 +ᵥ p2 = p1) → (∀ (g : G) (p : P), g +ᵥ p -ᵥ p = g) → AddTorsor G P",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "AddSubgroup.zsmul",
   "instHSMul",
   "AddGroup",
   "Subtype.val",
   "HSMul.hSMul",
   "AddSubgroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "Int",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddGroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x : ↥H) (x_1 : ℤ), ↑(x_1 • x) = ↑(x_1 • x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "Real.instLEReal",
   "Real",
   "Set",
   "Eq.refl",
   "MeasureTheory.Measure.map_apply",
   "ProbabilityTheory.entropy",
   "ProbabilityTheory.measureEntropy_le_log_card_of_mem",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasurableSingletonClass",
   "measurableSet_discrete",
   "Eq.mpr",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "Nat.cast",
   "MeasureTheory.OuterMeasure.measureOf",
   "Finset.toSet",
   "Finset",
   "Measurable",
   "MeasureTheory.Measure.ae",
   "Subtype",
   "id",
   "Membership.mem",
   "Set.preimage",
   "HasCompl.compl",
   "Finset.instMembershipFinset",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Filter.Eventually",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "LE.le",
   "Countable",
   "Real.log",
   "Eq.ndrec",
   "MeasureTheory.Measure.toOuterMeasure",
   "Nat.card",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.entropy_le_log_card_of_mem",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {A : Finset S} {μ : MeasureTheory.Measure Ω} {X : Ω → S},\n  Measurable X → (∀ᵐ (ω : Ω) ∂μ, X ω ∈ A) → H[X ; μ] ≤ Real.log ↑(Nat.card { x // x ∈ A })",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Membership",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["LE", "Add"],
  "name": "ExistsAddOfLE",
  "constType": "(α : Type u) → [inst : Add α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p),\n  (∀ (w : α) (h : p w), motive (_ : Exists p)) → motive t",
  "constCategory": "Definition"},
 {"references": ["HasCompl"],
  "name": "HasCompl.mk",
  "constType": "{α : Type u_3} → (α → α) → HasCompl α",
  "constCategory": "Other"},
 {"references": [],
  "name": "CompletelyDistribLattice",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Min",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "LinearOrderedAddCommMonoid.toLinearOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "HAdd.hAdd",
   "ExistsAddOfLE",
   "instLTNat",
   "Preorder.toLE",
   "Iff.mpr",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "not_le_of_gt",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "Nat",
   "OrderedAddCommMonoid.toPartialOrder",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "Ne",
   "le_of_not_lt",
   "Nat.canonicallyOrderedCommSemiring",
   "Nat.succ_pred_eq_of_pos",
   "pow_zero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "pow_unbounded_of_one_lt",
   "And",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Eq.mp",
   "LinearOrderedSemiring",
   "Nat.find",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "And.intro",
   "Archimedean",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Exists",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "Zero.toOfNat0",
   "ne_of_gt",
   "Nat.pred",
   "instHPow",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "id",
   "instAddNat",
   "instHAdd",
   "pos_iff_ne_zero",
   "One.toOfNat1",
   "Nat.pred_lt",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "Nat.find_min",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Nat.find_spec",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun"],
  "name": "exists_nat_pow_near",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedSemiring α] [inst_1 : Archimedean α] [inst_2 : ExistsAddOfLE α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)",
  "constCategory": "Theorem"},
 {"references": ["Prod.mk", "Prod"],
  "name": "prod",
  "constType":
  "{Ω : Type u_1} → {S : Type u_2} → {T : Type u_3} → (Ω → S) → (Ω → T) → Ω → S × T",
  "constCategory": "Definition"},
 {"references":
  ["Set.neg",
   "InvolutiveNeg",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Eq.ndrec",
   "InvolutiveNeg.toNeg",
   "Set",
   "Eq.refl",
   "Singleton.singleton",
   "Neg.neg",
   "Set.image",
   "Set.image_singleton",
   "Set.image_neg",
   "Eq.symm",
   "id",
   "Eq"],
  "name": "Set.neg_singleton",
  "constType": "∀ {α : Type u_2} [inst : InvolutiveNeg α] (a : α), -{a} = {-a}",
  "constCategory": "Theorem"},
 {"references": ["propext", "imp_self", "True", "Eq"],
  "name": "Std.Logic._auxLemma.4",
  "constType": "∀ {a : Prop}, (a → a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHSub",
   "Exists",
   "Finset.Nonempty",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "Finset.instMembershipFinset",
   "Exists.intro",
   "Finset.Nonempty.zero_mem_sub.match_1",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Eq",
   "Finset.mem_sub",
   "Zero.toOfNat0",
   "And",
   "SubNegMonoid.toSub",
   "AddGroup",
   "DecidableEq",
   "Finset",
   "And.intro",
   "NegZeroClass.toZero",
   "Finset.sub",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Finset.Nonempty.zero_mem_sub",
  "constType":
  "∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : AddGroup α] {s : Finset α}, Finset.Nonempty s → 0 ∈ s - s",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.PFR.ForMathlib.Uniform._hyg.100",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.gt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references": ["Setoid.r", "Setoid", "Quotient", "Quot.mk"],
  "name": "Quotient.mk''",
  "constType": "{α : Sort u_1} → {s₁ : Setoid α} → α → Quotient s₁",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Exists.intro",
   "Nat",
   "Exists.casesOn",
   "Eq"],
  "name": "Nat.le_of_add_le_add_left.match_1",
  "constType":
  "∀ {a b c : ℕ} (motive : (∃ k, a + b + k = a + c) → Prop) (x : ∃ k, a + b + k = a + c),\n  (∀ (d : ℕ) (hd : a + b + d = a + c), motive (_ : ∃ k, a + b + k = a + c)) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "add_le_of_le_of_nonpos",
   "CovariantClass",
   "Preorder",
   "LE.le",
   "AddZeroClass",
   "Preorder.toLE"],
  "name": "Left.add_nonpos",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Neg.toHasAbs",
   "LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Real.instLTReal",
   "DivisionRing.toRing",
   "Real",
   "Real.instLEReal",
   "Rat",
   "CauSeq",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "LT.mk",
   "LE.le",
   "lt_iff_le_not_le",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "And",
   "Eq.mpr",
   "CauSeq.instPreorderCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Iff",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "Rat.divisionRing",
   "Real.mk",
   "LT.lt",
   "Rat.instNegRat",
   "congr",
   "Not",
   "Real.ind_mk",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "id"],
  "name": "Real.partialOrder.proof_3",
  "constType": "∀ (a b : ℝ), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "List.pmap.proof_3",
   "HAdd.hAdd",
   "ULift.down",
   "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat",
   "Fin.rec0",
   "MeasureTheory.IsProbabilityMeasure",
   "And.left",
   "Exists.casesOn",
   "autoParam",
   "instLTNat",
   "ULift",
   "Eq",
   "measurable_down",
   "inferInstance",
   "And.right",
   "Eq.mpr",
   "ULift.instMeasurableSpace",
   "List.finRange",
   "List.Mem.casesOn",
   "Nat",
   "And.casesOn",
   "Fin.cases",
   "Fin.mk",
   "List.pmap",
   "MeasureTheory.Measure.comap",
   "Function.comp",
   "eq_of_heq",
   "Fin.fintype",
   "Finset.instMembershipFinset",
   "ProbabilityTheory.IdentDistrib",
   "_auto._@.Mathlib.Probability.Independence.Basic._hyg.438",
   "ProbabilityTheory.identDistrib_ulift_self",
   "And",
   "HEq.refl",
   "LT.lt",
   "Fin.instOfNatFin",
   "List.pmap.proof_4",
   "Matrix.vecCons",
   "And.intro",
   "MeasurableSpace",
   "Fin",
   "Exists",
   "HEq",
   "Eq.refl",
   "Exists.intro",
   "MeasureTheory.Measure",
   "ProbabilityTheory.IdentDistrib.trans",
   "Finset",
   "Fintype.elems",
   "Measurable",
   "instOfNatNat",
   "List.nil",
   "Eq.symm",
   "Nat.succ",
   "id",
   "NeZero.succ",
   "Membership.mem",
   "Fintype.complete",
   "List.finRange.proof_1",
   "funext",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "List.Mem.tail",
   "ProbabilityTheory.IdentDistrib.symm",
   "ProbabilityTheory.independent_copies'",
   "List.Mem",
   "Matrix.vecEmpty",
   "Measurable.comp",
   "MeasureTheory.isProbabilityMeasure_comap_down",
   "Eq.ndrec",
   "List",
   "letFun",
   "List.Mem.head",
   "ProbabilityTheory.iIndepFun",
   "Eq.casesOn",
   "List.noConfusion",
   "Fin.succ"],
  "name": "ProbabilityTheory.independent_copies4_nondep",
  "constType":
  "∀ {α : Type u} [mS : MeasurableSpace α] {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n  [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂] [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n  {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α},\n  Measurable X₁ →\n    Measurable X₂ →\n      Measurable X₃ →\n        Measurable X₄ →\n          ∀ (μ₁ : MeasureTheory.Measure Ω₁) (μ₂ : MeasureTheory.Measure Ω₂) (μ₃ : MeasureTheory.Measure Ω₃)\n            (μ₄ : MeasureTheory.Measure Ω₄) [hμ₁ : MeasureTheory.IsProbabilityMeasure μ₁]\n            [hμ₂ : MeasureTheory.IsProbabilityMeasure μ₂] [hμ₃ : MeasureTheory.IsProbabilityMeasure μ₃]\n            [hμ₄ : MeasureTheory.IsProbabilityMeasure μ₄],\n            ∃ A mA μA X₁' X₂' X₃' X₄',\n              MeasureTheory.IsProbabilityMeasure μA ∧\n                ProbabilityTheory.iIndepFun (fun x => mS) ![X₁', X₂', X₃', X₄'] ∧\n                  Measurable X₁' ∧\n                    Measurable X₂' ∧\n                      Measurable X₃' ∧\n                        Measurable X₄' ∧\n                          ProbabilityTheory.IdentDistrib X₁' X₁ ∧\n                            ProbabilityTheory.IdentDistrib X₂' X₂ ∧\n                              ProbabilityTheory.IdentDistrib X₃' X₃ ∧ ProbabilityTheory.IdentDistrib X₄' X₄",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "GaloisInsertion", "Preorder.toLE"],
  "name": "GaloisInsertion.choice",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : Preorder α] →\n      [inst_1 : Preorder β] → {l : α → β} → {u : β → α} → GaloisInsertion l u → (x : α) → u (l x) ≤ x → β",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedField", "Rat"],
  "name": "LinearOrderedField.qsmul",
  "constType": "{α : Type u_2} → [self : LinearOrderedField α] → ℚ → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Submonoid.instSetLikeSubmonoid",
   "Subgroup.toSubmonoid",
   "Set",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "And.left",
   "Monoid.toMulOneClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Subgroup.instCompleteLatticeSubgroup.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (_a _b : Subgroup G) (_x : G),\n  _x ∈ ↑_a.toSubmonoid ∧ _x ∈ ↑_b.toSubmonoid → _x ∈ ↑_a.toSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "PartialOrder.toPreorder",
   "Submonoid.instInfSetSubmonoid",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Submonoid",
   "PartialOrder.le_antisymm",
   "Submonoid.instCompleteLatticeSubmonoid.proof_1",
   "completeLatticeOfInf",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeSup.toPartialOrder",
   "Eq"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_5",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (a b : Submonoid M), a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "LT.lt.le",
   "Real.instLTReal",
   "Real",
   "Real.instMulReal",
   "Eq.refl",
   "Eq",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Real.rpow_pos_of_pos",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "instHPow",
   "LT.lt",
   "Real.instPowReal",
   "Real.instPreorderReal",
   "Real.rpow_mul",
   "HMul.hMul",
   "Real.mul_rpow",
   "id"],
  "name": "Mathlib.Tactic.RPowRing.pow_pf",
  "constType":
  "∀ {a b e₂ b' e₁ : ℝ}, 0 < a → 0 < b → b ^ e₂ = b' → (a ^ e₁ * b) ^ e₂ = a ^ (e₁ * e₂) * b'",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "Exists",
   "Units",
   "Units.mk0",
   "OfNat.ofNat",
   "MonoidWithZero.toMonoid",
   "propext",
   "GroupWithZero",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "Eq",
   "Units.exists0"],
  "name": "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.7",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {p : G₀ˣ → Prop}, (∃ g, p g) = ∃ g, ∃ (hg : g ≠ 0), p (Units.mk0 g hg)",
  "constCategory": "Theorem"},
 {"references":
  ["Filter.EventuallyEq.prod_mk",
   "Filter.EventuallyEq",
   "AEMeasurable.measurable_mk",
   "Exists.intro",
   "Prod.instMeasurableSpace",
   "AEMeasurable.ae_eq_mk",
   "MeasureTheory.Measure",
   "And",
   "Measurable.prod_mk",
   "Prod.mk",
   "Prod",
   "Measurable",
   "And.intro",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace",
   "AEMeasurable",
   "AEMeasurable.mk"],
  "name": "AEMeasurable.prod_mk",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {m0 : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {f : α → β} {g : α → γ},\n  AEMeasurable f → AEMeasurable g → AEMeasurable fun x => (f x, g x)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "Eq",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder",
   "congrFun"],
  "name": "Linarith.mul_eq",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a = 0 → 0 < b → b * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "OfNat.ofNat",
   "SMulWithZero.toSMulZeroClass",
   "instHSMul",
   "HSMul.hSMul",
   "MulZeroClass.toSMulWithZero",
   "MulZeroClass.toZero",
   "SMulWithZero.zero_smul",
   "MulZeroOneClass.toMulZeroClass",
   "SMulZeroClass.toSMul",
   "Eq",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulActionWithZero.proof_4",
  "constType": "∀ (R : Type u_1) [inst : MonoidWithZero R] (m : R), 0 • m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.map₂",
   "instHasEquiv",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "CauSeq.mul_equiv_mul",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "instHMul",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Mul",
   "HasEquiv.Equiv",
   "CauSeq.instMulCauSeq",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Mul.mk"],
  "name": "CauSeq.Completion.instMulCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Mul (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "Ring.toNonAssocRing",
   "True",
   "DivisionRing.toInv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "DivisionSemiring.toSemiring",
   "AddZeroClass.toZero",
   "of_eq_true",
   "congr",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "Inv.inv"],
  "name": "Mathlib.Tactic.Ring.inv_single",
  "constType":
  "∀ {R : Type u_1} [inst : DivisionRing R] {a b : R}, a⁻¹ = b → (a + 0)⁻¹ = b + 0",
  "constCategory": "Theorem"},
 {"references": ["Option"],
  "name": "WithTop",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UniformSpace",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "Norm",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_1",
   "CompleteLattice.sInf_le",
   "completeLatticeOfInf",
   "AddSubmonoid",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "CompleteLattice.toInfSet",
   "Lattice.toSemilatticeSup",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "AddZeroClass",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubmonoid.instCompleteLatticeAddSubmonoid.proof_14",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (s : Set (AddSubmonoid M)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Real",
   "Ring.toAddCommGroup",
   "Real.instRingReal",
   "AddCommGroup"],
  "name": "Real.instAddCommGroupReal",
  "constType": "AddCommGroup ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Filter.mp_mem.match_1",
   "Membership.mem",
   "setOf",
   "Filter.inter_mem",
   "Set",
   "Filter.mem_of_superset",
   "Inter.inter",
   "Filter",
   "Set.instInterSet",
   "Set.instMembershipSet",
   "instMembershipSetFilter"],
  "name": "Filter.mp_mem",
  "constType":
  "∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → {x | x ∈ s → x ∈ t} ∈ f → t ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["add_right_cancel",
   "Function.Injective",
   "instHAdd",
   "HAdd.hAdd",
   "IsRightCancelAdd",
   "Add"],
  "name": "add_left_injective",
  "constType":
  "∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G), Function.Injective fun x => x + a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedCancelAddCommMonoid.le_of_add_le_add_left",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.min_def",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedCancelAddCommMonoid",
   "LinearOrderedCancelAddCommMonoid.mk",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.toMin",
   "OrderedCancelAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "LinearOrderedAddCommGroup.toMax"],
  "name": "LinearOrderedAddCommGroup.toLinearOrderedAddCancelCommMonoid",
  "constType":
  "{α : Type u} → [inst : LinearOrderedAddCommGroup α] → LinearOrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["SemiconjBy", "Mul"],
  "name": "Commute",
  "constType": "{S : Type u_2} → [inst : Mul S] → S → S → Prop",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "DivisionRing.toInv",
   "DivisionRing.zpow",
   "Inv.inv",
   "Eq"],
  "name": "DivisionRing.zpow_neg'",
  "constType":
  "∀ {K : Type u} [self : DivisionRing K] (n : ℕ) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.giGenerateFrom",
   "CompletelyDistribLattice.toCompleteLattice",
   "CompleteLattice",
   "setOf",
   "Set",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "MeasurableSpace",
   "GaloisInsertion.liftCompleteLattice",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice"],
  "name": "MeasurableSpace.instCompleteLatticeMeasurableSpace",
  "constType": "{α : Type u_1} → CompleteLattice (MeasurableSpace α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "Eq.ndrec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "id"],
  "name": "NeZero.one",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "constCategory": "Definition"},
 {"references": ["Exists", "Countable", "Function.Injective", "Nat"],
  "name": "Countable.exists_injective_nat'",
  "constType": "∀ {α : Sort u} [self : Countable α], ∃ f, Function.Injective f",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "MetricSpace.toPseudoMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "NormedRing",
   "Norm",
   "MetricSpace",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toMetricSpace : MetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → NormedRing α",
  "constCategory": "Other"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "FunLike.coe",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "OrderHom.mk",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "Monotone",
   "OrderHom.casesOn",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.match_2",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (s : α)\n  (motive : (x : OmegaCompletePartialOrder.Chain α) → (∀ (i : ℕ), x i ≤ s) → Prop)\n  (x : OmegaCompletePartialOrder.Chain α) (hs : ∀ (i : ℕ), x i ≤ s),\n  (∀ (c : ℕ → α) (monotone' : Monotone c) (hs : ∀ (i : ℕ), { toFun := c, monotone' := monotone' } i ≤ s),\n      motive { toFun := c, monotone' := monotone' } hs) →\n    motive x hs",
  "constCategory": "Definition"},
 {"references": ["Contravariant", "ContravariantClass"],
  "name": "ContravariantClass.mk",
  "constType":
  "∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop}, Contravariant M N μ r → ContravariantClass M N μ r",
  "constCategory": "Other"},
 {"references": [],
  "name": "SemilatticeInf",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Real.instLinearOrderedFieldReal",
   "OfNat.ofNat",
   "MeasureTheory.map_measureReal_apply",
   "MeasureTheory.Measure.map",
   "Real.natCast",
   "Real",
   "Set",
   "Eq.refl",
   "MeasureTheory.IsProbabilityMeasure",
   "LinearOrderedField.toDiv",
   "Eq",
   "Real.instOneReal",
   "MeasureTheory.Measure",
   "MeasurableSingletonClass",
   "Eq.mpr",
   "Set.instSingletonSet",
   "ProbabilityTheory.IsUniform.measureReal_preimage_of_mem",
   "Nat.cast",
   "Finset.toSet",
   "Finset",
   "Measurable",
   "HDiv.hDiv",
   "Subtype",
   "id",
   "Membership.mem",
   "instHDiv",
   "Set.preimage",
   "Finset.instMembershipFinset",
   "One.toOfNat1",
   "MeasureTheory.Measure.real",
   "MeasurableSet.singleton",
   "Countable",
   "Eq.ndrec",
   "Singleton.singleton",
   "Nat.card",
   "ProbabilityTheory.IsUniform",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.IsUniform.measureReal_preimage_of_mem'",
  "constType":
  "∀ {Ω : Type uΩ} {S : Type uS} [mΩ : MeasurableSpace Ω] [inst : Countable S] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {X : Ω → S} {μ : MeasureTheory.Measure Ω} {H : Finset S}\n  [inst_2 : MeasureTheory.IsProbabilityMeasure μ],\n  ProbabilityTheory.IsUniform (↑H) X →\n    Measurable X → ∀ {s : S}, s ∈ H → (MeasureTheory.Measure.map X μ).real {s} = 1 / ↑(Nat.card { x // x ∈ H })",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instHasSubsetSet",
   "Set.add",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "HasSubset.Subset",
   "Add",
   "Set.image2_subset_left"],
  "name": "Set.add_subset_add_left",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t₁ t₂ : Set α}, t₁ ⊆ t₂ → s + t₁ ⊆ s + t₂",
  "constCategory": "Theorem"},
 {"references":
  ["HeytingAlgebra",
   "Pi.booleanAlgebra.proof_1",
   "Pi.booleanAlgebra.proof_7",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra.proof_2",
   "BooleanAlgebra.mk",
   "BooleanAlgebra",
   "Preorder.toLE",
   "OrderTop.toTop",
   "BooleanAlgebra.toBiheytingAlgebra",
   "DistribLattice",
   "SDiff.mk",
   "Pi.booleanAlgebra.proof_5",
   "GeneralizedHeytingAlgebra.toLattice",
   "Pi.sdiff",
   "Lattice.toSemilatticeSup",
   "HeytingAlgebra.toHasCompl",
   "BooleanAlgebra.toDistribLattice",
   "SDiff",
   "SemilatticeSup.toPartialOrder",
   "Pi.booleanAlgebra.proof_3",
   "GeneralizedHeytingAlgebra.toHImp",
   "DistribLattice.mk",
   "SDiff.sdiff",
   "HeytingAlgebra.toOrderBot",
   "Pi.distribLattice",
   "BiheytingAlgebra.toHeytingAlgebra",
   "Pi.heytingAlgebra",
   "HeytingAlgebra.toGeneralizedHeytingAlgebra",
   "Pi.booleanAlgebra.proof_6",
   "OrderBot.toBot",
   "GeneralizedHeytingAlgebra.toOrderTop",
   "BooleanAlgebra.toSDiff",
   "Pi.booleanAlgebra.proof_4"],
  "name": "Pi.booleanAlgebra",
  "constType":
  "{ι : Type u} → {α : ι → Type v} → [inst : (i : ι) → BooleanAlgebra (α i)] → BooleanAlgebra ((i : ι) → α i)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHMul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "Monoid.one_mul",
  "constType": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Subtype.property",
   "Membership.mem",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "AddSubmonoid.add_mem",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.instMembership",
   "Subtype"],
  "name": "AddSubmonoid.add.proof_1",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) (a b : ↥S), ↑a + ↑b ∈ S",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["And.right",
   "Function.Bijective",
   "Function.Surjective",
   "Function.Injective"],
  "name": "Function.Bijective.surjective",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → Function.Surjective f",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "setOf",
   "Set",
   "Inter.inter",
   "And.intro",
   "And.casesOn",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Filter.mp_mem.match_1",
  "constType":
  "∀ {α : Type u_1} {s t : Set α} (x : α) (motive : x ∈ s ∩ {x | x ∈ s → x ∈ t} → Prop)\n  (x_1 : x ∈ s ∩ {x | x ∈ s → x ∈ t}),\n  (∀ (h₁ : x ∈ s) (h₂ : x ∈ {x | x ∈ s → x ∈ t}), motive (_ : x ∈ s ∧ x ∈ {x | x ∈ s → x ∈ t})) → motive x_1",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "Mathlib.Algebra.Invertible.Defs._auxLemma.2",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.preimage.proof_1",
   "Set.preimage",
   "Finset.toSet",
   "Finset",
   "Set.InjOn",
   "Set.Finite.toFinset"],
  "name": "Finset.preimage",
  "constType":
  "{α : Type u} → {β : Type v} → (s : Finset β) → (f : α → β) → Set.InjOn f (f ⁻¹' ↑s) → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "False",
   "Eq.rec",
   "LT.lt",
   "Nat.lt_irrefl",
   "Nat",
   "Eq.symm",
   "absurd",
   "instLTNat",
   "Eq"],
  "name": "Nat.ne_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a ≠ b",
  "constCategory": "Theorem"},
 {"references": ["CommMonoid", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toCommMonoid",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → CommMonoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Zero.toOfNat0",
   "Left.neg_neg_iff",
   "AddGroup",
   "Iff",
   "LT.lt",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "neg_neg_iff_pos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, -a < 0 ↔ 0 < a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "OfNat.ofNat",
   "AddGroup",
   "propext",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "PFR.Main._auxLemma.1",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "SubNegMonoid.toNeg",
   "sum_range_diag_flip",
   "div_zero",
   "IsAbsoluteValue.abv_neg",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "Nat.ble",
   "CauSeq.bounded",
   "SemilatticeSup.toSup",
   "Nat.addMonoid",
   "Nat.lt_succ_self",
   "LinearOrderedField.toLinearOrderedSemifield",
   "le_of_lt",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Nat.strictOrderedSemiring",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "GCongr.sum_le_sum",
   "instDistribLattice",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AddCommMagma.toAdd",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.orderedSemiring",
   "instNatAtLeastTwo",
   "MonoidWithZero.toZero",
   "congrFun",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "two_mul",
   "GE.ge",
   "Eq.refl",
   "zero_sub",
   "abv_sum_le_sum_abv",
   "IsAbsoluteValue.abv_add",
   "cauchy_product.match_1",
   "IsCancelAdd.toIsRightCancelAdd",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Lattice.toSemilatticeSup",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "mul_add",
   "lt_add_one",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "add_sub_cancel'_right",
   "Neg.neg",
   "Nat.addCommSemigroup",
   "GroupWithZero.toMonoidWithZero",
   "Monoid.toMulOneClass",
   "LE.le",
   "GroupWithZero.toDiv",
   "Distrib.leftDistribClass",
   "Mathlib.Meta.NormNum.isNat_mul",
   "sub_add_cancel",
   "Eq.ndrec",
   "letFun",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "NegZeroClass.toNeg",
   "Subtype.mk",
   "MulOneClass.toMul",
   "OrderedCommRing.toCommRing",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "StrictOrderedCommRing.toOrderedCommRing",
   "CanonicallyOrderedCommSemiring.toOne",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "cauchy_product.match_4",
   "le_trans",
   "Eq.trans",
   "Finset.sum_range_sub_sum_range",
   "StrictOrderedRing.toPartialOrder",
   "Finset.instMembershipFinset",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "lt_add_of_pos_left",
   "SemigroupWithZero.toSemigroup",
   "Nat.instTransNatLeInstLENatLtInstLTNat",
   "Std.Classes.Order._auxLemma.4",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "Field.toEuclideanDomain",
   "LinearOrder.toMax",
   "Eq.mp",
   "CommRing.toRing",
   "mul_pos",
   "le_max_right",
   "instTransLeToLELtToLT",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "StrictOrderedRing.toRing",
   "LinearOrderedSemifield.toSemifield",
   "LinearOrderedRing.toStrictOrderedRing",
   "instSubNat",
   "CommRing.toNonUnitalCommRing",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "ne_of_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "LinearOrderedField.toDiv",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Finset.mul_sum",
   "div_mul_cancel",
   "AddMonoid.toZero",
   "CauSeq.cauchy₂",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "AddCommGroup.toAddGroup",
   "instOfNatNat",
   "id",
   "eq_self",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instAddNat",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Field.isDomain",
   "StrictOrderedSemiring.to_charZero",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "mul_lt_mul_of_pos_right",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Bool",
   "instMulNat",
   "OrderedSemiring.toPartialOrder",
   "Distrib.toAdd",
   "two_ne_zero",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "AddCommSemigroup.toAddCommMagma",
   "sub_self",
   "AddCommGroup.toAddCommMonoid",
   "Semifield.toCommGroupWithZero",
   "Nat.cast_zero",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "SubNegMonoid.toSub",
   "mul_assoc",
   "IsDomain.to_noZeroDivisors",
   "Finset.range",
   "IsAbsoluteValue.abv_nonneg",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "mul_lt_mul_of_pos_left",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Nat.instTransNatLtInstLTNat",
   "CommMagma.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "le_abs_self",
   "MonoidWithZero.toMulZeroOneClass",
   "Nat.le_succ_of_le",
   "eq_true",
   "Nat.zero",
   "LT.lt",
   "instTransEq",
   "OrderedSemiring.toPosMulMono",
   "Exists",
   "cauchy_product.match_2",
   "Subtype.val",
   "IsCauSeq",
   "sub_right_comm",
   "Semiring.toMonoidWithZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "True",
   "Abs.abs",
   "AddMonoidWithOne.toNatCast",
   "Finset",
   "Finset.filter",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "Nat.succ",
   "CharZero.NeZero.two",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Neg.toHasAbs",
   "Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Finset.sum",
   "lt_of_lt_of_le",
   "mul_ne_zero",
   "div_div",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "Nat.instMaxNat",
   "DivInvMonoid.toMonoid",
   "Finset.mem_range",
   "Mathlib.Meta.NormNum.isNat_eq_true",
   "le_max_left",
   "Bool.false",
   "Ring.toAddCommGroup",
   "Mathlib.Meta.Positivity.pos_of_isNat",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Add",
   "sub_sub",
   "add_halves",
   "add_le_add",
   "sub_eq_add_neg",
   "MulZeroClass.mul_zero",
   "instLTNat",
   "abs_of_nonneg",
   "Preorder.toLE",
   "Eq",
   "Nat.linearOrder",
   "IsAbsoluteValue",
   "cauchy_product.match_3",
   "Finset.sum_add_distrib",
   "IsAbsoluteValue.abv_mul",
   "Eq.mpr",
   "Ring.toNeg",
   "DivisionCommMonoid.toDivisionMonoid",
   "Ring",
   "Nat",
   "Mul",
   "Finset.sum_congr",
   "Ne",
   "DivisionSemiring.toGroupWithZero",
   "Finset.sum_mul",
   "OrderedSemiring.zeroLEOneClass",
   "LeftDistribClass",
   "Nat.canonicallyOrderedCommSemiring",
   "EuclideanDomain.toCommRing",
   "DistribLattice.toLattice",
   "Mathlib.Order.Basic._auxLemma.2",
   "instHMul",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "AddCancelMonoid.toIsCancelAdd",
   "mul_le_mul_of_nonneg_left",
   "div_pos",
   "congrArg",
   "OrderedAddCommGroup.toAddCommGroup",
   "abs_nonneg",
   "add_lt_add",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "LinearOrderedCommRing.toStrictOrderedCommRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing",
   "mul_comm",
   "Zero.toOfNat0",
   "instLENat",
   "Preorder.toLT",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "Eq.symm",
   "Nat.decLe",
   "Nat.succ_pos",
   "NeZero.succ",
   "funext",
   "instHAdd",
   "lt_of_le_of_lt",
   "HSub.hSub",
   "le_tsub_of_add_le_left",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "Finset.sum_nonneg",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "LinearOrderedField.toField",
   "SubtractionMonoid.toSubNegMonoid",
   "OrderedSemiring.toSemiring",
   "Max.max",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NegZeroClass.toZero",
   "Nat.semiring"],
  "name": "cauchy_product",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] {abv : β → α} [inst_1 : Ring β]\n  [inst_2 : IsAbsoluteValue abv] {a b : ℕ → β},\n  (IsCauSeq abs fun m => Finset.sum (Finset.range m) fun n => abv (a n)) →\n    (IsCauSeq abv fun m => Finset.sum (Finset.range m) fun n => b n) →\n      ∀ (ε : α),\n        0 < ε →\n          ∃ i,\n            ∀ j ≥ i,\n              abv\n                  (((Finset.sum (Finset.range j) fun k => a k) * Finset.sum (Finset.range j) fun k => b k) -\n                    Finset.sum (Finset.range j) fun n => Finset.sum (Finset.range (n + 1)) fun m => a m * b (n - m)) <\n                ε",
  "constCategory": "Theorem"},
 {"references":
  ["CanLift",
   "Finset.toSet",
   "Set",
   "Set.Finite.exists_finset_coe",
   "Finset",
   "CanLift.mk",
   "Set.Finite"],
  "name": "Set.instCanLiftSetFinsetToSetFinite",
  "constType":
  "∀ {α : Type u}, CanLift (Set α) (Finset α) Finset.toSet Set.Finite",
  "constCategory": "Definition"},
 {"references":
  ["_auto._@.Mathlib.Init.Order.Defs._hyg.2934",
   "Min.min",
   "Ordering",
   "Or",
   "PartialOrder.toPreorder",
   "Min",
   "Max",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.2973",
   "autoParam",
   "LE.le",
   "Preorder.toLE",
   "Ord",
   "Eq",
   "ite",
   "Ord.compare",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "Max.max",
   "LinearOrderedSemiring",
   "_auto._@.Mathlib.Init.Order.Defs._hyg.3012",
   "compareOfLessAndEq",
   "DecidableRel"],
  "name": "LinearOrderedSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toStrictOrderedSemiring : StrictOrderedSemiring α] →\n    [toMin : Min α] →\n      [toMax : Max α] →\n        [toOrd : Ord α] →\n          (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n            (decidableLE : DecidableRel fun x x_1 => x ≤ x_1) →\n              (decidableEq : DecidableEq α) →\n                (decidableLT : DecidableRel fun x x_1 => x < x_1) →\n                  autoParam (∀ (a b : α), min a b = if a ≤ b then a else b) _auto✝ →\n                    autoParam (∀ (a b : α), max a b = if a ≤ b then b else a) _auto✝¹ →\n                      autoParam (∀ (a b : α), compare a b = compareOfLessAndEq a b) _auto✝² → LinearOrderedSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Set.mem_inter_iff",
   "Membership.mem",
   "And",
   "propext",
   "Set",
   "Inter.inter",
   "Eq",
   "Set.instInterSet",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.25",
  "constType":
  "∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∩ b) = (x ∈ a ∧ x ∈ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHSub",
   "Real.instMulReal",
   "Real",
   "Real.instLEReal",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "Eq",
   "Dist.dist",
   "SeminormedRing",
   "Norm",
   "instHMul",
   "PseudoMetricSpace.toDist",
   "Ring",
   "Ring.toSub",
   "HMul.hMul",
   "Norm.norm",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "PseudoMetricSpace"],
  "name": "SeminormedRing.mk",
  "constType":
  "{α : Type u_5} →\n  [toNorm : Norm α] →\n    [toRing : Ring α] →\n      [toPseudoMetricSpace : PseudoMetricSpace α] →\n        (∀ (x y : α), dist x y = ‖x - y‖) → (∀ (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖) → SeminormedRing α",
  "constCategory": "Other"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.zero_add",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Real.natCast",
   "HAdd.hAdd",
   "Real",
   "Real.instAddReal",
   "Real.instAddMonoidReal",
   "AddMonoid.toAddZeroClass",
   "NatCast.mk",
   "True",
   "Real.instOneReal",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "Complex.ext",
   "Nat",
   "AddMonoidWithOne.natCast_succ",
   "Eq.trans",
   "Complex.instOneComplex",
   "eq_self",
   "Complex.addCommGroup",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.mk",
   "One.toOfNat1",
   "Real.instRingReal",
   "AddGroup.toSubNegMonoid",
   "NatCast.natCast",
   "Complex.re",
   "Complex.im",
   "Real.instZeroReal",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Complex.mk",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "Complex",
   "add_zero",
   "congrArg",
   "congrFun"],
  "name": "Complex.Complex.addGroupWithOne.proof_2",
  "constType": "∀ (x : ℕ), NatCast.natCast (x + 1) = NatCast.natCast x + 1",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq",
   "LinearOrderedAddCommGroup.max_def",
   "LinearOrderedAddCommGroup.decidableLT",
   "LinearOrder",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "LinearOrderedAddCommGroup.toMin",
   "LinearOrder.mk",
   "LinearOrderedAddCommGroup.min_def",
   "LinearOrderedAddCommGroup.le_total",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LinearOrderedAddCommGroup.decidableEq",
   "LinearOrderedAddCommGroup.toOrd"],
  "name": "LinearOrderedAddCommGroup.toLinearOrder",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.card",
   "AddZeroClass.toAdd",
   "Membership.mem",
   "AddHomClass.toFunLike",
   "List.isSetoid",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "List.length_pmap",
   "Quot.inductionOn",
   "Multiset.instMembershipMultiset",
   "Eq",
   "Setoid.r",
   "Nat.addMonoid",
   "List",
   "Multiset",
   "Multiset.pmap",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHom.addMonoidHomClass",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
   "AddMonoidHom",
   "Quot.mk",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.card_pmap",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {p : α → Prop} (f : (a : α) → p a → β) (s : Multiset α) (H : ∀ a ∈ s, p a),\n  Multiset.card (Multiset.pmap f s H) = Multiset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.nodup_range", "Multiset.range", "Finset", "Finset.mk", "Nat"],
  "name": "Finset.range",
  "constType": "ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references":
  ["BiheytingAlgebra",
   "OrderTop.mk",
   "BooleanAlgebra.le_top",
   "BooleanAlgebra.toBiheytingAlgebra.proof_2",
   "PartialOrder.toPreorder",
   "HasCompl.compl",
   "BooleanAlgebra.toHasCompl",
   "BooleanAlgebra.toGeneralizedBooleanAlgebra",
   "BooleanAlgebra.toBiheytingAlgebra.proof_1",
   "GeneralizedCoheytingAlgebra.sdiff_le_iff",
   "BooleanAlgebra",
   "Preorder.toLE",
   "HNot.mk",
   "DistribLattice.toLattice",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "BooleanAlgebra.toHImp",
   "GeneralizedCoheytingAlgebra",
   "BiheytingAlgebra.mk",
   "HeytingAlgebra.mk",
   "BooleanAlgebra.toSDiff",
   "GeneralizedCoheytingAlgebra.toOrderBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.toBiheytingAlgebra.proof_3",
   "SemilatticeSup.toPartialOrder",
   "BooleanAlgebra.toTop",
   "GeneralizedHeytingAlgebra.mk"],
  "name": "BooleanAlgebra.toBiheytingAlgebra",
  "constType": "{α : Type u} → [inst : BooleanAlgebra α] → BiheytingAlgebra α",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE",
   "Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup",
   "Quotient.mk''",
   "AddSubgroup",
   "HasQuotient.Quotient",
   "QuotientAddGroup.leftRel",
   "QuotientAddGroup.instHasQuotientAddSubgroup"],
  "name": "QuotientAddGroup.mk",
  "constType":
  "{α : Type u_1} → [inst : AddGroup α] → {s : AddSubgroup α} → α → α ⧸ s",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "Mathlib.Meta.NormNum.IsRat.casesOn",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Nat.cast_commute",
   "Int.cast_add",
   "Invertible",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Ring",
   "Commute.invOf_right",
   "Int.cast_mul",
   "invertibleMul",
   "Nat",
   "Int.add",
   "Eq.trans",
   "Mathlib.Meta.NormNum.invertibleOfMul'",
   "Invertible.invOf",
   "congr_arg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Commute.right_comm",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.instAddInt",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Eq.mp",
   "congr",
   "congrArg",
   "Int",
   "congrFun",
   "Commute.invOf_left",
   "AddGroupWithOne.toIntCast",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "mul_mul_invOf_self_cancel'",
   "True",
   "Ring.toNonAssocRing",
   "add_mul",
   "Nat.cast_mul",
   "mul_mul_invOf_self_cancel",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Eq.symm",
   "id",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "Int.instMulInt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.NormNum.Basic._auxLemma.1",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "Mathlib.Meta.NormNum.IsRat",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "Int.mul",
   "Eq.ndrec",
   "instNatCastInt",
   "letFun",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "NonUnitalSemiring.toSemigroupWithZero",
   "instMulNat",
   "Nat.mul"],
  "name": "Mathlib.Meta.NormNum.isRat_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {na nb nc : ℤ} {da db dc k : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsRat a na da →\n      Mathlib.Meta.NormNum.IsRat b nb db →\n        Int.add (Int.mul na ↑db) (Int.mul nb ↑da) = Int.mul (↑k) nc →\n          Nat.mul da db = Nat.mul k dc → Mathlib.Meta.NormNum.IsRat (f a b) nc dc",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Filter.univ_sets",
   "Set",
   "Filter",
   "Set.univ",
   "instMembershipSetFilter"],
  "name": "Filter.univ_mem",
  "constType": "∀ {α : Type u} {f : Filter α}, Set.univ ∈ f",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.5",
   "AddGroup.toSubtractionMonoid",
   "sub_pos",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Iff.mpr",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "StrictOrderedRing",
   "AddGroup.toAddCancelMonoid",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "StrictOrderedRing.toPartialOrder",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "sub_mul",
   "HSub.hSub",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring.proof_3",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] (a b c : α), a < b → 0 < c → a * c < b * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Dist",
  "constType": "Type u_3 → Type u_3",
  "constCategory": "Other"},
 {"references":
  ["Set.instSProd",
   "Set.image2",
   "Prod.snd",
   "Set",
   "Finite",
   "Eq.refl",
   "Prod.fst",
   "Finite.Set.finite_image",
   "Eq",
   "inferInstance",
   "Eq.mpr",
   "Set.image_prod",
   "Eq.ndrec",
   "Set.Elem",
   "SProd.sprod",
   "Prod",
   "Set.image",
   "Eq.symm",
   "Finite.Set.finite_prod",
   "id"],
  "name": "Finite.Set.finite_image2",
  "constType":
  "∀ {α : Type u} {β : Type v} {γ : Type x} (f : α → β → γ) (s : Set α) (t : Set β) [inst : Finite ↑s] [inst : Finite ↑t],\n  Finite ↑(Set.image2 f s t)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "NatCast.natCast",
   "Eq"],
  "name": "AddMonoidWithOne.natCast_zero",
  "constType":
  "∀ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_pos'",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "instLTNat",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Nat",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_pos",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, 0 < ↑n ↔ 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "PartialOrder.toPreorder",
   "AbsoluteValue.add_le'",
   "instHAdd",
   "Semiring",
   "AbsoluteValue",
   "HAdd.hAdd",
   "FunLike.coe",
   "LE.le",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "AbsoluteValue.subadditiveHomClass",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.add_le",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) (x y : R),\n  abv (x + y) ≤ abv x + abv y",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Preorder.toLT", "LT.lt", "Ne.symm", "Preorder", "LT.lt.ne"],
  "name": "LT.lt.ne'",
  "constType": "∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddRightCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Submonoid.mk",
   "Subgroup.mk",
   "Inf.mk",
   "Subgroup.instInfSubgroup.proof_2",
   "Inf",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Submonoid.instInfSubmonoid",
   "Inf.inf",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "Subgroup.instInfSubgroup.proof_1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.instInfSubgroup",
  "constType": "{G : Type u_1} → [inst : Group G] → Inf (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "Function.swap",
   "PartialOrder.toPreorder",
   "covariant_swap_add_of_covariant_add",
   "instHAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoid.toAddCommSemigroup",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassRight",
  "constType":
  "∀ (M : Type u_3) [inst : OrderedAddCommMonoid M],\n  CovariantClass M M (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "eq_true",
   "LT.lt",
   "instOfNatNat",
   "Nat.zero_lt_succ",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "True",
   "Eq"],
  "name": "Std.Data.Nat.Lemmas._auxLemma.6",
  "constType": "∀ (n : ℕ), (0 < Nat.succ n) = True",
  "constCategory": "Theorem"},
 {"references": ["Semigroup.toMul", "instHMul", "HMul.hMul", "Semigroup", "Eq"],
  "name": "Semigroup.mul_assoc",
  "constType":
  "∀ {G : Type u} [self : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Group"],
  "name": "Group.toDivInvMonoid",
  "constType": "{G : Type u} → [self : Group G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "One",
   "ZeroLEOneClass.zero_le_one",
   "LE",
   "One.toOfNat1",
   "LE.le"],
  "name": "zero_le_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "PartialOrder.toPreorder",
   "SemilatticeInf.toInf",
   "propext",
   "Inf.inf",
   "SemilatticeInf.toPartialOrder",
   "le_inf_iff",
   "LE.le",
   "Preorder.toLE",
   "SemilatticeInf",
   "Eq"],
  "name": "Mathlib.Order.Lattice._auxLemma.13",
  "constType":
  "∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, (a ≤ b ⊓ c) = (a ≤ b ∧ a ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "Semiring",
   "AbsoluteValue",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "OrderedSemiring",
   "MulHom",
   "Zero.toOfNat0",
   "MulHom.toFun",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.mk",
  "constType":
  "{R : Type u_1} →\n  {S : Type u_2} →\n    [inst : Semiring R] →\n      [inst_1 : OrderedSemiring S] →\n        (toMulHom : R →ₙ* S) →\n          (∀ (x : R), 0 ≤ MulHom.toFun toMulHom x) →\n            (∀ (x : R), MulHom.toFun toMulHom x = 0 ↔ x = 0) →\n              (∀ (x y : R), MulHom.toFun toMulHom (x + y) ≤ MulHom.toFun toMulHom x + MulHom.toFun toMulHom y) →\n                AbsoluteValue R S",
  "constCategory": "Other"},
 {"references": ["Exists", "Classical.choose"],
  "name": "Exists.choose",
  "constType": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Nat.linearOrder",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "instOfNatNat",
   "Nat",
   "CharZero.mk",
   "Nat.succ",
   "id",
   "IsCancelAdd.toIsLeftCancelAdd",
   "lt_add_one",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "Eq.ndrec",
   "CharZero",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "strictMono_nat_of_lt_succ",
   "StrictMono.injective"],
  "name": "StrictOrderedSemiring.to_charZero",
  "constType": "∀ {α : Type u_1} [inst : StrictOrderedSemiring α], CharZero α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Quot.liftOn",
   "Setoid.r",
   "List.instMembershipList",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.Mem.proof_1"],
  "name": "Multiset.Mem",
  "constType": "{α : Type u_1} → α → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references": ["Nat.zero", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.add.match_1",
  "constType":
  "(motive : ℕ → ℕ → Sort u_1) →\n  (x x_1 : ℕ) → ((a : ℕ) → motive a Nat.zero) → ((a : ℕ) → (b : ℕ) → motive a (Nat.succ b)) → motive x x_1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Eq.refl",
   "CharZero.cast_injective",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Eq.mpr",
   "Eq.ndrec",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "map_natCast",
   "Eq.symm",
   "CharZero.mk",
   "id"],
  "name": "RingHom.charZero",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S],\n  (R →+* S) → ∀ [hS : CharZero S], CharZero R",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.Mathlib.Data.Int.Cast.Defs._hyg.70",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Complex.log_one",
   "Complex.instNormedFieldComplex",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "dite",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Eq.mpr",
   "Complex.instPowComplex",
   "instHPow",
   "MulZeroClass.toZero",
   "NeZero.charZero_one",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "eq_self",
   "HPow.hPow",
   "Complex.instZeroComplex",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "False",
   "Complex.charZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "Complex.exp_zero",
   "NormedField.toNormedCommRing",
   "Complex.cpow_def",
   "NormedCommRing.toSeminormedCommRing",
   "instHMul",
   "if_pos",
   "Eq.ndrec",
   "False.elim",
   "of_eq_true",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "Eq.mp",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Not",
   "Complex",
   "Complex.log",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.one_cpow",
  "constType": "∀ (x : ℂ), 1 ^ x = 1",
  "constCategory": "Theorem"},
 {"references": ["Add", "MeasurableSpace"],
  "name": "MeasurableAdd₂",
  "constType":
  "(M : Type u_2) → [inst : MeasurableSpace M] → [inst : Add M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "OrderedSemiring.toSemiring",
   "Nat",
   "Nat.cast_nonneg'",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Nat.cast_nonneg",
  "constType": "∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), 0 ≤ ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Exists",
   "Function.comp",
   "FunLike.coe",
   "Exists.casesOn",
   "Countable.exists_injective_nat",
   "instCountableNat",
   "Equiv.instFunLikeEquiv",
   "Countable",
   "Function.Injective.countable",
   "Function.Injective.Prod_map",
   "Function.Injective",
   "Nat.pairEquiv",
   "Prod.map",
   "Function.Injective.comp",
   "Equiv.injective",
   "Prod",
   "Nat"],
  "name": "instCountableProd",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Countable α] [inst : Countable β], Countable (α × β)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "DivisionMonoid.inv_inv",
  "constType": "∀ {G : Type u} [self : DivisionMonoid G] (x : G), x⁻¹⁻¹ = x",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.le_of_lt_succ",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Preorder.toLE",
   "Eq",
   "Nat.linearOrder",
   "Nat.factorial",
   "AddZeroClass.toZero",
   "PProd",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.addMonoid",
   "Nat.mul_le_mul_right",
   "Nat.choose",
   "PUnit",
   "Std.Classes.Order._auxLemma.3",
   "Nat",
   "lt_or_eq_of_le",
   "Eq.trans",
   "mul_left_comm",
   "OrderedAddCommMonoid.toPartialOrder",
   "Nat.choose_succ_succ",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "add_assoc",
   "add_comm",
   "Nat.brecOn",
   "Or",
   "add_tsub_assoc_of_le",
   "Mathlib.Order.Basic._auxLemma.1",
   "Nat.canonicallyOrderedCommSemiring",
   "Or.casesOn",
   "AddCommMagma.toAdd",
   "CommMagma.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "Nat.rec",
   "PProd.fst",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Nat.orderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "tsub_zero",
   "LT.lt",
   "congr",
   "mul_one",
   "add_zero",
   "tsub_mul",
   "congrArg",
   "Nat.commSemigroup",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "congrFun",
   "AddZeroClass.toAdd",
   "Nat.addCommMonoid",
   "tsub_eq_zero_of_le",
   "CanonicallyOrderedCommSemiring.toMul",
   "Nat.succ_sub",
   "instSubNat",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Nat.addSemigroup",
   "GE.ge",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Nat.choose_zero_right",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "mul_comm",
   "Zero.toOfNat0",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Nat.succ_sub_succ",
   "Nat.semigroup",
   "instLENat",
   "one_mul",
   "Nat.le_of_succ_le_succ",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "Nat.distrib",
   "instOfNatNat",
   "CanonicallyOrderedAddCommMonoid.existsAddOfLE",
   "Nat.factorial_succ",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.isTotal",
   "Eq.symm",
   "Nat.succ",
   "id",
   "Nat.instOrderedSubNatInstLENatInstAddNatInstSubNat",
   "eq_self",
   "add_tsub_cancel_left",
   "Nat.below",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Nat.choose_succ_self",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "HSub.hSub",
   "Nat.addCommSemigroup",
   "LE.le",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Nat.choose_self",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "CommSemigroup.toCommMagma",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Nat.eq_zero_of_le_zero",
   "Nat.choose_mul_factorial_mul_factorial.match_1",
   "letFun",
   "HMul.hMul",
   "instMulNat",
   "Nat.semiring"],
  "name": "Nat.choose_mul_factorial_mul_factorial",
  "constType":
  "∀ {n k : ℕ}, k ≤ n → Nat.choose n k * Nat.factorial k * Nat.factorial (n - k) = Nat.factorial n",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT", "LT.lt", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "lt_of_le_of_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (motive : (x x_1 x_2 : α) → x ≤ x_1 → x_1 < x_2 → Prop) (x x_1 x_2 : α)\n  (x_3 : x ≤ x_1) (x_4 : x_1 < x_2),\n  (∀ (_a _b _c : α) (hab : _a ≤ _b) (hbc : _b < _c), motive _a _b _c hab hbc) → motive x x_1 x_2 x_3 x_4",
  "constCategory": "Definition"},
 {"references": ["instHMul", "CommMagma", "HMul.hMul", "Mul", "Eq"],
  "name": "CommMagma.mk",
  "constType":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b : G), a * b = b * a) → CommMagma G",
  "constCategory": "Other"},
 {"references":
  ["lt_or_le",
   "Or",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "Or.symm",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE"],
  "name": "le_or_lt",
  "constType": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "And.right",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddGroup",
   "Set",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "AddSubmonoid",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (_a _b : AddSubgroup G) (_x : G),\n  _x ∈ ↑_a.toAddSubmonoid ∧ _x ∈ ↑_b.toAddSubmonoid → _x ∈ ↑_b.toAddSubmonoid",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MeasureTheory.ProbabilityMeasure",
   "Real.instLEReal",
   "NormedLatticeAddCommGroup.orderClosedTopology",
   "IsMinOn",
   "CompleteLattice.toBot",
   "MeasureTheory.IsProbabilityMeasure",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "trivial",
   "MeasurableSingletonClass",
   "inferInstance",
   "Real.linearOrder",
   "Fintype",
   "Continuous",
   "isMinOn_univ_iff",
   "instClosedIicTopology",
   "And.casesOn",
   "Continuous.continuousOn",
   "Finite.to_countable",
   "MeasureTheory.ProbabilityMeasure.toMeasure",
   "Prod.snd",
   "instTopologicalSpaceProd",
   "Lattice.toSemilatticeInf",
   "instDistribLattice",
   "PseudoMetricSpace.toUniformSpace",
   "Prod.fst",
   "isCompact_univ",
   "Inhabited.default",
   "Set.instMembershipSet",
   "DistribLattice.toLattice",
   "And",
   "DiscreteTopology",
   "propext",
   "Eq.mp",
   "And.intro",
   "AddCommGroup",
   "Real.normedLatticeAddCommGroup",
   "MeasurableSpace",
   "Finite.of_fintype",
   "continuous_tau_restrict_probabilityMeasure",
   "Subtype.prop",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "instInhabitedProd",
   "CompactSpace",
   "Real",
   "Set",
   "Eq.refl",
   "Exists.intro",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "rfl",
   "MeasureTheory.MeasureSpace.volume",
   "BorelSpace.opensMeasurable",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "MeasurableSingletonClass.toDiscreteMeasurableSpace",
   "TopologicalSpace",
   "tau",
   "UniformSpace.toTopologicalSpace",
   "DiscreteTopology.mk",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "tau_min_exists_measure.match_1",
   "Membership.mem",
   "Bot.bot",
   "refPackage",
   "instCompactSpaceProbabilityMeasureInstTopologicalSpaceProbabilityMeasure",
   "Real.pseudoMetricSpace",
   "SemilatticeInf.toPartialOrder",
   "instCompactSpaceProdInstTopologicalSpaceProd",
   "SubNegZeroMonoid.toNegZeroClass",
   "Inhabited.mk",
   "Set.univ",
   "LE.le",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "TopologicalSpace.instCompleteLatticeTopologicalSpace",
   "DiscreteMeasurableSpace.toBorelSpace",
   "Eq.ndrec",
   "MeasureTheory.ProbabilityMeasure.instTopologicalSpaceProbabilityMeasure",
   "Prod.mk",
   "MeasureTheory.MeasureSpace",
   "letFun",
   "Prod",
   "NegZeroClass.toZero",
   "MeasureTheory.ProbabilityMeasure.instInhabitedProbabilityMeasure",
   "Subtype.mk",
   "IsCompact.exists_isMinOn"],
  "name": "tau_min_exists_measure",
  "constType":
  "∀ {Ω₀₁ : Type u_1} {Ω₀₂ : Type u_2} [inst : MeasureTheory.MeasureSpace Ω₀₁] [inst_1 : MeasureTheory.MeasureSpace Ω₀₂]\n  [inst_2 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume]\n  [inst_3 : MeasureTheory.IsProbabilityMeasure MeasureTheory.volume] {G : Type uG} [inst_4 : AddCommGroup G]\n  [inst_5 : Fintype G] [inst_6 : MeasurableSpace G] (p : refPackage Ω₀₁ Ω₀₂ G) [inst_7 : MeasurableSingletonClass G],\n  ∃ μ,\n    MeasureTheory.IsProbabilityMeasure μ.1 ∧\n      MeasureTheory.IsProbabilityMeasure μ.2 ∧\n        ∀ (ν₁ ν₂ : MeasureTheory.Measure G),\n          MeasureTheory.IsProbabilityMeasure ν₁ →\n            MeasureTheory.IsProbabilityMeasure ν₂ → τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.liftOn",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "CauSeq.Completion.instInvCauchyToRing.proof_1",
   "Classical.propDecidable",
   "CauSeq.LimZero",
   "CauSeq.instZeroCauSeq",
   "dite",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Inv",
   "Inv.mk",
   "Zero.toOfNat0",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "CauSeq.inv",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "Not",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instInvCauchyToRing",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : DivisionRing β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Inv (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Set",
   "Submonoid",
   "And.left",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Submonoid.instCompleteLatticeSubmonoid.proof_9",
  "constType":
  "∀ {M : Type u_1} [inst : MulOneClass M] (x x_1 : Submonoid M) (x_2 : M), x_2 ∈ ↑x ∧ x_2 ∈ ↑x_1 → x_2 ∈ ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.ble",
   "Iff.mp",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "Bool",
   "Nat",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → Nat.ble b' a' = false → a < b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "DistribLattice",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "LinearOrderedRing.decidableLE",
   "LinearOrder",
   "LinearOrderedRing.toOrd",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedRing",
   "LinearOrder.mk",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.min_def",
   "LinearOrderedRing.le_total",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.compare_eq_compareOfLessAndEq",
   "LinearOrderedRing.max_def",
   "LinearOrderedRing.decidableLT"],
  "name": "LinearOrderedRing.toLinearOrder",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "And",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "propext",
   "instDistribLattice",
   "LinearOrder.toMax",
   "Max.max",
   "SemilatticeInf.toPartialOrder",
   "max_le_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Order.MinMax._auxLemma.4",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, (max a b ≤ c) = (a ≤ c ∧ b ≤ c)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Not",
   "And.intro",
   "Preorder",
   "And.casesOn",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] (_a _b : α) (motive : _a ≤ _b ∧ ¬_b ≤ _a → Prop) (x : _a ≤ _b ∧ ¬_b ≤ _a),\n  (∀ (hab : _a ≤ _b) (hba : ¬_b ≤ _a), motive (_ : _a ≤ _b ∧ ¬_b ≤ _a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["NormedField", "SeminormedAddCommGroup"],
  "name": "NormedSpace",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [inst : NormedField α] → [inst : SeminormedAddCommGroup β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["OrderedCancelAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedAddCommMonoid.mk",
   "OrderedCancelAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "StrictOrderedSemiring.add_le_add_left",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.le_of_add_le_add_left"],
  "name": "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → OrderedCancelAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references": ["Function.LeftInverse"],
  "name": "Function.RightInverse",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CauSeq.instIntCast",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "IntCast.mk",
   "Int.cast",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq.Completion.mk",
   "Int",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "IntCast"],
  "name": "CauSeq.Completion.instIntCastCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → IntCast (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Real",
   "Real.definition._@.Mathlib.Data.Real.Basic._hyg.1157",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.1157",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "Real.instLEReal",
   "ENNReal.ofReal",
   "ProbabilityTheory.entropy",
   "MeasureTheory.IsProbabilityMeasure",
   "CanonicallyOrderedCommSemiring.toOne",
   "Exists.casesOn",
   "Nonempty",
   "Preorder.toLE",
   "Eq",
   "MeasurableSingletonClass",
   "ENNReal",
   "Semiring.toNonAssocSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "FiniteRange",
   "MeasureTheory.measure_ne_top",
   "CompletelyDistribLattice.toCompleteLattice",
   "MulOneClass.toOne",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "MeasureTheory.Measure.real",
   "MeasurableSet.singleton",
   "instHMul",
   "MeasureTheory.Measure.toOuterMeasure",
   "_private.PFR.ForMathlib.Entropy.Basic.0.MeasureTheory.Measure.real._eq_1",
   "propext",
   "Eq.mp",
   "Singleton.singleton",
   "ENNReal.toReal",
   "MeasurableSpace",
   "ProbabilityTheory.prob_ge_exp_neg_entropy",
   "Exists",
   "CanonicallyOrderedCommSemiring.toMul",
   "MeasureTheory.map_measureReal_apply",
   "MeasureTheory.IsProbabilityMeasure.toIsFiniteMeasure",
   "Real",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "GE.ge",
   "Eq.refl",
   "ge_iff_le",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "rfl",
   "Real.instNegReal",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Set.instSingletonSet",
   "one_mul",
   "Measurable",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Eq.symm",
   "Set.preimage",
   "Real.toNNReal",
   "Neg.neg",
   "One.toOfNat1",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "Real.exp",
   "LE.le",
   "MeasureTheory.IsProbabilityMeasure.measure_univ",
   "ENNReal.instCompleteLinearOrderENNReal",
   "Eq.ndrec",
   "MeasureTheory.Measure.isFiniteMeasure_map",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "letFun",
   "HMul.hMul",
   "ENNReal.ofReal_le_iff_le_toReal",
   "OrderedSemiring.toPartialOrder",
   "ENNReal.ofNNReal"],
  "name": "ProbabilityTheory.prob_ge_exp_neg_entropy'",
  "constType":
  "∀ {S : Type uS} [inst : Nonempty S] [inst : MeasurableSpace S] [inst_1 : MeasurableSingletonClass S] {Ω : Type u_1}\n  [inst_2 : MeasurableSpace Ω] {μ : MeasureTheory.Measure Ω} [inst_3 : MeasureTheory.IsProbabilityMeasure μ]\n  (X : Ω → S), Measurable X → ∀ [inst_4 : FiniteRange X], ∃ s, Real.exp (-H[X ; μ]) ≤ μ.real (X ⁻¹' {s})",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Unit",
   "Nat.ble_self_eq_true",
   "Nat.ble_eq_true_of_le.match_1",
   "LE.le",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.ble_succ_eq_true",
   "Bool.true",
   "PUnit",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_eq_true_of_le",
  "constType": "∀ {n m : ℕ}, n ≤ m → Nat.ble n m = true",
  "constCategory": "Theorem"},
 {"references":
  ["EmbeddingLike.toFunLike",
   "EquivLike",
   "Function.Injective",
   "EmbeddingLike.injective",
   "EquivLike.toEmbeddingLike",
   "FunLike.coe"],
  "name": "EquivLike.injective",
  "constType":
  "∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Injective ⇑e",
  "constCategory": "Theorem"},
 {"references": ["OrderedAddCommMonoid"],
  "name": "Archimedean",
  "constType": "(α : Type u_2) → [inst : OrderedAddCommMonoid α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Subsemigroup.carrier",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Submonoid.one_mem'",
   "MulOneClass.toOne",
   "Inf.inf",
   "Submonoid.instInfSubmonoid",
   "Set",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Set.instMembershipSet",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Submonoid",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Subgroup.instInfSubgroup.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G), 1 ∈ (H₁.toSubmonoid ⊓ H₂.toSubmonoid).carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Nat.gt_of_not_le",
   "Iff",
   "instLENat",
   "Nat.not_le_of_gt",
   "LT.lt",
   "Not",
   "Nat",
   "instLTNat",
   "LE.le"],
  "name": "Nat.not_le",
  "constType": "∀ {a b : ℕ}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Semiring.toNonUnitalSemiring",
   "LinearOrder.decidableLE",
   "OfNat.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real",
   "LinearOrder.max_def",
   "StrictOrderedRing.toNontrivial",
   "Eq",
   "Real.linearOrder",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.strictOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "StrictOrderedRing.mk",
   "Semiring.mul_one",
   "LinearOrder.le_total",
   "LinearOrder.min_def",
   "One.toOfNat1",
   "StrictOrderedRing.mul_pos",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "StrictOrderedRing.zero_le_one",
   "LinearOrder.toOrd",
   "Semiring.toOne",
   "instHMul",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "StrictOrderedRing.add_le_add_left",
   "HMul.hMul",
   "LinearOrderedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Real.instLinearOrderedFieldReal.proof_3",
  "constType": "∀ (a : ℝ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "MeasureTheory.Measure",
   "ProbabilityTheory.kernel.proof_1",
   "MeasureTheory.Measure.instMeasurableSpace",
   "AddSubsemigroup.mk",
   "MeasureTheory.Measure.instAddCommMonoid",
   "Measurable",
   "AddCommMonoid.toAddMonoid",
   "AddSubmonoid.mk",
   "AddMonoid.toAddZeroClass",
   "ProbabilityTheory.kernel.proof_2",
   "Pi.addZeroClass",
   "AddSubmonoid",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.kernel",
  "constType":
  "(α : Type u_1) →\n  (β : Type u_2) → [inst : MeasurableSpace α] → [inst : MeasurableSpace β] → AddSubmonoid (α → MeasureTheory.Measure β)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Int.ofNat",
   "Monoid.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "Nat",
   "GroupWithZero.toMonoidWithZero",
   "Nat.succ",
   "GroupWithZero.zpow",
   "Eq"],
  "name": "GroupWithZero.zpow_succ'",
  "constType":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (n : ℕ) (a : G₀),\n  GroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * GroupWithZero.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "MeasureTheory.Measure.FiniteSpanningSetsIn.finite",
   "Set.finite_le_nat",
   "CompletelyDistribLattice.toCompleteLattice",
   "Nat.le",
   "MeasureTheory.Measure.toFiniteSpanningSetsIn",
   "MeasureTheory.spanningSets",
   "MeasureTheory.measure_biUnion_lt_top",
   "setOf",
   "PartialOrder.toPreorder",
   "Top.top",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Set.instMembershipSet",
   "LT.lt.ne",
   "ENNReal.instCompleteLinearOrderENNReal",
   "MeasureTheory.Measure",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Preorder.toLT",
   "MeasureTheory.SigmaFinite",
   "MeasureTheory.Measure.FiniteSpanningSetsIn.set",
   "LT.lt",
   "CompleteLattice.toTop",
   "MeasurableSet",
   "CompleteLinearOrder.toCompletelyDistribLattice",
   "Nat",
   "MeasurableSpace"],
  "name": "MeasureTheory.measure_spanningSets_lt_top",
  "constType":
  "∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.SigmaFinite μ] (i : ℕ),\n  ↑↑μ (MeasureTheory.spanningSets μ i) < ⊤",
  "constCategory": "Theorem"},
 {"references": ["gt_iff_lt", "propext", "LT.lt", "LT", "Eq", "GT.gt"],
  "name": "Std.Classes.Order._auxLemma.4",
  "constType": "∀ {α : Type u_1} [inst : LT α] {x y : α}, (x > y) = (y < x)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "cast",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocSemiring",
   "MulHomClass",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "MulHomClass.toFunLike",
   "AddCommMonoid.toAddMonoid",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "outParam",
   "AddZeroClass.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.mk",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      [inst : NonUnitalNonAssocSemiring α] →\n        [inst_1 : NonUnitalNonAssocSemiring β] →\n          [toMulHomClass : MulHomClass F α β] →\n            (∀ (f : F) (x y : α), f (x + y) = f x + f y) → (∀ (f : F), f 0 = 0) → NonUnitalRingHomClass F α β",
  "constCategory": "Other"},
 {"references":
  ["Zero",
   "OfNat.ofNat",
   "Cardinal",
   "Zero.mk",
   "instOfNatNat",
   "Nat",
   "Cardinal.mk",
   "Fin",
   "Cardinal.lift"],
  "name": "Cardinal.instZeroCardinal",
  "constType": "Zero Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.left_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Definition"},
 {"references": ["False", "EmptyCollection.mk", "Set", "EmptyCollection"],
  "name": "Set.instEmptyCollectionSet",
  "constType": "{α : Type u_1} → EmptyCollection (Set α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "InfSet",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Set",
   "Classical.propDecidable",
   "Nat.decLt",
   "dite",
   "instDecidableAnd",
   "instLTNat",
   "Eq",
   "Set.instMembershipSet",
   "GT.gt",
   "And",
   "Function.IsPeriodicPt.instDecidableIsPeriodicPt",
   "Nat.find",
   "Function.IsPeriodicPt",
   "Not",
   "instOfNatNat",
   "Nat",
   "Function.periodicPts"],
  "name": "Function.minimalPeriod",
  "constType": "{α : Type u_1} → (α → α) → α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["OrderHom.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "Monotone",
   "OrderHom.casesOn",
   "Nat",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.match_1",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (motive : OmegaCompletePartialOrder.Chain α → Prop)\n  (x : OmegaCompletePartialOrder.Chain α),\n  (∀ (c : ℕ → α) (monotone' : Monotone c), motive { toFun := c, monotone' := monotone' }) → motive x",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatNat",
   "Nat",
   "NatCast.mk",
   "rfl",
   "Eq",
   "NatCast.natCast"],
  "name": "Nat.commSemiring.proof_2",
  "constType": "NatCast.natCast 0 = NatCast.natCast 0",
  "constCategory": "Theorem"},
 {"references":
  ["neg_add_self",
   "Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "left_neg_eq_right_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {a b : G}, a + b = 0 → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "DivisionRing.toRing",
   "Real",
   "Abs.abs",
   "True",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "Rat.instNegRat",
   "Mathlib.Data.Real.Basic._auxLemma.17",
   "Real.instInvReal",
   "CauSeq.Completion.instInvCauchyToRing",
   "Eq.trans",
   "GroupWithZero.toInv",
   "CauSeq.Completion.Cauchy.field",
   "eq_self",
   "Neg.toHasAbs",
   "DivisionSemiring.toGroupWithZero",
   "Rat",
   "Field.toSemifield",
   "Rat.instLinearOrderedRingRat",
   "Mathlib.Data.Real.Basic._auxLemma.19",
   "Real.ofCauchy",
   "Rat.field",
   "GroupWithZero.inv_zero",
   "GroupWithZero.toMonoidWithZero",
   "CauSeq.Completion.instZeroCauchy",
   "Real.instZeroReal",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "CauSeq.Completion.Cauchy",
   "congr",
   "Semifield.toDivisionSemiring",
   "MonoidWithZero.toZero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal.proof_11",
  "constType": "0⁻¹ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype",
   "Finset.sum",
   "Finset",
   "Finset.instMembershipFinset",
   "Finset.sum_congr",
   "rfl",
   "Eq",
   "AddCommMonoid"],
  "name": "Fintype.sum_congr",
  "constType":
  "∀ {α : Type u_1} {M : Type u_4} [inst : Fintype α] [inst_1 : AddCommMonoid M] (f g : α → M),\n  (∀ (a : α), f a = g a) → (Finset.sum Finset.univ fun a => f a) = Finset.sum Finset.univ fun a => g a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "SubNegMonoid.toNeg",
   "neg_zero",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_add",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Eq",
   "Int.instInhabitedInt",
   "Int.eq_nat_or_neg",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Int.cast_neg",
   "HasDistribNeg.toInvolutiveNeg",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "Eq.trans",
   "Int.instCommRingInt",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Std.Logic._auxLemma.32",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.cast_zero",
   "instHMul",
   "Nat.rec",
   "NonAssocRing.toIntCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "congr",
   "congrArg",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "congrFun",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "forall_congr",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.instNegInt",
   "neg_mul",
   "Eq.symm",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instNonempty",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.instMulInt",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "Mathlib.Algebra.Group.Basic._auxLemma.14",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Ring.toAddCommGroup",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "Int.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocRing α] (m n : ℤ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["MeasurableSpace.GenerateMeasurable.compl",
   "MeasurableSpace.GenerateMeasurable.iUnion",
   "MeasurableSpace.GenerateMeasurable",
   "Set",
   "MeasurableSpace.mk",
   "MeasurableSpace",
   "MeasurableSpace.GenerateMeasurable.empty"],
  "name": "MeasurableSpace.generateFrom",
  "constType": "{α : Type u_1} → Set (Set α) → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references": ["Rat", "RatCast.ratCast", "RatCast"],
  "name": "Rat.cast",
  "constType": "{K : Type u} → [inst : RatCast K] → ℚ → K",
  "constCategory": "Definition"},
 {"references":
  ["instLinearOrder.proof_3",
   "instLinearOrder.proof_1",
   "LinearOrder",
   "Ord.mk",
   "PartialOrder.toPreorder",
   "Max.mk",
   "Inf.inf",
   "ConditionallyCompleteLattice.toLattice",
   "ConditionallyCompleteLinearOrder.decidableLE",
   "instLinearOrder.proof_2",
   "Min.mk",
   "ConditionallyCompleteLinearOrder.le_total",
   "Lattice.toInf",
   "ConditionallyCompleteLinearOrder.decidableEq",
   "SemilatticeSup.toSup",
   "Preorder.toLT",
   "LinearOrder.mk",
   "Sup.sup",
   "ConditionallyCompleteLinearOrder",
   "Lattice.toSemilatticeSup",
   "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
   "compareOfLessAndEq",
   "SemilatticeSup.toPartialOrder",
   "ConditionallyCompleteLinearOrder.decidableLT"],
  "name": "instLinearOrder",
  "constType":
  "(α : Type u_5) → [inst : ConditionallyCompleteLinearOrder α] → LinearOrder α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "Invertible.congr",
   "Semiring.toMonoidWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "Invertible",
   "Ring.toNonAssocRing",
   "True",
   "Semiring.toNatCast",
   "invertibleOne",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsRat.to_isInt.match_1",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Invertible.invOf",
   "Ring.toAddGroupWithOne",
   "Mathlib.Meta.NormNum.IsRat",
   "One.toOfNat1",
   "invOf_one'",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Semiring.toOne",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "letFun",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Int",
   "congrFun"],
  "name": "Mathlib.Meta.NormNum.IsRat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℤ}, Mathlib.Meta.NormNum.IsRat a n 1 → Mathlib.Meta.NormNum.IsInt a n",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Ne.isUnit",
   "instHDiv",
   "GroupWithZero.toDivisionMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "GroupWithZero.toDiv",
   "Zero.toOfNat0",
   "IsUnit.eq_div_iff",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Iff",
   "GroupWithZero",
   "HMul.hMul",
   "HDiv.hDiv",
   "MonoidWithZero.toZero"],
  "name": "eq_div_iff",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a b c : G₀}, b ≠ 0 → (c = a / b ↔ c * b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass.mk",
   "Zero.zero",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Add.add",
   "Function.Injective",
   "Zero.mk",
   "Function.Injective.addZeroClass.proof_2",
   "Add",
   "AddZeroClass",
   "Function.Injective.addZeroClass.proof_1",
   "Add.mk"],
  "name": "Function.Injective.addZeroClass",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : AddZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → AddZeroClass M₁",
  "constCategory": "Definition"},
 {"references":
  ["AddSubgroup.instAddSubgroupClassAddSubgroupToSubNegAddMonoidInstSetLikeAddSubgroup",
   "Membership.mem",
   "instHSMul",
   "AddGroup",
   "HSMul.hSMul",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup",
   "Nat",
   "AddSubgroup.instSetLikeAddSubgroup",
   "AddSubgroupClass.toAddSubmonoidClass",
   "AddGroup.toSubNegMonoid",
   "nsmul_mem",
   "SetLike.instMembership",
   "AddMonoid.toNatSMul"],
  "name": "AddSubgroup.nsmul_mem",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) {x : G}, x ∈ K → ∀ (n : ℕ), n • x ∈ K",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "outParam",
   "OfNat.ofNat",
   "FunLike",
   "ZeroHomClass",
   "FunLike.coe",
   "Eq"],
  "name": "ZeroHomClass.mk",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : Zero M] →\n        [inst_1 : Zero N] → [toFunLike : FunLike F M fun x => N] → (∀ (f : F), f 0 = 0) → ZeroHomClass F M N",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "AddMonoid.toZero",
   "add_neg_self",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "add_lt_add_iff_left",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "add_zero"],
  "name": "Left.neg_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddMonoidWithOne.toAddMonoid",
   "CommRing.toRing",
   "Int",
   "Int.instCommRingInt",
   "AddMonoid"],
  "name": "Int.instAddMonoidInt",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Real.definition._@.Mathlib.Data.Real.Basic._hyg.5622",
   "Real",
   "Subtype",
   "Eq"],
  "name": "Real.wrapped._@.Mathlib.Data.Real.Basic._hyg.5622",
  "constType": "Subtype (Eq Real.definition✝)",
  "constCategory": "Other"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "mul_neg",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "abs_of_nonneg",
   "AddGroupWithOne.toAddGroup",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toLinearOrder",
   "HasDistribNeg.toInvolutiveNeg",
   "abs_eq",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instDistribLattice",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "DistribLattice.toLattice",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "propext",
   "StrictOrderedSemiring.toOrderedSemiring",
   "congr",
   "LinearOrder.toPartialOrder",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPosMulMono",
   "congrArg",
   "OrderedAddCommGroup.toAddCommGroup",
   "mul_nonneg",
   "StrictOrderedRing.toRing",
   "abs_nonneg",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedRing.toStrictOrderedRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.1",
   "Ring.toNonAssocRing",
   "Abs.abs",
   "True",
   "le_total",
   "Zero.toOfNat0",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedRing",
   "InvolutiveNeg.toNeg",
   "LinearOrderedRing.toLinearOrderedAddCommGroup",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Mathlib.Algebra.Order.Ring.Abs._auxLemma.2",
   "Lattice.toSemilatticeSup",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "abs_of_nonpos",
   "Eq.ndrec",
   "HMul.hMul",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "NegZeroClass.toNeg"],
  "name": "abs_mul",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), |a * b| = |a| * |b|",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Ne",
   "OfNat.ofNat",
   "LT.lt.ne'",
   "PartialOrder.toPreorder",
   "Semiring",
   "AbsoluteValue.pos",
   "AbsoluteValue",
   "Semiring.toMonoidWithZero",
   "FunLike.coe",
   "SubadditiveHomClass.toFunLike",
   "Preorder.toLE",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AbsoluteValue.subadditiveHomClass",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "AbsoluteValue.ne_zero",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (abv : AbsoluteValue R S) {x : R},\n  x ≠ 0 → abv x ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "NonUnitalNonAssocRing.zero_mul",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocRing α] (a : α), 0 * a = 0",
  "constCategory": "Definition"},
 {"references":
  ["SetLike.instPartialOrder",
   "Set.instHasSubsetSet",
   "SetLike",
   "PartialOrder.toPreorder",
   "Iff",
   "Iff.rfl",
   "Set",
   "HasSubset.Subset",
   "LE.le",
   "Preorder.toLE",
   "SetLike.coe"],
  "name": "SetLike.coe_subset_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {S T : A}, ↑S ⊆ ↑T ↔ S ≤ T",
  "constCategory": "Theorem"},
 {"references": ["setOf", "Set", "Eq"],
  "name": "Set.singleton",
  "constType": "{α : Type u_1} → α → Set α",
  "constCategory": "Definition"},
 {"references": ["OrderedRing", "PartialOrder"],
  "name": "OrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Bool.true", "LT", "Rat", "Rat.blt", "Bool", "LT.mk", "Eq"],
  "name": "Rat.instLTRat",
  "constType": "LT ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "InfSet.sInf",
   "InfSet",
   "SupSet.sSup",
   "ConditionallyCompleteLattice",
   "LE.le",
   "BddAbove",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SupSet",
   "upperBounds",
   "BddBelow",
   "lowerBounds",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder"],
  "name": "ConditionallyCompleteLattice.mk",
  "constType":
  "{α : Type u_5} →\n  [toLattice : Lattice α] →\n    [toSupSet : SupSet α] →\n      [toInfSet : InfSet α] →\n        (∀ (s : Set α) (a : α), BddAbove s → a ∈ s → a ≤ sSup s) →\n          (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a) →\n            (∀ (s : Set α) (a : α), BddBelow s → a ∈ s → sInf s ≤ a) →\n              (∀ (s : Set α) (a : α), Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s) → ConditionallyCompleteLattice α",
  "constCategory": "Other"},
 {"references":
  ["And",
   "Exists",
   "MeasurableSpace.comap.proof_2",
   "Set.preimage",
   "MeasurableSpace.comap.proof_1",
   "Set",
   "MeasurableSpace.comap.proof_3",
   "MeasurableSet",
   "MeasurableSpace.mk",
   "MeasurableSpace",
   "Eq"],
  "name": "MeasurableSpace.comap",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α → β) → MeasurableSpace β → MeasurableSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "PartialOrder.toPreorder",
   "Inf.inf",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "Lattice.le_inf",
  "constType":
  "∀ {α : Type u} [self : Lattice α] (a b c : α), a ≤ b → a ≤ c → a ≤ b ⊓ c",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), x * -y = -(x * y)",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "MonoidHomClass",
   "outParam",
   "MulOneClass.toMul",
   "MulOneClass"],
  "name": "MonoidHomClass.toMulHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : MulOneClass M] → [inst_1 : MulOneClass N] → [self : MonoidHomClass F M N] → MulHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "PartialOrder.toPreorder",
   "Nat.linearOrderedCommMonoidWithZero.proof_3",
   "LinearOrderedCommSemiring.toMin",
   "Nat.linearOrderedCommMonoidWithZero.proof_1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.max_def",
   "Preorder.toLE",
   "OrderedCommMonoid.mk",
   "inferInstance",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.min_def",
   "Nat.mul_le_mul_left",
   "AddMonoid.toZero",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "LinearOrderedCommSemiring.toMax",
   "CommMonoidWithZero.toCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "Nat.linearOrderedCommMonoidWithZero.proof_2",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "StrictOrderedSemiring.toSemiring",
   "LE.le",
   "CommMonoidWithZero",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Nat.commSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "left_distrib",
   "Eq"],
  "name": "mul_add",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Quotient.decidableEq.proof_2",
   "instHasEquiv",
   "Setoid",
   "DecidableEq",
   "Decidable.isFalse",
   "Quotient.decidableEq.match_1",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "Quotient.recOnSubsingleton₂",
   "Quotient",
   "HasEquiv.Equiv",
   "Quotient.decidableEq.proof_1",
   "Quotient.sound",
   "Quotient.mk",
   "Eq"],
  "name": "Quotient.decidableEq",
  "constType":
  "{α : Sort u} → {s : Setoid α} → [d : (a b : α) → Decidable (a ≈ b)] → DecidableEq (Quotient s)",
  "constCategory": "Definition"},
 {"references":
  ["Or",
   "Or.inl",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Or.inr",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Or.casesOn",
   "Eq"],
  "name": "le_of_not_lt.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrder α] {a b : α} (motive : a < b ∨ a = b ∨ b < a → Prop) (x : a < b ∨ a = b ∨ b < a),\n  (∀ (hlt : a < b), motive (_ : a < b ∨ a = b ∨ b < a)) →\n    (∀ (HEq : a = b), motive (_ : a < b ∨ a = b ∨ b < a)) →\n      (∀ (hgt : b < a), motive (_ : a < b ∨ a = b ∨ b < a)) → motive x",
  "constCategory": "Definition"},
 {"references": ["Or", "Iff", "Or.comm"],
  "name": "or_comm",
  "constType": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "constCategory": "Theorem"},
 {"references":
  ["Group.mul_left_inv",
   "instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "mul_left_inv",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹ * a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Init.Order.Defs._auxLemma.1",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "Mathlib.Tactic.Abel.unfold_sub",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b c : α), a + -b = c → a - b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "Nat.unpair",
   "Function.uncurry",
   "Nat.pairEquiv.proof_1",
   "Nat.pair",
   "Equiv.mk",
   "Prod",
   "Nat",
   "Nat.pair_unpair"],
  "name": "Nat.pairEquiv",
  "constType": "ℕ × ℕ ≃ ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Preorder"],
  "name": "GaloisInsertion",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → (β → α) → Type (max u_2 u_3)",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.const",
   "instHasEquiv",
   "CauSeq.lim",
   "CauSeq.IsComplete",
   "CauSeq",
   "CauSeq.eq_lim_of_const_equiv",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "Setoid.symm",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "CauSeq.equiv",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HasEquiv.Equiv",
   "Eq.symm",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.lim_eq_of_equiv_const",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [inst_3 : CauSeq.IsComplete β abv] {f : CauSeq β abv} {x : β},\n  f ≈ CauSeq.const abv x → CauSeq.lim f = x",
  "constCategory": "Theorem"},
 {"references": ["LT"],
  "name": "LT.mk",
  "constType": "{α : Type u} → (α → α → Prop) → LT α",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_lt_add_iff_right",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "LT",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Eq",
   "Zero.toOfNat0",
   "Function.swap",
   "SubNegMonoid.toSub",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq.ndrec",
   "propext",
   "LT.lt",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero"],
  "name": "sub_pos",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a - b ↔ b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "StrictOrderedSemiring.zero_le_one",
   "PartialOrder.toPreorder",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LE.le",
   "StrictOrderedSemiring.toSemiring",
   "Preorder.toLE",
   "Semiring.toOne",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_3",
  "constType": "0 ≤ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4056",
   "autoParam",
   "Eq",
   "instHMul",
   "One",
   "_auto._@.Mathlib.Algebra.Group.Defs._hyg.4095",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "Semigroup"],
  "name": "Monoid.mk",
  "constType":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            autoParam (∀ (x : M), npow 0 x = 1) _auto✝ →\n              autoParam (∀ (n : ℕ) (x : M), npow (n + 1) x = x * npow n x) _auto✝¹ → Monoid M",
  "constCategory": "Other"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Bot.bot",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "BooleanAlgebra.toBot",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "BooleanAlgebra.bot_le",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE",
   "BooleanAlgebra"],
  "name": "Set.instBooleanAlgebraSet.proof_15",
  "constType": "∀ {α : Type u_1} (a : α → Prop), ⊥ ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "neg_zero",
   "Real.instMulReal",
   "HAdd.hAdd",
   "Real.instAddReal",
   "Real.commRing",
   "Real.instAddMonoidReal",
   "div_self_mul_self'",
   "MulZeroClass.mul_zero",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Complex.inv_re",
   "Complex.inv_im",
   "Complex.normSq",
   "LinearOrderedField.toLinearOrderedSemifield",
   "HDiv.hDiv",
   "Real.instInvReal",
   "MonoidWithZeroHom",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "GroupWithZero.toInv",
   "zero_div",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Complex.ext_iff",
   "Complex.im",
   "instHMul",
   "And",
   "of_eq_true",
   "congr",
   "MonoidWithZero.toZero",
   "congrArg",
   "add_zero",
   "Inv.inv",
   "AddCommGroup.toDivisionAddCommMonoid",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "CommRing.toNonUnitalCommRing",
   "Real",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Complex.instInvComplex",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "LinearOrderedField.toDiv",
   "True",
   "Real.instNegReal",
   "Real.instAddCommGroupReal",
   "Zero.toOfNat0",
   "Complex.instSemiringComplex",
   "MulZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Complex.ofReal'",
   "eq_self",
   "MonoidWithZeroHom.monoidWithZeroHomClass",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "Neg.neg",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "GroupWithZero.toMonoidWithZero",
   "Complex.re",
   "Real.instZeroReal",
   "Complex.mk",
   "Real.semiring",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "Complex",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "and_self"],
  "name": "Complex.ofReal_inv",
  "constType": "∀ (r : ℝ), ↑r⁻¹ = (↑r)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Set",
   "Eq.refl",
   "Exists.intro",
   "Quotient",
   "Exists.casesOn",
   "rfl",
   "QuotientAddGroup.leftRel",
   "Iff.mpr",
   "QuotientAddGroup.mk",
   "QuotientAddGroup.instHasQuotientAddSubgroup",
   "Eq",
   "Set.range",
   "AddSubgroup.mem_leftTransversals_iff_bijective",
   "AddGroup",
   "Set.Elem",
   "Eq.rec",
   "AddSubgroup",
   "HasQuotient.Quotient",
   "Eq.symm",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Eq.trans",
   "Membership.mem",
   "Function.Bijective",
   "congr_arg",
   "Function.Surjective",
   "Subtype.ext",
   "Set.instMembershipSet",
   "Set.restrict",
   "Quotient.mk''",
   "Function.Injective",
   "AddSubgroup.leftTransversals",
   "And.intro",
   "Subtype.mk",
   "SetLike.coe",
   "Subtype.casesOn"],
  "name": "AddSubgroup.range_mem_leftTransversals",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {f : G ⧸ H → G},\n  (∀ (q : G ⧸ H), ↑(f q) = q) → Set.range f ∈ AddSubgroup.leftTransversals ↑H",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "div_le_div_of_le_left",
   "AbsoluteValue.mulHomClass",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Nat.cast_zero",
   "Real.orderedRing",
   "Semiring.toNatCast",
   "Nat.cast",
   "Complex.instField",
   "Finset.range",
   "Real.strictOrderedSemiring",
   "map_mul",
   "LinearOrderedField.toLinearOrderedSemifield",
   "IsAbsoluteValue.abv_nonneg",
   "HDiv.hDiv",
   "le_of_lt",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Nat.strictOrderedSemiring",
   "HPow.hPow",
   "Complex.abs",
   "div_lt_iff",
   "Complex.instNontrivialComplex",
   "instHDiv",
   "MulOneClass.toOne",
   "Mathlib.Meta.Positivity.nonneg_of_isNat",
   "Real.instRingReal",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommMagma.toMul",
   "SubadditiveHomClass.toFunLike",
   "MonoidWithZero.toMulZeroOneClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "LT.lt",
   "Field.toDiv",
   "OrderedSemiring.toMulPosMono",
   "Field.toDivisionRing",
   "Nat.commSemigroup",
   "Exists",
   "CommMonoidWithZero.toZero",
   "Real",
   "IsCauSeq",
   "Semiring.toMonoidWithZero",
   "LinearOrderedField.toLinearOrderedCommRing",
   "Eq.refl",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Nat.cast_le_cast",
   "map_div₀",
   "Abs.abs",
   "Nat.cast_mul",
   "AbsoluteValue.subadditiveHomClass",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Complex.instSemiringComplex",
   "Nat.le_succ",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat.succ",
   "CommGroupWithZero.toDivisionCommMonoid",
   "DivInvMonoid.toDiv",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Real.instLinearOrderedRingReal",
   "series_ratio_test",
   "Real.instLTReal",
   "MonoidHomClass.toMulHomClass",
   "Finset.sum",
   "div_div",
   "Field.toSemifield",
   "MulHomClass.toFunLike",
   "One.toOfNat1",
   "mul_le_mul_of_nonneg_right",
   "FunLike.coe",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toMonoidWithZero",
   "LE.le",
   "Monoid.toMulOneClass",
   "AbsoluteValue.nonneg",
   "GroupWithZero.toDiv",
   "Eq.ndrec",
   "Real.instPreorderReal",
   "letFun",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "exists_nat_gt",
   "Real.instAddCommMonoidReal",
   "AbsoluteValue.monoidWithZeroHomClass",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "AbsoluteValue",
   "HAdd.hAdd",
   "Real.instSupReal",
   "Preorder.toLE",
   "Eq",
   "Nat.factorial",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "AbsoluteValue.isAbsoluteValue",
   "le_trans",
   "mul_div_assoc",
   "Nat",
   "DivisionRing.toDivInvMonoid",
   "StrictOrderedRing.toPartialOrder",
   "Real.partialOrder",
   "DivisionSemiring.toGroupWithZero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Real.orderedSemiring",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Real.instIsDomainRealSemiring",
   "Field.toEuclideanDomain",
   "pow_succ",
   "LinearOrderedSemifield.toSemifield",
   "Real.instLinearOrderedFieldReal",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.natCast",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing",
   "LinearOrderedField.toDiv",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "mul_comm",
   "one_mul",
   "instLENat",
   "instHPow",
   "Preorder.toLT",
   "div_nonneg",
   "Complex.abs_natCast",
   "instOfNatNat",
   "mul_div_right_comm",
   "Nat.factorial_succ",
   "Eq.symm",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "lt_of_le_of_lt",
   "instHAdd",
   "Complex.abs_abs",
   "Complex.isCauSeq_abs_exp.match_1",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedSemiring.toSemiring",
   "Real.instArchimedean",
   "Real.instZeroReal",
   "Semiring.toOne",
   "StrictOrderedSemiring.to_charZero",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedField.toField",
   "CommSemigroup.toCommMagma",
   "Real.semiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "Complex",
   "instMulNat",
   "OrderedSemiring.toPartialOrder"],
  "name": "Complex.isCauSeq_abs_exp",
  "constType":
  "∀ (z : ℂ), IsCauSeq abs fun n => Finset.sum (Finset.range n) fun m => Complex.abs (z ^ m / ↑(Nat.factorial m))",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "EquivLike",
   "Equiv.toFun",
   "Equiv.invFun",
   "Equiv.instEquivLikeEquiv.proof_1",
   "Equiv.right_inv",
   "Equiv.left_inv",
   "EquivLike.mk"],
  "name": "Equiv.instEquivLikeEquiv",
  "constType": "{α : Sort u} → {β : Sort v} → EquivLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.add_comm",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_6",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["Nat.zero", "Inhabited", "Nat", "Inhabited.mk"],
  "name": "instInhabitedNat",
  "constType": "Inhabited ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.unpair_pair",
   "Nat.unpair",
   "Function.uncurry",
   "Nat.pair",
   "Prod",
   "Nat",
   "Nat.pairEquiv.match_1",
   "Eq"],
  "name": "Nat.pairEquiv.proof_1",
  "constType": "∀ (x : ℕ × ℕ), Nat.unpair (Function.uncurry Nat.pair x) = x",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.mpr",
   "Eq.ndrec",
   "Int.natAbs_neg",
   "Rat.reduced",
   "Rat.num",
   "Rat",
   "Eq.refl",
   "Rat.den",
   "Nat.Coprime",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "Int",
   "Eq",
   "id",
   "Int.natAbs"],
  "name": "Rat.neg.proof_1",
  "constType": "∀ (a : ℚ), Nat.Coprime (Int.natAbs (-a.num)) a.den",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Function.Injective",
  "constType": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.mem_image2_of_mem",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {a : α} {b : β},\n  a ∈ s → b ∈ t → f a b ∈ Set.image2 f s t",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "Add.add",
  "constType": "{α : Type u} → [self : Add α] → α → α → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Ord",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "SubNegMonoid.toNeg",
   "add_left_neg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "Eq"],
  "name": "AddGroup.toSubtractionMonoid.proof_1",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), - -a = a",
  "constCategory": "Theorem"},
 {"references": ["Prod.casesOn", "Prod.mk", "Prod"],
  "name": "instFiniteRangeProdProd.match_1",
  "constType":
  "∀ {G : Type u_1} {H : Type u_2} (motive : G × H → Prop) (h : G × H), (∀ (x : G) (y : H), motive (x, y)) → motive h",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "One", "One.mk", "OfNat"],
  "name": "One.ofOfNat1",
  "constType": "{α : Type u_1} → [inst : OfNat α 1] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "RingHom.instRingHomClass",
   "RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "IsScalarTower.mk",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalRingHomClass.toMulHomClass",
   "MulZeroClass.toMul",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "mul_assoc",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "CommSemiring",
   "HSMul.hSMul",
   "Algebra",
   "smul_eq_mul",
   "Algebra.toSMul",
   "id",
   "Mul.toSMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Semiring",
   "algebraMap",
   "Algebra.smul_def",
   "MulZeroClass.toSMulWithZero",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "IsScalarTower",
   "SMulZeroClass.toSMul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "MonoidWithZero.toZero"],
  "name": "IsScalarTower.right",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A], IsScalarTower R A A",
  "constCategory": "Definition"},
 {"references": ["Set", "lowerBounds", "IsGreatest", "Preorder"],
  "name": "IsGLB",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "CommMonoidWithZero.toZero",
   "LinearOrderedSemifield.toSemifield",
   "instHDiv",
   "OfNat.ofNat",
   "LinearOrderedSemifield",
   "PartialOrder.toPreorder",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "CommGroupWithZero.toCommMonoidWithZero",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "LinearOrderedSemifield.toDiv",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "HDiv.hDiv",
   "le_div_iff",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "lt_iff_lt_of_le_iff_le"],
  "name": "div_lt_iff",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → (b / c < a ↔ b < a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero",
   "MulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toMulAction",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : MonoidWithZero R] → [inst_1 : Zero M] → [self : MulActionWithZero R M] → MulAction R M",
  "constCategory": "Definition"},
 {"references": ["SupSet", "CompleteLattice"],
  "name": "CompleteLattice.toSupSet",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → SupSet α",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "DivisionRing.toRing",
   "Inf.inf",
   "Real.instLEReal",
   "Real",
   "Eq.refl",
   "Real.instSupReal",
   "Preorder.le_trans",
   "Sup.mk",
   "implies_congr",
   "Preorder.toLE",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Inf.mk",
   "Eq.mpr",
   "Real.mk_inf",
   "Preorder.toLT",
   "Rat.instNegRat",
   "Real.ind_mk",
   "CauSeq.inf_le_left",
   "Eq.symm",
   "SemilatticeSup.toPartialOrder",
   "id",
   "Neg.toHasAbs",
   "Real.partialOrder",
   "Real.mk_le",
   "Preorder.le_refl",
   "Rat",
   "SemilatticeSup.mk",
   "Real.instInfReal",
   "CauSeq",
   "CauSeq.instInfCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "LE.le",
   "CauSeq.instSupCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Mathlib.Data.Real.Basic._auxLemma.15",
   "Preorder.mk",
   "CauSeq.le_sup_left",
   "Eq.ndrec",
   "CauSeq.sup_le",
   "CauSeq.le_sup_right",
   "Mathlib.Data.Real.Basic._auxLemma.8",
   "propext",
   "Rat.divisionRing",
   "Real.mk",
   "PartialOrder.le_antisymm",
   "Sup.sup",
   "Real.mk_sup",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Preorder.lt_iff_le_not_le",
   "congrFun"],
  "name": "Real.instDistribLatticeReal.proof_7",
  "constType": "∀ (a b : ℝ), a ⊓ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedField.mul_inv_cancel",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "LinearOrderedSemiring.toMax",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedSemifield",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedField.toLinearOrderedSemifield.proof_1",
   "LinearOrderedSemiring.decidableEq",
   "LinearOrderedField.toLinearOrderedCommRing",
   "LinearOrderedSemiring.toOrd",
   "LinearOrderedSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedSemiring.decidableLT",
   "LinearOrderedField.inv_zero",
   "LinearOrderedField.toDiv",
   "LinearOrderedSemiring.min_def",
   "LinearOrderedSemiring.le_total",
   "LinearOrderedField",
   "LinearOrderedField.div_eq_mul_inv",
   "LinearOrderedField.zpow_succ'",
   "LinearOrderedSemiring.decidableLE",
   "LinearOrderedField.zpow_zero'",
   "LinearOrderedSemifield.mk",
   "LinearOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.max_def",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedField.zpow_neg'",
   "LinearOrderedField.zpow",
   "LinearOrderedField.toInv",
   "LinearOrderedSemiring.toMin"],
  "name": "LinearOrderedField.toLinearOrderedSemifield",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LinearOrderedSemifield α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "Semiring.npow",
   "CommMonoid",
   "CommSemiring",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommSemiring.toCommMonoid",
  "constType": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_trans.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_trans.match_2",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["Subtype.instMeasurableSpace",
   "Subtype.val",
   "MeasurableSpace.le_map_comap",
   "Measurable",
   "MeasurableSpace",
   "Subtype"],
  "name": "measurable_subtype_coe",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] {p : α → Prop}, Measurable Subtype.val",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "inferInstance",
  "constType": "{α : Sort u} → [i : α] → α",
  "constCategory": "Definition"},
 {"references": ["HNot"],
  "name": "HNot.mk",
  "constType": "{α : Type u_4} → (α → α) → HNot α",
  "constCategory": "Other"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "instHAdd",
   "HAdd.hAdd",
   "DiscreteMeasurableSpace",
   "measurable_discrete",
   "MeasurableAdd₂.mk",
   "Prod",
   "Prod.fst",
   "Add",
   "MeasurableAdd₂",
   "MeasurableSpace",
   "Prod.instMeasurableSpace"],
  "name": "DiscreteMeasurableSpace.toMeasurableAdd₂",
  "constType":
  "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : Add α] [inst_2 : DiscreteMeasurableSpace (α × α)],\n  MeasurableAdd₂ α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Int.instMulInt",
   "Eq.mpr",
   "Eq.ndrec",
   "instOfNatInt",
   "Int.one_mul",
   "Eq.refl",
   "HMul.hMul",
   "Int",
   "Int.mul_comm",
   "id",
   "Eq"],
  "name": "Int.mul_one",
  "constType": "∀ (a : ℤ), a * 1 = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "ULift",
  "constType": "Type s → Type (max s r)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "Zero.toOfNat0",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.divisionRing",
   "Field",
   "AddMonoid.toZero",
   "LinearOrderedField.toLinearOrderedSemifield",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Ne",
   "Field.toSemifield",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "DivisionRing.toInv",
   "DivisionRing.mul_inv_cancel",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "CauSeq.Completion.Cauchy.field.proof_7",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : CauSeq.Completion.Cauchy abv), a ≠ 0 → a * a⁻¹ = 1",
  "constCategory": "Theorem"},
 {"references": ["Field", "Nontrivial"],
  "name": "Field.toNontrivial",
  "constType": "∀ {K : Type u} [self : Field K], Nontrivial K",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "Subtype.val",
   "HAdd.hAdd",
   "AddSubgroup",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "rfl",
   "AddSubgroup.add",
   "SetLike.instMembership",
   "Subtype",
   "Eq"],
  "name": "AddSubgroup.toAddCommGroup.proof_3",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommGroup G] (H : AddSubgroup G) (x x_1 : ↥H), ↑(x + x_1) = ↑(x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submonoid.mk",
   "InfSet.mk",
   "MulOneClass.toMul",
   "Submonoid.instSetLikeSubmonoid",
   "MulOneClass",
   "Subsemigroup.mk",
   "Set",
   "InfSet",
   "Set.iInter",
   "Submonoid",
   "Submonoid.instInfSetSubmonoid.proof_2",
   "Submonoid.instInfSetSubmonoid.proof_1",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "Submonoid.instInfSetSubmonoid",
  "constType": "{M : Type u_1} → [inst : MulOneClass M] → InfSet (Submonoid M)",
  "constCategory": "Definition"},
 {"references":
  ["Set.range",
   "Membership.mem",
   "Exists",
   "propext",
   "Set",
   "Set.mem_range",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Image._auxLemma.20",
  "constType":
  "∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {x : α}, (x ∈ Set.range f) = ∃ y, f y = x",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CoheytingAlgebra",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Subtype.val",
   "Real.instLEReal",
   "Real",
   "NNReal",
   "LE.le"],
  "name": "NNReal.toReal",
  "constType": "NNReal → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "Lean.SourceInfo.none",
   "Lean.mkAtom",
   "Array.empty",
   "Lean.Name.mkStr4",
   "Array.push",
   "Lean.Name.mkStr1",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "_auto._@.PFR.ForMathlib.Entropy.RuzsaDist._hyg.380",
  "constType": "Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instInsertFinset",
   "Or",
   "Set",
   "Mathlib.Data.Finset.Basic._auxLemma.6",
   "Finset.instMembershipFinset",
   "Insert.insert",
   "True",
   "iff_self",
   "Set.instMembershipSet",
   "Eq",
   "Set.ext",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.toSet",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.62",
   "congrArg",
   "Eq.trans",
   "Mathlib.Data.Finset.Basic._auxLemma.63",
   "Set.instInsertSet"],
  "name": "Finset.coe_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), ↑(insert a s) = insert a ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "DecidablePred",
   "Setoid.r",
   "List.filter",
   "List",
   "List.isSetoid",
   "Quot",
   "List.Perm.filter",
   "Quot.mk",
   "Eq",
   "Quot.sound"],
  "name": "Multiset.filter.proof_1",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (_l₁ _l₂ : List α),\n  Setoid.r _l₁ _l₂ →\n    Quot.mk Setoid.r (List.filter (fun b => decide (p b)) _l₁) =\n      Quot.mk Setoid.r (List.filter (fun b => decide (p b)) _l₂)",
  "constCategory": "Theorem"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DenselyNormedField",
  "constType": "Type u_5 → Type u_5",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "CommMagma",
   "CommMagma.mk",
   "CommSemigroup.mul_comm",
   "CommSemigroup",
   "CommSemigroup.toSemigroup"],
  "name": "CommSemigroup.toCommMagma",
  "constType": "{G : Type u} → [self : CommSemigroup G] → CommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff.rfl",
   "Nat.instDvdNat",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "SemigroupWithZero.toZero",
   "zero_dvd_iff",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "CharP",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "id",
   "AddMonoidWithOne.toAddMonoid",
   "CharP.mk",
   "Dvd.dvd",
   "SemigroupWithZero.toSemigroup",
   "AddMonoidWithOne",
   "Nat.commSemiring",
   "Eq.ndrec",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "NonUnitalSemiring.toSemigroupWithZero"],
  "name": "CharP.ofCharZero",
  "constType":
  "∀ (R : Type u_1) [inst : AddMonoidWithOne R] [inst_1 : CharZero R], CharP R 0",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Semigroup.toMul",
   "Monoid.toSemigroup",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "LinearOrderedCommMonoid",
   "LinearOrderedCommMonoidWithZero",
   "One.toOfNat1",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "OrderedCommMonoid.toCommMonoid",
   "HMul.hMul",
   "OrderedCommMonoid.toPartialOrder",
   "CommMonoid.toMonoid"],
  "name": "LinearOrderedCommMonoidWithZero.mk",
  "constType":
  "{α : Type u_1} →\n  [toLinearOrderedCommMonoid : LinearOrderedCommMonoid α] →\n    [toZero : Zero α] → (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → 0 ≤ 1 → LinearOrderedCommMonoidWithZero α",
  "constCategory": "Other"},
 {"references":
  ["ProbabilityTheory.measureEntropy.proof_1",
   "Real.negMulLog",
   "instHSMul",
   "Set",
   "Real",
   "PseudoMetricSpace.toUniformSpace",
   "MeasureTheory.Measure.instSMul",
   "Real.pseudoMetricSpace",
   "tsum",
   "ENNReal.instInvENNReal",
   "Set.univ",
   "ENNReal.instCanonicallyOrderedCommSemiringENNReal",
   "autoParam",
   "MeasureTheory.Measure",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "ENNReal",
   "Set.instSingletonSet",
   "CanonicallyOrderedCommSemiring.toCommSemiring",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "_auto._@.PFR.ForMathlib.Entropy.Measure._hyg.98",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "HSMul.hSMul",
   "Singleton.singleton",
   "Algebra.id",
   "UniformSpace.toTopologicalSpace",
   "Algebra.toSMul",
   "Real.instAddCommMonoidReal",
   "ENNReal.toReal",
   "MeasurableSpace",
   "Inv.inv"],
  "name": "ProbabilityTheory.measureEntropy",
  "constType":
  "{S : Type u_2} → [inst : MeasurableSpace S] → autoParam (MeasureTheory.Measure S) _auto✝ → ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Set.eq_empty_iff_forall_not_mem",
   "Membership.mem",
   "EmptyCollection.emptyCollection",
   "propext",
   "Set",
   "Not",
   "Set.instEmptyCollectionSet",
   "Set.instMembershipSet",
   "Eq"],
  "name": "Mathlib.Data.Set.Basic._auxLemma.11",
  "constType": "∀ {α : Type u} {s : Set α}, (s = ∅) = ∀ (x : α), x ∉ s",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Nat", "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat",
  "constType": "{α : Type u_1} → [inst : Ring α] → α → ℤ → ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["Unit", "Unit.unit", "Nat", "Nat.succ", "Nat.casesOn"],
  "name": "Nat.zero_add.match_1",
  "constType":
  "∀ (motive : ℕ → Prop) (x : ℕ), (Unit → motive 0) → (∀ (n : ℕ), motive (Nat.succ n)) → motive x",
  "constCategory": "Definition"},
 {"references": [],
  "name": "RelEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → (α → α → Prop) → (β → β → Prop) → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references": [],
  "name": "NonUnitalNonAssocRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Subsemigroup.carrier",
   "Membership.mem",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulOneClass",
   "Submonoid.toSubsemigroup",
   "MulOneClass.toOne",
   "Set",
   "Submonoid",
   "One.toOfNat1",
   "Set.instMembershipSet"],
  "name": "Submonoid.one_mem'",
  "constType":
  "∀ {M : Type u_4} [inst : MulOneClass M] (self : Submonoid M), 1 ∈ self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Complex.mk",
   "Real",
   "Complex",
   "One.toOfNat1",
   "Real.instOneReal"],
  "name": "Complex.I",
  "constType": "ℂ",
  "constCategory": "Definition"},
 {"references": ["Norm", "SeminormedAddCommGroup"],
  "name": "SeminormedAddCommGroup.toNorm",
  "constType": "{E : Type u_9} → [self : SeminormedAddCommGroup E] → Norm E",
  "constCategory": "Definition"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Nat.commSemiring",
   "inferInstance",
   "NonUnitalSemiring.toSemigroupWithZero",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Semigroup"],
  "name": "Nat.semigroup",
  "constType": "Semigroup ℕ",
  "constCategory": "Definition"},
 {"references": ["Or", "Or.inl"],
  "name": "Or.intro_left",
  "constType": "∀ {a : Prop} (b : Prop), a → a ∨ b",
  "constCategory": "Theorem"},
 {"references":
  ["Cardinal.toNat.proof_2",
   "OfNat.ofNat",
   "Nat.linearOrderedCommMonoidWithZero",
   "PartialOrder.toPreorder",
   "Classical.choose",
   "ZeroHom.mk",
   "ZeroHom",
   "dite",
   "Cardinal.partialOrder",
   "Cardinal.toNat.proof_1",
   "Cardinal.linearOrder",
   "Eq",
   "Cardinal.instZeroCardinal",
   "Cardinal.instNatCastCardinal",
   "Cardinal.aleph0",
   "Nat.cast",
   "Preorder.toLT",
   "LT.lt",
   "Cardinal",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "instOfNatNat",
   "Not",
   "Nat"],
  "name": "Cardinal.toNat",
  "constType": "ZeroHom Cardinal.{v} ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [inst : Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Set", "DiscreteMeasurableSpace", "MeasurableSet", "MeasurableSpace"],
  "name": "DiscreteMeasurableSpace.forall_measurableSet",
  "constType":
  "∀ {α : Type u_7} [inst : MeasurableSpace α] [self : DiscreteMeasurableSpace α] (s : Set α), MeasurableSet s",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "OfNat.ofNat",
   "LinearOrderedField",
   "One",
   "OrderedCommSemiring.toOrderedSemiring",
   "One.mk",
   "Ring",
   "CauSeq.Completion.Cauchy",
   "One.toOfNat1",
   "CauSeq.Completion.ofRat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.instOneCauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → One (CauSeq.Completion.Cauchy abv)",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.lift.proof_2",
   "LE.mk",
   "Preorder.toLT",
   "LT.lt",
   "LT.mk",
   "Preorder",
   "Preorder.lift.proof_3",
   "LE.le",
   "Preorder.lift.proof_1",
   "Preorder.toLE",
   "Preorder.mk"],
  "name": "Preorder.lift",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : Preorder β] → (α → β) → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.instLECardinal.match_1",
   "Iff.intro",
   "Equiv",
   "Nonempty.intro",
   "Function.Embedding.congr",
   "instHasEquiv",
   "propext",
   "Function.Embedding",
   "Cardinal.map.match_1",
   "HasEquiv.Equiv",
   "Cardinal.isEquivalent",
   "Nonempty",
   "Equiv.symm",
   "Eq"],
  "name": "Cardinal.instLECardinal.proof_1",
  "constType":
  "∀ (x x_1 x_2 x_3 : Type u_1),\n  x ≈ x_2 → x_1 ≈ x_3 → (fun α β => Nonempty (α ↪ β)) x x_1 = (fun α β => Nonempty (α ↪ β)) x_2 x_3",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Complex.instDecidableEqComplex",
   "MulZeroOneClass.toMulOneClass",
   "Eq.refl",
   "dite",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Complex.Complex.addGroupWithOne",
   "Complex.instSemiringComplex",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Complex.instPowComplex",
   "instHPow",
   "Complex.log_zero",
   "NeZero.charZero_one",
   "Eq.trans",
   "if_neg",
   "Complex.instOneComplex",
   "id",
   "HPow.hPow",
   "eq_self",
   "Complex.instZeroComplex",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "MulOneClass.toOne",
   "Complex.charZero",
   "One.toOfNat1",
   "Complex.exp_zero",
   "instDecidableTrue",
   "ite_congr",
   "Complex.cpow_def",
   "instHMul",
   "instDecidableFalse",
   "Eq.ndrec",
   "of_eq_true",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "congr",
   "HMul.hMul",
   "one_ne_zero",
   "mul_one",
   "Not",
   "Complex",
   "Complex.log",
   "Complex.exp_log",
   "congrArg",
   "Complex.instMulComplex",
   "Complex.exp",
   "congrFun"],
  "name": "Complex.cpow_one",
  "constType": "∀ (x : ℂ), x ^ 1 = x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "OfNat.ofNat",
   "instOfNatInt",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "CommRing",
   "Eq"],
  "name": "CommRing.toNonUnitalCommRing.proof_2",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), Ring.zsmul 0 a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "ZeroHomClass.mk",
   "outParam",
   "ZeroHomClass",
   "AddHomClass.toFunLike",
   "AddMonoidHomClass.toAddHomClass",
   "AddMonoidHomClass",
   "AddMonoidHomClass.map_zero",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toZeroHomClass",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} →\n      [inst : AddZeroClass M] → [inst_1 : AddZeroClass N] → [self : AddMonoidHomClass F M N] → ZeroHomClass F M N",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHDiv",
   "DivisionRing.div_eq_mul_inv",
   "DivisionRing.toRing",
   "Field.toSemifield",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.toInv",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "HDiv.hDiv",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toDiv",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Inv.inv"],
  "name": "CauSeq.Completion.Cauchy.field.proof_2",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a b : CauSeq.Completion.Cauchy abv), a / b = a * b⁻¹",
  "constCategory": "Theorem"},
 {"references": ["Classical.decEq", "DecidableEq", "Complex"],
  "name": "Complex.instDecidableEqComplex",
  "constType": "DecidableEq ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "Real.instLinearOrderedFieldReal.proof_12",
   "zpowRec",
   "_private.Mathlib.Data.Real.Basic.0.Real.inv'",
   "LinearOrder.decidableLE",
   "Monoid.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_5",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.toNontrivial",
   "Inv.mk",
   "Real.linearOrder",
   "LinearOrderedField",
   "LinearOrderedField.mk",
   "Semiring.npow",
   "Div.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "Rat.cast",
   "LinearOrder.toMin",
   "LinearOrder.decidableEq",
   "Real.instInvReal",
   "Real.strictOrderedRing",
   "Real.instLinearOrderedFieldReal.proof_11",
   "Real.instLinearOrderedFieldReal.proof_2",
   "Semigroup.mk",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toPartialOrder",
   "Real.instLinearOrderedFieldReal.proof_13",
   "RatCast.mk",
   "StrictOrderedRing.mk",
   "qsmulRec",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "Real.ratCast",
   "Real.instLinearOrderedFieldReal.proof_7",
   "NonUnitalNonAssocSemiring.toMul",
   "StrictOrderedRing.mul_pos",
   "DivInvMonoid.div'",
   "Ring.toSemiring",
   "Real.instLinearOrderedFieldReal.proof_4",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.instLinearOrderedFieldReal.proof_10",
   "LinearOrderedCommRing.mk",
   "LinearOrder.decidableLT",
   "Real.linearOrderedCommRing",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "Real.instLinearOrderedFieldReal.proof_3",
   "LinearOrderedCommRing",
   "Real.instLinearOrderedFieldReal.proof_6",
   "LinearOrderedCommRing.mul_comm",
   "Real.instLinearOrderedFieldReal.proof_9",
   "Real.instLinearOrderedFieldReal.proof_1",
   "LinearOrderedRing.mk",
   "Real.instLinearOrderedFieldReal.proof_8",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv"],
  "name": "Real.instLinearOrderedFieldReal",
  "constType": "LinearOrderedField ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Finset.card_image_of_injective",
   "Eq.mpr",
   "Finset.image₂_singleton_right",
   "Eq.ndrec",
   "Function.Injective",
   "DecidableEq",
   "Finset.image",
   "Finset.image₂",
   "Finset",
   "Eq.refl",
   "Singleton.singleton",
   "Nat",
   "id",
   "Finset.instSingletonFinset",
   "Eq"],
  "name": "Finset.card_image₂_singleton_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : α → β → γ} (s : Finset α) {b : β},\n  (Function.Injective fun a => f a b) → Finset.card (Finset.image₂ f s {b}) = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "RightDistribClass.mk",
  "constType":
  "∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R], (∀ (a b c : R), (a + b) * c = a * c + b * c) → RightDistribClass R",
  "constCategory": "Other"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "Complex.instZeroComplex",
   "OfNat.ofNat",
   "propext",
   "Real",
   "Complex.ofReal_eq_zero",
   "Complex",
   "Eq"],
  "name": "Mathlib.Data.Complex.Basic._auxLemma.2",
  "constType": "∀ {z : ℝ}, (↑z = 0) = (z = 0)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.mk",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "constCategory": "Other"},
 {"references":
  ["CauSeq.equiv",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "CauSeq",
   "Quotient",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy",
  "constType":
  "{α : Type u_1} →\n  [inst : LinearOrderedField α] →\n    {β : Type u_2} → [inst_1 : Ring β] → (abv : β → α) → [inst : IsAbsoluteValue abv] → Type u_2",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LinearOrderedSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "LT.lt.le",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "Set",
   "le_rfl",
   "Preorder",
   "LT.lt.not_le",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Set.instMembershipSet",
   "GT.gt",
   "Iff.intro",
   "StrictMonoOn",
   "Iff",
   "le_of_not_gt",
   "Preorder.toLT",
   "Eq.rec",
   "LT.lt",
   "LE.le.lt_or_eq_dec",
   "LinearOrder.toPartialOrder",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "Or.elim"],
  "name": "StrictMonoOn.le_iff_le",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β} {s : Set α},\n  StrictMonoOn f s → ∀ {a b : α}, a ∈ s → b ∈ s → (f a ≤ f b ↔ a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne.toSub",
   "instAddNat",
   "instSubNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_add",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Nat.sub_add_cancel",
   "eq_sub_of_add_eq",
   "Eq.mpr",
   "Eq.ndrec",
   "instLENat",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "AddGroupWithOne",
   "Nat",
   "Eq.symm",
   "id"],
  "name": "Nat.cast_sub",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] {m n : ℕ}, m ≤ n → ↑(n - m) = ↑n - ↑m",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "IntCast"],
  "name": "NonAssocRing.toIntCast",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → IntCast α",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Max.max",
   "LinearOrderedAddCommGroup.toMax",
   "LinearOrderedAddCommGroup.decidableLE",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrderedAddCommGroup.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrderedAddCommGroup α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "And", "setOf", "Set", "Set.instMembershipSet"],
  "name": "Set.inter",
  "constType": "{α : Type u_1} → Set α → Set α → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Set.Finite.intro",
   "Set.finite_def.match_2",
   "Nonempty.intro",
   "Fintype",
   "Iff.mp",
   "Set.Elem",
   "Set",
   "Set.finite_def.match_1",
   "Nonempty",
   "Set.Finite"],
  "name": "Set.Finite.nonempty_fintype",
  "constType":
  "∀ {α : Type u} {s : Set α}, Set.Finite s → Nonempty (Fintype ↑s)",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_1} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.image2",
   "Set.instHasSubsetSet",
   "Eq.ndrec",
   "Set.mem_image2_of_mem",
   "Set",
   "HasSubset.Subset",
   "And.casesOn",
   "Exists.casesOn",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.image2_subset",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s s' : Set α} {t t' : Set β},\n  s ⊆ s' → t ⊆ t' → Set.image2 f s t ⊆ Set.image2 f s' t'",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "upperBounds",
   "Set",
   "Preorder",
   "Set.instMembershipSet"],
  "name": "IsGreatest",
  "constType": "{α : Type u} → [inst : Preorder α] → Set α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["Add", "Mul"],
  "name": "LeftDistribClass",
  "constType": "(R : Type u_1) → [inst : Mul R] → [inst : Add R] → Prop",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Semiring.toNonUnitalSemiring",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "Ring.toSub",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_1",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a b : α), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Preorder.le_refl",
  "constType": "∀ {α : Type u} [self : Preorder α] (a : α), a ≤ a",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → GroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Membership.mem",
   "OfNat.ofNat",
   "ZeroHom.toFun",
   "instHAdd",
   "ZeroHom.mk",
   "Subtype.val",
   "HAdd.hAdd",
   "Set",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid.toAddZeroClass",
   "rfl",
   "AddGroup.toSubNegMonoid",
   "SetLike.instMembership",
   "Eq",
   "Set.instMembershipSet",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "AddGroup",
   "AddSubgroup",
   "SubNegMonoid.toAddMonoid",
   "AddSubgroup.instSetLikeAddSubgroup",
   "Subtype",
   "SetLike.coe"],
  "name": "AddSubgroup.subtype.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (x x_1 : ↥H),\n  ZeroHom.toFun { toFun := Subtype.val, map_zero' := (_ : ↑0 = ↑0) } (x + x_1) =\n    ZeroHom.toFun { toFun := Subtype.val, map_zero' := (_ : ↑0 = ↑0) } (x + x_1)",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "CauSeq.Completion.instAddCauchy",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Real.instAddReal",
   "HAdd.hAdd",
   "Real",
   "Real.ext_cauchy",
   "Eq.refl",
   "nsmulRec",
   "AddMonoid.toAddZeroClass",
   "True",
   "Abs.abs",
   "Eq",
   "Rat.instSupRat",
   "Zero.toOfNat0",
   "zero_add",
   "Rat.commRing",
   "Real.cauchy_zero",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "Rat.instNegRat",
   "instOfNatNat",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Add.mk",
   "id",
   "eq_self",
   "Neg.toHasAbs",
   "add_assoc",
   "add_comm",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "AddSemigroup.mk",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Real.cauchy_add",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Rat.instLinearOrderedRingRat",
   "CauSeq.Completion.instZeroCauchy",
   "AddMonoid.mk",
   "Real.instZeroReal",
   "CauSeq.Completion.Cauchy.ring",
   "of_eq_true",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Zero.mk",
   "CauSeq.Completion.Cauchy",
   "congr",
   "CauSeq.Completion.Cauchy.commRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "add_zero",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "Real.cauchy",
   "congrFun"],
  "name": "Real.commRing.proof_6",
  "constType": "∀ (a b : ℝ), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["SMul", "Semiring", "CommSemiring", "Algebra"],
  "name": "Algebra.toSMul",
  "constType":
  "{R : Type u} → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [self : Algebra R A] → SMul R A",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "instLTNat",
   "Eq",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Nat.cast",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.7",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, (0 < ↑n) = (0 < n)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Invertible.invOf",
   "MulOneClass.toMul",
   "Monoid",
   "invertibleMul.proof_1",
   "Monoid.toOne",
   "invertibleMul.proof_2",
   "HMul.hMul",
   "Invertible.mk",
   "Monoid.toMulOneClass",
   "Invertible"],
  "name": "invertibleMul",
  "constType":
  "{α : Type u} → [inst : Monoid α] → (a b : α) → [inst_1 : Invertible a] → [inst_2 : Invertible b] → Invertible (a * b)",
  "constCategory": "Definition"},
 {"references": ["Ordering"],
  "name": "Ordering.lt",
  "constType": "Ordering",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "instHMul",
   "Subsemigroup.rec",
   "Subsemigroup.mk",
   "Set",
   "Subsemigroup",
   "HMul.hMul",
   "Mul",
   "Set.instMembershipSet"],
  "name": "Subsemigroup.casesOn",
  "constType":
  "{M : Type u_4} →\n  [inst : Mul M] →\n    {motive : Subsemigroup M → Sort u} →\n      (t : Subsemigroup M) →\n        ((carrier : Set M) →\n            (mul_mem' : ∀ {a b : M}, a ∈ carrier → b ∈ carrier → a * b ∈ carrier) →\n              motive { carrier := carrier, mul_mem' := mul_mem' }) →\n          motive t",
  "constCategory": "Definition"},
 {"references": ["Int.casesOn", "Int.ofNat", "Int.negSucc", "Nat", "Int"],
  "name": "zpowRec.match_1",
  "constType":
  "{M : Type u_2} →\n  (motive : ℤ → M → Sort u_1) →\n    (x : ℤ) →\n      (x_1 : M) →\n        ((n : ℕ) → (a : M) → motive (Int.ofNat n) a) → ((n : ℕ) → (a : M) → motive (Int.negSucc n) a) → motive x x_1",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "instHDiv",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.toInv",
   "DivisionSemiring.toDiv",
   "HDiv.hDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Inv.inv",
   "Eq"],
  "name": "DivisionSemiring.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax"],
  "name": "autoParam",
  "constType": "Sort u → Lean.Syntax → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "Complex.instNegComplex",
   "instHAdd",
   "HAdd.hAdd",
   "Neg.neg",
   "Complex.instAddComplex",
   "Semiring.toNatCast",
   "Complex.instSemiringComplex",
   "instHMul",
   "Complex.instField",
   "HMul.hMul",
   "Complex",
   "HDiv.hDiv",
   "Field.toDiv",
   "Complex.instMulComplex",
   "instOfNat",
   "Complex.cos.proof_1",
   "Complex.exp",
   "Complex.I"],
  "name": "Complex.cos",
  "constType": "ℂ → ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "DivisionRing",
   "DivisionRing.toDivisionSemiring",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "instHMul",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "CauSeq.Completion.Cauchy.ring",
   "Semiring.npow",
   "OrderedCommSemiring.toOrderedSemiring",
   "HMul.hMul",
   "CauSeq.Completion.Cauchy",
   "instOfNatNat",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.divisionRing.proof_5",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : DivisionRing β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (n : ℕ) (x : CauSeq.Completion.Cauchy abv),\n  Semiring.npow (n + 1) x = x * Semiring.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteSemilatticeInf.toPartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder.match_1",
   "PartialOrder.toPreorder",
   "FunLike.coe",
   "iSup",
   "LE.le",
   "Preorder.toLE",
   "RelHomClass.toFunLike",
   "le_iSup_of_le",
   "OrderHom.mk",
   "CompleteLattice",
   "instLENat",
   "StrictOrderedSemiring.toPartialOrder",
   "OmegaCompletePartialOrder.Chain",
   "OmegaCompletePartialOrder.Chain.instOrderHomClassChainNatInstLENatToLE",
   "le_refl",
   "Monotone",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Nat",
   "CompleteLattice.toSupSet",
   "id",
   "Nat.strictOrderedSemiring"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
  "constType":
  "∀ (α : Type u_1) [inst : CompleteLattice α] (x : OmegaCompletePartialOrder.Chain α) (i : ℕ), x i ≤ (fun c => ⨆ i, c i) x",
  "constCategory": "Theorem"},
 {"references": ["Nat.le", "Nat", "Nat.succ"],
  "name": "Nat.le.step",
  "constType": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "constCategory": "Other"},
 {"references":
  ["AddMonoidWithOne",
   "inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u_1} → [inst : Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev",
   "congrFun"],
  "name": "sub_sub",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b c : α), a - b - c = a - (b + c)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribLattice.toLattice",
   "inferInstance",
   "Prop.booleanAlgebra",
   "PartialOrder.toPreorder",
   "Pi.booleanAlgebra",
   "Preorder.le_trans",
   "Lattice.toSemilatticeSup",
   "BooleanAlgebra.toDistribLattice",
   "LE.le",
   "Preorder.toLE",
   "BooleanAlgebra",
   "SemilatticeSup.toPartialOrder"],
  "name": "Set.instBooleanAlgebraSet.proof_2",
  "constType": "∀ {α : Type u_1} (a b c : α → Prop), a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.head",
  "constType": "∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)",
  "constCategory": "Other"},
 {"references": ["Top", "CompleteLattice"],
  "name": "CompleteLattice.toTop",
  "constType": "{α : Type u_9} → [self : CompleteLattice α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Exists.intro",
   "MeasureTheory.IsProbabilityMeasure",
   "ProbabilityTheory.IdentDistrib",
   "Exists.casesOn",
   "MeasureTheory.MeasureSpace.volume",
   "Matrix.vecEmpty",
   "MeasureTheory.Measure",
   "And",
   "MeasureTheory.MeasureSpace.toMeasurableSpace",
   "MeasureTheory.MeasureSpace",
   "ProbabilityTheory.iIndepFun",
   "instOfNatNat",
   "Measurable",
   "And.intro",
   "Matrix.vecCons",
   "Nat",
   "And.casesOn",
   "MeasurableSpace",
   "Nat.succ",
   "Fin"],
  "name": "tau_strictly_decreases.match_1",
  "constType":
  "∀ {Ω : Type u_1} [mΩ : MeasureTheory.MeasureSpace Ω] {G : Type u_2} [inst : MeasurableSpace G] {X₁ X₂ : Ω → G}\n  (motive :\n    (∃ A mA μA X₁' X₂' X₃' X₄',\n        MeasureTheory.IsProbabilityMeasure μA ∧\n          ProbabilityTheory.iIndepFun (fun x => inst) ![X₁', X₂', X₃', X₄'] ∧\n            Measurable X₁' ∧\n              Measurable X₂' ∧\n                Measurable X₃' ∧\n                  Measurable X₄' ∧\n                    ProbabilityTheory.IdentDistrib X₁' X₁ ∧\n                      ProbabilityTheory.IdentDistrib X₂' X₂ ∧\n                        ProbabilityTheory.IdentDistrib X₃' X₁ ∧ ProbabilityTheory.IdentDistrib X₄' X₂) →\n      Prop)\n  (x :\n    ∃ A mA μA X₁' X₂' X₃' X₄',\n      MeasureTheory.IsProbabilityMeasure μA ∧\n        ProbabilityTheory.iIndepFun (fun x => inst) ![X₁', X₂', X₃', X₄'] ∧\n          Measurable X₁' ∧\n            Measurable X₂' ∧\n              Measurable X₃' ∧\n                Measurable X₄' ∧\n                  ProbabilityTheory.IdentDistrib X₁' X₁ ∧\n                    ProbabilityTheory.IdentDistrib X₂' X₂ ∧\n                      ProbabilityTheory.IdentDistrib X₃' X₁ ∧ ProbabilityTheory.IdentDistrib X₄' X₂),\n  (∀ (A : Type u_1) (mA : MeasurableSpace A) (μ : MeasureTheory.Measure A) (Y₁ Y₂ Y₁' Y₂' : A → G)\n      (hμ : MeasureTheory.IsProbabilityMeasure μ)\n      (h_indep : ProbabilityTheory.iIndepFun (fun x => inst) ![Y₁, Y₂, Y₁', Y₂']) (hY₁ : Measurable Y₁)\n      (hY₂ : Measurable Y₂) (hY₁' : Measurable Y₁') (hY₂' : Measurable Y₂')\n      (h_id1 : ProbabilityTheory.IdentDistrib Y₁ X₁) (h_id2 : ProbabilityTheory.IdentDistrib Y₂ X₂)\n      (h_id1' : ProbabilityTheory.IdentDistrib Y₁' X₁) (h_id2' : ProbabilityTheory.IdentDistrib Y₂' X₂),\n      motive\n        (_ :\n          ∃ A mA μA X₁' X₂' X₃' X₄',\n            MeasureTheory.IsProbabilityMeasure μA ∧\n              ProbabilityTheory.iIndepFun (fun x => inst) ![X₁', X₂', X₃', X₄'] ∧\n                Measurable X₁' ∧\n                  Measurable X₂' ∧\n                    Measurable X₃' ∧\n                      Measurable X₄' ∧\n                        ProbabilityTheory.IdentDistrib X₁' X₁ ∧\n                          ProbabilityTheory.IdentDistrib X₂' X₂ ∧\n                            ProbabilityTheory.IdentDistrib X₃' X₁ ∧ ProbabilityTheory.IdentDistrib X₄' X₂)) →\n    motive x",
  "constCategory": "Definition"},
 {"references":
  ["NormedRing",
   "DivisionRing.toRing",
   "NormedDivisionRing.toDivisionRing",
   "NormedDivisionRing.toNormedRing.proof_1",
   "NormedDivisionRing.toNorm",
   "NormedRing.mk",
   "NormedDivisionRing",
   "NormedDivisionRing.dist_eq",
   "NormedDivisionRing.toMetricSpace"],
  "name": "NormedDivisionRing.toNormedRing",
  "constType": "{α : Type u_1} → [β : NormedDivisionRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsGLB",
   "Set",
   "Monotone.mem_lowerBounds_image",
   "Preorder",
   "And.left",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "upperBounds",
   "And.right",
   "Iff",
   "Iff.mp",
   "lowerBounds",
   "And.intro",
   "Set.image",
   "Set.mem_image_of_mem"],
  "name": "IsGLB.of_image",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},\n  (∀ {x y : α}, f x ≤ f y ↔ x ≤ y) → ∀ {s : Set α} {x : α}, IsGLB (f '' s) (f x) → IsGLB s x",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "congr_arg", "Function.Injective", "Eq"],
  "name": "Function.Injective.eq_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α}, f a = f b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedField", "IsCauSeq", "Ring", "Nat", "Subtype"],
  "name": "CauSeq",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → (β : Type u_2) → [inst : Ring β] → (β → α) → Type u_2",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_nonneg",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddGroup",
   "propext",
   "CovariantClass",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Algebra.Order.Ring.Defs._auxLemma.2",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α},\n  (0 ≤ a - b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "Int.rawCast",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Ring.toNeg",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Nat.addMonoid",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "neg_mul",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "Int.negOfNat",
   "MulOneClass.toOne",
   "instHAdd",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.negSucc",
   "Int.cast",
   "HMul.hMul",
   "congrArg",
   "congrFun"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {a b : R}, Int.rawCast (Int.negOfNat 1) * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff.mp",
   "List.mem_range",
   "List.instMembershipList",
   "List",
   "LT.lt",
   "Nat",
   "instLTNat",
   "List.range"],
  "name": "List.finRange.proof_1",
  "constType": "∀ (n x : ℕ), x ∈ List.range n → x < n",
  "constCategory": "Theorem"},
 {"references":
  ["Nonempty.intro", "Inhabited", "Nonempty", "Inhabited.default"],
  "name": "instNonempty",
  "constType": "∀ {α : Sort u} [inst : Inhabited α], Nonempty α",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup",
   "SemilatticeSup.toSup",
   "PartialOrder.toPreorder",
   "SemilatticeSup.le_sup_right",
   "Sup.sup",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "le_sup_right",
  "constType": "∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instStrictOrderedCommRingReal.proof_2",
   "StrictOrderedCommRing",
   "StrictOrderedCommRing.mk",
   "PartialOrder.mk",
   "PartialOrder.toPreorder",
   "Real.partialOrder",
   "Semiring",
   "Real",
   "StrictOrderedRing.mk",
   "Real.commRing",
   "CommRing.mul_comm",
   "CommRing",
   "PartialOrder",
   "Real.instStrictOrderedCommRingReal.proof_3",
   "Real.semiring",
   "Real.instStrictOrderedCommRingReal.proof_1",
   "CommRing.toRing",
   "PartialOrder.le_antisymm",
   "Real.mul_pos"],
  "name": "Real.instStrictOrderedCommRingReal",
  "constType": "StrictOrderedCommRing ℝ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "EmptyCollection.emptyCollection",
   "Set.add",
   "instHAdd",
   "Set",
   "HAdd.hAdd",
   "Set.instEmptyCollectionSet",
   "add_right_injective",
   "Set.Finite",
   "Eq",
   "Set.instMembershipSet",
   "add_left_injective",
   "Function.Injective.injOn",
   "And",
   "Iff",
   "IsRightCancelAdd",
   "Add",
   "IsLeftCancelAdd",
   "Set.finite_image2"],
  "name": "Set.finite_add",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] [inst_1 : IsLeftCancelAdd α] [inst_2 : IsRightCancelAdd α] {s t : Set α},\n  Set.Finite (s + t) ↔ Set.Finite s ∧ Set.Finite t ∨ s = ∅ ∨ t = ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.mpr",
   "Set.image2",
   "Eq.ndrec",
   "Set.image_id'",
   "Set.image_image2_distrib",
   "Set",
   "Eq.refl",
   "Set.image",
   "Eq.trans",
   "id",
   "Eq"],
  "name": "Set.image_image2_distrib_right",
  "constType":
  "∀ {α : Type u_1} {β : Type u_3} {β' : Type u_4} {γ : Type u_5} {δ : Type u_7} {f : α → β → γ} {s : Set α} {t : Set β}\n  {g : γ → δ} {f' : α → β' → δ} {g' : β → β'},\n  (∀ (a : α) (b : β), g (f a b) = f' a (g' b)) → g '' Set.image2 f s t = Set.image2 f' s (g' '' t)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Real.instSubReal",
   "Real",
   "HSub.hSub",
   "Eq.refl",
   "Sub.sub",
   "Eq",
   "Sub.mk"],
  "name": "Real.commRing.proof_18",
  "constType": "∀ (a b : ℝ), a - b = a - b",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "Ord"],
  "name": "LinearOrderedRing.toOrd",
  "constType": "{α : Type u} → [self : LinearOrderedRing α] → Ord α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.right_distrib",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a b c : α), (a + b) * c = a * c + b * c",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Neg.toHasAbs",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "DivisionRing.toRing",
   "CauSeq.instSubCauSeq",
   "instDistribLattice",
   "LT",
   "HSub.hSub",
   "LinearOrderedField.toLinearOrderedCommRing",
   "CauSeq",
   "LT.mk",
   "CauSeq.Pos",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
   "Abs.abs",
   "DistribLattice.toLattice",
   "LinearOrderedField",
   "LinearOrderedRing.toLinearOrder",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "LinearOrderedField.toField",
   "Lattice.toSemilatticeSup",
   "Field.toDivisionRing"],
  "name":
  "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
  "constType":
  "{α : Type u_1} → [inst : LinearOrderedField α] → LT (CauSeq α abs)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "Rat.nonneg_antisymm",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Rat.instLERat",
   "CommRing.toNonUnitalCommRing",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "sub_eq_add_neg",
   "neg_neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "SubNegMonoid.toSub",
   "Rat.commRing",
   "Rat.addCommGroup",
   "Rat.le_iff_Nonneg",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Rat.Nonneg",
   "Rat.instMulRat",
   "eq_neg_of_add_eq_zero_left",
   "Eq.symm",
   "Rat.addGroup",
   "instHSub",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Rat.instSubRat",
   "Eq.ndrec",
   "SubtractionMonoid.toSubNegMonoid",
   "propext",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "neg_sub"],
  "name": "Rat.le_antisymm",
  "constType": "∀ {a b : ℚ}, a ≤ b → b ≤ a → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "One.toOfNat1",
   "Complex.one_cpow",
   "True",
   "Eq",
   "Complex.re",
   "Real.instOneReal",
   "of_eq_true",
   "Complex.instPowComplex",
   "instHPow",
   "Real.instPowReal",
   "Complex",
   "congrArg",
   "Eq.trans",
   "Complex.instOneComplex",
   "congrFun"],
  "name": "Real.one_rpow",
  "constType": "∀ (x : ℝ), 1 ^ x = 1",
  "constCategory": "Theorem"},
 {"references": ["Abs"],
  "name": "Abs.abs",
  "constType": "{α : Type u_1} → [self : Abs α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "HAdd.hAdd",
   "Set",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Iff.of_eq",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Set.Elem",
   "AddSubgroup.IsComplement.existsUnique",
   "AddSubgroup.IsComplement",
   "Eq.trans",
   "Subtype",
   "id",
   "Mathlib.GroupTheory.Complement._auxAddLemma.1",
   "Membership.mem",
   "funext",
   "Set.add",
   "Prod.snd",
   "Std.Logic._auxLemma.39",
   "instHAdd",
   "Prod.fst",
   "Set.univ",
   "Std.Logic._auxLemma.51",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "And",
   "Set.eq_univ_of_forall",
   "Prod.mk",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "Prod",
   "congrArg",
   "Mathlib.Data.Prod.Basic._auxLemma.2",
   "Subtype.mk",
   "ExistsUnique.exists",
   "exists_prop_congr'"],
  "name": "AddSubgroup.IsComplement.add_eq",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] {S T : Set G}, AddSubgroup.IsComplement S T → S + T = Set.univ",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Infinite.not_finite",
   "Iff",
   "Infinite",
   "Finite",
   "Not",
   "Infinite.mk"],
  "name": "not_finite_iff_infinite",
  "constType": "∀ {α : Sort u_1}, ¬Finite α ↔ Infinite α",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Invertible.invOf",
   "One",
   "HMul.hMul",
   "One.toOfNat1",
   "Mul",
   "Invertible.mul_invOf_self",
   "Invertible",
   "Eq"],
  "name": "mul_invOf_self'",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) {x : Invertible a}, a * ⅟a = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Real",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "Preorder.toLE",
   "Subtype.property",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "HMul.hMul",
   "CovariantClass.mk",
   "MonoidWithZero.toZero",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "MulPosMono",
   "Subtype",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toMulPosMono",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], MulPosMono α",
  "constCategory": "Definition"},
 {"references":
  ["eq_true", "le_refl", "Preorder", "LE.le", "True", "Preorder.toLE", "Eq"],
  "name": "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.7",
  "constType": "∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.nsmul",
   "OfNat.ofNat",
   "AddGroup",
   "instAddNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.nsmul_succ",
   "instOfNatNat",
   "Nat",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "AddGroup.toAddCancelMonoid.proof_5",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (n : ℕ) (x : G), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x",
  "constCategory": "Theorem"},
 {"references":
  ["Real.instZeroReal",
   "Zero.toOfNat0",
   "Complex.ofReal'",
   "Complex.im",
   "OfNat.ofNat",
   "Real",
   "rfl",
   "Eq"],
  "name": "Complex.ofReal_im",
  "constType": "∀ (r : ℝ), (↑r).im = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "LE.le",
   "Preorder.toLE",
   "DecidableRel"],
  "name": "LinearOrderedAddCommGroup.decidableLE",
  "constType":
  "{α : Type u} → [self : LinearOrderedAddCommGroup α] → DecidableRel fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddGroup.add_left_neg",
   "OfNat.ofNat",
   "AddGroup",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "add_left_neg",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a : G), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "Add",
   "AddSubsemigroup.carrier",
   "Set.instMembershipSet",
   "AddSubsemigroup"],
  "name": "AddSubsemigroup.add_mem'",
  "constType":
  "∀ {M : Type u_4} [inst : Add M] (self : AddSubsemigroup M) {a b : M},\n  a ∈ self.carrier → b ∈ self.carrier → a + b ∈ self.carrier",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "OrderedRing",
   "AddGroup.toSubtractionMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "Iff.mpr",
   "Preorder.toLE",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "OrderedRing.toRing",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "OrderedRing.mul_nonneg",
   "AddMonoid.toZero",
   "AddCommGroup.toAddGroup",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "id",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "OrderedRing.toOrderedAddCommGroup",
   "HSub.hSub",
   "Mathlib.Algebra.Order.Ring.Defs._auxLemma.2",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "sub_nonneg",
   "SubNegZeroMonoid.toNegZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "OrderedRing.toPartialOrder",
   "instHMul",
   "mul_sub",
   "Eq.mp",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NegZeroClass.toZero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "OrderedRing.toOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedRing α] (a b c : α), a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["PProd",
   "PUnit.unit",
   "Nat.rec",
   "Nat.below",
   "Nat.zero",
   "PUnit",
   "Nat",
   "Nat.succ",
   "PProd.mk"],
  "name": "Nat.brecOn",
  "constType":
  "{motive : ℕ → Sort u} → (t : ℕ) → ((t : ℕ) → Nat.below t → motive t) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_self",
   "Set",
   "Set.biInter_range",
   "AddSubmonoid",
   "True",
   "Eq",
   "Set.instMembershipSet",
   "Set.range",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "iInf",
   "of_eq_true",
   "Set.iInter",
   "AddSubmonoid.instInfSetAddSubmonoid",
   "congrArg",
   "AddZeroClass",
   "Eq.trans",
   "SetLike.coe",
   "congrFun"],
  "name": "AddSubmonoid.coe_iInf",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] {ι : Sort u_4} {S : ι → AddSubmonoid M}, ↑(⨅ i, S i) = ⋂ i, ↑(S i)",
  "constCategory": "Theorem"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "Semiring",
   "AddMonoid.toZero",
   "AddCommMonoid.toAddMonoid",
   "instOfNatNat",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semiring.toNatCast",
   "NatCast.natCast",
   "Eq"],
  "name": "Semiring.natCast_zero",
  "constType": "∀ {α : Type u} [self : Semiring α], NatCast.natCast 0 = 0",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "One.toOfNat1",
   "MulAction",
   "Eq"],
  "name": "MulAction.one_smul",
  "constType":
  "∀ {α : Type u_10} {β : Type u_11} [inst : Monoid α] [self : MulAction α β] (b : β), 1 • b = b",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Mathlib.Meta.NormNum.IsNat.rec",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.casesOn",
  "constType":
  "{α : Type u_1} →\n  [inst : AddMonoidWithOne α] →\n    {a : α} →\n      {n : ℕ} →\n        {motive : Mathlib.Meta.NormNum.IsNat a n → Sort u} →\n          (t : Mathlib.Meta.NormNum.IsNat a n) →\n            ((out : a = ↑n) → motive (_ : Mathlib.Meta.NormNum.IsNat a n)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["PartialOrder.toPreorder",
   "Filter.map",
   "Filter.instPartialOrderFilter",
   "Filter",
   "LE.le",
   "Preorder.toLE"],
  "name": "Filter.Tendsto",
  "constType":
  "{α : Type u} → {β : Type v} → (α → β) → Filter α → Filter β → Prop",
  "constCategory": "Definition"},
 {"references": ["Setoid", "Quotient.out", "Quotient"],
  "name": "Quotient.out'",
  "constType": "{α : Sort u_1} → {s₁ : Setoid α} → Quotient s₁ → α",
  "constCategory": "Definition"},
 {"references":
  ["mul_eq_zero",
   "OfNat.ofNat",
   "Or",
   "Iff.rfl",
   "eq_comm",
   "MulZeroClass",
   "Eq.refl",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "propext",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "id"],
  "name": "zero_eq_mul",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "AddGroupWithOne.toIntCast",
   "neg_zero",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "neg_neg",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Nat.add",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.cast_negSucc",
   "Nat",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Int.cast_ofNat",
   "Int.cast_zero",
   "Int.cast_neg.match_1",
   "Eq.ndrec",
   "instNatCastInt",
   "Int.negSucc",
   "Int.cast",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Int.cast_neg",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℤ), ↑(-n) = -↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Set.Finite.mem_toFinset",
   "Set",
   "Finset",
   "Finset.instMembershipFinset",
   "Set.Finite.toFinset",
   "Set.Finite",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.Data.Set.Finite._auxLemma.3",
  "constType":
  "∀ {α : Type u} {s : Set α} {a : α} (hs : Set.Finite s), (a ∈ Set.Finite.toFinset hs) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Complex.Complex.addGroupWithOne.proof_6",
   "OfNat.ofNat",
   "Real.natCast",
   "SubNegMonoid.toNeg",
   "Real",
   "NatCast.mk",
   "Complex.Complex.addGroupWithOne.proof_7",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Nat.cast",
   "Complex.Complex.addGroupWithOne.proof_3",
   "Complex.Complex.addGroupWithOne.proof_2",
   "AddGroupWithOne",
   "AddCommGroup.toAddGroup",
   "Nat",
   "AddMonoidWithOne.mk",
   "Complex.instOneComplex",
   "Complex.Complex.addGroupWithOne.proof_5",
   "Complex.Complex.addGroupWithOne.proof_9",
   "Complex.Complex.addGroupWithOne.proof_1",
   "Complex.addCommGroup",
   "One.mk",
   "One.toOfNat1",
   "Real.intCast",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "IntCast.mk",
   "Int.cast",
   "Complex.mk",
   "Complex.Complex.addGroupWithOne.proof_4",
   "Complex.Complex.addGroupWithOne.proof_8",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "Complex",
   "AddCommGroup",
   "Int"],
  "name": "Complex.Complex.addGroupWithOne",
  "constType": "AddGroupWithOne ℂ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Int.ofNat",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "DivisionSemiring",
   "HMul.hMul",
   "DivisionSemiring.zpow",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.succ",
   "Eq"],
  "name": "DivisionSemiring.zpow_succ'",
  "constType":
  "∀ {α : Type u_4} [self : DivisionSemiring α] (n : ℕ) (a : α),\n  DivisionSemiring.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionSemiring.zpow (Int.ofNat n) a",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "instRatCastRat",
   "OfNat.ofNat",
   "instHDiv",
   "RatCast.mk",
   "Rat.num_div_den",
   "Rat.instIntCastRat",
   "Rat",
   "Rat.num",
   "Rat.semiring",
   "Rat.mk'",
   "Eq",
   "Semiring.toNatCast",
   "Rat.instDivRat",
   "Nat.cast",
   "Int.cast",
   "Rat.cast",
   "Rat.den",
   "Nat.Coprime",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "Int",
   "Int.natAbs"],
  "name": "Rat.field.proof_5",
  "constType":
  "∀ (a : ℤ) (b : ℕ) (h1 : b ≠ 0) (h2 : Nat.Coprime (Int.natAbs a) b),\n  ↑(Rat.mk' a b) = ↑(↑(Rat.mk' a b)).num / ↑(↑(Rat.mk' a b)).den",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "mul_div_assoc",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toDiv"],
  "name": "mul_div_assoc'",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * (b / c) = a * b / c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "not_lt_of_ge",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_of_not_gt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "add_right_neg",
   "Eq.mpr",
   "Eq.ndrec",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_self",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "rfl"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat (Nat.rawCast n) n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "NormedAddCommGroup",
  "constType": "Type u_9 → Type u_9",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "CommRing.toNonUnitalCommRing",
   "AddCommMonoid.toAddMonoid",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Iff.mp",
   "AddMonoid.toZero",
   "Field",
   "MulZeroClass.toZero",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Ne",
   "mul_eq_zero",
   "Or",
   "False",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "DivisionSemiring.toGroupWithZero",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Or.casesOn",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "And",
   "instHMul",
   "Field.toEuclideanDomain.match_2",
   "CommRing.toRing",
   "HMul.hMul",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.noZeroDivisors",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Field.toEuclideanDomain.proof_5",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (a b : K), b ≠ 0 → a * b = 0 ∧ a ≠ 0 → False",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.le_add_right",
   "PartialOrder.toPreorder",
   "OrderBot",
   "Preorder.toLE",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_2",
   "Multiset.instPartialOrderMultiset",
   "Multiset.instCanonicallyOrderedAddCommMonoidMultiset.proof_1",
   "Multiset.instOrderedCancelAddCommMonoidMultiset",
   "Multiset",
   "OrderBot.toBot",
   "CanonicallyOrderedAddCommMonoid",
   "inferInstanceAs",
   "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "OrderBot.mk",
   "CanonicallyOrderedAddCommMonoid.mk",
   "OrderedAddCommMonoid.toPartialOrder"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoidMultiset",
  "constType": "{α : Type u_1} → CanonicallyOrderedAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv", "Setoid", "Cardinal.isEquivalent.proof_1", "Setoid.mk", "Nonempty"],
  "name": "Cardinal.isEquivalent",
  "constType": "Setoid (Type u)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "NonUnitalNonAssocSemiring",
   "OfNat.ofNat",
   "AddMonoid.toZero",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocSemiring.mul_zero",
  "constType":
  "∀ {α : Type u} [self : NonUnitalNonAssocSemiring α] (a : α), a * 0 = 0",
  "constCategory": "Definition"},
 {"references": ["outParam", "Add"],
  "name": "AddHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : Add M] → [inst : Add N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "HMul.hMul",
   "NonUnitalCommSemiring",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq"],
  "name": "NonUnitalCommSemiring.mul_comm",
  "constType":
  "∀ {α : Type u} [self : NonUnitalCommSemiring α] (a b : α), a * b = b * a",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "And",
   "Set",
   "And.intro",
   "Exists.intro",
   "Set.instMembershipSet"],
  "name": "Set.Set.completeAtomicBooleanAlgebra.proof_1",
  "constType":
  "∀ {α : Type u_1} (s : Set (Set α)), ∀ t ∈ s, ∀ a ∈ t, ∃ t ∈ s, a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "MulOneClass.toMul",
   "Iff.rfl",
   "div_eq_mul_inv",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "DivisionMonoid",
   "instHMul",
   "Eq.mpr",
   "Eq.ndrec",
   "Iff",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "IsUnit.mul_inv_eq_iff_eq_mul",
   "IsUnit",
   "HDiv.hDiv",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "IsUnit.div_eq_iff",
  "constType":
  "∀ {α : Type u_3} [inst : DivisionMonoid α] {a b c : α}, IsUnit b → (a / b = c ↔ a = c * b)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedSemiring", "Semiring"],
  "name": "StrictOrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : StrictOrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Pow",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Bot.bot",
   "OfNat.ofNat",
   "AddSubgroup.zero_mem",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "Iff.mp",
   "AddGroup",
   "Eq.rec",
   "AddSubgroup.mem_bot",
   "AddSubgroup",
   "Bot.mk",
   "AddSubgroup.instBotAddSubgroup",
   "Eq.symm",
   "AddSubgroup.instSetLikeAddSubgroup",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_9",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (S : AddSubgroup G), ∀ _x ∈ ⊥, _x ∈ S",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "RingHomClass.toRingHom.proof_3",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "RingHom.mk",
   "NonAssocSemiring",
   "AddMonoidHomClass.toAddMonoidHom",
   "RingHomClass.toAddMonoidHomClass",
   "RingHomClass.toRingHom.proof_1",
   "RingHomClass.toMonoidHomClass",
   "MonoidHom.toOneHom",
   "RingHomClass.toRingHom.proof_2",
   "MonoidHom.mk",
   "AddMonoidHom"],
  "name": "RingHomClass.toRingHom",
  "constType":
  "{F : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → [inst : RingHomClass F α β] → F → α →+* β",
  "constCategory": "Definition"},
 {"references":
  ["Complex.ofReal'",
   "OfNat.ofNat",
   "Real",
   "Eq.refl",
   "Complex.ofReal_exp_ofReal_re",
   "Eq",
   "Complex.re",
   "Complex.ofReal_im",
   "Complex.im",
   "Zero.toOfNat0",
   "Real.instZeroReal",
   "Eq.mpr",
   "Eq.ndrec",
   "Complex",
   "Eq.symm",
   "Complex.exp",
   "id"],
  "name": "Complex.exp_ofReal_im",
  "constType": "∀ (x : ℝ), (Complex.exp ↑x).im = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Inv.inv",
   "Eq"],
  "name": "CommGroupWithZero.inv_zero",
  "constType": "∀ {G₀ : Type u_4} [self : CommGroupWithZero G₀], 0⁻¹ = 0",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "OfNat.ofNat",
   "Unit",
   "Nat.not_succ_le_self.match_1",
   "rfl",
   "Eq",
   "PProd",
   "Nat.ble",
   "PProd.fst",
   "Nat.rec",
   "Bool.true",
   "PUnit",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Nat.succ"],
  "name": "Nat.ble_self_eq_true",
  "constType": "∀ (n : ℕ), Nat.ble n n = true",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Real.instZeroReal",
   "Nonneg.zero",
   "Real",
   "Real.instPreorderReal",
   "NNReal"],
  "name": "instNNRealZero",
  "constType": "Zero NNReal",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "SubNegMonoid",
   "Monoid.toSemigroup",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Multiplicative.monoid",
   "Eq",
   "instHMul",
   "Multiplicative",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "instOfNatNat",
   "Monoid.npow_succ",
   "Nat",
   "Monoid.npow"],
  "name": "Multiplicative.divInvMonoid.proof_4",
  "constType":
  "∀ {α : Type u_1} [inst : SubNegMonoid α] (n : ℕ) (x : Multiplicative α), Monoid.npow (n + 1) x = x * Monoid.npow n x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "MeasureTheory.OuterMeasure.empty'",
   "Set",
   "HasCompl.compl",
   "Set.compl_univ",
   "Set.instEmptyCollectionSet",
   "BooleanAlgebra.toHasCompl",
   "Set.univ",
   "instENNRealZero",
   "True",
   "Eq",
   "MeasureTheory.Measure",
   "Zero.toOfNat0",
   "ENNReal",
   "MeasureTheory.OuterMeasure.measureOf",
   "Set.instBooleanAlgebraSet",
   "of_eq_true",
   "MeasureTheory.Measure.toOuterMeasure",
   "congrArg",
   "MeasurableSpace",
   "Eq.trans",
   "congrFun"],
  "name": "MeasureTheory.Measure.ae.proof_1",
  "constType":
  "∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α), ↑↑μ Set.univᶜ = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Fintype.elems",
   "Finset",
   "Finset.instMembershipFinset"],
  "name": "Fintype.complete",
  "constType": "∀ {α : Type u_4} [self : Fintype α] (x : α), x ∈ Fintype.elems",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Set.add",
   "Set.mem_add",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "Set",
   "Add",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Mathlib.GroupTheory.Complement._auxAddLemma.1",
  "constType":
  "∀ {α : Type u_2} [inst : Add α] {s t : Set α} {a : α}, (a ∈ s + t) = ∃ x y, x ∈ s ∧ y ∈ t ∧ x + y = a",
  "constCategory": "Theorem"},
 {"references":
  ["MeasureTheory.Measure",
   "Filter.EventuallyEq",
   "Filter.EventuallyEq.rfl",
   "MeasureTheory.Measure.ae",
   "MeasurableSpace"],
  "name": "MeasureTheory.ae_eq_refl",
  "constType":
  "∀ {α : Type u_1} {δ : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} (f : α → δ),\n  f =ᶠ[MeasureTheory.Measure.ae μ] f",
  "constCategory": "Theorem"},
 {"references":
  ["Set.instSProd",
   "Equiv",
   "Equiv.subtypeProdEquivProd",
   "Set.Elem",
   "SProd.sprod",
   "Set",
   "Prod"],
  "name": "Equiv.Set.prod",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (s : Set α) → (t : Set β) → ↑(s ×ˢ t) ≃ ↑s × ↑t",
  "constCategory": "Definition"},
 {"references":
  ["Mul.toSMul",
   "instHMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "Mul",
   "rfl",
   "Eq"],
  "name": "smul_eq_mul",
  "constType": "∀ (α : Type u_10) [inst : Mul α] {a a' : α}, a • a' = a * a'",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "instHDiv",
   "DivisionSemiring.toGroupWithZero",
   "Field",
   "Field.toSemifield",
   "Semifield.toDivisionSemiring",
   "HDiv.hDiv",
   "div_zero",
   "MonoidWithZero.toZero",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.toDiv",
   "Eq"],
  "name": "Field.toEuclideanDomain.proof_1",
  "constType": "∀ {K : Type u_1} [inst : Field K] (a : K), a / 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Real.orderedAddCommGroup",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "Real.instLEReal",
   "Real.instMulReal",
   "AddGroup.toSubtractionMonoid",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.9",
   "Real.pi",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Real.instPowReal",
   "Complex.ofReal_cpow",
   "le_of_lt",
   "Eq.trans",
   "HPow.hPow",
   "Real.partialOrder",
   "Complex.im",
   "instHMul",
   "eq_true",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "propext",
   "LT.lt",
   "Complex.cpow_mul",
   "Real.instAddGroupReal",
   "Complex.log",
   "congrArg",
   "congrFun",
   "AddZeroClass.toAdd",
   "Real",
   "Mathlib.Analysis.SpecialFunctions.Pow.Real._auxLemma.8",
   "Eq.refl",
   "Complex.ofReal_log",
   "AddMonoid.toAddZeroClass",
   "True",
   "Real.instNegReal",
   "Zero.toOfNat0",
   "Complex.ofReal_mul",
   "Complex.instPowComplex",
   "instHPow",
   "AddGroup.toAddCancelMonoid",
   "Eq.symm",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Complex.ofReal'",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Real.instLTReal",
   "Complex.ofReal_inj",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "Real.instZeroReal",
   "Real.pi_pos",
   "Real.log",
   "Eq.ndrec",
   "SubNegMonoid.toAddMonoid",
   "Real.instPreorderReal",
   "HMul.hMul",
   "Complex",
   "Real.rpow_nonneg_of_nonneg",
   "NegZeroClass.toZero",
   "Complex.instMulComplex"],
  "name": "Real.rpow_mul",
  "constType": "∀ {x : ℝ}, 0 ≤ x → ∀ (y z : ℝ), x ^ (y * z) = (x ^ y) ^ z",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "neg_eq_zero",
   "propext",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Basic._auxLemma.16",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, (-a = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → CommMagma α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "funext",
   "Set",
   "implies_true",
   "Eq.refl",
   "Mathlib.Logic.Basic._auxLemma.39",
   "Std.Logic._auxLemma.51",
   "Mathlib.Data.Set.Lattice._auxLemma.3",
   "True",
   "iff_self",
   "Iff.of_eq",
   "Set.instMembershipSet",
   "Eq",
   "Mathlib.Data.Set.Basic._auxLemma.45",
   "Set.ext",
   "And",
   "Set.instSingletonSet",
   "Set.iUnion",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "exists_prop_congr'",
   "congrFun"],
  "name": "Set.biUnion_of_singleton",
  "constType": "∀ {α : Type u_1} (s : Set α), ⋃ x ∈ s, {x} = s",
  "constCategory": "Theorem"},
 {"references":
  ["Invertible.invOf",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Meta.NormNum.IsRat",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Mathlib.Meta.NormNum.IsRat.mk",
   "Ring.toSemiring",
   "Invertible",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toOne",
   "instHMul",
   "Nat.cast",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Nat",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsRat.rec",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {num : ℤ} {denom : ℕ} {motive : Mathlib.Meta.NormNum.IsRat a num denom → Prop},\n  (∀ (inv : Invertible ↑denom) (eq : a = ↑num * ⅟↑denom), motive (_ : Mathlib.Meta.NormNum.IsRat a num denom)) →\n    ∀ (t : Mathlib.Meta.NormNum.IsRat a num denom), motive t",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "And",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddSubmonoid.instSetLikeAddSubmonoid",
   "AddSubmonoid.zero_mem",
   "Set",
   "And.intro",
   "AddSubmonoid",
   "AddZeroClass",
   "SetLike.coe",
   "Set.instMembershipSet"],
  "name": "AddSubmonoid.instInfAddSubmonoid.proof_2",
  "constType":
  "∀ {M : Type u_1} [inst : AddZeroClass M] (S₁ S₂ : AddSubmonoid M), 0 ∈ ↑S₁ ∧ 0 ∈ ↑S₂",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "Neg.toHasAbs",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "instDistribLattice",
   "LinearOrderedField.toLinearOrderedCommRing",
   "StrictOrderedSemiring.toSemiring",
   "Abs.abs",
   "DistribLattice.toLattice",
   "IsAbsoluteValue",
   "LinearOrderedRing.toLinearOrder",
   "LinearOrderedField",
   "Ring.toNeg",
   "SemilatticeSup.toSup",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "Lattice.toSemilatticeSup"],
  "name":
  "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedField α], IsAbsoluteValue abs",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalRing", "NonUnitalSeminormedRing"],
  "name": "NonUnitalSeminormedRing.toNonUnitalRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalSeminormedRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Eq.refl",
   "MulHomClass.toFunLike",
   "FunLike.coe",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass.toMulHomClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Function.Injective.eq_iff",
   "NonAssocSemiring",
   "RingHom.charZero",
   "Eq",
   "RingHomClass.toNonUnitalRingHomClass",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Function.Injective",
   "CharZero",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.cast_inj",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "map_natCast",
   "Eq.symm",
   "CharZero.mk",
   "id"],
  "name": "RingHom.charZero_iff",
  "constType":
  "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {ϕ : R →+* S},\n  Function.Injective ⇑ϕ → (CharZero R ↔ CharZero S)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Subgroup.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "Set",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Subgroup.inv_mem'",
   "AddSubgroup.toAddSubmonoid",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "AddSubmonoid.zero_mem'",
   "RelIso.instRelHomClassRelIso",
   "AddSubgroup.casesOn",
   "Submonoid.toAddSubmonoid",
   "AddGroup",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "RelIso",
   "AddSubgroup",
   "Subgroup",
   "AddSubmonoid.mk",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Multiplicative.mulOneClass",
   "Membership.mem",
   "Submonoid.mk",
   "Submonoid.one_mem'",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "AddSubmonoid.toSubmonoid",
   "Neg.neg",
   "FunLike.coe",
   "SubNegZeroMonoid.toNegZeroClass",
   "Additive.addZeroClass",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "Monoid.toMulOneClass",
   "AddSubmonoid",
   "AddGroup.toSubNegMonoid",
   "Set.instMembershipSet",
   "RelHomClass.toFunLike",
   "Eq.ndrec",
   "Multiplicative",
   "AddSubgroup.neg_mem'",
   "Multiplicative.group",
   "SubNegMonoid.toAddMonoid",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Group.toDivInvMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubgroup.mk",
   "NegZeroClass.toNeg",
   "AddSubsemigroup.carrier",
   "Additive"],
  "name": "AddSubgroup.toSubgroup.proof_4",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] (x : AddSubgroup A),\n  (fun S =>\n        let src := Submonoid.toAddSubmonoid S.toSubmonoid;\n        { toAddSubmonoid := { toAddSubsemigroup := src.toAddSubsemigroup, zero_mem' := (_ : 0 ∈ src.carrier) },\n          neg_mem' := (_ : ∀ {x : A}, x ∈ S.carrier → x⁻¹ ∈ S.carrier) })\n      ((fun S =>\n          let src := AddSubmonoid.toSubmonoid S.toAddSubmonoid;\n          { toSubmonoid := { toSubsemigroup := src.toSubsemigroup, one_mem' := (_ : 1 ∈ src.carrier) },\n            inv_mem' := (_ : ∀ {x : Multiplicative A}, x ∈ S.carrier → -x ∈ S.carrier) })\n        x) =\n    x",
  "constCategory": "Theorem"},
 {"references":
  ["SemilatticeSup.toSup",
   "Iff",
   "PartialOrder.toPreorder",
   "GeneralizedCoheytingAlgebra",
   "Sup.sup",
   "SDiff.sdiff",
   "OrderBot",
   "Lattice",
   "Lattice.toSemilatticeSup",
   "SDiff",
   "LE.le",
   "SemilatticeSup.toPartialOrder",
   "Preorder.toLE"],
  "name": "GeneralizedCoheytingAlgebra.mk",
  "constType":
  "{α : Type u_4} →\n  [toLattice : Lattice α] →\n    [toOrderBot : OrderBot α] →\n      [toSDiff : SDiff α] → (∀ (a b c : α), a \\ b ≤ c ↔ a ≤ b ⊔ c) → GeneralizedCoheytingAlgebra α",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "PartialOrder.toPreorder",
   "Set",
   "InfSet.sInf",
   "CompleteLattice.sInf_le",
   "completeLatticeOfInf",
   "AddSubgroup.instCompleteLatticeAddSubgroup.proof_1",
   "LE.le",
   "Preorder.toLE",
   "Set.instMembershipSet",
   "SetLike.instPartialOrder",
   "CompleteLattice.toLattice",
   "AddSubgroup.instInfSetAddSubgroup",
   "AddGroup",
   "CompleteLattice.toInfSet",
   "AddSubgroup",
   "Lattice.toSemilatticeSup",
   "AddSubgroup.instSetLikeAddSubgroup",
   "SemilatticeSup.toPartialOrder"],
  "name": "AddSubgroup.instCompleteLatticeAddSubgroup.proof_7",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (s : Set (AddSubgroup G)), ∀ a ∈ s, sInf s ≤ a",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "SetLike"],
  "name": "AddSubgroupClass",
  "constType":
  "(S : Type u_5) → (G : Type u_6) → [inst : SubNegMonoid G] → [inst : SetLike S G] → Prop",
  "constCategory": "Other"},
 {"references": ["NormedAddCommGroup", "AddCommGroup"],
  "name": "NormedAddCommGroup.toAddCommGroup",
  "constType":
  "{E : Type u_9} → [self : NormedAddCommGroup E] → AddCommGroup E",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "PartialOrder.toPreorder",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "OrderedAddCommGroup.toOrderedCancelAddCommMonoid",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LE.le",
   "Ring.toNonAssocRing",
   "Preorder.toLE",
   "AddGroupWithOne.toAddGroup",
   "NonUnitalNonAssocSemiring.toDistrib",
   "le_of_add_le_add_left",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "StrictOrderedRing",
   "AddGroup.toAddCancelMonoid"],
  "name": "StrictOrderedRing.toStrictOrderedSemiring.proof_1",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] {a b c : α}, a + b ≤ a + c → b ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "not_le_of_gt",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "LinearOrder.toPartialOrder",
   "lt_of_not_ge",
   "Preorder.toLE"],
  "name": "lt_iff_not_ge",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] (x y : α), x < y ↔ ¬x ≥ y",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Semigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "HasDistribNeg.neg_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Mul α] [self : HasDistribNeg α] (x y : α), -x * y = -(x * y)",
  "constCategory": "Definition"},
 {"references":
  ["InvOneClass.mk",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid.inv_one",
   "InvOneClass",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "OfNat.ofNat",
   "LinearOrder.decidableLE",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrder.max_def",
   "Real",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "One.toOfNat1",
   "StrictOrderedRing.toNontrivial",
   "Semiring.npow_zero",
   "StrictOrderedRing.mul_pos",
   "Ring.toSemiring",
   "Eq",
   "StrictOrderedRing.zero_le_one",
   "Semiring.toOne",
   "LinearOrder.toOrd",
   "Real.linearOrder",
   "Semiring.npow",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "StrictOrderedRing.add_le_add_left",
   "LinearOrder.toMax",
   "LinearOrder.toMin",
   "instOfNatNat",
   "LinearOrder.decidableEq",
   "Nat",
   "Real.strictOrderedRing",
   "LinearOrderedRing.mk"],
  "name": "Real.instLinearOrderedFieldReal.proof_4",
  "constType": "∀ (x : ℝ), Semiring.npow 0 x = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddRightCancelMonoid",
   "OfNat.ofNat",
   "AddRightCancelSemigroup.toAddSemigroup",
   "AddRightCancelMonoid.toZero",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "HAdd.hAdd",
   "Eq"],
  "name": "AddRightCancelMonoid.add_zero",
  "constType":
  "∀ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a",
  "constCategory": "Definition"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "Not",
   "LT.lt.not_le",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt_of_le",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembershipMultiset"],
  "name": "Finset.instMembershipFinset",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instOfNatInt",
   "DivisionRing.toRing",
   "DivisionRing.zpow_zero'",
   "Field.toSemifield",
   "One.toOfNat1",
   "Ring.toSemiring",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "DivisionRing.zpow",
   "Eq",
   "Semiring.toOne",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "DivisionSemiring.toSemiring",
   "LinearOrderedField",
   "Field",
   "OrderedCommSemiring.toOrderedSemiring",
   "CauSeq.Completion.Cauchy.divisionRing",
   "CauSeq.Completion.Cauchy",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "Int",
   "StrictOrderedCommSemiring.toOrderedCommSemiring"],
  "name": "CauSeq.Completion.Cauchy.field.proof_3",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedField α] {β : Type u_1} [inst_1 : Field β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] (a : CauSeq.Completion.Cauchy abv), DivisionRing.zpow 0 a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["OneHom.toFun",
   "RingHom",
   "OfNat.ofNat",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "OneHom.map_one'",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.instRingHomClass.proof_3",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  OneHom.toFun (↑↑f) 1 = 1",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "StrictOrderedCommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NormedRing.toNorm",
   "instHMul",
   "NormedRing.norm_mul",
   "NormedCommRing",
   "Real.instMulReal",
   "Real.instLEReal",
   "Real",
   "HMul.hMul",
   "NormedCommRing.toNormedRing",
   "Norm.norm",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LE.le",
   "NormedRing.toRing"],
  "name": "NormedCommRing.toSeminormedCommRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [β : NormedCommRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "AddSemigroup.toAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Eq.mpr",
   "AddGroup",
   "Eq.ndrec",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "id"],
  "name": "AddGroup.toAddCancelMonoid.proof_1",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b c : G), a + b = a + c → b = c",
  "constCategory": "Theorem"},
 {"references":
  ["FiniteRange.null_of_compl",
   "OfNat.ofNat",
   "MeasureTheory.Measure.map",
   "Set",
   "ProbabilityTheory.FiniteSupport.mk",
   "HasCompl.compl",
   "Set.Set.completeAtomicBooleanAlgebra",
   "Exists.intro",
   "instENNRealZero",
   "CompleteAtomicBooleanAlgebra.toHasCompl",
   "Eq",
   "Zero.toOfNat0",
   "MeasureTheory.Measure",
   "MeasurableSingletonClass",
   "ENNReal",
   "ProbabilityTheory.FiniteSupport",
   "FiniteRange",
   "MeasureTheory.OuterMeasure.measureOf",
   "MeasureTheory.Measure.toOuterMeasure",
   "Finset.toSet",
   "FiniteRange.toFinset",
   "Finset",
   "MeasurableSpace"],
  "name": "ProbabilityTheory.finiteSupport_of_finiteRange",
  "constType":
  "∀ {Ω : Type u_1} {S : Type u_2} [mΩ : MeasurableSpace Ω] [inst : MeasurableSpace S]\n  [inst_1 : MeasurableSingletonClass S] {μ : MeasureTheory.Measure Ω} {X : Ω → S} [hX' : FiniteRange X],\n  ProbabilityTheory.FiniteSupport",
  "constCategory": "Definition"},
 {"references":
  ["mul_comm",
   "instHMul",
   "mul_assoc",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "Mul.mul",
   "CommSemigroup",
   "left_comm",
   "Eq",
   "CommSemigroup.toSemigroup"],
  "name": "mul_left_comm",
  "constType":
  "∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * (b * c) = b * (a * c)",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedAddCommMonoid",
   "Exists",
   "PartialOrder.toPreorder",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "OrderBot",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "CanonicallyOrderedAddCommMonoid.mk",
  "constType":
  "{α : Type u_1} →\n  [toOrderedAddCommMonoid : OrderedAddCommMonoid α] →\n    [toOrderBot : OrderBot α] →\n      (∀ {a b : α}, a ≤ b → ∃ c, b = a + c) → (∀ (a b : α), a ≤ a + b) → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Other"},
 {"references":
  ["PProd",
   "Nat.rec",
   "PProd.fst",
   "OfNat.ofNat",
   "Nat.below",
   "Nat.brecOn",
   "Nat.pow.match_1",
   "Unit",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.mul",
   "Nat.succ"],
  "name": "Nat.pow",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Filter",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["List.cons",
   "List",
   "List.Mem.tail",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.rec"],
  "name": "List.Mem.casesOn",
  "constType":
  "∀ {α : Type u} {a : α} {motive : (a_1 : List α) → List.Mem a a_1 → Prop} {a_1 : List α} (t : List.Mem a a_1),\n  (∀ (as : List α), motive (a :: as) (_ : List.Mem a (a :: as))) →\n    (∀ (b : α) {as : List α} (a_2 : List.Mem a as), motive (b :: as) (_ : List.Mem a (b :: as))) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CommSemiring",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Mathlib.Meta.NormNum.IsNat.out",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "add_add_add_comm"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ b₁ a₂ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.vaddFinset",
   "Finset.card",
   "Finset.card_image_of_injective",
   "AddGroup",
   "DecidableEq",
   "Finset",
   "SubNegMonoid.toAddMonoid",
   "AddAction.injective",
   "AddAction.toVAdd",
   "HVAdd.hVAdd",
   "Nat",
   "instHVAdd",
   "AddGroup.toSubNegMonoid",
   "AddAction",
   "Eq"],
  "name": "Finset.card_vadd_finset",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : DecidableEq β] [inst_1 : AddGroup α] [inst_2 : AddAction α β] (a : α)\n  (s : Finset β), Finset.card (a +ᵥ s) = Finset.card s",
  "constCategory": "Theorem"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} → [self : Ring R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.ext_iff",
   "Iff",
   "Finset",
   "Finset.instMembershipFinset",
   "Iff.mpr",
   "Eq"],
  "name": "Finset.ext",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddLeftCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Semifield", "Inv"],
  "name": "Semifield.toInv",
  "constType": "{α : Type u_4} → [self : Semifield α] → Inv α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ne",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "HMul.hMul",
   "Not",
   "WellFounded",
   "EuclideanDomain",
   "Nontrivial",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "EuclideanDomain.mk",
  "constType":
  "{R : Type u} →\n  [toCommRing : CommRing R] →\n    [toNontrivial : Nontrivial R] →\n      (quotient : R → R → R) →\n        (∀ (a : R), quotient a 0 = 0) →\n          (remainder : R → R → R) →\n            (∀ (a b : R), b * quotient a b + remainder a b = a) →\n              (r : R → R → Prop) →\n                WellFounded r →\n                  (∀ (a : R) {b : R}, b ≠ 0 → r (remainder a b) b) →\n                    (∀ (a : R) {b : R}, b ≠ 0 → ¬r (a * b) a) → EuclideanDomain R",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "instHMul",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "Ring",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Eq",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "Ring.toNonAssocRing.proof_2",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (a b c : α), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references": ["RelEmbedding", "Function.Embedding"],
  "name": "RelEmbedding.toEmbedding",
  "constType":
  "{α : Type u_5} → {β : Type u_6} → {r : α → α → Prop} → {s : β → β → Prop} → r ↪r s → α ↪ β",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_5",
   "CanonicallyOrderedCommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_2",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_11",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_6",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_13",
   "Semiring.toNatCast",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_1",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_9",
   "Semiring.npow",
   "WithTop",
   "CommSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_4",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.mk",
   "WithTop.commSemiring",
   "WithTop.canonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mk",
   "CanonicallyOrderedAddCommMonoid.toOrderBot",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_15",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_12",
   "Semiring.toOne",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "DecidableEq",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_14",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_10",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_3",
   "CanonicallyOrderedAddCommMonoid",
   "Nontrivial",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "WithTop.instCanonicallyOrderedCommSemiringWithTop.proof_7"],
  "name": "WithTop.instCanonicallyOrderedCommSemiringWithTop",
  "constType":
  "{α : Type u_1} →\n  [inst : DecidableEq α] →\n    [inst : CanonicallyOrderedCommSemiring α] → [inst : Nontrivial α] → CanonicallyOrderedCommSemiring (WithTop α)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Eq",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "Eq.ndrec",
   "HMul.hMul",
   "mul_inv_cancel_left",
   "Group",
   "Group.toDivInvMonoid",
   "mul_right_inv",
   "id",
   "Inv.inv"],
  "name": "Group.toDivisionMonoid.proof_2",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "NonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq"],
  "name": "NonUnitalNonAssocCommSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b : α), a * b = b * a) → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "OfNat.ofNat",
   "if_pos",
   "Set",
   "Classical.decPred",
   "Set.indicator",
   "Eq",
   "Set.instMembershipSet"],
  "name": "Set.indicator_of_mem",
  "constType":
  "∀ {α : Type u_1} {M : Type u_4} [inst : Zero M] {s : Set α} {a : α}, a ∈ s → ∀ (f : α → M), Set.indicator s f a = f a",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "Nat"],
  "name": "Monoid.npow",
  "constType": "{M : Type u} → [self : Monoid M] → ℕ → M → M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero",
   "AddZeroClass.toZero",
   "Add.add",
   "Set.zero",
   "Set.add",
   "Set",
   "Zero.mk",
   "Set.addZeroClass.proof_2",
   "AddZeroClass.mk",
   "Add",
   "Zero.zero",
   "AddZeroClass",
   "Set.addZeroClass.proof_1",
   "Add.mk"],
  "name": "Set.addZeroClass",
  "constType":
  "{α : Type u_2} → [inst : AddZeroClass α] → AddZeroClass (Set α)",
  "constCategory": "Definition"},
 {"references": ["Union", "Set.union", "Union.mk", "Set"],
  "name": "Set.instUnionSet",
  "constType": "{α : Type u_1} → Union (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedField",
   "Subtype.val",
   "IsCauSeq",
   "Ring",
   "CauSeq",
   "Nat",
   "Subtype.mk",
   "CauSeq.ofEq.proof_1",
   "Eq"],
  "name": "CauSeq.ofEq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → (f : CauSeq β abv) → (g : ℕ → β) → (∀ (i : ℕ), ↑f i = g i) → CauSeq β abv",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "OfNat.ofNat",
   "setOf",
   "Set",
   "Function.IsPeriodicPt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "GT.gt"],
  "name": "Function.periodicPts",
  "constType": "{α : Type u_1} → (α → α) → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Multiset.instZeroMultiset",
   "Multiset",
   "Bot.mk",
   "OrderBot",
   "OrderBot.mk",
   "Preorder.toLE",
   "Multiset.zero_le",
   "Multiset.instPartialOrderMultiset"],
  "name": "Multiset.instOrderBotMultisetToLEToPreorderInstPartialOrderMultiset",
  "constType": "{α : Type u_1} → OrderBot (Multiset α)",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["MeasurableSpace.giGenerateFrom.proof_2",
   "CompleteSemilatticeInf.toPartialOrder",
   "CompletelyDistribLattice.toCompleteLattice",
   "PartialOrder.toPreorder",
   "setOf",
   "Set",
   "Set.Set.completeAtomicBooleanAlgebra",
   "MeasurableSpace.instPartialOrderMeasurableSpace",
   "MeasurableSpace.giGenerateFrom.proof_1",
   "GaloisInsertion",
   "LE.le",
   "Preorder.toLE",
   "CompleteAtomicBooleanAlgebra.toCompletelyDistribLattice",
   "MeasurableSpace.generateFrom_le_iff",
   "MeasurableSpace.mkOfClosure",
   "MeasurableSet",
   "MeasurableSpace.generateFrom",
   "GaloisInsertion.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "MeasurableSpace",
   "MeasurableSpace.giGenerateFrom.proof_3"],
  "name": "MeasurableSpace.giGenerateFrom",
  "constType":
  "{α : Type u_1} → GaloisInsertion MeasurableSpace.generateFrom fun m => {t | MeasurableSet t}",
  "constCategory": "Definition"},
 {"references":
  ["ENNReal",
   "WithTop",
   "NNReal.instConditionallyCompleteLinearOrderBotNNReal",
   "inferInstanceAs",
   "CompleteLinearOrder",
   "WithTop.instCompleteLinearOrderWithTop",
   "NNReal"],
  "name": "ENNReal.instCompleteLinearOrderENNReal",
  "constType": "CompleteLinearOrder ENNReal",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "CanonicallyOrderedCommSemiring.npow",
   "One.toOfNat1",
   "instOfNatNat",
   "CanonicallyOrderedCommSemiring",
   "Nat",
   "CanonicallyOrderedCommSemiring.toOne",
   "Eq"],
  "name": "CanonicallyOrderedCommSemiring.npow_zero",
  "constType":
  "∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] (x : α), CanonicallyOrderedCommSemiring.npow 0 x = 1",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec",
   "HEq",
   "HEq.refl",
   "Mathlib.Meta.NormNum.IsInt.casesOn",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "eq_of_heq",
   "Ring.toIntCast",
   "Ring",
   "Eq.refl",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.casesOn",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isRat.match_1",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] (motive : (x : α) → (x_1 : ℤ) → Mathlib.Meta.NormNum.IsInt x x_1 → Prop) (x : α)\n  (x_1 : ℤ) (x_2 : Mathlib.Meta.NormNum.IsInt x x_1),\n  (∀ (n : ℤ), motive (↑n) n (_ : Mathlib.Meta.NormNum.IsInt (↑n) n)) → motive x x_1 x_2",
  "constCategory": "Definition"},
 {"references":
  ["Set.pairwiseDisjoint_empty",
   "AddCommSemigroup.toAddCommMagma",
   "Finset.exists_maximal",
   "EmptyCollection.emptyCollection",
   "PartialOrder.toPreorder",
   "SubNegMonoid.toNeg",
   "AddCommGroup.toAddCommMonoid",
   "And.left",
   "Insert.insert",
   "Iff.mpr",
   "SubNegMonoid.toSub",
   "And.right",
   "Finset.toSet",
   "Finset.sub",
   "Nat.strictOrderedSemiring",
   "instHSub",
   "Set.instSProd",
   "Finset.card_add_iff",
   "add_comm",
   "Finset.decidableMem",
   "Prod.snd",
   "Finset.add_subset_add_right",
   "Finset.empty_mem_powerset",
   "AddMonoid.toAddAction",
   "AddCommMagma.toAdd",
   "instHVAdd",
   "And",
   "False.elim",
   "DecidableEq",
   "propext",
   "LT.lt",
   "congr",
   "And.intro",
   "AddCommGroup",
   "Finset.instHasSubsetFinset",
   "Finset.add",
   "congrFun",
   "AddZeroClass.toAdd",
   "Finset.vaddFinset",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Set",
   "Eq.ge",
   "Eq.refl",
   "Exists.intro",
   "Classical.dec",
   "AddMonoid.toAddZeroClass",
   "True",
   "Finset.mem_sub",
   "Set.PairwiseDisjoint.insert",
   "AddMonoid.toAddSemigroup",
   "SProd.sprod",
   "Finset",
   "AddGroup.toAddCancelMonoid",
   "Finset.ssubset_insert",
   "Finset.filter",
   "HVAdd.hVAdd",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Finset.instInsertFinset",
   "Set.PairwiseDisjoint",
   "Finset.powerset",
   "LE.le.trans",
   "Disjoint",
   "add_sub_cancel'_right",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "Finset.pairwiseDisjoint_vadd_iff",
   "Eq.ndrec",
   "Finset.subtractionMonoid",
   "Finset.decidableDisjoint",
   "Prod",
   "Finset.coe_empty",
   "NegZeroClass.toNeg",
   "add_sub_add_left_eq_sub",
   "Finset.Nonempty.zero_mem_sub",
   "Finset.insert_subset_iff",
   "Finset.instEmptyCollectionFinset",
   "Mathlib.Tactic.PushNeg.not_implies_eq",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "dite",
   "Exists.casesOn",
   "Eq",
   "Eq.mpr",
   "Iff.mp",
   "Nat",
   "Mathlib.Tactic.PushNeg.not_forall_eq",
   "And.casesOn",
   "Eq.trans",
   "Add.toVAdd",
   "Ne",
   "Finset.card_le_of_subset",
   "HasSubset.Subset",
   "Set.instEmptyCollectionSet",
   "Finset.instMembershipFinset",
   "Prod.fst",
   "Set.instMembershipSet",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "of_eq_true",
   "Eq.mp",
   "AddAction.toVAdd",
   "Not",
   "sub_neg_eq_add",
   "congrArg",
   "Mathlib.Combinatorics.Additive.RuzsaCovering._auxAddLemma.1",
   "Finset.card",
   "Finset.mem_add",
   "Finset.Nonempty",
   "Finset.decidableDforallFinset",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Set.InjOn",
   "instLENat",
   "Preorder.toLT",
   "AddCommGroup.toAddGroup",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Finset.mem_powerset",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Finset.partialOrder",
   "Finset.subset_add_left",
   "AddGroup.toSubNegMonoid",
   "Finset.instOrderBotFinsetToLEToPreorderPartialOrder",
   "Mathlib.Combinatorics.Additive.RuzsaCovering._auxAddLemma.2",
   "StrictOrderedSemiring.toPartialOrder",
   "SubtractionMonoid.toSubNegMonoid",
   "Finset.filter_nonempty_iff",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Finset.mem_filter",
   "instMulNat",
   "Finset.coe_insert",
   "add_sub_assoc",
   "Set.instInsertSet"],
  "name": "Finset.exists_subset_add_sub",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : AddCommGroup α] (s : Finset α) {t : Finset α},\n  Finset.Nonempty t → ∃ u, Finset.card u * Finset.card t ≤ Finset.card (s + t) ∧ s ⊆ u + t - t",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Subtype.val",
   "instHAdd",
   "IsCauSeq",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "CauSeq",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Ring.toSemiring",
   "Ring.toNonAssocRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "IsAbsoluteValue",
   "LinearOrderedField",
   "Pi.instAdd",
   "CauSeq.instAddCauSeq.proof_1",
   "OrderedCommSemiring.toOrderedSemiring",
   "Ring",
   "LinearOrderedField.toLinearOrderedSemifield",
   "Add",
   "Nat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Subtype.mk",
   "Add.mk"],
  "name": "CauSeq.instAddCauSeq",
  "constType":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LinearOrderedField α] →\n      [inst_1 : Ring β] → {abv : β → α} → [inst_2 : IsAbsoluteValue abv] → Add (CauSeq β abv)",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike"],
  "name": "FunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : FunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references": ["MulHomClass", "outParam", "FunLike", "Mul"],
  "name": "MulHomClass.toFunLike",
  "constType":
  "{F : Type u_9} →\n  {M : outParam (Type u_10)} →\n    {N : outParam (Type u_11)} → [inst : Mul M] → [inst_1 : Mul N] → [self : MulHomClass F M N] → FunLike F M fun x => N",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "Eq.ndrec",
   "Eq.refl",
   "Eq.symm",
   "DivisionRing.toInv",
   "Inv.inv",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.inv_congr",
  "constType":
  "∀ {R : Type u_1} [inst : DivisionRing R] {a a' b : R}, a = a' → a'⁻¹ = b → a⁻¹ = b",
  "constCategory": "Theorem"},
 {"references":
  ["Trans", "le_trans", "Preorder", "LE.le", "Trans.mk", "Preorder.toLE"],
  "name": "instTransLeToLE",
  "constType": "{α : Type u} → [inst : Preorder α] → Trans LE.le LE.le LE.le",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "InvolutiveNeg.toNeg", "Neg.neg", "Eq"],
  "name": "InvolutiveNeg.neg_neg",
  "constType": "∀ {A : Type u_2} [self : InvolutiveNeg A] (x : A), - -x = x",
  "constCategory": "Definition"},
 {"references": ["le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "LE.le.trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["instHasEquiv",
   "CauSeq.instLECauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "DivisionRing.toRing",
   "Iff.rfl",
   "Real.instLEReal",
   "Real",
   "Mathlib.Data.Real.Basic._auxLemma.1",
   "Abs.abs",
   "Rat.instSupRat",
   "Eq",
   "CauSeq.instLTCauSeqToRingToDivisionRingToFieldAbsToHasAbsToNegToSupToSemilatticeSupToLatticeInstDistribLatticeToLinearOrderToLinearOrderedRingToLinearOrderedCommRing",
   "Eq.mpr",
   "Mathlib.Data.Real.Basic._auxLemma.6",
   "Iff",
   "Rat.instNegRat",
   "Eq.trans",
   "id",
   "Neg.toHasAbs",
   "Or",
   "Real.instLTReal",
   "Mathlib.Data.Real.Basic._auxLemma.7",
   "Rat",
   "CauSeq",
   "Rat.instLinearOrderedRingRat",
   "LE.le",
   "CauSeq.equiv",
   "IsAbsoluteValue.abs_isAbsoluteValue",
   "Rat.divisionRing",
   "Real.mk",
   "LT.lt",
   "congr",
   "HasEquiv.Equiv",
   "congrArg",
   "Rat.instLinearOrderedFieldRat",
   "congrFun"],
  "name": "Real.mk_le",
  "constType": "∀ {f g : CauSeq ℚ abs}, Real.mk f ≤ Real.mk g ↔ f ≤ g",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulOneClass",
   "Iff.rfl",
   "MulPosReflectLT",
   "MulOneClass.toOne",
   "Eq.refl",
   "One.toOfNat1",
   "Preorder",
   "MulPosStrictMono",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Eq.mpr",
   "one_mul",
   "Eq.ndrec",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "HMul.hMul",
   "Iff.trans",
   "mul_lt_mul_right",
   "id"],
  "name": "lt_mul_iff_one_lt_left",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulOneClass α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α]\n  [inst_4 : MulPosReflectLT α], 0 < a → (a < b * a ↔ 1 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["DistribMulAction.toMulAction",
   "Module.toDistribMulAction",
   "instHSMul",
   "Real.instMulReal",
   "NormedField",
   "Real",
   "Real.instLEReal",
   "Semiring.toMonoidWithZero",
   "SeminormedAddCommGroup",
   "Field.toSemifield",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "NormedSpace",
   "LE.le",
   "NormedField.toNorm",
   "NormedField.toField",
   "instHMul",
   "DivisionSemiring.toSemiring",
   "SeminormedAddCommGroup.toAddCommGroup",
   "MulAction.toSMul",
   "MonoidWithZero.toMonoid",
   "HSMul.hSMul",
   "HMul.hMul",
   "SeminormedAddCommGroup.toNorm",
   "Semifield.toDivisionSemiring",
   "Norm.norm",
   "Module"],
  "name": "NormedSpace.mk",
  "constType":
  "{α : Type u_5} →\n  {β : Type u_6} →\n    [inst : NormedField α] →\n      [inst_1 : SeminormedAddCommGroup β] →\n        [toModule : Module α β] → (∀ (a : α) (b : β), ‖a • b‖ ≤ ‖a‖ * ‖b‖) → NormedSpace α β",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "LinearOrderedSemifield.toInv",
   "LinearOrderedSemifield.zpow",
   "LinearOrderedSemifield",
   "instNatCastInt",
   "Int.negSucc",
   "Nat",
   "Nat.succ",
   "Int",
   "Inv.inv",
   "Eq"],
  "name": "LinearOrderedSemifield.zpow_neg'",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.negSucc n) a = (LinearOrderedSemifield.zpow (↑(Nat.succ n)) a)⁻¹",
  "constCategory": "Definition"},
 {"references": ["Neg.neg", "Neg.mk", "Neg"],
  "name": "Pi.instNeg",
  "constType":
  "{I : Type u} → {f : I → Type v₁} → [inst : (i : I) → Neg (f i)] → Neg ((i : I) → f i)",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "MonoidWithZeroHomClass",
   "MulHomClass.toFunLike",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "FunLike.coe",
   "GroupWithZero.toMonoidWithZero",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "map_ne_zero",
   "Iff.mp",
   "Iff",
   "not_iff_not",
   "GroupWithZero",
   "Not",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "MonoidWithZero"],
  "name": "map_eq_zero",
  "constType":
  "∀ {M₀ : Type u_2} {G₀ : Type u_3} {F : Type u_6} [inst : MonoidWithZero M₀] [inst_1 : GroupWithZero G₀]\n  [inst_2 : Nontrivial M₀] [inst_3 : MonoidWithZeroHomClass F G₀ M₀] (f : F) {a : G₀}, f a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero",
   "ZeroHom.mk",
   "AddMonoidHom.id.proof_2",
   "AddZeroClass",
   "AddMonoidHom",
   "AddMonoidHom.mk",
   "AddMonoidHom.id.proof_1"],
  "name": "AddMonoidHom.id",
  "constType": "(M : Type u_9) → [inst : AddZeroClass M] → M →+ M",
  "constCategory": "Definition"},
 {"references": ["SMul"],
  "name": "SMul.smul",
  "constType": "{M : Type u} → {α : Type v} → [self : SMul M α] → M → α → α",
  "constCategory": "Definition"},
 {"references":
  ["MeasureTheory.Measure",
   "MeasureTheory.Measure.definition._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.18520",
   "MeasurableSpace",
   "Subtype",
   "Eq"],
  "name":
  "MeasureTheory.Measure.wrapped._@.Mathlib.MeasureTheory.Measure.MeasureSpace._hyg.18520",
  "constType": "Subtype (Eq @MeasureTheory.Measure.definition✝)",
  "constCategory": "Other"},
 {"references":
  ["ZeroLEOneClass",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "AddMonoid.toZero",
   "instOfNatNat",
   "monotone_nat_of_le_succ",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "Nat.succ",
   "Nat.strictOrderedSemiring",
   "id",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "LE.le",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "AddMonoidWithOne.toOne",
   "zero_le_one",
   "CovariantClass",
   "Monotone",
   "le_add_of_nonneg_right",
   "AddCommMonoidWithOne"],
  "name": "Nat.mono_cast",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α],\n  Monotone Nat.cast",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "Eq.ndrec",
   "ZeroHom.casesOn",
   "ZeroHom.toFun",
   "ZeroHom.mk",
   "Eq.rec",
   "Eq.refl",
   "ZeroHom",
   "Eq.symm",
   "Eq"],
  "name": "ZeroHom.zeroHomClass.proof_1",
  "constType":
  "∀ {M : Type u_2} {N : Type u_1} [inst : Zero M] [inst_1 : Zero N] (f g : ZeroHom M N), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NonUnitalNonAssocSemiring",
   "instHMul",
   "OfNat.ofNat",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "HMul.hMul",
   "AddCommMonoid.toAddMonoid",
   "Mul",
   "Eq",
   "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.mk",
  "constType":
  "{α : Type u} →\n  [toAddCommMonoid : AddCommMonoid α] →\n    [toMul : Mul α] →\n      (∀ (a b c : α), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : α), (a + b) * c = a * c + b * c) →\n          (∀ (a : α), 0 * a = 0) → (∀ (a : α), a * 0 = 0) → NonUnitalNonAssocSemiring α",
  "constCategory": "Other"},
 {"references": [],
  "name": "Acc",
  "constType": "{α : Sort u} → (α → α → Prop) → α → Prop",
  "constCategory": "Other"},
 {"references": ["Eq", "IsCommutative"],
  "name": "IsCommutative.comm",
  "constType":
  "∀ {α : Type u} {op : α → α → α} [self : IsCommutative α op] (a b : α), op a b = op b a",
  "constCategory": "Definition"},
 {"references":
  ["CompleteLattice.le_top",
   "OrderTop.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "BoundedOrder.mk",
   "CompleteLattice",
   "CompleteLattice.bot_le",
   "CompleteLattice.toTop",
   "CompleteLattice.toBot",
   "OrderBot.mk",
   "CompleteLattice.toCompleteSemilatticeInf",
   "Preorder.toLE",
   "BoundedOrder"],
  "name": "CompleteLattice.toBoundedOrder",
  "constType": "{α : Type u_1} → [h : CompleteLattice α] → BoundedOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Prod.snd",
   "CompleteLattice.toConditionallyCompleteLattice",
   "ConditionallyCompleteLattice.toLattice",
   "Measurable",
   "Prod",
   "Measurable.of_comap_le",
   "MeasurableSpace.instCompleteLatticeMeasurableSpace",
   "Prod.fst",
   "Lattice.toSemilatticeSup",
   "MeasurableSpace.comap",
   "MeasurableSpace",
   "le_sup_left",
   "Prod.instMeasurableSpace"],
  "name": "measurable_fst",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}, Measurable Prod.fst",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrder.decidableLE",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "LinearOrder.toMax",
   "Max.max",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "ite",
   "Eq"],
  "name": "LinearOrder.max_def",
  "constType":
  "∀ {α : Type u} [self : LinearOrder α] (a b : α), max a b = if a ≤ b then b else a",
  "constCategory": "Definition"},
 {"references": ["trans", "HasSubset.Subset", "IsTrans", "HasSubset"],
  "name": "subset_trans",
  "constType":
  "∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "CompleteSemilatticeInf.toPartialOrder",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Set",
   "Preorder.toLE",
   "AddSubmonoid.zero_mem'",
   "Zero.toOfNat0",
   "RelIso.instRelHomClassRelIso",
   "AddZeroClass.toZero",
   "Submonoid.toAddSubmonoid",
   "AddGroup",
   "Subgroup.toSubmonoid",
   "RelIso",
   "Subgroup",
   "Membership.mem",
   "AddSubmonoid.instCompleteLatticeAddSubmonoid",
   "AddSubmonoid.toAddSubsemigroup",
   "FunLike.coe",
   "Additive.addZeroClass",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "AddSubmonoid",
   "Monoid.toMulOneClass",
   "RelHomClass.toFunLike",
   "Set.instMembershipSet",
   "Multiplicative",
   "Multiplicative.group",
   "Submonoid",
   "Submonoid.instCompleteLatticeSubmonoid",
   "Group.toDivInvMonoid",
   "CompleteLattice.toCompleteSemilatticeInf",
   "AddSubsemigroup.carrier",
   "Additive"],
  "name": "AddSubgroup.toSubgroup.proof_2",
  "constType":
  "∀ {A : Type u_1} [inst : AddGroup A] (S : Subgroup (Multiplicative A)),\n  0 ∈ (Submonoid.toAddSubmonoid S.toSubmonoid).carrier",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0", "Zero", "Ne", "OfNat.ofNat", "NeZero", "NeZero.out"],
  "name": "NeZero.ne",
  "constType": "∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Zero",
   "AddMonoid.nsmul",
   "OfNat.ofNat",
   "SMul",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Function.Injective.addMonoid",
   "Function.Injective.subNegMonoid.proof_2",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "AddMonoid.add_zero",
   "Sub.mk",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Sub.sub",
   "Function.Injective.subNegMonoid.proof_4",
   "Nat",
   "Neg",
   "instHSub",
   "SubNegMonoid",
   "Function.Injective.subNegMonoid.proof_3",
   "instHAdd",
   "Function.Injective.subNegMonoid.proof_1",
   "HSub.hSub",
   "Neg.neg",
   "SubNegMonoid.SMulInt",
   "SubNegMonoid.mk",
   "AddMonoid",
   "AddMonoid.mk",
   "AddMonoid.toNatSMul",
   "AddMonoid.nsmul_zero",
   "Function.Injective",
   "AddMonoid.nsmul_succ",
   "SubNegMonoid.toAddMonoid",
   "AddMonoid.zero_add",
   "Add",
   "Int",
   "Neg.mk"],
  "name": "Function.Injective.subNegMonoid",
  "constType":
  "{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : SMul ℕ M₁] →\n          [inst_3 : Neg M₁] →\n            [inst_4 : Sub M₁] →\n              [inst_5 : SMul ℤ M₁] →\n                [inst_6 : SubNegMonoid M₂] →\n                  (f : M₁ → M₂) →\n                    Function.Injective f →\n                      f 0 = 0 →\n                        (∀ (x y : M₁), f (x + y) = f x + f y) →\n                          (∀ (x : M₁), f (-x) = -f x) →\n                            (∀ (x y : M₁), f (x - y) = f x - f y) →\n                              (∀ (x : M₁) (n : ℕ), f (n • x) = n • f x) →\n                                (∀ (x : M₁) (n : ℤ), f (n • x) = n • f x) → SubNegMonoid M₁",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NatCast",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Setoid.r",
   "Quot.out_eq",
   "Setoid",
   "Quotient.out",
   "Quotient",
   "Quotient.mk",
   "Eq"],
  "name": "Quotient.out_eq",
  "constType":
  "∀ {α : Sort u_1} [s : Setoid α] (q : Quotient s), ⟦Quotient.out q⟧ = q",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.decide",
   "DecidablePred",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.filter",
   "Multiset.Nodup",
   "Quot.induction_on",
   "List.Nodup.filter"],
  "name": "Multiset.Nodup.filter",
  "constType":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] {s : Multiset α},\n  Multiset.Nodup s → Multiset.Nodup (Multiset.filter p s)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Semiring.toNonUnitalSemiring",
   "AddHomClass.toFunLike",
   "Real",
   "Real.instAddMonoidReal",
   "AddCommMonoid.toAddMonoid",
   "DenselyNormedField.toNormedField",
   "FunLike.coe",
   "AddMonoid.toAddZeroClass",
   "Ring.toSemiring",
   "Eq",
   "Field.toCommRing",
   "NormedField.toField",
   "of_eq_true",
   "CommRing.toRing",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidHom.addMonoidHomClass",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoidHom.id",
   "AddMonoidHom",
   "Real.denselyNormedField"],
  "name": "Real.isROrC.proof_8",
  "constType": "∀ (z : ℝ), (AddMonoidHom.id ℝ) z = (AddMonoidHom.id ℝ) z",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "DenselyOrdered",
   "OrderedAddCommMonoid.toCovariantClassRight",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Trans.trans",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "zero_lt_two",
   "HAdd.hAdd",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "div_lt_div_of_lt",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "NeZero.one",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "add_lt_add_right",
   "DenselyOrdered.mk",
   "Semiring.toNatCast",
   "Eq",
   "LinearOrderedSemifield.toLinearOrderedCommSemiring",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "Preorder.toLT",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Nat",
   "Eq.symm",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "IsCancelAdd.toIsLeftCancelAdd",
   "LinearOrderedSemifield",
   "instHAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.zeroLEOneClass",
   "add_self_div_two",
   "add_lt_add_left",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instTransEq_1",
   "And",
   "LinearOrderedSemifield.toDiv",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "instTransEq",
   "And.intro"],
  "name": "LinearOrderedSemiField.toDenselyOrdered",
  "constType":
  "∀ {α : Type u_2} [inst : LinearOrderedSemifield α], DenselyOrdered α",
  "constCategory": "Definition"},
 {"references": ["Preorder", "LE.le", "Preorder.toLE"],
  "name": "Monotone",
  "constType":
  "{α : Type u} → {β : Type v} → [inst : Preorder α] → [inst : Preorder β] → (α → β) → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "Nat",
   "Nat.decLe",
   "Nat.strictOrderedSemiring"],
  "name": "Nat.orderedSemiring",
  "constType": "OrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "OrderedAddCommMonoid.mk",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Exists.imp",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid",
   "inferInstance",
   "Nat.le.dest",
   "AddMonoid.toAddSemigroup",
   "Nat.orderedSemiring",
   "Nat",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Nat.canonicallyOrderedCommSemiring.proof_1",
  "constType": "∀ {x x_1 : ℕ}, x ≤ x_1 → ∃ a, x_1 = x + a",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MulOneClass"],
  "name": "MonoidHomClass",
  "constType":
  "Type u_9 →\n  (M : outParam (Type u_10)) →\n    (N : outParam (Type u_11)) → [inst : MulOneClass M] → [inst : MulOneClass N] → Type (max (max u_10 u_11) u_9)",
  "constCategory": "Other"},
 {"references": ["NatCast", "Nat"],
  "name": "NatCast.natCast",
  "constType": "{R : Type u} → [self : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "RelHomClass"],
  "name": "RelHomClass.toFunLike",
  "constType":
  "{F : Type u_5} →\n  {α : outParam (Type u_6)} →\n    {β : outParam (Type u_7)} →\n      {r : outParam (α → α → Prop)} →\n        {s : outParam (β → β → Prop)} → [self : RelHomClass F r s] → FunLike F α fun x => β",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "Exists",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "HAdd.hAdd",
   "exists_pos_add_of_lt'",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Exists.casesOn",
   "ExistsAddOfLE",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "StrictOrderedSemiring",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Preorder.toLT",
   "Monoid.toNatPow",
   "Nat",
   "And.casesOn",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "HPow.hPow",
   "add_comm",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "And",
   "add_one_pow_unbounded_of_pos",
   "Eq.ndrec",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "StrictOrderedSemiring.toPartialOrder",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "LT.lt",
   "Archimedean",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "pow_unbounded_of_one_lt",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedSemiring α] [inst_1 : Archimedean α] {y : α} [inst_2 : ExistsAddOfLE α] (x : α),\n  1 < y → ∃ n, x < y ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Neg.neg",
   "Ring.toSemiring",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommRing.toNonUnitalCommRing.proof_5",
  "constType": "∀ {α : Type u_1} [s : CommRing α] (a : α), -a + a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "SubtractionMonoid",
   "Eq"],
  "name": "SubtractionMonoid.neg_add_rev",
  "constType":
  "∀ {G : Type u} [self : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulZeroClass",
   "MulZeroClass.mul_zero",
   "Preorder",
   "PosMulReflectLT",
   "LE.le",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Preorder.toLT",
   "LT.lt",
   "Eq.rec",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "lt_of_mul_lt_mul_left",
   "Eq.symm"],
  "name": "pos_of_mul_pos_right",
  "constType":
  "∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulReflectLT α],\n  0 < a * b → 0 ≤ a → 0 < b",
  "constCategory": "Theorem"},
 {"references": ["LE.mk", "Subtype.val", "LE", "LE.le", "Subtype"],
  "name": "Subtype.le",
  "constType": "{α : Type u} → [inst : LE α] → {p : α → Prop} → LE (Subtype p)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "OfNat.ofNat",
   "AddCommMonoid.toAddMonoid",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "StrictOrderedSemiring.toSemiring",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "AddMonoid.toZero",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Nat",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.linearOrderedCommSemiring"],
  "name": "Nat.linearOrderedCommMonoidWithZero.proof_2",
  "constType": "∀ (a : ℕ), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["UniformSpace", "PseudoMetricSpace"],
  "name": "PseudoMetricSpace.toUniformSpace",
  "constType": "{α : Type u} → [self : PseudoMetricSpace α] → UniformSpace α",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLattice.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice.mk",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left"],
  "name": "instDistribLattice",
  "constType": "{α : Type u} → [inst : LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_add.match_1",
   "LE.le",
   "PProd",
   "Nat.le_succ_of_le",
   "Nat.add",
   "PProd.fst",
   "Nat.rec",
   "instLENat",
   "Nat.le_refl",
   "PUnit",
   "Nat",
   "Nat.succ"],
  "name": "Nat.le_add_right",
  "constType": "∀ (n k : ℕ), n ≤ n + k",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "LE.le",
   "Preorder.toLE",
   "PartialOrder",
   "Nat.strictMono_cast",
   "Nat.linearOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "Iff",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "CovariantClass",
   "StrictMono.lt_iff_lt",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Nat.cast_lt",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, ↑m < ↑n ↔ m < n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "True",
   "Eq",
   "Finset.sum_range_succ_comm",
   "of_eq_true",
   "Finset.range",
   "congr",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "AddCommMonoid"],
  "name": "Finset.sum_range_succ",
  "constType":
  "∀ {β : Type u} [inst : AddCommMonoid β] (f : ℕ → β) (n : ℕ),\n  (Finset.sum (Finset.range (n + 1)) fun x => f x) = (Finset.sum (Finset.range n) fun x => f x) + f n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le.step",
   "Nat.le",
   "Eq.ndrec",
   "HEq",
   "instLENat",
   "HEq.refl",
   "eq_of_heq",
   "Eq.refl",
   "Nat.le.refl",
   "Nat.le.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ",
   "LE.le",
   "Eq"],
  "name": "Nat.le_antisymm.match_1",
  "constType":
  "∀ {n : ℕ} (motive : (m : ℕ) → n ≤ m → m ≤ n → Prop) (m : ℕ) (h₁ : n ≤ m) (h₂ : m ≤ n),\n  (∀ (h₂ : n ≤ n), motive n (_ : Nat.le n n) h₂) →\n    (∀ (m : ℕ) (h : Nat.le n m) (h₂ : Nat.succ m ≤ n), motive (Nat.succ m) (_ : Nat.le n (Nat.succ m)) h₂) →\n      motive m h₁ h₂",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "Iff.mp", "Iff", "Iff.mpr"],
  "name": "Iff.trans",
  "constType": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "HAdd.hAdd",
   "AddLeftCancelMonoid.nsmul",
   "instOfNatNat",
   "Nat",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "AddLeftCancelMonoid.nsmul_succ",
  "constType":
  "∀ {M : Type u} [self : AddLeftCancelMonoid M] (n : ℕ) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x",
  "constCategory": "Definition"},
 {"references": ["SDiff"],
  "name": "SDiff.mk",
  "constType": "{α : Type u} → (α → α → α) → SDiff α",
  "constCategory": "Other"},
 {"references":
  ["MulAction.one_smul",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "One.toOfNat1",
   "MulAction",
   "Eq"],
  "name": "one_smul",
  "constType":
  "∀ (M : Type u_1) {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α] (b : α), 1 • b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "instHDiv",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedField.toLinearOrderedCommRing",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "LinearOrderedField.toDiv",
   "Eq",
   "instHMul",
   "LinearOrderedField",
   "HMul.hMul",
   "HDiv.hDiv",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "LinearOrderedField.toInv",
   "Inv.inv"],
  "name": "LinearOrderedField.div_eq_mul_inv",
  "constType":
  "∀ {α : Type u_2} [self : LinearOrderedField α] (a b : α), a / b = a * b⁻¹",
  "constCategory": "Definition"},
 {"references":
  ["Min.min",
   "LE.mk",
   "Classical.decRel",
   "Quotient.liftOn₂",
   "Eq.refl",
   "Cardinal.partialOrder.proof_2",
   "Cardinal.instLECardinal.proof_1",
   "LT.mk",
   "Min.mk",
   "LE.le",
   "Preorder.toLE",
   "Nonempty",
   "Eq",
   "ite",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "And",
   "Cardinal.partialOrder.proof_1",
   "Cardinal.partialOrder.proof_3",
   "Cardinal",
   "Not",
   "Function.Embedding",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.linearOrder.proof_2",
  "constType": "∀ (a b : Cardinal.{u_1}), min a b = min a b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.card",
   "HEq",
   "eq_of_heq",
   "Set",
   "Eq.refl",
   "Fintype.card_ofFinset",
   "Finset.instMembershipFinset",
   "Fintype.card",
   "heq_of_eq",
   "Subsingleton.elim",
   "Set.instMembershipSet",
   "Eq",
   "Fintype",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "Set.Elem",
   "Finset",
   "Fintype.subsingleton",
   "Nat",
   "Eq.symm",
   "Fintype.ofFinset",
   "id"],
  "name": "Fintype.card_of_finset'",
  "constType":
  "∀ {α : Type u_1} {p : Set α} (s : Finset α),\n  (∀ (x : α), x ∈ s ↔ x ∈ p) → ∀ [inst : Fintype ↑p], Fintype.card ↑p = Finset.card s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.filter_subset",
   "Ne",
   "OfNat.ofNat",
   "Finset.sum",
   "Eq.refl",
   "Finset.instMembershipFinset",
   "AddCommMonoid.toAddMonoid",
   "Finset.sum_subset",
   "Eq",
   "DecidablePred",
   "Zero.toOfNat0",
   "And",
   "Eq.mpr",
   "Eq.ndrec",
   "propext",
   "AddMonoid.toZero",
   "Finset",
   "Finset.mem_filter",
   "Finset.filter",
   "Not",
   "And.intro",
   "not_imp_comm",
   "AddCommMonoid",
   "id"],
  "name": "Finset.sum_filter_of_ne",
  "constType":
  "∀ {β : Type u} {α : Type v} {s : Finset α} {f : α → β} [inst : AddCommMonoid β] {p : α → Prop}\n  [inst_1 : DecidablePred p],\n  (∀ x ∈ s, f x ≠ 0 → p x) → (Finset.sum (Finset.filter p s) fun x => f x) = Finset.sum s fun x => f x",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "True",
   "Preorder.toLE",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "eq_true",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder",
   "congrFun"],
  "name": "Linarith.le_of_le_of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a ≤ 0 → b = 0 → a + b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "ZeroLEOneClass",
   "Nat.cast_le",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddCommMonoidWithOne.toAddCommMonoid",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "AddMonoid.toZero",
   "CovariantClass",
   "Nat",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoidWithOne"],
  "name": "Mathlib.Data.Nat.Cast.Order._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : AddCommMonoidWithOne α] [inst_1 : PartialOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)",
  "constCategory": "Theorem"},
 {"references":
  ["LE.mk",
   "PartialOrder.mk",
   "Quotient.liftOn₂",
   "Cardinal.instLECardinal.proof_1",
   "Cardinal.partialOrder.proof_2",
   "LT.mk",
   "LE.le",
   "Nonempty",
   "PartialOrder",
   "Preorder.mk",
   "Cardinal.instLECardinal",
   "And",
   "Cardinal.partialOrder.proof_1",
   "Cardinal.partialOrder.proof_3",
   "Cardinal",
   "Cardinal.partialOrder.proof_4",
   "Function.Embedding",
   "Not",
   "Cardinal.isEquivalent"],
  "name": "Cardinal.partialOrder",
  "constType": "PartialOrder Cardinal.{u}",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "Complex.instSubComplex",
   "instHDiv",
   "OfNat.ofNat",
   "Complex.instNegComplex",
   "HSub.hSub",
   "Neg.neg",
   "Semiring.toNatCast",
   "Complex.instSemiringComplex",
   "instHMul",
   "Complex.sin.proof_1",
   "Complex.instField",
   "HMul.hMul",
   "Complex",
   "HDiv.hDiv",
   "Field.toDiv",
   "Complex.instMulComplex",
   "instOfNat",
   "Complex.exp",
   "Complex.I"],
  "name": "Complex.sin",
  "constType": "ℂ → ℂ",
  "constCategory": "Definition"},
 {"references": ["Ordering", "Ord"],
  "name": "Ord.mk",
  "constType": "{α : Type u} → (α → α → Ordering) → Ord α",
  "constCategory": "Other"},
 {"references":
  ["OrderHom.mk",
   "Eq.ndrec",
   "Eq.rec",
   "Eq.refl",
   "Monotone",
   "OrderHom",
   "OrderHom.casesOn",
   "OrderHom.toFun",
   "Preorder",
   "Eq.symm",
   "Eq"],
  "name": "OrderHom.instOrderHomClassOrderHomToLEToLE.proof_1",
  "constType":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Preorder α] [inst_1 : Preorder β] (f g : α →o β), f.toFun = g.toFun → f = g",
  "constCategory": "Theorem"}]